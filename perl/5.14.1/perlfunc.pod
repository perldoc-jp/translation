
=encoding euc-jp

=head1 NAME
X<function>

=begin original

perlfunc - Perl builtin functions

=end original

perlfunc - Perl 組み込み関数

=head1 DESCRIPTION

=begin original

The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in L<perlop>.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.  If it does both, scalar arguments 
come first and list argument follow, and there can only ever
be one such list argument.  For instance, splice() has three scalar
arguments followed by a list, whereas gethostbyname() has four scalar
arguments.

=end original

この節の関数は、式の中で項として使うことができます。
これらは、大きく二つに分けられます:
リスト演算子と名前付き単項演算子です。
これらの違いは、その後に出て来るコンマとの優先順位の関係にあります。　
(L<perlop> の優先順位の表を参照してください。)
リスト演算子は 2 個以上の引数をとるのに対して、単項演算子が複数の引数を
とることはありません。
つまり、コンマは単項演算子の引数の終わりとなりますが、リスト演算子の
場合には、引数の区切りでしかありません。
単項演算子は一般に、引数に対してスカラコンテキストを与えるのに対して、
スカラ演算子の場合には、引数に対してスカラコンテキストを与える場合も、
リストコンテキストを与える場合もあります。
一つのリスト演算子が両方のコンテキストを与える場合には、スカラ引数が
いくつか並び、最後にリスト引数が一つ続きます;
そしてそのようなリスト引数は一つだけしかありません。
たとえば、splice() は三つのスカラ引数に一つのリスト引数が続きます。
一方 gethostbyname() は四つのスカラ引数を持ちます。

=begin original

In the syntax descriptions that follow, list operators that expect a
list (and provide list context for elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Commas should separate literal elements of the LIST.

=end original

後に載せる構文記述では、リストをとり (そのリストの要素にリストコンテキストを
与える)リスト演算子は、引数として LIST をとるように書いています。
そのようなリストには、任意のスカラ引数の組み合わせやリスト値を
含めることができ、リスト値はリストの中に、個々の要素が展開されたように
埋め込まれます。
1 次元の長いリスト値が形成されることになります。
LIST のリテラルな要素は、コンマで区切られます。

=begin original

Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use parentheses, the simple but occasionally 
surprising rule is this: It I<looks> like a function, therefore it I<is> a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  Whitespace
between the function and left parenthesis doesn't count, so sometimes
you need to be careful:

=end original

以下のリストの関数はすべて、引数の前後の括弧は省略可能となっています。
(構文記述では省略しています。)
括弧を使うときには、単純な、(しかし、ときには驚く結果となる規則が
適用できます:
I<関数に見える>ならば、I<それは関数>で、優先順位は関係ありません。
そう見えなければ、それはリスト演算子か単項演算子で、優先順位が関係します。
関数と開き括弧の間の空白は関係ありませんので、ときに
気を付けなければなりません:

    print 1+2+4;      # Prints 7.
    print(1+2) + 4;   # Prints 3.
    print (1+2)+4;    # Also prints 3!
    print +(1+2)+4;   # Prints 7.
    print ((1+2)+4);  # Prints 7.

=begin original

If you run Perl with the B<-w> switch it can warn you about this.  For
example, the third line above produces:

=end original

Perl に B<-w> スイッチを付けて実行すれば、こういったものには警告を
出してくれます。
たとえば、上記の三つめは、以下のような警告が出ます:

    print (...) interpreted as function at - line 1.
    Useless use of integer addition in void context at - line 1.

=begin original

A few functions take no arguments at all, and therefore work as neither
unary nor list operators.  These include such functions as C<time>
and C<endpwent>.  For example, C<time+86_400> always means
C<time() + 86_400>.

=end original

いくつかの関数は引数を全くとらないので、単項演算子としても
リスト演算子としても動作しません。
このような関数としては C<time> や C<endpwent> があります。
例えば、C<time+86_400> は常に C<time() + 86_400> として扱われます。

=begin original

For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in scalar context by
returning the undefined value, and in list context by returning the
empty list.

=end original

スカラコンテキストでも、リストコンテキストでも使える関数は、致命的でない
エラーを示すために、スカラコンテキストでは未定義値を返し、
リストコンテキストでは空リストを返します。

=begin original

Remember the following important rule: There is B<no rule> that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value would be most
appropriate to return in scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
X<context>

=end original

以下に述べる重要なルールを忘れないで下さい: リストコンテキストでの
振る舞いとスカラコンテキストでの振る舞いの関係、あるいはその逆に
B<ルールはありません>。
2 つの全く異なったことがあります。
それぞれの演算子と関数は、スカラコンテキストでは、もっとも適切と
思われる値を返します。
リストコンテキストで返す時のリストの長さを返す演算子もあります。
リストの最初の値を返す演算子もあります。
リストの最後の値を返す演算子もあります。
成功した操作の数を返す演算子もあります。
一般的には、一貫性を求めない限り、こちらが求めることをします。
X<context>

=begin original

A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like C<(1,2,3)> into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it
was never a list to start with.

=end original

スカラコンテキストでの名前付き配列は、スカラコンテキストでのリストを
一目見たものとは全く違います。
コンパイラはコンパイル時にコンテキストを知っているので、
C<(1,2,3)> のようなリストをスカラコンテキストで得ることはできません。
これはスカラコンマ演算子を生成し、コンマのリスト作成版ではありません。
これは初めからリストであることはないことを意味します。

=begin original

In general, functions in Perl that serve as wrappers for system calls ("syscalls")
of the same name (like chown(2), fork(2), closedir(2), etc.) return
true when they succeed and C<undef> otherwise, as is usually mentioned
in the descriptions below.  This is different from the C interfaces,
which return C<-1> on failure.  Exceptions to this rule include C<wait>,
C<waitpid>, and C<syscall>.  System calls also set the special C<$!>
variable on failure.  Other functions do not, except accidentally.

=end original

一般的に、同じ名前のシステムコールのラッパーとして動作する Perl の関数
(chown(2), fork(2), closedir(2) など)は、以下に述べるように、
成功時に真を返し、そうでなければ C<undef> を返します。
これは失敗時に C<-1> を返す C のインターフェースとは違います。
このルールの例外は C<wait>, C<waitpid>, C<syscall> です。
システムコールは失敗時に特殊変数 C<$!> をセットします。
その他の関数は、事故を除いて、セットしません。

=begin original

Extension modules can also hook into the Perl parser to define new
kinds of keyword-headed expression.  These may look like functions, but
may also look completely different.  The syntax following the keyword
is defined entirely by the extension.  If you are an implementor, see
L<perlapi/PL_keyword_plugin> for the mechanism.  If you are using such
a module, see the module's documentation for details of the syntax that
it defines.

=end original

エクステンションモジュールは、新しい種類のキーワードが頭に付いた式を
定義するために Perl パーサをフックできます。
これらは関数のように見えるかもしれませんが、全く別物かもしれません。
キーワード以降の文法は完全にエクステンションによって定義されます。
もしあなたが実装者なら、この機構については L<perlapi/PL_keyword_plugin> を
参照してください。
もしあなたがそのようなモジュールを使っているなら、
定義されている文法の詳細についてはモジュールの文書を参照してください。

=head2 Perl Functions by Category
X<function>

(カテゴリ別の Perl 関数)

=begin original

Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.

=end original

以下に、カテゴリ別の関数(キーワードや名前付き演算子のような、
関数のように見えるものも含みます)を示します。
複数の場所に現れる関数もあります。

=over 4

=item Functions for SCALARs or strings
X<scalar> X<string> X<character>

(スカラや文字列のための関数)

C<chomp>, C<chop>, C<chr>, C<crypt>, C<hex>, C<index>, C<lc>, C<lcfirst>,
C<length>, C<oct>, C<ord>, C<pack>, C<q//>, C<qq//>, C<reverse>,
C<rindex>, C<sprintf>, C<substr>, C<tr///>, C<uc>, C<ucfirst>, C<y///>

=item Regular expressions and pattern matching
X<regular expression> X<regex> X<regexp>

(正規表現とパターンマッチング)

C<m//>, C<pos>, C<quotemeta>, C<s///>, C<split>, C<study>, C<qr//>

=item Numeric functions
X<numeric> X<number> X<trigonometric> X<trigonometry>

(数値関数)

C<abs>, C<atan2>, C<cos>, C<exp>, C<hex>, C<int>, C<log>, C<oct>, C<rand>,
C<sin>, C<sqrt>, C<srand>

=item Functions for real @ARRAYs
X<array>

(実配列のための関数)

C<each>, C<keys>, C<pop>, C<push>, C<shift>, C<splice>, C<unshift>, C<values>

=item Functions for list data
X<list>

(リストデータのための関数)

C<grep>, C<join>, C<map>, C<qw//>, C<reverse>, C<sort>, C<unpack>

=item Functions for real %HASHes
X<hash>

(実ハッシュのための関数)

C<delete>, C<each>, C<exists>, C<keys>, C<values>

=item Input and output functions
X<I/O> X<input> X<output> X<dbm>

(入出力関数)

C<binmode>, C<close>, C<closedir>, C<dbmclose>, C<dbmopen>, C<die>, C<eof>,
C<fileno>, C<flock>, C<format>, C<getc>, C<print>, C<printf>, C<read>,
C<readdir>, C<rewinddir>, C<say>, C<seek>, C<seekdir>, C<select>, C<syscall>,
C<sysread>, C<sysseek>, C<syswrite>, C<tell>, C<telldir>, C<truncate>,
C<warn>, C<write>

=item Functions for fixed-length data or records

(固定長データやレコードのための関数)

C<pack>, C<read>, C<syscall>, C<sysread>, C<syswrite>, C<unpack>, C<vec>

=item Functions for filehandles, files, or directories
X<file> X<filehandle> X<directory> X<pipe> X<link> X<symlink>

(ファイルハンドル、ファイル、ディレクトリのための関数)

C<-I<X>>, C<chdir>, C<chmod>, C<chown>, C<chroot>, C<fcntl>, C<glob>,
C<ioctl>, C<link>, C<lstat>, C<mkdir>, C<open>, C<opendir>,
C<readlink>, C<rename>, C<rmdir>, C<stat>, C<symlink>, C<sysopen>,
C<umask>, C<unlink>, C<utime>

=item Keywords related to the control flow of your Perl program
X<control flow>

(プログラムの流れを制御することに関連するキーワード)

C<caller>, C<continue>, C<die>, C<do>, C<dump>, C<eval>, C<exit>,
C<goto>, C<last>, C<next>, C<redo>, C<return>, C<sub>, C<wantarray>

=item Keywords related to the switch feature

(switch 機能に関連するキーワード)

C<break>, C<continue>, C<default, >C<given>, C<when>

=begin original

These are available only if you enable the C<"switch"> feature.
See L<feature> and L<perlsyn/"Switch statements">.  
Alternately, include a C<use v5.10> or later to the current scope.

=end original

これらは C<"switch"> 機能が有効の場合にのみ利用可能です。
L<feature> と L<perlsyn/"Switch statements"> を参照してください。
あるいは、現在のスコープに C<use v5.10> 以降を含めてください。

=item Keywords related to scoping

(スコープに関するキーワード)

C<caller>, C<import>, C<local>, C<my>, C<our>, C<package>, C<state>, C<use>

=begin original

C<state> is available only if the C<"state"> feature is enabled. See
L<feature>.  Alternately, include a C<use v5.10> or later to the current scope.

=end original

C<state> は C<"state"> 機能が有効の場合にのみ利用可能です。
L<feature> を参照してください。
あるいは、現在のスコープに C<use v5.10> 以降を含めてください。

=item Miscellaneous functions

(さまざまな関数)

C<defined>, C<dump>, C<eval>, C<formline>, C<local>, C<my>, C<our>,
C<reset>, C<scalar>, C<state>, C<undef>, C<wantarray>

=item Functions for processes and process groups
X<process> X<pid> X<process id>

(プロセスとプロセスグループのための関数)

C<alarm>, C<exec>, C<fork>, C<getpgrp>, C<getppid>, C<getpriority>, C<kill>,
C<pipe>, C<qx//>, C<setpgrp>, C<setpriority>, C<sleep>, C<system>,
C<times>, C<wait>, C<waitpid>

=item Keywords related to Perl modules
X<module>

(Perl モジュールに関するキーワード)

C<do>, C<import>, C<no>, C<package>, C<require>, C<use>

=item Keywords related to classes and object-orientation
X<object> X<class> X<package>

(クラスとオブジェクト指向に関するキーワード)

C<bless>, C<dbmclose>, C<dbmopen>, C<package>, C<ref>, C<tie>, C<tied>,
C<untie>, C<use>

=item Low-level socket functions
X<socket> X<sock>

(低レベルソケット関数)

C<accept>, C<bind>, C<connect>, C<getpeername>, C<getsockname>,
C<getsockopt>, C<listen>, C<recv>, C<send>, C<setsockopt>, C<shutdown>,
C<socket>, C<socketpair>

=item System V interprocess communication functions
X<IPC> X<System V> X<semaphore> X<shared memory> X<memory> X<message>

(System V プロセス間通信関数)

C<msgctl>, C<msgget>, C<msgrcv>, C<msgsnd>, C<semctl>, C<semget>, C<semop>,
C<shmctl>, C<shmget>, C<shmread>, C<shmwrite>

=item Fetching user and group info
X<user> X<group> X<password> X<uid> X<gid>  X<passwd> X</etc/passwd>

(ユーザーとグループの情報取得)

C<endgrent>, C<endhostent>, C<endnetent>, C<endpwent>, C<getgrent>,
C<getgrgid>, C<getgrnam>, C<getlogin>, C<getpwent>, C<getpwnam>,
C<getpwuid>, C<setgrent>, C<setpwent>

=item Fetching network info
X<network> X<protocol> X<host> X<hostname> X<IP> X<address> X<service>

(ネットワーク情報取得)

C<endprotoent>, C<endservent>, C<gethostbyaddr>, C<gethostbyname>,
C<gethostent>, C<getnetbyaddr>, C<getnetbyname>, C<getnetent>,
C<getprotobyname>, C<getprotobynumber>, C<getprotoent>,
C<getservbyname>, C<getservbyport>, C<getservent>, C<sethostent>,
C<setnetent>, C<setprotoent>, C<setservent>

=item Time-related functions
X<time> X<date>

(時刻に関する関数)

C<gmtime>, C<localtime>, C<time>, C<times>

=item Functions new in perl5
X<perl5>

(perl5 で新設された関数)

C<abs>, C<bless>, C<break>, C<chomp>, C<chr>, C<continue>, C<default>, 
C<exists>, C<formline>, C<given>, C<glob>, C<import>, C<lc>, C<lcfirst>,
C<lock>, C<map>, C<my>, C<no>, C<our>, C<prototype>, C<qr//>, C<qw//>, C<qx//>,
C<readline>, C<readpipe>, C<ref>, C<sub>*, C<sysopen>, C<tie>, C<tied>, C<uc>,
C<ucfirst>, C<untie>, C<use>, C<when>

=begin original

* C<sub> was a keyword in Perl 4, but in Perl 5 it is an
operator, which can be used in expressions.

=end original

* - C<sub> は Perl4 ではキーワードですが、Perl5 では演算子なので、
式で使えます。

=item Functions obsoleted in perl5

(perl5 では古いものとなった関数)

C<dbmclose>, C<dbmopen>

=back

=head2 Portability
X<portability> X<Unix> X<portable>

(移植性)

=begin original

Perl was born in Unix and can therefore access all common Unix
system calls.  In non-Unix environments, the functionality of some
Unix system calls may not be available or details of the available
functionality may differ slightly.  The Perl functions affected
by this are:

=end original

Perl は Unix 環境で生まれたので、全ての共通する Unix システムコールに
アクセスします。非 Unix 環境では、いくつかの Unix システムコールの
機能が使えなかったり、使える機能の詳細が多少異なったりします。
これによる影響を受ける Perl 関数は以下のものです:

C<-X>, C<binmode>, C<chmod>, C<chown>, C<chroot>, C<crypt>,
C<dbmclose>, C<dbmopen>, C<dump>, C<endgrent>, C<endhostent>,
C<endnetent>, C<endprotoent>, C<endpwent>, C<endservent>, C<exec>,
C<fcntl>, C<flock>, C<fork>, C<getgrent>, C<getgrgid>, C<gethostbyname>,
C<gethostent>, C<getlogin>, C<getnetbyaddr>, C<getnetbyname>, C<getnetent>,
C<getppid>, C<getpgrp>, C<getpriority>, C<getprotobynumber>,
C<getprotoent>, C<getpwent>, C<getpwnam>, C<getpwuid>,
C<getservbyport>, C<getservent>, C<getsockopt>, C<glob>, C<ioctl>,
C<kill>, C<link>, C<lstat>, C<msgctl>, C<msgget>, C<msgrcv>,
C<msgsnd>, C<open>, C<pipe>, C<readlink>, C<rename>, C<select>, C<semctl>,
C<semget>, C<semop>, C<setgrent>, C<sethostent>, C<setnetent>,
C<setpgrp>, C<setpriority>, C<setprotoent>, C<setpwent>,
C<setservent>, C<setsockopt>, C<shmctl>, C<shmget>, C<shmread>,
C<shmwrite>, C<socket>, C<socketpair>,
C<stat>, C<symlink>, C<syscall>, C<sysopen>, C<system>,
C<times>, C<truncate>, C<umask>, C<unlink>,
C<utime>, C<wait>, C<waitpid>

=begin original

For more information about the portability of these functions, see
L<perlport> and other available platform-specific documentation.

=end original

これらの関数の移植性に関するさらなる情報については、
L<perlport> とその他のプラットホーム固有のドキュメントを参照して下さい。

=head2 Alphabetical Listing of Perl Functions

=over 

=item -X FILEHANDLE
X<-r>X<-w>X<-x>X<-o>X<-R>X<-W>X<-X>X<-O>X<-e>X<-z>X<-s>X<-f>X<-d>X<-l>X<-p>
X<-S>X<-b>X<-c>X<-t>X<-u>X<-g>X<-k>X<-T>X<-B>X<-M>X<-A>X<-C>

=item -X EXPR

=item -X DIRHANDLE

=item -X

=begin original

A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename, a filehandle, or a dirhandle, 
and tests the associated file to see if something is true about it.  If the
argument is omitted, tests C<$_>, except for C<-t>, which tests STDIN.
Unless otherwise documented, it returns C<1> for true and C<''> for false, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator.  The
operator may be any of:

=end original

X は以下にあげる文字で、ファイルテストを行ないます。
この単項演算子は、ファイル名かファイルハンドルを唯一の
引数として動作し、「あること」について真であるか否かを
判定した結果を返します。
引数が省略されると、C<-t> では STDIN を調べますが、その他は C<$_> を調べます。
特に記述されていなければ、真として C<1> を返し、偽として
C<''> を返し、ファイルが存在しなければ、未定義値を返します。
みかけは変わっていますが、優先順位は名前付き単項演算子と同じで、
他の単項演算子と同じく、引数を括弧で括ることもできます。
演算子には以下のものがあります:

=begin original

    -r  File is readable by effective uid/gid.
    -w  File is writable by effective uid/gid.
    -x  File is executable by effective uid/gid.
    -o  File is owned by effective uid.

=end original

    -r  ファイルが実効 uid/gid で読み出し可
    -w  ファイルが実効 uid/gid で書き込み可
    -x  ファイルが実効 uid/gid で実行可
    -o  ファイルが実効 uid の所有物

=begin original

    -R  File is readable by real uid/gid.
    -W  File is writable by real uid/gid.
    -X  File is executable by real uid/gid.
    -O  File is owned by real uid.

=end original

    -R  ファイルが実 uid/gid で読み出し可
    -W  ファイルが実 uid/gid で書き込み可
    -X  ファイルが実 uid/gid で実行可
    -O  ファイルが実 uid の所有物

=begin original

    -e  File exists.
    -z  File has zero size (is empty).
    -s  File has nonzero size (returns size in bytes).

=end original

    -e  ファイルが存在する
    -z  ファイルの大きさがゼロ(空)
    -s  ファイルの大きさがゼロ以外 (バイト単位での大きさを返す)

=begin original

    -f  File is a plain file.
    -d  File is a directory.
    -l  File is a symbolic link.
    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
    -S  File is a socket.
    -b  File is a block special file.
    -c  File is a character special file.
    -t  Filehandle is opened to a tty.

=end original

    -f  ファイルは通常ファイル
    -d  ファイルはディレクトリ
    -l  ファイルはシンボリックリンク
    -p  ファイルは名前付きパイプ (FIFO) またはファイルハンドルはパイプ
    -S  ファイルはソケット
    -b  ファイルはブロック特殊ファイル
    -c  ファイルはキャラクタ特殊ファイル
    -t  ファイルハンドルは tty にオープンされている

=begin original

    -u  File has setuid bit set.
    -g  File has setgid bit set.
    -k  File has sticky bit set.

=end original

    -u  ファイルの setuid ビットがセットされている
    -g  ファイルの setgid ビットがセットされている
    -k  ファイルの sticky ビットがセットされている

=begin original

    -T  File is an ASCII text file (heuristic guess).
    -B  File is a "binary" file (opposite of -T).

=end original

    -T  ファイルは ASCII テキストファイル (発見的に推測します)
    -B  ファイルは「バイナリ」ファイル (-T の反対)

=begin original

    -M  Script start time minus file modification time, in days.
    -A  Same for access time.
    -C  Same for inode change time (Unix, may differ for other platforms)

=end original

    -M  スクリプト実行開始時刻からファイル修正時刻を引いたもの(日単位)
    -A  同様にアクセスがあってからの日数
    -C  同様に(Unix では) inode が変更されてからの日数(それ以外のプラットフォームでは違うかもしれません)

=begin original

Example:

=end original

例:

    while (<>) {
        chomp;
        next unless -f $_;  # ignore specials
        #...
    }

=begin original

Note that C<-s/a/b/> does not do a negated substitution.  Saying
C<-exp($foo)> still works as expected, however: only single letters
following a minus are interpreted as file tests.

=end original

C<-s/a/b> は、置換演算 (s///) の符号反転ではありません。
しかし、C<-exp($foo)> は期待どおりに動作します。
マイナス記号の後に英字が 1 字続くときにのみ、ファイルテストと
解釈されます。

=begin original

These operators are exempt from the "looks like a function rule" described
above. That is, an opening parenthesis after the operator does not affect
how much of the following code constitutes the argument. Put the opening
parentheses before the operator to separate it from code that follows (this
applies only to operators with higher precedence than unary operators, of
course):

=end original

これらの演算子は上述の「関数のように見えるルール」から免除されます。
つまり、演算子の後の開きかっこは、引き続くコードのどこまでが引数を
構成するかに影響を与えません。
演算子を引き続くコードから分離するには、演算子の前に開きかっこを
置いてください (これはもちろん、単項演算子より高い優先順位を持つ
演算子にのみ適用されます):

    -s($file) + 1024   # probably wrong; same as -s($file + 1024)
    (-s $file) + 1024  # correct

=begin original

The interpretation of the file permission operators C<-r>, C<-R>,
C<-w>, C<-W>, C<-x>, and C<-X> is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.  Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.

=end original

ファイルのパーミッション演算子 C<-r>, C<-R>, C<-w>, C<-W>, C<-x>,
C<-X> の解釈は、ファイルのモードとユーザの実効／実 uid と
実効／実 gid のみから判断されます。
実際にファイルが読めたり、書けたり、実行できたりするためには、
別の条件が必要かもしれません:
例えば、ネットワークファイルシステムアクセスコントロール、
ACL(アクセスコントロールリスト)、読み込み専用ファイルシステム、
認識できない実行ファイルフォーマット、などです。
これらの 6 つの演算子を、特定の操作が可能かどうかを確認するために使うのは
通常は誤りであることに注意してください; なぜなら、これらは競合条件を
招きやすいからです。

=begin original

Also note that, for the superuser on the local filesystems, the C<-r>,
C<-R>, C<-w>, and C<-W> tests always return 1, and C<-x> and C<-X> return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a stat() to determine the actual mode of the file,
or temporarily set their effective uid to something else.

=end original

ローカルファイルシステムのスーパーユーザには、
C<-r>, C<-R>, C<-w>, C<-W> に対して、常に 1 が返り、モード中の
いずれかの実行許可ビットが立っていれば、C<-x>, C<-X> にも 1 が
返ることにも注意してください。
スーパーユーザが実行するスクリプトでは、ファイルのモードを調べるためには、
stat() を行なうか、実効 uid を一時的に別のものにする
必要があるでしょう。

=begin original

If you are using ACLs, there is a pragma called C<filetest> that may
produce more accurate results than the bare stat() mode bits.
When under C<use filetest 'access'> the above-mentioned filetests
test whether the permission can(not) be granted using the
access(2) family of system calls.  Also note that the C<-x> and C<-X> may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls' definitions. Note also that, due to
the implementation of C<use filetest 'access'>, the C<_> special
filehandle won't cache the results of the file tests when this pragma is
in effect.  Read the documentation for the C<filetest> pragma for more
information.

=end original

ACL を使っている場合は、生の stat() モードビットより
精度の高い結果を作成する C<filetest> プラグマがあります。
C<use filetest 'access'> とした場合、上述したファイルテストは
システムコールの access(2) ファミリーを使って権限が与えられているか
どうかをテストします。
また、このプラグマが指定されている場合、C<-x> と C<-X> は
たとえ実行許可ビット(または追加の実行許可 ACL)がセットされていない
場合でも真を返すことに注意してください。
この挙動は使用するシステムコールの定義によるものです。
C<use filetest 'access'> の実装により、このプラグマが有効の場合は
C<_> 特殊ファイルハンドルはファイルテストの結果をキャッシュしないことに
注意してください。
さらなる情報については C<filetest> プラグマのドキュメントを
参照してください。

=begin original

The C<-T> and C<-B> switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many strange characters (>30%)
are found, it's a C<-B> file; otherwise it's a C<-T> file.  Also, any file
containing a zero byte in the first block is considered a binary file.  If C<-T>
or C<-B> is used on a filehandle, the current IO buffer is examined
rather than the first block.  Both C<-T> and C<-B> return true on an empty
file, or a file at EOF when testing a filehandle.  Because you have to
read a file to do the C<-T> test, on most occasions you want to use a C<-f>
against the file first, as in C<next unless -f $file && -T $file>.

=end original

ファイルテスト C<-T> と C<-B> の動作原理は、次のようになっています。
ファイルの最初の数ブロックを調べて、変わった制御コードや
上位ビットがセットされているような、通常のテキストには現れない文字を探します。
そのような文字が、たくさん (>30%) 見つかるようであれば、
そのファイルは C<-B> ファイルであると判断されます;
さもなければ C<-T> ファイルとなります。
最初のブロックにヌル文字が含まれるファイルも、
バイナリファイルとみなされます。
C<-T> や C<-B> をファイルハンドルに対して用いると、
最初のブロックを調べる代わりに、IO バッファを調べます。
調べたファイルの中身が何もないときや、
ファイルハンドルを調べたときに EOF に達して
いたときには、C<-T> も C<-B> も「真」を返します。
C<-T> テストをするためにはファイルを読み込まないといけないので、
たいていは C<next unless -f $file && -T $file> というような形で
まず調べたいファイルに対して C<-f> を使いたいはずです。

=begin original

If any of the file tests (or either the C<stat> or C<lstat> operator) is given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with C<-t>, and you need to remember
that lstat() and C<-l> leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an C<lstat> call, C<-T> and C<-B> will reset it with the results of C<stat _>).
Example:

=end original

どのファイルテスト (あるいは、C<stat> や C<lstat>) 演算子にも、
下線だけから成る特別なファイルハンドルを与えると、
前回のファイルテスト (や stat) の stat 構造体が使われ、
システムコールを省きます。
(C<-t> には使えませんし、lstat() や C<-l> は実ファイルではなく、
シンボリックリンクの情報を stat 構造体に残すことを
覚えておく必要があります。)
(また、stat バッファが C<lstat> 呼び出しで埋まった場合、
C<-T> と C<-B> の結果は C<stat _> の結果でリセットされます。
例:

    print "Can do.\n" if -r $a || -w _ || -x _;

    stat($filename);
    print "Readable\n" if -r _;
    print "Writable\n" if -w _;
    print "Executable\n" if -x _;
    print "Setuid\n" if -u _;
    print "Setgid\n" if -g _;
    print "Sticky\n" if -k _;
    print "Text\n" if -T _;
    print "Binary\n" if -B _;

=begin original

As of Perl 5.9.1, as a form of purely syntactic sugar, you can stack file
test operators, in a way that C<-f -w -x $file> is equivalent to
C<-x $file && -w _ && -f _>. (This is only fancy fancy: if you use
the return value of C<-f $file> as an argument to another filetest
operator, no special magic will happen.)

=end original

Perl 5.9.1 から、純粋にシンタックスシュガーとして、ファイルテスト演算子を
スタックさせることができるので、C<-f -w -x $file> は
C<-x $file && -w _ && -f _> と等価です。
(これは文法上だけの話です; もし C<-f $file> の返り値を他のファイルテスト
演算子の引数として使う場合は、何の特別なことも起きません。)

=item abs VALUE
X<abs> X<absolute>

=item abs

=begin original

Returns the absolute value of its argument.
If VALUE is omitted, uses C<$_>.

=end original

引数の絶対値を返します。
VALUE が省略された場合は、C<$_> を使います。

=item accept NEWSOCKET,GENERICSOCKET
X<accept>

=begin original

Accepts an incoming socket connect, just as accept(2) 
does.  Returns the packed address if it succeeded, false otherwise.
See the example in L<perlipc/"Sockets: Client/Server Communication">.

=end original

accept(2) システムコールと同様に、着信するソケットの接続を受け付けます。
成功時にはパックされたアドレスを返し、失敗すれば偽を返します。
L<perlipc/"Sockets: Client/Server Communication"> の
例を参照してください。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは $^F の値で決定される、新しくオープンされたファイル記述子に対して
セットされます。L<perlvar/$^F> を参照してください。

=item alarm SECONDS
X<alarm>
X<SIGALRM>
X<timer>

=item alarm

=begin original

Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.  If SECONDS is not
specified, the value stored in C<$_> is used. (On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)

=end original

指定した壁時計秒数が経過した後に、自プロセスに SIGALRM が
送られてくるようにします。SECONDS が指定されていない場合は、
C<$_>に格納されている値を使います。
(マシンによっては、秒の数え方が異なるため、指定した秒数よりも
最大で 1 秒ずれます。)

=begin original

Only one timer may be counting at once.  Each call disables the
previous timer, and an argument of C<0> may be supplied to cancel the
previous timer without starting a new one.  The returned value is the
amount of time remaining on the previous timer.

=end original

一度には一つのタイマだけが設定可能です。
呼び出しを行なう度に、以前のタイマを無効にしますし、
新しくタイマを起動しないで以前のタイマをキャンセルするために
引数に C<0> を指定して呼び出すことができます。
以前のタイマの残り時間が、返り値となります。

=begin original

For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides ualarm().  You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C<syscall> interface to access setitimer(2) if
your system supports it. See L<perlfaq8> for details.

=end original

1 秒より精度の高いスリープを行なうには、
Time::HiRes モジュール(CPAN から、また Perl 5.8 からは
標準配布されています) が ualarm() を提供します。
Perl の 4 引数版 select() を最初の 3 引数を未定義にして使うか、
setitimer(2) をサポートしているシステムでは、Perl の
C<syscall> インタフェースを使ってアクセスすることもできます。
詳しくは L<perlfaq8> を参照してください。

=begin original

It is usually a mistake to intermix C<alarm> and C<sleep> calls, because
C<sleep> may be internally implemented on your system with C<alarm>.

=end original

C<alarm> と C<sleep> を混ぜて使うのは普通は間違いです; なぜなら、
C<sleep> は内部的に C<alarm> を使って内部的に実装されているかも
しれないからです。

=begin original

If you want to use C<alarm> to time out a system call you need to use an
C<eval>/C<die> pair.  You can't rely on the alarm causing the system call to
fail with C<$!> set to C<EINTR> because Perl sets up signal handlers to
restart system calls on some systems.  Using C<eval>/C<die> always works,
modulo the caveats given in L<perlipc/"Signals">.

=end original

C<alarm> をシステムコールの時間切れのために使いたいなら、
C<eval>/C<die> のペアで使う必要があります。
システムコールが失敗したときに C<$!> に C<EINTR> がセットされることに
頼ってはいけません。なぜならシステムによっては Perl は 
システムコールを再開するためにシグナルハンドラを設定するからです。
C<eval>/C<die> は常にうまく動きます。
注意点については L<perlipc/"Signals"> を参照して下さい。

    eval {
        local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
        alarm $timeout;
        $nread = sysread SOCKET, $buffer, $size;
        alarm 0;
    };
    if ($@) {
        die unless $@ eq "alarm\n";   # propagate unexpected errors
        # timed out
    }
    else {
        # didn't
    }

=begin original

For more information see L<perlipc>.

=end original

さらなる情報については L<perlipc> を参照してください。

=item atan2 Y,X
X<atan2> X<arctangent> X<tan> X<tangent>

=begin original

Returns the arctangent of Y/X in the range -PI to PI.

=end original

-πからπの範囲で Y/X の逆正接を返します。

=begin original

For the tangent operation, you may use the C<Math::Trig::tan>
function, or use the familiar relation:

=end original

正接を求めたいときは、C<Math::Trig::tan> を使うか、
以下のよく知られた関係を使ってください。

    sub tan { sin($_[0]) / cos($_[0])  }

=begin original

The return value for C<atan2(0,0)> is implementation-defined; consult
your atan2(3) manpage for more information.

=end original

C<atan2(0,0)> の返り値は実装依存です; さらなる情報については
atan2(3) man ページを参照してください。

=item bind SOCKET,NAME
X<bind>

=begin original

Binds a network address to a socket, just as bind(2)
does.  Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

bind(2) システムコールと同様に、ネットワークアドレスをソケットに結び付けます。
成功時には真を返し、失敗時には偽を返します。
NAME は、ソケットに対する、適切な型のパックされたアドレスでなければなりません。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=item binmode FILEHANDLE, LAYER
X<binmode> X<binary> X<text> X<DOS> X<Windows>

=item binmode FILEHANDLE

=begin original

Arranges for FILEHANDLE to be read or written in "binary" or "text"
mode on systems where the run-time libraries distinguish between
binary and text files.  If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.  Returns true on success,
otherwise it returns C<undef> and sets C<$!> (errno).

=end original

バイナリファイルとテキストファイルを区別する OS において、
FILEHANDLE を「バイナリ」または「テキスト」で読み書きするように
指定します。
FILEHANDLE が式である場合には、その式の値がファイルハンドルの
名前として使われます。
成功時には真を返し、失敗時には C<undef> を返して C<$!> (errno) を設定します。

=begin original

On some systems (in general, DOS- and Windows-based systems) binmode()
is necessary when you're not working with a text file.  For the sake
of portability it is a good idea always to use it when appropriate,
and never to use it when it isn't appropriate.  Also, people can
set their I/O to be by default UTF8-encoded Unicode, not bytes.

=end original

テキストファイルでないものを扱う場合に binmode() が必要な
システムもあります(一般的には DOS と Windows ベースのシステムです)。
移植性のために、適切なときには常にこれを使い、適切でないときには
決して使わないというのは良い考えです。
また、デフォルトとして I/O を bytes ではなく UTF-8 エンコードされた
Unicode にセットすることも出来ます。

=begin original

In other words: regardless of platform, use binmode() on binary data,
like images, for example.

=end original

言い換えると: プラットフォームに関わらず、
例えばイメージのようなバイナリファイルに対しては binmode() を
使ってください。

=begin original

If LAYER is present it is a single string, but may contain multiple
directives. The directives alter the behaviour of the filehandle.
When LAYER is present, using binmode on a text file makes sense.

=end original

LAYER が存在すると、それは単一の文字列ですが、複数の指示子を
含むことができます。
指示子はファイルハンドルの振る舞いを変更します。
LAYER が存在すると、テキストファイルでの binmode が意味を持ちます。

=begin original

If LAYER is omitted or specified as C<:raw> the filehandle is made
suitable for passing binary data. This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).
Note that, despite what may be implied in I<"Programming Perl"> (the
Camel, 3rd edition) or elsewhere, C<:raw> is I<not> simply the inverse of C<:crlf>.
Other layers that would affect the binary nature of the stream are
I<also> disabled. See L<PerlIO>, L<perlrun>, and the discussion about the
PERLIO environment variable.

=end original

LAYER が省略されたり、C<:raw> が指定されると、ファイルハンドルはバイナリ
データの通過に適するように設定されます。
これには CRLF 変換をオフにしたり、それぞれを(Unicode 文字ではなく)
バイトであるとマークしたりすることを含みます。
I<"プログラミング Perl">(ラクダ本第三版) やその他で暗示されているにも関わらず、
C<:raw> は単なる C<:crlf> の I<逆ではありません>。
ストリームのバイナリとしての性質に影響を与える
I<その他の層も無効にされます>。
L<PerlIO>, L<perlrun> およびPERLIO 環境変数に関する議論を参照してください。

=begin original

The C<:bytes>, C<:crlf>, C<:utf8>, and any other directives of the
form C<:...>, are called I/O I<layers>.  The C<open> pragma can be used to
establish default I/O layers.  See L<open>.

=end original

C<:bytes>, C<:crlf>, and C<:utf8>, 及びその他の C<:...> 形式の指示子は
I/O I<層> が呼び出されます。
C<open> プラグマはデフォルト I/O 層を指定するために使われます。
L<open> を参照してください。

=begin original

I<The LAYER parameter of the binmode() function is described as "DISCIPLINE"
in "Programming Perl, 3rd Edition".  However, since the publishing of this
book, by many known as "Camel III", the consensus of the naming of this
functionality has moved from "discipline" to "layer".  All documentation
of this version of Perl therefore refers to "layers" rather than to
"disciplines".  Now back to the regularly scheduled documentation...>

=end original

I<binmode() 関数の LAYER パラメータは 「プログラミングPerl 第3版」では
「ディシプリン(DISCIPLINE)」と表現されていました。
しかし、「ラクダ本第3版」として知られているこの本の出版後、この機能の名前は
「ディシプリン」から「層」に変更することで合意されました。
従って、このバージョンの Perl の全ての文書では「ディシプリン」ではなく
「層」と記述されています。では通常の解説に戻ります…。>

=begin original

To mark FILEHANDLE as UTF-8, use C<:utf8> or C<:encoding(UTF-8)>.
C<:utf8> just marks the data as UTF-8 without further checking,
while C<:encoding(UTF-8)> checks the data for actually being valid
UTF-8. More details can be found in L<PerlIO::encoding>.

=end original

FILEHANDLE が UTF-8 であるというマークをつけるには、C<:utf8> か
C<:encoding(UTF-8)> を使ってください。
C<:utf8> は、さらなるチェックなしにデータが UTF-8 としてマークしますが、
C<:encoding(UTF-8)> はデータが実際に有効な UTF-8 かどうかをチェックします。
さらなる詳細は L<PerlIO::encoding> にあります。

=begin original

In general, binmode() should be called after open() but before any I/O
is done on the filehandle.  Calling binmode() normally flushes any
pending buffered output data (and perhaps pending input data) on the
handle.  An exception to this is the C<:encoding> layer that
changes the default character encoding of the handle; see L</open>.
The C<:encoding> layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.  The C<:encoding>
also implicitly pushes on top of itself the C<:utf8> layer because
internally Perl operates on UTF8-encoded Unicode characters.

=end original

一般的に binmode() は open() を呼び出した後、このファイルハンドルに対する
I/O 操作をする前に呼び出すべきです。
binmode() を呼び出すと、普通はこのファイルハンドルに対して
バッファリングされている全ての出力データ
(およびおそらくは入力データ)をフラッシュします。
例外は、このハンドルに対するデフォルト文字エンコーディングを変更する
C<:encoding> 層です; L</open> を参照してください。
C<:encoding> 層はストリームの途中で呼び出す必要があることがあり、
それによってストリームはフラッシュされません。
Perl は内部で UTF-8 エンコードされた Unicode 文字を操作しているので、
C<:encoding> は暗黙のうちに自身を C<:utf8> 層の上に押し上げます。

=begin original

The operating system, device drivers, C libraries, and Perl run-time
system all conspire to let the programmer treat a single
character (C<\n>) as the line terminator, irrespective of external
representation.  On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C<\n> is made up of more than
one character.

=end original

オペレーションシステム、デバイスドライバ、C ライブラリ、
Perl ランタイムシステムは全て、プログラマが外部表現に関わらず
1 文字 (C<\n>) を行終端として扱えるように協調作業します。
多くのオペレーティングシステムでは、ネイティブテキストファイル表現は
内部表現と同じですが、C<\n> の外部表現が複数文字になる
プラットフォームもあります。

=begin original

All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use
a single character to end each line in the external representation of text
(even though that single character is CARRIAGE RETURN on old, pre-Darwin
flavors of Mac OS, and is LINE FEED on Unix and most VMS files). In other
systems like OS/2, DOS, and the various flavors of MS-Windows, your program
sees a C<\n> as a simple C<\cJ>, but what's stored in text files are the
two characters C<\cM\cJ>.  That means that if you don't use binmode() on
these systems, C<\cM\cJ> sequences on disk will be converted to C<\n> on
input, and any C<\n> in your program will be converted back to C<\cM\cJ> on
output.  This is what you want for text files, but it can be disastrous for
binary files.

=end original

全ての Unix 系、(新旧の)Mac OS、VMS の Stream_LF ファイルは
テキストの外部表現として各行の末尾に一つの文字を
使っています(しかしその文字は古い Darwin 以前の Mac OS では復帰で、
Unix とほとんどのVMS のファイルでは改行です)。
VMS, MS-DOS, MS-Windows 系といったその他のシステムでは、
プログラムからは C<\n> は単純に C<\cJ> に見えますが、
テキストファイルとして保存される場合は C<\cM\cJ> の 2 文字になります。
つまり、もしこれらのシステムで binmode() を使わないと、
ディスク上の C<\cM\cJ> という並びは入力時に C<\n> に変換され、
プログラムが出力した全ての C<\n> は C<\cM\cJ> に逆変換されます。
これはテキストファイルの場合は思い通りの結果でしょうが、
バイナリファイルの場合は悲惨です。

=begin original

Another consequence of using binmode() (on some systems) is that
special end-of-file markers will be seen as part of the data stream.
For systems from the Microsoft family this means that, if your binary
data contain C<\cZ>, the I/O subsystem will regard it as the end of
the file, unless you use binmode().

=end original

binmode() を(いくつかのシステムで)使うことによるその他の作用としては、
特別なファイル終端マーカーがデータストリームの一部として
見られることです。
Microsoft ファミリーのシステムでは、binmode() を使っていないと
もしバイナリデータに C<\cZ> が含まれていたときに、I/O サブシステムが
これをファイル終端とみなすことを意味します。

=begin original

binmode() is important not only for readline() and print() operations,
but also when using read(), seek(), sysread(), syswrite() and tell()
(see L<perlport> for more details).  See the C<$/> and C<$\> variables
in L<perlvar> for how to manually set your input and output
line-termination sequences.

=end original

binmode() は readline() と print() 操作にだけではなく、
read(), seek(), sysread(), syswrite(), tell() を使うときにも重要です
(詳細は L<perlport> を参照してください)。
入出力の行端末シーケンスを手動でセットする方法については
L<perlvar> の C<$/> 変数と C<$\> 変数を参照してください。

=item bless REF,CLASSNAME
X<bless>

=item bless REF

=begin original

This function tells the thingy referenced by REF that it is now an object
in the CLASSNAME package.  If CLASSNAME is omitted, the current package
is used.  Because a C<bless> is often the last thing in a constructor,
it returns the reference for convenience.  Always use the two-argument
version if a derived class might inherit the function doing the blessing.
See L<perltoot> and L<perlobj> for more about the blessing (and blessings)
of objects.

=end original

この関数は、REF で渡された オブジェクトに対し、
CLASSNAME 内のオブジェクトとなったことを伝えます。
CLASSNAME が省略された場合には、その時点のパッケージとなります。
C<bless> は通常、コンストラクタの最後に置かれますので、
簡便のためにそのリファレンスを返します。
派生クラスが bless される関数を継承する場合は、
常に 2 引数版を使ってください。
オブジェクトの bless (や再 bless) について、
詳しくは L<perltoot> と L<perlobj> を参照してください。

=begin original

Consider always blessing objects in CLASSNAMEs that are mixed case.
Namespaces with all lowercase names are considered reserved for
Perl pragmata.  Builtin types have all uppercase names. To prevent
confusion, you may wish to avoid such package names as well.  Make sure
that CLASSNAME is a true value.

=end original

大文字小文字が混じっている CLASSNAME のオブジェクトは常に bless することを
考慮してください。
全て小文字の名前を持つ名前空間は Perl プラグマのために予約されています。
組み込みの型は全て大文字の名前を持ちます。
混乱を避けるために、
パッケージ名としてこのような名前は避けるべきです。
CLASSNAME は真の値を持つようにしてください。

=begin original

See L<perlmod/"Perl Modules">.

=end original

L<perlmod/"Perl Modules"> を参照して下さい。

=item break

=begin original

Break out of a C<given()> block.

=end original

C<given()> ブロックから脱出します。

=begin original

This keyword is enabled by the C<"switch"> feature: see
L<feature> for more information.  Alternately, include a C<use
v5.10> or later to the current scope.

=end original

このキーワードは C<"switch"> 機能によって有効になります:
さらなる情報については L<feature> を参照してください。
あるいは、現在のスコープに C<use v5.10> 以降を含めてください。

=item caller EXPR
X<caller> X<call stack> X<stack> X<stack trace>

=item caller

=begin original

Returns the context of the current subroutine call.  In scalar context,
returns the caller's package name if there I<is> a caller (that is, if
we're in a subroutine or C<eval> or C<require>) and the undefined value
otherwise.  In list context, returns

=end original

その時点のサブルーチン呼び出しのコンテキストを返します。
スカラコンテキストでは、呼び元が I<ある> 場合
(サブルーチン、C<eval>、C<require> の中にいるとき) には
呼び出し元のパッケージ名を返し、その他のときには未定義値を返します。
リストコンテキストでは、以下を返します:

    # 0         1          2
    ($package, $filename, $line) = caller;

=begin original

With EXPR, it returns some extra information that the debugger uses to
print a stack trace.  The value of EXPR indicates how many call frames
to go back before the current one.

=end original

EXPR を付けると、デバッガがスタックトレースを表示するために使う情報を返します。
EXPR の値は、現状から数えて、
いくつ前のコールフレームまで戻るかを示します。

    #  0         1          2      3            4
    ($package, $filename, $line, $subroutine, $hasargs,

    #  5          6          7            8       9         10
    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
     = caller($i);

=begin original

Here $subroutine may be C<(eval)> if the frame is not a subroutine
call, but an C<eval>.  In such a case additional elements $evaltext and
C<$is_require> are set: C<$is_require> is true if the frame is created by a
C<require> or C<use> statement, $evaltext contains the text of the
C<eval EXPR> statement.  In particular, for an C<eval BLOCK> statement,
$subroutine is C<(eval)>, but $evaltext is undefined.  (Note also that
each C<use> statement creates a C<require> frame inside an C<eval EXPR>
frame.)  $subroutine may also be C<(unknown)> if this particular
subroutine happens to have been deleted from the symbol table.
C<$hasargs> is true if a new instance of C<@_> was set up for the frame.
C<$hints> and C<$bitmask> contain pragmatic hints that the caller was
compiled with.  The C<$hints> and C<$bitmask> values are subject to change
between versions of Perl, and are not meant for external use.

=end original

もしフレームがサブルーチン呼び出しではなく C<eval> だった場合、この
$subroutine は C<(eval)> になります。
この場合、追加の要素である $evaltext と C<$is_require> がセットされます:
C<$is_require> はフレームが C<require> または C<use> で作られた場合に
真になり、$evaltext は C<eval EXPR> のテキストが入ります。
特に、C<eval BLOCK> の場合、$subroutine は C<(eval)> になりますが、
$evaltext は未定義値になります。
(それぞれの C<use> は C<eval EXPR> の中で C<require> フレームを作ることに
注意してください。)
$subroutine は、そのサブルーチンがシンボルテーブルから削除された場合は
C<(unknown)> になります。
C<$hasargs> はこのフレーム用に C<@_> の新しい実体が設定された場合に真となります。
C<$hints> と C<$bitmask> は caller がコンパイルされたときの
実際的なヒントを含みます。
C<$hints> は C<$bitmask> は Perl のバージョンによって変更される
可能性があるので、外部での使用を想定していません。 

=begin original

C<$hinthash> is a reference to a hash containing the value of C<%^H> when the
caller was compiled, or C<undef> if C<%^H> was empty. Do not modify the values
of this hash, as they are the actual values stored in the optree.

=end original

C<$hinthash> は、caller がコンパイルされた時の C<%^H> の値を含む
ハッシュへのリファレンスか、あるいは C<%^H> が空の場合は C<undef> です。
このハッシュの値は構文木に保管されている実際の値なので、変更しないで下さい。

=begin original

Furthermore, when called from within the DB package, caller returns more
detailed information: it sets the list variable C<@DB::args> to be the
arguments with which the subroutine was invoked.

=end original

さらに、DB パッケージの中から呼ばれた場合は、caller は
より詳細な情報を返します。
サブルーチンが起動されたときの引数を変数 C<@DB::args> に設定します。

=begin original

Be aware that the optimizer might have optimized call frames away before
C<caller> had a chance to get the information.  That means that C<caller(N)>
might not return information about the call frame you expect it to, for
C<< N > 1 >>.  In particular, C<@DB::args> might have information from the
previous time C<caller> was called.

=end original

C<caller> が情報を得る前にオプティマイザが呼び出しフレームを最適化して
しまうかもしれないことに注意してください。
これは、C<caller(N)> が C<< N > 1 >> のとき、
あなたが予測した呼び出しフレームの情報を返さないかもしれないことを意味します。
特に、C<@DB::args> は C<caller> が前回呼び出された時の情報を
持っているかもしれません。

=begin original

Be aware that setting C<@DB::args> is I<best effort>, intended for
debugging or generating backtraces, and should not be relied upon. In
particular, as C<@_> contains aliases to the caller's arguments, Perl does
not take a copy of C<@_>, so C<@DB::args> will contain modifications the
subroutine makes to C<@_> or its contents, not the original values at call
time. C<@DB::args>, like C<@_>, does not hold explicit references to its
elements, so under certain cases its elements may have become freed and
reallocated for other variables or temporary values. Finally, a side effect
of the current implementation is that the effects of C<shift @_> can
I<normally> be undone (but not C<pop @_> or other splicing, I<and> not if a
reference to C<@_> has been taken, I<and> subject to the caveat about reallocated
elements), so C<@DB::args> is actually a hybrid of the current state and
initial state of C<@_>. Buyer beware.

=end original

C<@DB::args> の設定は I<ベストエフォート> で、デバッグやバックトレースの
生成を目的としていて、これに依存するべきではないということにも
注意してください。
特に、C<@_> は呼び出し元の引数へのエイリアスを含んでいるので、Perl は
C<@_> のコピーを取らず、従って C<@DB::args> はサブルーチンが
C<@_> やその内容に行った変更を含んでいて、呼び出し時の元の値ではありません。
C<@DB::args> は、C<@_> と同様、その要素への明示的なリファレンスを
保持しないので、ある種の状況では、解放されて他の変数や一時的な値のために
再割り当てされているかもしれません。
最後に、現在の実装の副作用は、C<shift @_> の効果は I<普通は> 行われない
(しかし C<pop @_> やその他の splice は違い、I<そして> もし
C<@_> のリファレンスが取られると違い、I<そして> 再割り当てされた要素に関する
問題になりやすいです)ことなので、C<@DB::args> は実際には現在の状態と
C<@_> の初期状態との合成物となります。
ご用心を。

=item chdir EXPR
X<chdir>
X<cd>
X<directory, change>

=item chdir FILEHANDLE

=item chdir DIRHANDLE

=item chdir

=begin original

Changes the working directory to EXPR, if possible. If EXPR is omitted,
changes to the directory specified by C<$ENV{HOME}>, if set; if not,
changes to the directory specified by C<$ENV{LOGDIR}>. (Under VMS, the
variable C<$ENV{SYS$LOGIN}> is also checked, and used if it is set.) If
neither is set, C<chdir> does nothing. It returns true on success,
false otherwise. See the example under C<die>.

=end original

(可能であれば、) カレントディレクトリを EXPR に移します。
EXPR を指定しないと、C<$ENV{HOME}> が設定されていれば、
そのディレクトリに移ります。
そうでなく、C<$ENV{LOGDIR}>が設定されていれば、そのディレクトリに移ります。
(VMS では C<$ENV{SYS$LOGIN}> もチェックされ、もしセットされていれば使われます。)
どちらも設定されていなければ、C<chdir> は何もしません。
成功時には真を返し、そうでなければ偽を返します。
C<die> の項の例を参照してください。

=begin original

On systems that support fchdir(2), you may pass a filehandle or
directory handle as the argument.  On systems that don't support fchdir(2),
passing handles raises an exception.

=end original

fchdir(2) に対応しているシステムでは、ファイルハンドルや
ディレクトリハンドルを引数として渡せます。
fchdir に対応していないシステムでは、ハンドルを渡すと例外が発生します。

=item chmod LIST
X<chmod> X<permission> X<mode>

=begin original

Changes the permissions of a list of files.  The first element of the
list must be the numeric mode, which should probably be an octal
number, and which definitely should I<not> be a string of octal digits:
C<0644> is okay, but C<"0644"> is not.  Returns the number of files
successfully changed.  See also L</oct> if all you have is a string.

=end original

LIST に含まれるファイルの、パーミッションを変更します。
LIST の最初の要素は、数値表現のモードでなければなりません。
恐らく 8 進表記の数であるべきでしょう。しかし、8 進表記のC<文字列ではいけません>。
C<0644> は OK ですが、 C<'0644'> はだめ、ということです。
変更に成功したファイルの数を返します。
文字列を使いたい場合は、L</oct> を参照してください。

    $cnt = chmod 0755, "foo", "bar";
    chmod 0755, @executables;
    $mode = "0644"; chmod $mode, "foo";      # !!! sets mode to
                                             # --w----r-T
    $mode = "0644"; chmod oct($mode), "foo"; # this is better
    $mode = 0644;   chmod $mode, "foo";      # this is best

=begin original

On systems that support fchmod(2), you may pass filehandles among the
files.  On systems that don't support fchmod(2), passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

fchmod(2) に対応しているシステムでは、ファイルハンドルを引数として渡せます。
fchmod(2) に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません;
裸の単語はファイル名として扱われます。

    open(my $fh, "<", "foo");
    my $perm = (stat $fh)[2] & 07777;
    chmod($perm | 0600, $fh);

=begin original

You can also import the symbolic C<S_I*> constants from the C<Fcntl>

module:

=end original

シンボリックな C<S_I*> 定数を C<Fcntl> モジュールから
インポートすることもできます。

    use Fcntl qw( :mode );
    chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
    # Identical to the chmod 0755 of the example above.

=item chomp VARIABLE
X<chomp> X<INPUT_RECORD_SEPARATOR> X<$/> X<newline> X<eol>

=item chomp( LIST )

=item chomp

=begin original

This safer version of L</chop> removes any trailing string
that corresponds to the current value of C<$/> (also known as
$INPUT_RECORD_SEPARATOR in the C<English> module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph
mode (C<$/ = "">), it removes all trailing newlines from the string.
When in slurp mode (C<$/ = undef>) or fixed-length record mode (C<$/> is
a reference to an integer or the like; see L<perlvar>) chomp() won't
remove anything.
If VARIABLE is omitted, it chomps C<$_>.  Example:

=end original

より安全な C<chop> (以下を参照してください) です。
C<$/> (C<English> モジュールでは、$INPUT_RECORD_SEPARATOR
とも言う) のその時点の値に対応する行末文字を削除します。
全ての引数から削除した文字数の合計を返します。
入力レコードから、改行を削除したいのだけれど、最後のレコードには改行が
入っているのかわからないような場合に、使用できます。
段落モード (C<$/ = "">) では、レコードの最後の改行をすべて取り除きます。
吸い込みモード (C<$/ = undef>) や 固定長レコードモード
(C<$/> が整数へのリファレンスや類似のものの場合; L<perlvar>を参照してください)
では、chomp() は何も取り除きません。
VARIABLE が省略されると、$_ を対象として chomp します。
例:

    while (<>) {
        chomp;  # avoid \n on last field
        @array = split(/:/);
        # ...
    }

=begin original

If VARIABLE is a hash, it chomps the hash's values, but not its keys.

=end original

VARIABLE がハッシュなら、ハッシュのキーではなく値について chomp します。

=begin original

You can actually chomp anything that's an lvalue, including an assignment:

=end original

左辺値であれば、代入を含めて、任意のものを chomp できます:

    chomp($cwd = `pwd`);
    chomp($answer = <STDIN>);

=begin original

If you chomp a list, each element is chomped, and the total number of
characters removed is returned.

=end original

リストを chomp すると、個々の要素が chomp され、
削除された文字数の合計が返されます。

=begin original

Note that parentheses are necessary when you're chomping anything
that is not a simple variable.  This is because C<chomp $cwd = `pwd`;>
is interpreted as C<(chomp $cwd) = `pwd`;>, rather than as
C<chomp( $cwd = `pwd` )> which you might expect.  Similarly,
C<chomp $a, $b> is interpreted as C<chomp($a), $b> rather than
as C<chomp($a, $b)>.

=end original

単純な変数以外のものを chomp する場合はかっこが必要であることに
注意してください。
これは、C<chomp $cwd = `pwd`;> は、予測している
C<chomp( $cwd = `pwd` )> ではなく、C<(chomp $cwd) = `pwd`;> と
解釈されるからです。
同様に、C<chomp $a, $b> は C<chomp($a, $b)> ではなく C<chomp($a), $b>
と解釈されます。

=item chop VARIABLE
X<chop>

=item chop( LIST )

=item chop

=begin original

Chops off the last character of a string and returns the character
chopped.  It is much more efficient than C<s/.$//s> because it neither
scans nor copies the string.  If VARIABLE is omitted, chops C<$_>.
If VARIABLE is a hash, it chops the hash's values, but not its keys.

=end original

文字列の最後の文字を切り捨てて、その切り取った文字を返します。
文字列の検索もコピーも行ないませんので
C<s/.$//s> よりも、ずっと効率的です。
VARIABLE が省略されると、C<$_> を対象として chop します。
VARIABLE がハッシュの場合、ハッシュの value を chop しますが、
key は chop しません。

=begin original

You can actually chop anything that's an lvalue, including an assignment.

=end original

実際のところ、代入を含む左辺値となりうるなんでも chop できます。

=begin original

If you chop a list, each element is chopped.  Only the value of the
last C<chop> is returned.

=end original

リストを chop すると、個々の要素が chop されます。
最後の C<chop> の値だけが返されます。

=begin original

Note that C<chop> returns the last character.  To return all but the last
character, use C<substr($string, 0, -1)>.

=end original

C<chop> は最後の文字を返すことに注意してください。
最後以外の全ての文字を返すためには、C<substr($string, 0, -1)> を
使ってください。

=begin original

See also L</chomp>.

=end original

L</chomp> も参照してください。

=item chown LIST
X<chown> X<owner> X<user> X<group>

=begin original

Changes the owner (and group) of a list of files.  The first two
elements of the list must be the I<numeric> uid and gid, in that
order.  A value of -1 in either position is interpreted by most
systems to leave that value unchanged.  Returns the number of files
successfully changed.

=end original

LIST に含まれるファイルの所有者 (とグループ) を変更します。
LIST の最初の二つの要素には、I<数値表現> の uid と gid を
この順序で与えなければなりません。
どちらかの値を -1 にすると、ほとんどのシステムではその値は
変更しないと解釈します。
変更に成功したファイルの数が返されます。

    $cnt = chown $uid, $gid, 'foo', 'bar';
    chown $uid, $gid, @filenames;

=begin original

On systems that support fchown(2), you may pass filehandles among the
files.  On systems that don't support fchown(2), passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

fchown(2) に対応しているシステムでは、ファイルハンドルを引数として渡せます。
fchown(2) に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません; 裸の単語はファイル名として扱われます。

=begin original

Here's an example that looks up nonnumeric uids in the passwd file:

=end original

passwd ファイルから数値表現でない uid を検索する例を
示します:

    print "User: ";
    chomp($user = <STDIN>);
    print "Files: ";
    chomp($pattern = <STDIN>);

    ($login,$pass,$uid,$gid) = getpwnam($user)
        or die "$user not in passwd file";

    @ary = glob($pattern);  # expand filenames
    chown $uid, $gid, @ary;

=begin original

On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
On POSIX systems, you can detect this condition this way:

=end original

ほとんどのシステムでは、スーパーユーザーだけがファイルの所有者を
変更できますが、グループは実行者の副グループに変更できるべきです。
安全でないシステムでは、この制限はゆるめられています。
しかしこれは移植性のある仮定ではありません。
POSIX システムでは、以下のようにしてこの条件を検出できます:

    use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
    $can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);

=item chr NUMBER
X<chr> X<character> X<ASCII> X<Unicode>

=item chr

=begin original

Returns the character represented by that NUMBER in the character set.
For example, C<chr(65)> is C<"A"> in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.  

=end original

特定の文字セットでの NUMBER で表わされる文字を返します。
たとえば、C<chr(65)> は ASCII と Unicode の両方で C<"A"> となります。
chr(0x263a) は Unicode のスマイリーフェイスです。

=begin original

Negative values give the Unicode replacement character (chr(0xfffd)),
except under the L<bytes> pragma, where the low eight bits of the value
(truncated to an integer) are used.

=end original

負の数は Unicode の置換文字 (chr(0xfffd)) を与えますが、
L<bytes> プラグマの影響下では、(integer に切り詰められた)値の下位 8 ビットが
使われます。

=begin original

If NUMBER is omitted, uses C<$_>.

=end original

NUMBER が省略された場合、C<$_> を使います。

=begin original

For the reverse, use L</ord>.

=end original

逆を行うためには、L</ord> を参照してください。

=begin original

Note that characters from 128 to 255 (inclusive) are by default
internally not encoded as UTF-8 for backward compatibility reasons.

=end original

128 から 255 までの文字は過去との互換性のために
デフォルトでは UTF-8 Unicode にエンコードされません。

=begin original

See L<perlunicode> for more about Unicode.

=end original

Unicode についてもっと知りたいなら、L<perlunicode> を
参照してください。

=item chroot FILENAME
X<chroot> X<root>

=item chroot

=begin original

This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C</> by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If FILENAME is
omitted, does a C<chroot> to C<$_>.

=end original

同じ名前のシステムコールと同じことをします。
現在のプロセス及び子プロセスに対して、C</>で始まるパス名に関して
指定されたディレクトリを新しいルートディレクトリとして扱います。
(これはカレントディレクトリを変更しません。カレントディレクトリはそのままです)。
セキュリティ上の理由により、この呼び出しはスーパーユーザーしか行えません。
FILENAME を省略すると、C<$_> へ C<chroot> します。

=item close FILEHANDLE
X<close>

=item close

=begin original

Closes the file or pipe associated with the filehandle, flushes the IO
buffers, and closes the system file descriptor.  Returns true if those
operations succeed and if no error was reported by any PerlIO
layer.  Closes the currently selected filehandle if the argument is
omitted.

=end original

FILEHANDLE に対応したファイルまたはパイプをクローズして、
IO バッファをフラッシュし、システムファイル記述子をクローズします。
操作が成功し、PerlIO 層からエラーが報告されなかった場合に真を返します。
引数が省略された場合、現在選択されているファイルハンドルをクローズします。

=begin original

You don't have to close FILEHANDLE if you are immediately going to do
another C<open> on it, because C<open> closes it for you.  (See
C<open>.)  However, an explicit C<close> on an input file resets the line
counter (C<$.>), while the implicit close done by C<open> does not.

=end original

クローズしてすぐにまた、同じファイルハンドルに
対してオープンを行なう場合には、C<open> が自動的に C<close>
を行ないますので、close FILEHANDLE する必要はありません
(C<open> を参照してください)。
ただし、明示的にクローズを行なったときにのみ入力ファイルの
行番号 (C<$.>) のリセットが行なわれ、C<open> によって行なわれる
暗黙の C<close>では行なわれません。

=begin original

If the filehandle came from a piped open, C<close> returns false if one of
the other syscalls involved fails or if its program exits with non-zero
status.  If the only problem was that the program exited non-zero, C<$!>
will be set to C<0>.  Closing a pipe also waits for the process executing
on the pipe to exit--in case you wish to look at the output of the pipe
afterwards--and implicitly puts the exit status value of that command into
C<$?> and C<${^CHILD_ERROR_NATIVE}>.

=end original

ファイルハンドルがパイプつきオープンなら、
C<close> はその他のシステムコールが失敗したり
プログラムが非ゼロのステータスで終了した場合にも偽を返します
(プログラムが非ゼロで終了しただけの場合は、C<$!>がC<0>にセットされます)。
後でパイプの出力を見たい場合のために、パイプのクローズでは、
パイプ上で実行されているプロセスの終了を待ち、
また自動的にコマンドのステータス値を C<$?> と
C<${^CHILD_ERROR_NATIVE}> に設定します。

=begin original

If there are multiple threads running, C<close> on a filehandle from a
piped open returns true without waiting for the child process to terminate,
if the filehandle is still open in another thread.

=end original

複数のスレッドがある場合、パイプで開かれたファイルハンドルに対する
C<close> は、そのファイルハンドルが他のスレッドでまだ開かれている場合、
子プロセスの終了を待たずに真を返します。

=begin original

Closing the read end of a pipe before the process writing to it at the
other end is done writing results in the writer receiving a SIGPIPE.  If
the other end can't handle that, be sure to read all the data before
closing the pipe.

=end original

書き込み側が閉じる前に途中でパイプの読み込み側が閉じた場合、
書き込み側に SIGPIPE が配送されます。
書き込み側がこれを扱えない場合、パイプを閉じる前に
確実に全てのデータが読み込まれるようにする必要があります。

=begin original

Example:

=end original

例:

    open(OUTPUT, '|sort >foo')  # pipe to sort
        or die "Can't start sort: $!";
    #...                        # print stuff to output
    close OUTPUT                # wait for sort to finish
        or warn $! ? "Error closing sort pipe: $!"
                   : "Exit status $? from sort";
    open(INPUT, 'foo')          # get sort's results
        or die "Can't open 'foo' for input: $!";

=begin original

FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name or an autovivified handle.

=end original

FILEHANDLE は式でもかまいません。この場合、値は間接ファイルハンドルと
して扱われ、普通は実際のファイルハンドル名か自動有効化されたハンドルです。

=item closedir DIRHANDLE
X<closedir>

=begin original

Closes a directory opened by C<opendir> and returns the success of that
system call.

=end original

C<opendir> でオープンしたディレクトリをクローズし、
システムコールの返り値を返します。

=item connect SOCKET,NAME
X<connect>

=begin original

Attempts to connect to a remote socket, just like connect(2).
Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

connect(2) システムコールと同様に、リモートソケットへの接続を試みます。
成功時には真を返し、失敗時には偽を返します。
NAME は、ソケットに対する、適切な型のパックされた
アドレスでなければなりません。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=item continue BLOCK
X<continue>

=item continue

=begin original

C<continue> is actually a flow control statement rather than a function.  If
there is a C<continue> BLOCK attached to a BLOCK (typically in a C<while> or
C<foreach>), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a C<for> loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the C<next> statement (which is similar to the C C<continue>
statement).

=end original

C<continue> は実際には関数ではなく、実行制御文です。
C<continue> BLOCK が BLOCK (典型的には C<while> または C<foreach> の中)にあると、
これは条件文が再評価される直前に常に実行されます。
これは C における C<for> ループの 3 番目の部分と同様です。
従って、これは C<next> 文
(これは C の C<continue> 文と似ています)を使ってループが繰り返されるときでも
ループ変数を増やしたいときに使えます。

=begin original

C<last>, C<next>, or C<redo> may appear within a C<continue>
block; C<last> and C<redo> behave as if they had been executed within
the main block.  So will C<next>, but since it will execute a C<continue>
block, it may be more entertaining.

=end original

C<last>, C<next>, C<redo> が C<continue> ブロック内に現れる可能性があります;
C<last> と C<redo> はメインブロックの中で実行されたのと同じように振舞います。
C<next> の場合は、C<continue> ブロックを実行することになるので、
より面白いことになります。

    while (EXPR) {
        ### redo always comes here
        do_something;
    } continue {
        ### next always comes here
        do_something_else;
        # then back the top to re-check EXPR
    }
    ### last always comes here

=begin original

Omitting the C<continue> section is equivalent to using an
empty one, logically enough, so C<next> goes directly back
to check the condition at the top of the loop.

=end original

C<continue> 節を省略するのは、空の節を指定したのと同じで、
論理的には十分なので、この場合、C<next> は直接ループ先頭の
条件チェックに戻ります。

=begin original

If the C<"switch"> feature is enabled, C<continue> is also a function that
falls through the current C<when> or C<default> block instead of iterating
a dynamically enclosing C<foreach> or exiting a lexically enclosing C<given>.
See L<feature> and L<perlsyn/"Switch statements"> for more
information.

=end original

C<"switch"> 機能が有効なら、C<continue> は動的に囲まれた C<foreach> や
レキシカルに囲まれた C<given> で反復するのではなく、現在の C<when> または
C<default> のブロックを通り抜けるための文にもなります。
さらなる情報については L<feature> と L<perlsyn/"Switch statements"> を
参照してください。

=item cos EXPR
X<cos> X<cosine> X<acos> X<arccosine>

=item cos

=begin original

Returns the cosine of EXPR (expressed in radians).  If EXPR is omitted,
takes the cosine of C<$_>.

=end original

(ラジアンで示した) EXPR の余弦を返します。
EXPR が省略されたときには、C<$_> の余弦を取ります。

=begin original

For the inverse cosine operation, you may use the C<Math::Trig::acos()>
function, or use this relation:

=end original

逆余弦を求めるためには、C<Math::Trig::acos()> 関数を使うか、
以下の関係を使ってください。

    sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

=item crypt PLAINTEXT,SALT
X<crypt> X<digest> X<hash> X<salt> X<plaintext> X<password>
X<decrypt> X<cryptography> X<passwd> X<encrypt>

=begin original

Creates a digest string exactly like the crypt(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munition).

=end original

C ライブラリの crypt(3) 関数と全く同じように、ダイジェスト文字列を
作成します(一時的な必需品として、まだ絶滅していないバージョンを
持っていると仮定しています)。

=begin original

crypt() is a one-way hash function.  The PLAINTEXT and SALT are turned
into a short string, called a digest, which is returned.  The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.  Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.

=end original

crypt() は一方向ハッシュ関数です。
PLAINTEXT と SALT はダイジェストと呼ばれる短い文字列に変えられて、
それが返されます。
PLAINTEXT と SALT が同じ場合は常に同じ文字列を返しますが、ハッシュから
元の PLAINTEXT を得る(既知の)方法はありません。
PLAINTEXT や SALT を少し変更してもダイジェストは大きく変更されます。

=begin original

There is no decrypt function.  This function isn't all that useful for
cryptography (for that, look for F<Crypt> modules on your nearby CPAN
mirror) and the name "crypt" is a bit of a misnomer.  Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.  An example is checking
if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
crypt()'d with the same salt as the stored digest.  If the two digests
match, the password is correct.

=end original

復号化関数はありません。
この関数は暗号化のためにはまったく役に立ちません(このためには、
お近くの CPAN ミラーで F<Crypt> モジュールを探してください)ので、
"crypt" という名前は少し間違った名前です。
その代わりに、一般的には二つのテキスト片が同じかどうかをテキストそのものを
転送したり保管したりせずにチェックするために使います。
例としては、正しいパスワードが与えられたかどうかをチェックがあります。
パスワード自身ではなく、パスワードのダイジェストが保管されます。
ユーザーがパスワードを入力すると、保管されているダイジェストと同じ
salt で crypt() します。
二つのダイジェストが同じなら、パスワードは正しいです。

=begin original

When verifying an existing digest string you should use the digest as
the salt (like C<crypt($plain, $digest) eq $digest>).  The SALT used
to create the digest is visible as part of the digest.  This ensures
crypt() will hash the new string with the same salt as the digest.
This allows your code to work with the standard L<crypt|/crypt> and
with more exotic implementations.  In other words, assume
nothing about the returned string itself nor about how many bytes 
of SALT may matter.

=end original

すでにあるダイジェスト文字列を検証するには、ダイジェストを
(C<crypt($plain, $digest) eq $digest> のようにして)salt として使います。
ダイジェストを作るのに使われた SALT はダイジェストの一部として見えます。
これにより、crypt() は同じ salt で新しい文字列をダイジェストとして
ハッシュ化できるようにします。
これによって標準的な C<crypt|/crypt> や、より風変わりな実装でも動作します。
言い換えると、返される文字列や、SALT が何バイトあるかといったことに対して、
どのような仮定もしてはいけません。

=begin original

Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C<[./0-9A-Za-z]>, and only
the first eight bytes of PLAINTEXT mattered. But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.

=end original

伝統的には結果は 13 バイトの文字列です: 最初の 2 バイトは salt、引き続いて
集合 C<[./0-9A-Za-z]> からの 11 バイトで、PLAINTEXT の最初の
8 バイトだけが意味があります。
しかし、(MD5 のように) 異なったハッシュ手法、
(C2 のような) 高レベルセキュリティ手法、非 Unix プラットフォームでの
実装などでは異なった文字列が生成されることがあります。

=begin original

When choosing a new salt create a random two character string whose
characters come from the set C<[./0-9A-Za-z]> (like C<join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]>).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C<crypt()> accepts.

=end original

新しい salt を選択する場合は、集合 C<[./0-9A-Za-z]> から
(C<join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]> のようにして)
ランダムに2 つの文字を選びます。
この文字集合は単なる推薦です; salt として許される文字はシステムの暗号化
ライブラリだけに依存し、Perl は C<crypt()> がどのような salt を受け付けるかに
ついて制限しません。

=begin original

Here's an example that makes sure that whoever runs this program knows
their password:

=end original

プログラムを実行する人が、
自分のパスワードを知っていることを確認する例です:

    $pwd = (getpwuid($<))[1];

    system "stty -echo";
    print "Password: ";
    chomp($word = <STDIN>);
    print "\n";
    system "stty echo";

    if (crypt($word, $pwd) ne $pwd) {
        die "Sorry...\n";
    } else {
        print "ok\n";
    }

=begin original

Of course, typing in your own password to whoever asks you
for it is unwise.

=end original

もちろん、自分自身のパスワードを誰にでも入力するのは賢明ではありません。

=begin original

The L<crypt|/crypt> function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.  Look at the L<Digest> module for more robust algorithms.

=end original

L<crypt|/crypt> 関数は大量のデータのハッシュ化には向いていません。
これは情報を戻せないという理由だけではありません。
より頑強なアルゴリズムについては L<Digest> モジュールを参照してください。

=begin original

If using crypt() on a Unicode string (which I<potentially> has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of)
the string back to an eight-bit byte string before calling crypt()
(on that copy).  If that works, good.  If not, crypt() dies with
C<Wide character in crypt>.

=end original

Unicode 文字列(I<潜在的には> 255 を越えるコードポイントを持つ文字を
含みます)に crypt() を使った場合、Perl は crypt() を呼び出す前に与えられた
文字列を8 ビットバイト文字列にダウングレードする(文字列のコピーを作る)
ことで状況のつじつまを合わせようとします。
うまく動けば、それでよし。動かなければ、crypt() は
C<Wide character in crypt> というメッセージと共に die します。

=item dbmclose HASH
X<dbmclose>

=begin original

[This function has been largely superseded by the C<untie> function.]

=end original

[この関数は、C<untie> 関数に大きくとって代わられました。]

=begin original

Breaks the binding between a DBM file and a hash.

=end original

DBM ファイルとハッシュの連結をはずします。

=item dbmopen HASH,DBNAME,MASK
X<dbmopen> X<dbm> X<ndbm> X<sdbm> X<gdbm>

=begin original

[This function has been largely superseded by the C<tie> function.]

=end original

[この関数は、C<tie> 関数に大きくとって代わられました。]

=begin original

This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a
hash.  HASH is the name of the hash.  (Unlike normal C<open>, the first
argument is I<not> a filehandle, even though it looks like one).  DBNAME
is the name of the database (without the F<.dir> or F<.pag> extension if
any).  If the database does not exist, it is created with protection
specified by MASK (as modified by the C<umask>).  If your system supports
only the older DBM functions, you may make only one C<dbmopen> call in your
program.  In older versions of Perl, if your system had neither DBM nor
ndbm, calling C<dbmopen> produced a fatal error; it now falls back to
sdbm(3).

=end original

dbm(3), ndbm(3), sdbm(3), gdbm(3) ファイルまたは Berkeley DB
ファイルを連想配列に結び付けます。
HASH は、その連想配列の名前です。
(普通の C<open> とは違って、最初の引数はファイルハンドル
I<ではありません>。まあ、似たようなものですが。)
DBNAME は、データベースの名前です (拡張子の .dir や
.pag はもしあってもつけません)。
データベースが存在しなければ、MODE MASK (を C<umask> で修正したもの) で
指定されたモードで作られます。
古い DBM 関数のみをサポートしているシステムでは、プログラム中で 1 度だけ
dbmopen() を実行することができます。
昔のバージョンの Perl では、DBM も ndbm も持っていないシステムでは、
dbmopen() を呼び出すと致命的エラーになります。
現在では sdbm(3) にフォールバックします。

=begin original

If you don't have write access to the DBM file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an C<eval> 
to trap the error.

=end original

DBM ファイルに対して、書き込み権が無いときには、ハッシュ
配列を読みだすことだけができ、設定することはできません。
書けるか否かを調べたい場合には、ファイルテスト
演算子を使うか、エラーをトラップするための C<eval> の中で、
ダミーのハッシュエントリを設定してみることになります。

=begin original

Note that functions such as C<keys> and C<values> may return huge lists
when used on large DBM files.  You may prefer to use the C<each>
function to iterate over large DBM files.  Example:

=end original

大きな DBM ファイルを扱うときには、C<keys> や C<values> のような関数は、
巨大なリストを返します。
大きな DBM ファイルでは、C<each> 関数を使って繰り返しを行なった方が
良いかもしれません。
例:

    # print out history file offsets
    dbmopen(%HIST,'/usr/lib/news/history',0666);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    dbmclose(%HIST);

=begin original

See also L<AnyDBM_File> for a more general description of the pros and
cons of the various dbm approaches, as well as L<DB_File> for a particularly
rich implementation.

=end original

様々な dbm 手法に対する利点欠点に関するより一般的な記述および
特にリッチな実装である L<DB_File> に関しては
L<AnyDBM_File> も参照してください。

=begin original

You can control which DBM library you use by loading that library
before you call dbmopen():

=end original

dbmopen() を呼び出す前にライブラリを読み込むことで、
どの DBM ライブラリを使うかを制御できます:

    use DB_File;
    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
        or die "Can't open netscape history file: $!";

=item default BLOCK

=begin original

Within a C<foreach> or a C<given>, a C<default> BLOCK acts like a C<when>
that's always true.  Only available after Perl 5.10, and only if the
C<switch> feature has been requested.  See L</when>.

=end original

C<foreach> や C<given> の中では、C<default> BLOCK は常に真の C<when> の
ように動作します。
Perl 5.10 以降でのみ、かつ C<switch> 機能が有効の場合にのみ利用可能です。
L</when> を参照してください。

=item defined EXPR
X<defined> X<undef> X<undefined>

=item defined

=begin original

Returns a Boolean value telling whether EXPR has a value other than
the undefined value C<undef>.  If EXPR is not present, C<$_> is
checked.

=end original

左辺値 EXPR が未定義値 C<undef> 以外の値を持つか否かを示す、ブール値を
返します。
EXPR がない場合は、C<$_> がチェックされます。

=begin original

Many operations return C<undef> to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish C<undef> from
other values.  (A simple Boolean test will not distinguish among
C<undef>, zero, the empty string, and C<"0">, which are all equally
false.)  Note that since C<undef> is a valid scalar, its presence
doesn't I<necessarily> indicate an exceptional condition: C<pop>
returns C<undef> when its argument is an empty array, I<or> when the
element to return happens to be C<undef>.

=end original

多くの演算子が、EOF や未初期化変数、システムエラーといった、
例外的な条件で C<undef> を返すようになっています。
この関数は、他の値と C<undef> とを区別するために使えます。
(単純な真偽値テストでは、C<undef>、0、C<"0"> のいずれも偽を返すので、
区別することができません。)
C<undef> は有効なスカラ値なので、その存在が I<必ずしも> 
例外的な状況を表すとは限らないということに注意してください:
C<pop> は引数が空の配列だったときに C<undef> を返しますが、
I<あるいは> 返すべき要素がたまたま C<undef> だったのかもしれません。

=begin original

You may also use C<defined(&func)> to check whether subroutine C<&func>
has ever been defined.  The return value is unaffected by any forward
declarations of C<&func>.  A subroutine that is not defined
may still be callable: its package may have an C<AUTOLOAD> method that
makes it spring into existence the first time that it is called; see
L<perlsub>.

=end original

C<defined(&func)> とすることでサブルーチン C<&func> の存在を、
確かめることもできます。
返り値は C<&func> の前方定義には影響されません。
定義されていないサブルーチンも呼び出し可能です:
最初に呼び出されたときに存在するようにするための
C<AUTOLOAD> メソッドを持ったパッケージかもしれません;
L<perlsub> を参照して下さい。

=begin original

Use of C<defined> on aggregates (hashes and arrays) is deprecated.  It
used to report whether memory for that aggregate had ever been
allocated.  This behavior may disappear in future versions of Perl.
You should instead use a simple test for size:

=end original

集合(ハッシュや配列)への C<defined> の使用は非推奨です。
これはその集合にメモリが割り当てられたかを報告するのに
用いられていました。
この振る舞いは将来のバージョンの Perl では消滅するかもしれません。
代わりにサイズに対する簡単なテストを使うべきです。

    if (@an_array) { print "has array elements\n" }
    if (%a_hash)   { print "has hash members\n"   }

=begin original

When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use L</exists> for the latter
purpose.

=end original

ハッシュの要素に対して用いると、value が定義されているか否かを
返すものであって、ハッシュに key が存在するか否かを返すのではありません。
この用途には、L</exists> を使ってください。

=begin original

Examples:

=end original

例:

    print if defined $switch{D};
    print "$val\n" while defined($val = pop(@ary));
    die "Can't readlink $sym: $!"
        unless defined($value = readlink $sym);
    sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }
    $debugging = 0 unless defined $debugging;

=begin original

Note:  Many folks tend to overuse C<defined> and are then surprised to
discover that the number C<0> and C<""> (the zero-length string) are, in fact,
defined values.  For example, if you say

=end original

注意: 多くの人々が C<defined> を使いすぎて、C<0> と C<"">(空文字列) が
実際のところ定義された値であることに驚くようです。
例えば、以下のように書くと:

    "ab" =~ /a(.*)b/;

=begin original

The pattern match succeeds and C<$1> is defined, although it
matched "nothing".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use C<defined> only when questioning the integrity of what
you're trying to do.  At other times, a simple comparison to C<0> or C<""> is
what you want.

=end original

パターンマッチングが成功し、C<$1> が定義されても、実際には
「なし」にマッチしています。
しかしこれは何にもマッチしていないわけではありません。
何かにはマッチしているのですが、たまたまそれが長さ 0 だっただけです。
これは非常に率直で正直なことです。
関数が未定義値を返すとき、正直な答えを返すことができないことを
告白しています。
ですので、あなたが自分がしようとしていることの完全性を確認するときにだけ
C<defined> を使うべきです。
その他の場合では、単に C<0> または C<""> と比較するというのがあなたの
求めているものです。

=begin original

See also L</undef>, L</exists>, L</ref>.

=end original

L</undef>, L</exists>, L</ref> も参照してください。

=item delete EXPR
X<delete>

=begin original

Given an expression that specifies an element or slice of a hash, C<delete>
deletes the specified elements from that hash so that exists() on that element
no longer returns true.  Setting a hash element to the undefined value does
not remove its key, but deleting it does; see L</exists>.

=end original

ハッシュの要素やスライスを指定する式を取り、C<delete> は
指定された要素をハッシュから削除するので、
その要素に対する exists() はもはや真を返さなくなります。
ハッシュ要素に未定義値をセットしてもそのキーは削除されませんが、
delete では削除されます; L</exists> を参照してください。

=begin original

In list context, returns the value or values deleted, or the last such
element in scalar context.  The return list's length always matches that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions.

=end original

リストコンテキストでは削除された要素を返し、スカラコンテキストでは
削除された要素のうち最後のものを返します。
返されたリストの長さは常に引数リストの長さと一致します:
存在しない要素を削除すると、対応する位置に未定義値をセットして返します。

=begin original

delete() may also be used on arrays and array slices, but its behavior is less
straightforward.  Although exists() will return false for deleted entries,
deleting array elements never changes indices of existing values; use shift()
or splice() for that.  However, if all deleted elements fall at the end of an
array, the array's size shrinks to the position of the highest element that
still tests true for exists(), or to 0 if none do.

=end original

delete() は配列や配列のスライスに対しても使えますが、その振る舞いは
あまり直感的ではありません。
削除されたエントリに対しては exists() は偽を返しますが、
配列要素を削除しても、存在する値の添え字は変わりません; このためには
shift() や splice() を使ってください。
しかし、全ての削除された要素が配列の末尾であった場合、配列のサイズは
exists() が真となる最大位置の要素(それがない場合は 0)に切り詰められます。

=begin original

B<WARNING:> Calling delete on array values is deprecated and likely to
be removed in a future version of Perl.

=end original

B<警告:> 配列の値に対して delete を呼び出すことは非推奨で、将来の
バージョンの Perl では削除される予定です。

=begin original

Deleting from C<%ENV> modifies the environment.  Deleting from a hash tied to
a DBM file deletes the entry from the DBM file.  Deleting from a C<tied> hash
or array may not necessarily return anything; it depends on the implementation
of the C<tied> package's DELETE method, which may do whatever it pleases.

=end original

C<%ENV> から削除を行なうと、実際に環境変数を変更します。
DBM ファイルに tie された配列からの削除は、その DBM ファイルからエントリを
削除します。
しかし、C<tie> されたハッシュや配列からの削除は、
値を返すとは限りません; これは C<tie> されたパッケージの DELETE
メソッドの実装に依存するので、どんなことでも起こります。

=begin original

The C<delete local EXPR> construct localizes the deletion to the current
block at run time.  Until the block exits, elements locally deleted
temporarily no longer exist.  See L<perlsub/"Localized deletion of elements
of composite types">.

=end original

C<delete local EXPR> 構文は、現在のブロックの削除を実行時にローカル化します。
ブロックから出るまで、ローカルで削除された要素は存在しなくなります。
L<perlsub/"Localized deletion of elements of composite types"> を
参照してください。

    %hash = (foo => 11, bar => 22, baz => 33);
    $scalar = delete $hash{foo};             # $scalar is 11
    $scalar = delete @hash{qw(foo bar)};     # $scalar is 22
    @array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)

=begin original

The following (inefficiently) deletes all the values of %HASH and @ARRAY:

=end original

以下は、%HASH と @ARRAY のすべての値を(非効率的に)削除します:

    foreach $key (keys %HASH) {
        delete $HASH{$key};
    }

    foreach $index (0 .. $#ARRAY) {
        delete $ARRAY[$index];
    }

=begin original

And so do these:

=end original

そして以下のようにもできます:

    delete @HASH{keys %HASH};

    delete @ARRAY[0 .. $#ARRAY];

=begin original

But both are slower than assigning the empty list
or undefining %HASH or @ARRAY, which is the customary 
way to empty out an aggregate:

=end original

しかし、これら二つは両方とも、構造を空にするための慣習的な方法である、
単に空リストを代入するか、%HASH や @ARRAY を
undef するより遅いです:

    %HASH = ();     # completely empty %HASH
    undef %HASH;    # forget %HASH ever existed

    @ARRAY = ();    # completely empty @ARRAY
    undef @ARRAY;   # forget @ARRAY ever existed

=begin original

The EXPR can be arbitrarily complicated provided its
final operation is an element or slice of an aggregate:

=end original

最終的な操作が集合の要素かスライスである限りは、
いずれかである限りは、EXPR には任意の複雑な式を置くことができます:

    delete $ref->[$x][$y]{$key};
    delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};

    delete $ref->[$x][$y][$index];
    delete @{$ref->[$x][$y]}[$index1, $index2, @moreindices];

=item die LIST
X<die> X<throw> X<exception> X<raise> X<$@> X<abort>

=begin original

C<die> raises an exception. Inside an C<eval> the error message is stuffed
into C<$@> and the C<eval> is terminated with the undefined value.
If the exception is outside of all enclosing C<eval>s, then the uncaught
exception prints LIST to C<STDERR> and exits with a non-zero value. If you
need to exit the process with a specific exit code, see L</exit>.

=end original

C<die> は例外を発生させます。
C<eval> の中で使用すると、エラーメッセージが C<$@> に入り、C<eval> は
未定義値を返して終了します。
例外が全ての C<eval> の外側の場合は、捕捉されなかった例外は LIST を
C<STDERR> に表示して、非 0 の値で終了します。
特定の終了コードでプロセスを終了させる必要がある場合は、L</exit> を
参照してください。

=begin original

Equivalent examples:

=end original

等価な例:

    die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
    chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

=begin original

If the last element of LIST does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.  Note that the "input line number" (also
known as "chunk") is subject to whatever notion of "line" happens to
be currently in effect, and is also available as the special variable
C<$.>.  See L<perlvar/"$/"> and L<perlvar/"$.">.

=end original

LIST の最後の要素が改行で終わっていなければ、その時点の
スクリプト名とスクリプトの行番号、(もしあれば) 
入力ファイルの行番号と改行文字が、続けて表示されます。
「入力行番号」("chunk" とも呼ばれます)は
「行」という概念が現在有効であると仮定しています。
また特殊変数 C<$.> でも利用可能です。
L<perlvar/"$/"> と L<perlvar/"$."> も参照してください。

=begin original

Hint: sometimes appending C<", stopped"> to your message will cause it
to make better sense when the string C<"at foo line 123"> is appended.
Suppose you are running script "canasta".

=end original

ヒント: メッセージの最後を C<", stopped"> のようなもので
終わるようにしておけば、C<"at foo line 123"> のように
追加されて、わかりやすくなります。
"canasta" というスクリプトを実行しているとします。

    die "/etc/games is no good";
    die "/etc/games is no good, stopped";

=begin original

produce, respectively

=end original

これは、それぞれ以下のように表示します。

    /etc/games is no good at canasta line 123.
    /etc/games is no good, stopped at canasta line 123.

=begin original

If the output is empty and C<$@> already contains a value (typically from a
previous eval) that value is reused after appending C<"\t...propagated">.
This is useful for propagating exceptions:

=end original

出力が空で C<$@> が(典型的には前回の eval で)既に値を持っている場合、
値は C<"\t...propagated"> を追加した後再利用されます。
これは例外を伝播させる場合に有効です:

    eval { ... };
    die unless $@ =~ /Expected exception/;

=begin original

If the output is empty and C<$@> contains an object reference that has a
C<PROPAGATE> method, that method will be called with additional file
and line number parameters.  The return value replaces the value in
C<$@>;  i.e., as if C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >>
were called.

=end original

出力が空で、C<$@> が C<PROPAGATE> メソッドを含むオブジェクトへの
リファレンスを含む場合、このメソッドが追加ファイルと行番号を引数として
呼び出されます。
返り値は C<$@> の値を置き換えます;
つまり、C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >> が
呼び出されたかのようになります。

=begin original

If C<$@> is empty then the string C<"Died"> is used.

=end original

C<$@> が空の場合、C<"Died"> が使われます。

=begin original

If an uncaught exception results in interpreter exit, the exit code is
determined from the values of C<$!> and C<$?> with this pseudocode:

=end original

例外が捕捉されないとインタプリタは終了し、終了コードは以下の
擬似コードのように、C<$!> と C<$?> の値から決定されます:

    exit $! if $!;              # errno
    exit $? >> 8 if $? >> 8;    # child exit status
    exit 255;                   # last resort

=begin original

The intent is to squeeze as much possible information about the likely cause
into the limited space of the system exit code. However, as C<$!> is the value
of C's C<errno>, which can be set by any system call, this means that the value
of the exit code used by C<die> can be non-predictable, so should not be relied
upon, other than to be non-zero.

=end original

この意図は、できるだけ多くの似たような原因に関する情報を、システム終了
コードという限られた領域に圧縮することです。
しかし、C<$!> はシステムコールによって設定される可能性がある C の
C<errno> の値であり、C<die> によって使われる終了コードの値は
予測不能であることを意味するので、非 0 ということ以上にこの値に
依存するべきではありません。

=begin original

You can also call C<die> with a reference argument, and if this is trapped
within an C<eval>, C<$@> contains that reference.  This permits more
elaborate exception handling using objects that maintain arbitrary state
about the exception.  Such a scheme is sometimes preferable to matching
particular string values of C<$@> with regular expressions.  Because C<$@> 
is a global variable and C<eval> may be used within object implementations,
be careful that analyzing the error object doesn't replace the reference in
the global variable.  It's easiest to make a local copy of the reference
before any manipulations.  Here's an example:

=end original

die() はリファレンス引数と共に呼び出すこともでき、これが
eval() 内部でトラップされた場合、C<$@> はそのリファレンスを持ちます。
これは、例外の性質について任意の状態を管理するオブジェクトを使った
より複雑な例外処理の実装を可能にします。
このようなスキームは C<$@> の特定の文字列値を正規表現を使って
マッチングするときに時々好まれます。
C<$@> はグローバル変数で、C<eval> はオブジェクト実装の内部で
使われることがあるので、エラーオブジェクトの解析はグローバル変数の
リファレンスを置き換えないことに注意を払わなければなりません。
他の操作をする前にリファレンスのローカルコピーを
作るのが一番簡単です。
以下に例を示します:

    use Scalar::Util "blessed";

    eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
    if (my $ev_err = $@) {
        if (blessed($ev_err) && $ev_err->isa("Some::Module::Exception")) {
            # handle Some::Module::Exception
        }
        else {
            # handle all other possible exceptions
        }
    }

=begin original

Because Perl stringifies uncaught exception messages before display,
you'll probably want to overload stringification operations on
exception objects.  See L<overload> for details about that.

=end original

perl は捕らえられなかった例外のメッセージを表示する前に文字列化するので、
このようなカスタム例外オブジェクトの文字列化をオーバーロードしたいと
思うかもしれません。
これに関する詳細は L<overload> を参照してください。

=begin original

You can arrange for a callback to be run just before the C<die>
does its deed, by setting the C<$SIG{__DIE__}> hook.  The associated
handler is called with the error text and can change the error
message, if it sees fit, by calling C<die> again.  See
L<perlvar/%SIG> for details on setting C<%SIG> entries, and
L<"eval BLOCK"> for some examples.  Although this feature was 
to be run only right before your program was to exit, this is not
currently so: the C<$SIG{__DIE__}> hook is currently called
even inside eval()ed blocks/strings!  If one wants the hook to do
nothing in such situations, put

=end original

C<$SIG{__DIE__}> フックをセットすることで、C<die> がその行動を行う
直前に実行されるコールバックを設定できます。
結び付けられたハンドラはエラーテキストと共に呼び出され、
必要なら再び C<die> を呼び出すことでエラーテキストを変更できアス。
C<%SIG> のエントリをセットする詳細については、L<perlvar/%SIG> を、
例については L<"eval BLOCK"> を参照してください。
この機能はプログラムが終了しようとする前に 1 回だけ実行していましたが、
現在ではそうではありません:
C<$SIG{__DIE__}> フックは eval() されたブロック/文字列の中でも
呼ばれるのです!
もしそのような状況で何もしなくない時は:

    die @_ if $^S;

=begin original

as the first line of the handler (see L<perlvar/$^S>).  Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.

=end original

をハンドラの最初の行に置いてください(L<perlvar/$^S> を参照してください)。
これは離れたところで不思議な行動を引き起こすので、
この直感的でない振る舞いは将来のリリースで修正されるかもしれません。

=begin original

See also exit(), warn(), and the Carp module.

=end original

exit() と warn() と Carp モジュールも参照してください。

=item do BLOCK
X<do> X<block>

=begin original

Not really a function.  Returns the value of the last command in the
sequence of commands indicated by BLOCK.  When modified by the C<while> or
C<until> loop modifier, executes the BLOCK once before testing the loop
condition. (On other statements the loop modifiers test the conditional
first.)

=end original

実際は関数ではありません。
BLOCK で示されるコマンド列の最後の値を返します。
C<while> や C<until> ループ修飾子で修飾すると、
ループ条件を調べる前に 1 度、BLOCK を実行します。
(これ以外の実行文は、ループ修飾子により、条件が最初に
調べられます。)

=begin original

C<do BLOCK> does I<not> count as a loop, so the loop control statements
C<next>, C<last>, or C<redo> cannot be used to leave or restart the block.
See L<perlsyn> for alternative strategies.

=end original

C<do BLOCK> はループとしては I<扱われません>。
従って、C<next>, C<last>, C<redo> といったループ制御文は
ブロックから抜けたり再開することはできません。
その他の戦略については L<perlsyn> を参照して下さい。

=item do SUBROUTINE(LIST)
X<do>

=begin original

This form of subroutine call is deprecated.  SUBROUTINE can be a bareword,
a scalar variable or a subroutine beginning with C<&>.

=end original

この形のサブルーチン呼び出しは非推奨です。
SUBROUTINE には裸の単語、スカラ変数、C<&> で始まるサブルーチンが使えます。

=item do EXPR
X<do>

=begin original

Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.

=end original

EXPR の値をファイル名として用い、そのファイルの中身を
Perl のスクリプトとして実行します。

    do 'stat.pl';

=begin original

is just like

=end original

は以下のものと同じようなものですが、

    eval `cat stat.pl`;

=begin original

except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the C<@INC> directories, and updates
C<%INC> if the file is found.  See L<perlvar/@INC> and L<perlvar/%INC> for
these variables.  It also differs in that code evaluated with C<do FILENAME>
cannot see lexicals in the enclosing scope; C<eval STRING> does.  It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.

=end original

より効率的で、簡潔であり、エラーメッセージでファイル名がわかる、
カレントディレクトリでファイルが見つからなかったときに
C<@INC> ディレクトリを検索する、ファイルがあったときに C<%INC> を更新する、
といったことがあります。
これらの変数については L<perlvar/@INC> と L<perlvar/%INC> を
参照してください。
C<do FILENAME> で評価されたコードは、入れ子のスコープにある
レキシカル変数を見ることができないのに対し、C<eval STRING>ではできる、
という違いがあります。
しかし、呼び出すたびにファイルを解析し直すという点では同じですから、
ループ内でこれを使おうなどとは、間違っても思ったりしないように。

=begin original

If C<do> can read the file but cannot compile it, it returns C<undef> and sets
an error message in C<$@>.  If C<do> cannot read the file, it returns undef
and sets C<$!> to the error.  Always check C<$@> first, as compilation
could fail in a way that also sets C<$!>.  If the file is successfully
compiled, C<do> returns the value of the last expression evaluated.

=end original

C<do> がファイルを読み込めたがコンパイルできなかった場合、
C<undef> を返して C<$@> にエラーメッセージを設定します。
C<do>がファイルを読み込めなかった場合、undef を返して C<$!> に
エラーを設定します。
コンパイルに失敗したときにも C<$!> が設定されるので、常に C<$@> を
先にチェックします。
ファイルのコンパイルに成功した場合、C<do> は最後に評価した表現の値を返します。

=begin original

Inclusion of library modules is better done with the
C<use> and C<require> operators, which also do automatic error checking
and raise an exception if there's a problem.

=end original

ライブラリモジュールのインクルードには、C<use> 演算子や
C<require> 演算子を使った方がよいです。
これらは自動的にエラーをチェックして、問題があれば例外を発生させます。

=begin original

You might like to use C<do> to read in a program configuration
file.  Manual error checking can be done this way:

=end original

C<do> をプログラム設定ファイルを読み込むのに使いたいかもしれません。
手動のエラーチェックは以下のようにして行えます:

    # read in config files: system first, then user
    for $file ("/share/prog/defaults.rc",
               "$ENV{HOME}/.someprogrc")
    {
        unless ($return = do $file) {
            warn "couldn't parse $file: $@" if $@;
            warn "couldn't do $file: $!"    unless defined $return;
            warn "couldn't run $file"       unless $return;
        }
    }

=item dump LABEL
X<dump> X<core> X<undump>

=item dump

=begin original

This function causes an immediate core dump.  See also the B<-u>
command-line switch in L<perlrun>, which does the same thing.
Primarily this is so that you can use the B<undump> program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a C<goto LABEL> (with all the restrictions that C<goto> suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If C<LABEL> is omitted, restarts the program from the top.

=end original

この関数は即座にコアダンプを行ないます。
同様のことを行う L<perlrun> の B<-u> オプションも参照してください。
プログラムの先頭で、
すべての変数を初期化したあとのコアダンプを B<undump>
プログラム(提供していません)を使って実行ファイルに返ることができます。
この新しいバイナリが実行されると、C<goto LABEL> から始めます
(C<goto> に関する制限はすべて適用されます)。
コアダンプをはさんで再生する goto と考えてください。
C<LABEL> が省略されると、プログラムを先頭から再開します。

=begin original

B<WARNING>: Any files opened at the time of the dump will I<not>
be open any more when the program is reincarnated, with possible
resulting confusion by Perl.

=end original

B<警告>: dump 時点でオープンされていたファイルは、
プログラムが再生されたときには、もはやオープンされていません。
Perl を混乱させる可能性があります。

=begin original

This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable. That's why you should now invoke
it as C<CORE::dump()>, if you don't want to be warned against a possible
typo.

=end original

この関数は大幅に時代遅れのものです; 主な理由としては、コアファイルを
実行形式に変換するのが非常に困難であることです。
これが、今ではタイプミスの可能性を警告されたくないなら
C<CORE::dump()> として起動するべき理由です。

=item each HASH
X<each> X<hash, iterator>

=item each ARRAY
X<array, iterator>

=item each EXPR

=begin original

When called in list context, returns a 2-element list consisting of the key
and value for the next element of a hash, or the index and value for the
next element of an array, so that you can iterate over it.  When called in
scalar context, returns only the key (not the value) in a hash, or the index
in an array.

=end original

リストコンテキストで呼び出した場合は、次の要素に対する、
ハッシュのキーと値か、配列のインデックスと値からなる
2 要素のリストを返すので、反復を行えます。
スカラコンテキストで呼び出した場合は、
ハッシュの場合は(値ではなく)キー、配列の場合はインデックスを返します。

=begin original

Hash entries are returned in an apparently random order.  The actual random
order is subject to change in future versions of Perl, but it is
guaranteed to be in the same order as either the C<keys> or C<values>
function would produce on the same (unmodified) hash.  Since Perl
5.8.2 the ordering can be different even between different runs of Perl
for security reasons (see L<perlsec/"Algorithmic Complexity Attacks">).

=end original

ハッシュエントリは見かけ上、ランダムな順序で返されます。
実際のランダムな順番は perl の将来のバージョンでは変わるかもしれませんが、
C<keys> や C<values> 関数が同じ(変更されていない)ハッシュに対して
生成するのと同じ順番であることは保証されます。
Perl 5.8.2 以降ではセキュリティ上の理由により、
実行される毎に順番は変わるかもしれません
(L<perlsec/"Algorithmic Complexity Attacks"> を参照してください)。

=begin original

After C<each> has returned all entries from the hash or array, the next
call to C<each> returns the empty list in list context and C<undef> in
scalar context.  The next call following that one restarts iteration.  Each
hash or array has its own internal iterator, accessed by C<each>, C<keys>,
and C<values>.  The iterator is implicitly reset when C<each> has reached
the end as just described; it can be explicitly reset by calling C<keys> or
C<values> on the hash or array.  If you add or delete a hash's elements
while iterating over it, entries may be skipped or duplicated--so don't do
that.  Exception: It is always safe to delete the item most recently
returned by C<each()>, so the following code works properly:

=end original

C<each> がハッシュをすべて読み込んでしまった後、リストコンテキストでは
空リストが返され、スカラコンテキストでは C<undef> が返されます。
そのあともう一度呼び出すと、再び反復を始めます。
ハッシュや配列毎にそれぞれ反復子があり、C<each>、C<keys>、C<values> で
アクセスされます。
反復子は、前述したように C<each> が要素をすべて読むことによって
暗黙にリセットされます; また、ハッシュや配列に対して
C<keys HASH>, C<values HASH> を呼び出すことで明示的にリセットできます。
繰り返しを行なっている間に、ハッシュに要素を追加したり削除したりすると、
要素が飛ばされたり重複したりするので、してはいけません。
例外: 一番最近に C<each()> から返されたものを削除するのは常に安全です。
これは以下のようなコードが正しく動くことを意味します:

        while (($key, $value) = each %hash) {
          print $key, "\n";
          delete $hash{$key};   # This is safe
        }

=begin original

This prints out your environment like the printenv(1) program,
but in a different order:

=end original

これは、printenv(1) プログラムのように環境変数を表示しますが、
順序は異なっています:

    while (($key,$value) = each %ENV) {
        print "$key=$value\n";
    }

=begin original

Starting with Perl 5.14, C<each> can take a scalar EXPR, which must hold
reference to an unblessed hash or array.  The argument will be dereferenced
automatically.  This aspect of C<each> is considered highly experimental.
The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<each> はスカラの EXPR を取ることができるようになりました;
これは bless されていないハッシュや配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<each> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

    while (($key,$value) = each $hashref) { ... }

=begin original

See also C<keys>, C<values>, and C<sort>.

=end original

C<keys> や C<values> や C<sort> も参照してください。

=item eof FILEHANDLE
X<eof>
X<end of file>
X<end-of-file>

=item eof ()

=item eof

=begin original

Returns 1 if the next read on FILEHANDLE will return end of file I<or> if
FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then C<ungetc>s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
C<eof(FILEHANDLE)> on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.

=end original

次に FILEHANDLE 上で読み込みを行なったときに、EOF が返されるときか、
I<または> FILEHANDLE がオープンされていないと、1 を返します。
FILEHANDLE は、値が実際のファイルハンドルを示す式であってもかまいません。
(この関数は、実際に文字を読み、C<ungetc> を行ないますので、
対話型の場合には有用ではありません。)
端末ファイルは EOF に達した後にさらに読み込んだり C<eof(FILEHANDLE)> を
呼び出したりしてはいけません。
そのようなことをすると、端末のようなファイルタイプは
EOF 状態を失ってしまうかもしれません。

=begin original

An C<eof> without an argument uses the last file read.  Using C<eof()>
with empty parentheses is different.  It refers to the pseudo file
formed from the files listed on the command line and accessed via the
C<< <> >> operator.  Since C<< <> >> isn't explicitly opened,
as a normal filehandle is, an C<eof()> before C<< <> >> has been
used will cause C<@ARGV> to be examined to determine if input is
available.   Similarly, an C<eof()> after C<< <> >> has returned
end-of-file will assume you are processing another C<@ARGV> list,
and if you haven't set C<@ARGV>, will read input from C<STDIN>;
see L<perlop/"I/O Operators">.

=end original

引数を省略した C<eof> は、最後に読み込みを行なったファイルを使います。
空の括弧をつけた C<eof()> は異なります。
これはコマンドラインのファイルリストで構成され、C<< <> >> 演算子経由で
アクセスされる擬似ファイルを示すために用いられます。
通常のファイルハンドルと違って C<< <> >> は明示的にオープンされないので、
C<< <> >> を使う前に C<eof()> を使うと、
入力が正常か確認するために C<@ARGV> がテストされます。
同様に、C<< <> >> の後の C<eof()> で EOF が返るのは、
他の C<@ARGV> リストを処理していると仮定し、もし C<@ARGV> を
セットしていないときは C<STDIN> から読み込みます;
L<perlop/"I/O Operators"> を参照してください。

=begin original

In a C<< while (<>) >> loop, C<eof> or C<eof(ARGV)> can be used to
detect the end of each file, whereas C<eof()> will detect the end 
of the very last file only.  Examples:

=end original

C<< while (<>) >> ループの中では、個々のファイルの終わりを調べるには、
C<eof> か C<eof(ARGV)> を用いるのに対して
C<eof()> は最後のファイルの終わりのみを調べます。
例:

    # reset line numbering on each input file
    while (<>) {
        next if /^\s*#/;  # skip comments
        print "$.\t$_";
    } continue {
        close ARGV if eof;  # Not eof()!
    }

    # insert dashes just before last line of last file
    while (<>) {
        if (eof()) {  # check for end of last file
            print "--------------\n";
        }
        print;
        last if eof();          # needed if we're reading from a terminal
    }

=begin original

Practical hint: you almost never need to use C<eof> in Perl, because the
input operators typically return C<undef> when they run out of data or 
encounter an error.

=end original

現実的なヒント: Perl で C<eof> が必要となることは、ほとんどありません;
基本的には、データがなくなったときやエラーがあったときに、入力演算子が
C<undef> を返してくれるからです。

=item eval EXPR
X<eval> X<try> X<catch> X<evaluate> X<parse> X<execute>
X<error, handling> X<exception, handling>

=item eval BLOCK

=item eval

=begin original

In the first form, the return value of EXPR is parsed and executed as if it
were a little Perl program.  The value of the expression (which is itself
determined within scalar context) is first parsed, and if there were no
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.  Note that the value is parsed every time the C<eval> executes.
If EXPR is omitted, evaluates C<$_>.  This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.

=end original

第一の形式では、EXPR の返り値が Perl のプログラムであるかのように
解析され、実行されます。
式の値(それ自身スカラコンテキストの中で決定されます)はまずパースされ、
エラーがなければ
Perl プログラムのレキシカルコンテキストの中で実行されますので、変数の設定、
サブルーチンやフォーマットの定義は、その後も残っています。　
返される値は C<eval> が実行されるごとにパースされることに注意してください。
EXPR を省略すると、C<$_> を評価します。
この形は主に EXPR のテキストのパースと実行を実行時にまで
遅延させるのに用います。

=begin original

In the second form, the code within the BLOCK is parsed only once--at the
same time the code surrounding the C<eval> itself was parsed--and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.

=end original

第二の形式では、BLOCK 内部のコードは一度だけパースされ -- コードを
囲む C<eval> 自身がパースされるのと同じ時点です -- 現在の Perl プログラムの
コンテキストで実行されます。
この形式は典型的には第一の形式より効率的に例外をトラップします(後述)。
また BLOCK 内部のコードはコンパイル時にチェックされるという利点を提供します。

=begin original

The final semicolon, if any, may be omitted from the value of EXPR or within
the BLOCK.

=end original

最後のセミコロンは、もしあれば、EXPR の値や BLOCK の中身から省くことができます。

=begin original

In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the C<eval> 
itself.  See L</wantarray> for more on how the evaluation context can be 
determined.

=end original

どちらの形式でも、返される値はミニプログラムの内部で最後に評価された
表現の値です; サブルーチンと同様、return 文も使えます。
返り値として提供される表現は、C<eval> 自身のコンテキストに依存して
無効・スカラ・リストのいずれかのコンテキストで評価されます。
評価コンテキストの決定方法についての詳細は L</wantarray> を参照してください。

=begin original

If there is a syntax error or runtime error, or a C<die> statement is
executed, C<eval> returns C<undef> in scalar context
or an empty list--or, for syntax errors, a list containing a single
undefined value--in list context, and C<$@> is set to the error
message.  The discrepancy in the return values in list context is
considered a bug by some, and will probably be fixed in a future
release.  If there was no error, C<$@> is guaranteed to be the empty
string.  Beware that using C<eval> neither silences Perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into C<$@>.
To do either of those, you have to use the C<$SIG{__WARN__}> facility, or
turn off warnings inside the BLOCK or EXPR using S<C<no warnings 'all'>>.
See L</warn>, L<perlvar>, L<warnings> and L<perllexwarn>.

=end original

構文エラーや実行エラーが発生するか、C<die> 文が実行されると、
C<eval> はスカラコンテキストでは C<undef> が、リストコンテキストでは
空リスト -- あるいは、文法エラーのときには、単一のエラーメッセージからなる
リストが設定されます。
リストコンテキストでの返り値の違いはある意味バグと考えられていて、
おそらく将来のリリースで修正されます。
エラーがなければ、C<$@> は空文字列であることが保証されます。　
C<eval> を、STDERR に警告メッセージを表示させない目的や、
警告メッセージを C<$@> に格納する目的では使わないでください。
そのような用途では、C<$SIG{__WARN__}> 機能を使うか、
S<C<no warnings 'all'>> を使って BLOCK か EXPR の内部での警告を
オフにする必要があります。
L</warn>, L<perlvar>, L<warnings>, L<perllexwarn> を参照してください。

=begin original

Note that, because C<eval> traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as C<socket> or C<symlink>)
is implemented.  It is also Perl's exception-trapping mechanism, where
the die operator is used to raise exceptions.

=end original

C<eval> は、致命的エラーとなるようなものをトラップすることができるので、
(C<socket> や C<symlink> といった) 特定の機能が実装されているかを、
調べるために使うことができることに注意してください。
die 演算子が例外を発生させるものとすれば、これはまた、Perl の例外捕捉機能と
捉えることもできます。

=begin original

If you want to trap errors when loading an XS module, some problems with
the binary interface (such as Perl version skew) may be fatal even with
C<eval> unless C<$ENV{PERL_DL_NONLAZY}> is set. See L<perlrun>.

=end original

XS モジュールのロード中のエラーをトラップしたいなら、
(Perl バージョンの違いのような) バイナリインターフェースに関する問題に
ついては C<$ENV{PERL_DL_NONLAZY}> がセットされていない C<eval> でも
致命的エラーになるかもしれません。
L<perlrun> を参照してください。

=begin original

If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in C<$@>.
Examples:

=end original

実行するコードが変わらないのであれば、毎回多量の再コンパイルすることなしに、
実行時エラーのトラップを行なうために、
eval-BLOCK 形式を使うことができます。
エラーがあれば、やはり $@ に返されます。
例:

    # make divide-by-zero nonfatal
    eval { $answer = $a / $b; }; warn $@ if $@;

    # same thing, but less efficient
    eval '$answer = $a / $b'; warn $@ if $@;

    # a compile-time error
    eval { $answer = }; # WRONG

    # a run-time error
    eval '$answer =';   # sets $@

=begin original

Using the C<eval{}> form as an exception trap in libraries does have some
issues.  Due to the current arguably broken state of C<__DIE__> hooks, you
may wish not to trigger any C<__DIE__> hooks that user code may have installed.
You can use the C<local $SIG{__DIE__}> construct for this purpose,
as this example shows:

=end original

C<eval{}> 形式をライブラリの例外を捕捉するために使うときには
問題があります。
現在の C<__DIE__> フックの状態はほぼ確実に壊れているという理由で、
ユーザーのコードが設定した C<__DIE__> フックを実行したくないかもしれません。
この目的には以下の例のように、C<local $SIG{__DIE__}> 構造が使えます。

    # a private exception trap for divide-by-zero
    eval { local $SIG{'__DIE__'}; $answer = $a / $b; };
    warn $@ if $@;

=begin original

This is especially significant, given that C<__DIE__> hooks can call
C<die> again, which has the effect of changing their error messages:

=end original

これは特に顕著です。与えられた C<__DIE__> フックは C<die> をもう一度
呼び出すことができ、これによってエラーメッセージを変える効果があります:

    # __DIE__ hooks may modify error messages
    {
       local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
       eval { die "foo lives here" };
       print $@ if $@;                # prints "bar lives here"
    }

=begin original

Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.

=end original

これは距離の離れた行動であるため、この直感的でない振る舞いは
将来のリリースでは修正されるかもしれません。

=begin original

With an C<eval>, you should be especially careful to remember what's
being looked at when:

=end original

C<eval> では、以下のような場合に、
何が調べられるかに特に注意しておくことが必要です:

    eval $x;        # CASE 1
    eval "$x";      # CASE 2

    eval '$x';      # CASE 3
    eval { $x };    # CASE 4

    eval "\$$x++";  # CASE 5
    $$x++;          # CASE 6

=begin original

Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C<'$x'>, which
does nothing but return the value of $x.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I<would> like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.

=end original

上記の CASE 1 と CASE 2 の動作は同一で、変数 $x 内の
コードを実行します。
(ただし、CASE 2 では、必要のないダブルクォートによって、
読む人が何が起こるか混乱することでしょう (何も起こりませんが)。)
同様に CASE 3 と CASE 4 の動作も等しく、$x の値を返す以外に
何もしない C<$x> というコードを実行します
(純粋に見た目の問題で、CASE 4 が好まれますが、
実行時でなくコンパイル時にコンパイルされるという利点もあります)。
CASE 5 の場合は、通常ダブルクォートを使用します。
この状況を除けば、CASE 6 のように、単に
シンボリックリファレンスを使えば良いでしょう。

=begin original

Before Perl 5.14, the assignment to C<$@> occurred before restoration 
of localised variables, which means that for your code to run on older
versions, a temporary is required if you want to mask some but not all
errors:

=end original

Perl 5.14 より前では、C<$@> への代入はローカル化された変数の復帰の前に
起きるので、古いバージョンで実行される場合は、全てではなく一部だけの
エラーをマスクしたい場合には一時変数が必要です:

    # alter $@ on nefarious repugnancy only
    {
       my $e;
       {
          local $@; # protect existing $@
          eval { test_repugnancy() };
          # $@ =~ /nefarious/ and die $@; # Perl 5.14 and higher only
          $@ =~ /nefarious/ and $e = $@;
       }
       die $e if defined $e
    }

=begin original

C<eval BLOCK> does I<not> count as a loop, so the loop control statements
C<next>, C<last>, or C<redo> cannot be used to leave or restart the block.

=end original

C<eval BLOCK> はループとして I<扱われません>。
従って、C<next>, C<last>, C<redo> といったループ制御文でブロックから離れたり
再実行したりはできません。

=begin original

An C<eval ''> executed within the C<DB> package doesn't see the usual
surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it. You don't normally need to worry about this unless
you are writing a Perl debugger.

=end original

C<DB> パッケージ内で C<eval ''> を実行すると、通常の
レキシカルスコープではなく、これを呼び出した最初の非 DB コード片の
スコープになります。
Perl デバッガを書いているのでない限り、普通はこれについて心配する必要は
ありません。

=item exec LIST
X<exec> X<execute>

=item exec PROGRAM LIST

=begin original

The C<exec> function executes a system command I<and never returns>;
use C<system> instead of C<exec> if you want it to return.  It fails and
returns false only if the command does not exist I<and> it is executed
directly instead of via your system's command shell (see below).

=end original

C<exec> 関数は、システムのコマンドを実行し、I<戻ってはきません>;
戻って欲しい場合には、C<exec>ではなく C<system> 関数を使ってください。
コマンドが存在せず、I<しかも> システムのコマンドシェル経由でなく
直接コマンドを実行しようとした場合にのみこの関数は失敗して偽を返します。

=begin original

Since it's a common mistake to use C<exec> instead of C<system>, Perl
warns you if there is a following statement that isn't C<die>, C<warn>,
or C<exit> (if C<-w> is set--but you always do that, right?).   If you
I<really> want to follow an C<exec> with some other statement, you
can use one of these styles to avoid the warning:

=end original

C<system> の代わりに C<exec> を使うというよくある間違いを防ぐために、
引き続く文が C<die>, C<warn>, C<exit>(C<-w> がセットされている場合 --
でもいつもセットしてますよね) 以外の場合、Perl は警告を出します。
もし I<本当に> C<exec> の後に他の文を書きたい場合、
以下のどちらかのスタイルを使うことで警告を回避できます:

    exec ('foo')   or print STDERR "couldn't exec foo: $!";
    { exec ('foo') }; print STDERR "couldn't exec foo: $!";

=begin original

If there is more than one argument in LIST, or if LIST is an array
with more than one value, calls execvp(3) with the arguments in LIST.
If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is C</bin/sh -c> on Unix platforms, but varies on other platforms).
If there are no shell metacharacters in the argument, it is split into
words and passed directly to C<execvp>, which is more efficient.
Examples:

=end original

LIST に複数の引数がある場合か、LIST が複数の値を持つ
配列の場合には、LIST の引数を使って、execvp(3) を呼び出します。
1 つのスカラ引数のみまたは要素が一つの配列の場合には、その引数から
シェルのメタ文字をチェックし、もし、メタ文字があれば、
引数全体をシステムのコマンドシェル(これはUnix では
C</bin/sh -c> ですが、システムによって異なります)に渡して解析させます。
もし、メタキャラクタがなければ、その引数を単語に分け、
より効率的な C<execvp> に直接渡します。
例:

    exec '/bin/echo', 'Your arguments are: ', @ARGV;
    exec "sort $outfile | uniq";

=begin original

If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an "indirect object" (without a
comma) in front of the LIST.  (This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:

=end original

第一引数に指定するものを本当に実行したいが、実行する
プログラムに対して別の名前を教えたい場合には、LISTの前に、
「間接オブジェクト」(コンマなし) として、実際に
実行したいプログラムを指定することができます。
(これによって、LIST に単一のスカラしかなくても、複数
値のリストであるように、LIST の解釈を行ないます。)
例:

    $shell = '/bin/csh';
    exec $shell '-sh';    # pretend it's a login shell

=begin original

or, more directly,

=end original

あるいは、より直接的に、

    exec {'/bin/csh'} '-sh';  # pretend it's a login shell

=begin original

When the arguments get executed via the system shell, results are
subject to its quirks and capabilities.  See L<perlop/"`STRING`">
for details.

=end original

引数がシステムシェルで実行されるとき、結果はシェルの奇癖と能力によって
変わります。
詳細については L<perlop/"`STRING`"> を参照してください。

=begin original

Using an indirect object with C<exec> or C<system> is also more
secure.  This usage (which also works fine with system()) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.  That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.

=end original

C<exec> や C<system> で間接オブジェクトを使うのもより安全です。
この使い方(system() でも同様にうまく動きます)は、たとえ引数が一つだけの
場合も、複数の値を持つリストとして引数を解釈することを強制します。
この方法で、シェルによるワイルドカード展開や、空白による単語の分割から
守られます。

    @args = ( "echo surprise" );

    exec @args;               # subject to shell escapes
                                # if @args == 1
    exec { $args[0] } @args;  # safe even with one-arg list

=begin original

The first version, the one without the indirect object, ran the I<echo>
program, passing it C<"surprise"> an argument.  The second version didn't;
it tried to run a program named I<"echo surprise">, didn't find it, and set
C<$?> to a non-zero value indicating failure.

=end original

間接オブジェクトなしの一つ目のバージョンでは、I<echo> プログラムが実行され、
C<"surprise"> が引数として渡されます。
二つ目のバージョンでは違います; I<"echo surprise"> という名前の
プログラムを実行しようとして、見つからないので、失敗したことを示すために
C<$?> に非 0 がセットされます。

=begin original

Beginning with v5.6.0, Perl attempts to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see L<perlport>).  To be safe, you may need to set C<$|> ($AUTOFLUSH
in English) or call the C<autoflush()> method of C<IO::Handle> on any
open handles to avoid lost output.

=end original

v5.6.0 から、Perl は exec の前に出力用に開かれている全てのファイルを
フラッシュしようとしますが、これに対応していないプラットフォームもあります
(L<perlport> を参照してください)。
安全のためには、出力が重複するのを避けるために、全てのオープンしている
ハンドルに対して C<$|> (English モジュールでは $AUTOFLUSH) を設定するか、
C<IO::Handle> モジュールの C<autoflush()> メソッドをを呼ぶ必要が
あるかもしれません。

=begin original

Note that C<exec> will not call your C<END> blocks, nor will it invoke
C<DESTROY> methods on your objects.

=end original

C<exec> は C<END> ブロックや、オブジェクトの C<DESTROY> メソッドを
起動しないことに注意してください。

=item exists EXPR
X<exists> X<autovivification>

=begin original

Given an expression that specifies an element of a hash, returns true if the
specified element in the hash has ever been initialized, even if the
corresponding value is undefined.

=end original

ハッシュ要素を示す表現が与えられ、指定された要素が、ハッシュに存在すれば、
たとえ対応する値が未定義でも真を返します。

    print "Exists\n"    if exists $hash{$key};
    print "Defined\n"   if defined $hash{$key};
    print "True\n"      if $hash{$key};

=begin original

exists may also be called on array elements, but its behavior is much less
obvious and is strongly tied to the use of L</delete> on arrays.  B<Be aware>
that calling exists on array values is deprecated and likely to be removed in
a future version of Perl.

=end original

exists は配列の要素に対しても呼び出せますが、その振る舞いははるかに
不明確で、配列に対する L</delete> の使用と強く結びついています。
配列の値に対して exists を呼び出すのは非推奨であり、将来のバージョンの
Perl では削除されるかもしれないことを B<注意してください> 。

    print "Exists\n"    if exists $array[$index];
    print "Defined\n"   if defined $array[$index];
    print "True\n"      if $array[$index];

=begin original

A hash or array element can be true only if it's defined and defined only if
it exists, but the reverse doesn't necessarily hold true.

=end original

ハッシュまたは配列要素は、定義されているときにのみ真となり、
存在しているときにのみ定義されますが、逆は必ずしも真ではありません。

=begin original

Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.  Mentioning a subroutine name for exists or defined
does not count as declaring it.  Note that a subroutine that does not
exist may still be callable: its package may have an C<AUTOLOAD>
method that makes it spring into existence the first time that it is
called; see L<perlsub>.

=end original

引数としてサブルーチンの名前が指定された場合、
指定されたサブルーチンが宣言されていれば(たとえ未定義でも)
真を返します。
exists や defined のために言及されているサブルーチン名は
宣言としてのカウントに入りません。
存在しないサブルーチンでも呼び出し可能かもしれないことに注意してください:
パッケージが C<AUTOLOAD> メソッドを持っていて、最初に呼び出された時に
存在を作り出すかもしれません; L<perlsub> を参照してください。

    print "Exists\n"  if exists &subroutine;
    print "Defined\n" if defined &subroutine;

=begin original

Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:

=end original

最終的な操作がハッシュや配列の key による検索またはサブルーチン名である限りは、
EXPR には任意の複雑な式を置くことができます:

    if (exists $ref->{A}->{B}->{$key})  { }
    if (exists $hash{A}{B}{$key})       { }

    if (exists $ref->{A}->{B}->[$ix])   { }
    if (exists $hash{A}{B}[$ix])        { }

    if (exists &{$ref->{A}{B}{$key}})   { }

=begin original

Although the mostly deeply nested array or hash will not spring into
existence just because its existence was tested, any intervening ones will.
Thus C<< $ref->{"A"} >> and C<< $ref->{"A"}->{"B"} >> will spring
into existence due to the existence test for the $key element above.
This happens anywhere the arrow operator is used, including even here:

=end original

ネストした配列やハッシュの一番深い部分は、その存在をテストしただけでは
存在するようにはなりませんが、途中のものは存在するようになります。
従って C<< $ref->{"A"} >> と C<< $ref->{"A"}->{"B"} >> は上記の $key の
存在をテストしたことによって存在するようになります。
これは、矢印演算子が使われるところでは、以下のようなものを含むどこででも
起こります。

    undef $ref;
    if (exists $ref->{"Some key"})    { }
    print $ref;  # prints HASH(0x80d3d5c)

=begin original

This surprising autovivification in what does not at first--or even
second--glance appear to be an lvalue context may be fixed in a future
release.

=end original

一目見ただけでは -- あるいは二目見ても -- 驚かされる、左辺値コンテキストでの
自動有効化は将来のリリースでは修正されるでしょう。

=begin original

Use of a subroutine call, rather than a subroutine name, as an argument
to exists() is an error.

=end original

exists() の引数としてサブルーチン名でなくサブルーチン呼び出しを使うと、
エラーになります。

    exists &sub;    # OK
    exists &sub();  # Error

=item exit EXPR
X<exit> X<terminate> X<abort>

=item exit

=begin original

Evaluates EXPR and exits immediately with that value.    Example:

=end original

EXPR を評価し、即座にその値を持って終了します。
例:

    $ans = <STDIN>;
    exit 0 if $ans =~ /^[Xx]/;

=begin original

See also C<die>.  If EXPR is omitted, exits with C<0> status.  The only
universally recognized values for EXPR are C<0> for success and C<1>
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.  For example, exiting
69 (EX_UNAVAILABLE) from a I<sendmail> incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.

=end original

C<die> も参照してください。
EXPR が省略された場合には、ステータスを C<0> として終了します。
EXPR の値として広く利用可能なのは C<0> が成功で C<1> がエラーということだけです。
その他の値は、 Perl が実行される環境によって異なる解釈がされる
可能性があります。
例えば、I<sendmail> 到着メールフィルタから 69 (EX_UNAVAILABLE) で終了すると
メーラーはアイテムを配達せずに差し戻しますが、
これはいつでも真ではありません。

=begin original

Don't use C<exit> to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.  Use C<die> instead,
which can be trapped by an C<eval>.

=end original

誰かが発生したエラーをトラップしようと考えている可能性がある場合は、
サブルーチンの中断に C<exit> を使わないでください。
代わりに C<eval> でトラップできる C<die> を使ってください。

=begin original

The exit() function does not always exit immediately.  It calls any
defined C<END> routines first, but these C<END> routines may not
themselves abort the exit.  Likewise any object destructors that need to
be called are called before the real exit.  C<END> routines and destructors
can change the exit status by modifying C<$?>. If this is a problem, you
can call C<POSIX:_exit($status)> to avoid END and destructor processing.
See L<perlmod> for details.

=end original

exit() 関数は常に直ちに終了するわけではありません。
まず、定義されている END ルーチンを呼び出しますが、
C<END> ルーチン自身は exit を止められません。
同様に、呼び出す必要のあるオブジェクトデストラクタは
すべて、実際の終了前に呼び出されます。
C<END> ルーチンとデストラクタは C<$?> を修正することで終了コードを
変更できます。
これが問題になる場合は、END やデストラクタが実行されることを
防ぐために C<POSIX:_exit($status)> を呼び出してください。
詳しくは L<perlmod> を参照してください。

=item exp EXPR
X<exp> X<exponential> X<antilog> X<antilogarithm> X<e>

=item exp

=begin original

Returns I<e> (the natural logarithm base) to the power of EXPR.
If EXPR is omitted, gives C<exp($_)>.

=end original

I<e> (自然対数の底) の EXPR 乗を返します。　
EXPR を省略した場合には、C<exp($_)> を返します。

=item fcntl FILEHANDLE,FUNCTION,SCALAR
X<fcntl>

=begin original

Implements the fcntl(2) function.  You'll probably have to say

=end original

fcntl(2) 関数を実装します。
正しい定数定義を得るために、まず、

    use Fcntl;

=begin original

first to get the correct constant definitions.  Argument processing and
value returned work just like C<ioctl> below.
For example:

=end original

と書くことが必要でしょう。
引数の処理と返り値については、下記の C<ioctl> と同様に動作します。
例:

    use Fcntl;
    fcntl($filehandle, F_GETFL, $packed_return_buffer)
        or die "can't fcntl F_GETFL: $!";

=begin original

You don't have to check for C<defined> on the return from C<fcntl>.
Like C<ioctl>, it maps a C<0> return from the system call into
C<"0 but true"> in Perl.  This string is true in boolean context and C<0>
in numeric context.  It is also exempt from the normal B<-w> warnings
on improper numeric conversions.

=end original

C<fcntl> からの返り値のチェックに C<defined> を使う必要はありません。
C<ioctl> と違って、C<fnctl> はシステムコールの結果が C<0> だった場合は
C<"0 だが真">を返します。
この文字列は真偽値コンテキストでは真となり、
数値コンテキストでは C<0> になります。
これはまた、不適切な数値変換に関する通常の B<-w> 警告を回避します。

=begin original

Note that C<fcntl> raises an exception if used on a machine that
doesn't implement fcntl(2).  See the Fcntl module or your fcntl(2)
manpage to learn what functions are available on your system.

=end original

fcntl(2) が実装されていないマシンでは、C<fcntl>は例外を
引き起こすことに注意してください。
システムでどの関数が利用可能かについては Fcntl モジュールや
fcntl(2) man ページを参照してください。

=begin original

Here's an example of setting a filehandle named C<REMOTE> to be
non-blocking at the system level.  You'll have to negotiate C<$|>
on your own, though.

=end original

これは C<REMOTE> というファイルハンドルをシステムレベルで
非ブロックモードにセットする例です。
ただし、 C<$|> を自分で管理しなければなりません。

    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

    $flags = fcntl(REMOTE, F_GETFL, 0)
                or die "Can't get flags for the socket: $!\n";

    $flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                or die "Can't set flags for the socket: $!\n";

=item fileno FILEHANDLE
X<fileno>

=begin original

Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.  If there is no real file descriptor at the OS
level, as can happen with filehandles connected to memory objects via
C<open> with a reference for the third argument, -1 is returned.

=end original

ファイルハンドルに対するファイル記述子を返します。
ファイルハンドルがオープンしていない場合は未定義値を返します。
OS レベルで実際のファイル記述子がない(C<open> の第 3 引数にリファレンスを
指定してファイルハンドルがメモリオブジェクトと結びつけられたときに
起こります)場合、-1 が返されます。

=begin original

This is mainly useful for constructing
bitmaps for C<select> and low-level POSIX tty-handling operations.
If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.

=end original

これは主に C<select> や低レベル POSIX tty 操作に対する、ビットマップを
構成するときに便利です。
FILEHANDLE が式であれば、
その値が間接ファイルハンドル(普通は名前)として使われます。

=begin original

You can use this to find out whether two handles refer to the
same underlying descriptor:

=end original

これを、二つのハンドルが同じ識別子を参照しているかどうかを見つけるのに
使えます:

    if (fileno(THIS) == fileno(THAT)) {
        print "THIS and THAT are dups\n";
    }

=item flock FILEHANDLE,OPERATION
X<flock> X<lock> X<locking>

=begin original

Calls flock(2), or an emulation of it, on FILEHANDLE.  Returns true
for success, false on failure.  Produces a fatal error if used on a
machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3).
C<flock> is Perl's portable file-locking interface, although it locks
entire files only, not records.

=end original

FILEHANDLE に対して flock(2)、またはそのエミュレーションを呼び出します。
成功時には真を、失敗時には偽を返します。
flock(2), fcntl(2) ロック, lockf(3) のいずれかを実装していない
マシンで使うと、致命的エラーが発生します。
C<flock> は Perl の移植性のあるファイルロックインターフェースです。
しかしレコードではなく、ファイル全体のみをロックします。

=begin original

Two potentially non-obvious but traditional C<flock> semantics are
that it waits indefinitely until the lock is granted, and that its locks
are B<merely advisory>.  Such discretionary locks are more flexible, but
offer fewer guarantees.  This means that programs that do not also use
C<flock> may modify files locked with C<flock>.  See L<perlport>, 
your port's specific documentation, and your system-specific local manpages
for details.  It's best to assume traditional behavior if you're writing
portable programs.  (But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
"features").  Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)

=end original

明白ではないものの、伝統的な C<flock> の動作としては、ロックが得られるまで
無限に待ち続けるものと、B<単に勧告的に> ロックするものの二つがあります。
このような自由裁量のロックはより柔軟ですが、保障されるものはより少ないです。
これは、C<flock> を使わないプログラムが C<flock> でロックされたファイルを
書き換えるかもしれないことを意味します。
詳細については、L<perlport>、システム固有のドキュメント、システム固有の
ローカルの man ページを参照してください。
移植性のあるプログラムを書く場合は、伝統的な振る舞いを仮定するのが
ベストです。
(しかし移植性のないプログラムを書く場合は、自身のシステムの性癖(しばしば
「仕様」と呼ばれます)に合わせて書くことも完全に自由です。
盲目的に移植性に固執することで、あなたの作業を仕上げるのを邪魔するべきでは
ありません。)

=begin original

OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the L<Fcntl> module,
either individually, or as a group using the C<:flock> tag.  LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.  If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX, then C<flock> returns immediately rather than blocking
waiting for the lock; check the return status to see if you got it.

=end original

OPERATION は LOCK_SH, LOCK_EX, LOCK_UN のいずれかで、LOCK_NB と
組み合わされることもあります。
これらの定数は伝統的には 1, 2, 8, 4 の値を持ちますが、L<Fcntl> モジュールから
シンボル名を独立してインポートするか、C<:flock> タグを使うグループとして、
シンボル名をを使うことができます。
LOCK_SH は共有ロックを要求し、LOCK_EX は排他ロックを要求し、LOCK_UN は
前回要求したロックを開放します。
LOCK_NB と LOCK_SH か LOCK_EX がビット単位の論理和されると、C<flock> は
ロックを取得するまで待つのではなく、すぐに返ります;
ロックが取得できたかどうかは返り値を調べます。

=begin original

To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.

=end original

不一致の可能性を避けるために、Perl はファイルをロック、アンロックする前に
FILEHANDLE をフラッシュします。

=begin original

Note that the emulation built with lockf(3) doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.  These
are the semantics that lockf(3) implements.  Most if not all systems
implement lockf(3) in terms of fcntl(2) locking, though, so the
differing semantics shouldn't bite too many people.

=end original

lockf(3) で作成されたエミュレーションは共有ロックを提供せず、
FILEHANDLE が書き込みモードで開いていることを必要とすることに
注意してください。
これは lockf(3) が実装している動作です。
しかし、全てではないにしてもほとんどのシステムでは fcntl(2) を使って
lockf(3) を実装しているので、異なった動作で多くの人々を混乱させることは
ないはずです。

=begin original

Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.

=end original

flock(3) の fcntl(2) エミュレーションは、 LOCK_SH を使うためには
FILEHANDLE を読み込みで開いている必要があり、LOCK_EX を使うためには
書き込みで開いている必要があることに注意してください。

=begin original

Note also that some versions of C<flock> cannot lock things over the
network; you would need to use the more system-specific C<fcntl> for
that.  If you like you can force Perl to ignore your system's flock(2)
function, and so provide its own fcntl(2)-based emulation, by passing
the switch C<-Ud_flock> to the F<Configure> program when you configure
and build a new Perl.

=end original

ネットワーク越しにはロックできない C<flock> もあることに注意してください;
このためには、よりシステム依存な C<fcntl> を使う必要があります。
Perl にシステムの flock(2) 関数を無視させ、自身の fcntl(2) ベースの
エミュレーションを使う場合は、新しい Perl を設定およびビルドするときに
F<Configure> プログラムに C<-Ud_flock> オプションを渡してください。

=begin original

Here's a mailbox appender for BSD systems.

=end original

BSD システムでのメールボックスへの追加処理の例を示します。

    use Fcntl qw(:flock SEEK_END); # import LOCK_* and SEEK_END constants

    sub lock {
        my ($fh) = @_;
        flock($fh, LOCK_EX) or die "Cannot lock mailbox - $!\n";

        # and, in case someone appended while we were waiting...
        seek($fh, 0, SEEK_END) or die "Cannot seek - $!\n";
    }

    sub unlock {
        my ($fh) = @_;
        flock($fh, LOCK_UN) or die "Cannot unlock mailbox - $!\n";
    }

    open(my $mbox, ">>", "/usr/spool/mail/$ENV{'USER'}")
        or die "Can't open mailbox: $!";

    lock($mbox);
    print $mbox $msg,"\n\n";
    unlock($mbox);

=begin original

On systems that support a real flock(2), locks are inherited across fork()
calls, whereas those that must resort to the more capricious fcntl(2)
function lose their locks, making it seriously harder to write servers.

=end original

真の flock(2) に対応しているシステムではロックは fork() を通して
継承されるのに対して、より不安定な fcntl(2) に頼らなければならない場合、
サーバを書くのは本当により難しくなります。

=begin original

See also L<DB_File> for other flock() examples.

=end original

その他の flock() の例としては L<DB_File> も参照してください。

=item fork
X<fork> X<child> X<parent>

=begin original

Does a fork(2) system call to create a new process running the
same program at the same point.  It returns the child pid to the
parent process, C<0> to the child process, or C<undef> if the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.

=end original

同じプログラムの同じ地点から開始する新しいプロセスを作成するために
システムコール fork(2) を行ないます。
親プロセスには、チャイルドプロセスの pid を、
チャイルドプロセスに C<0> を返しますが、
fork に失敗したときには、C<undef>を返します。
ファイル記述子(および記述子に関連するロック)は共有され、
その他の全てはコピーされます。
fork() に対応するほとんどのシステムでは、
これを極めて効率的にするために多大な努力が払われてきました
(例えば、データページへの copy-on-write テクノロジーなどです)。
これはここ 20 年にわたるマルチタスクに関する主要なパラダイムとなっています。

=begin original

Beginning with v5.6.0, Perl attempts to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see L<perlport>).  To be safe, you may need to set
C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method of
C<IO::Handle> on any open handles to avoid duplicate output.

=end original

v5.6.0 から、Perl は子プロセスを fork する前に出力用にオープンしている全ての
ファイルをフラッシュしようとしますが、これに対応していないプラットフォームも
あります(L<perlport> を参照してください)。
安全のためには、出力が重複するのを避けるために、
全てのオープンしているハンドルに対して C<$|> (English モジュールでは
$AUTOFLUSH) を設定するか、
C<IO::Handle> モジュールの C<autoflush()>メソッドをを呼ぶ必要が
あるかもしれません。

=begin original

If you C<fork> without ever waiting on your children, you will
accumulate zombies.  On some systems, you can avoid this by setting
C<$SIG{CHLD}> to C<"IGNORE">.  See also L<perlipc> for more examples of
forking and reaping moribund children.

=end original

チャイルドプロセスの終了を待たずに、C<fork> を繰り返せば、
ゾンビをためこむことになります。
C<$SIG{CHLD}> に C<"IGNORE"> を指定することでこれを回避できるシステムもあります。
fork と消滅しかけている子プロセスを回収するための更なる例については
L<perlipc> も参照してください。

=begin original

Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to F</dev/null> if it's any issue.

=end original

fork した子プロセスが STDIN や STDOUT といったシステムファイル記述子を
継承する場合、(CGI スクリプトやリモートシェルといった
バックグラウンドジョブのような)リモートサーバは考え通りに
動かないであろうことに注意してください。
このような場合ではこれらを F</dev/null> として再オープンするべきです。

=item format
X<format>

=begin original

Declare a picture format for use by the C<write> function.  For
example:

=end original

C<write> 関数で使うピクチャーフォーマットを宣言します。
例:

    format Something =
        Test: @<<<<<<<< @||||| @>>>>>
              $str,     $%,    '$' . int($num)
    .

    $str = "widget";
    $num = $cost/$quantity;
    $~ = 'Something';
    write;

=begin original

See L<perlform> for many details and examples.

=end original

詳細と例については L<perlform> を参照して下さい。

=item formline PICTURE,LIST
X<formline>

=begin original

This is an internal function used by C<format>s, though you may call it,
too.  It formats (see L<perlform>) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, C<$^A> (or C<$ACCUMULATOR> in English).
Eventually, when a C<write> is done, the contents of
C<$^A> are written to some filehandle.  You could also read C<$^A>
and then set C<$^A> back to C<"">.  Note that a format typically
does one C<formline> per line of form, but the C<formline> function itself
doesn't care how many newlines are embedded in the PICTURE.  This means
that the C<~> and C<~~> tokens treat the entire PICTURE as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the C<format> compiler.

=end original

これは、C<format> が使用する内部関数ですが、直接呼び出すこともできます。
これは、PICTURE の内容にしたがって、LIST の値を整形し (L<perlform> を
参照してください)、結果をフォーマット出力アキュムレータC<$^A>
(English モジュールでは C<$ACCUMULATOR>) に納めます。
最終的に、C<write> が実行されると、C<$^A> の中身が、
何らかのファイルハンドルに書き出されます。
また、自分で C<$^A> を読んで、C<$^A> の内容を C<""> に戻してもかまいません。
format は通常、1 行ごとに C<formline> を行ないますが、
C<formline> 関数自身は、PICTURE の中にいくつの改行が入っているかは、
関係がありません。
これは、C<~> と C<~~>トークンは PICTURE 全体を一行として扱うことを意味します。
従って、1 レコードフォーマットを実装するためには
フォーマットコンパイラのような複数 formline を使う必要があります。

=begin original

Be careful if you put double quotes around the picture, because an C<@>
character may be taken to mean the beginning of an array name.
C<formline> always returns true.  See L<perlform> for other examples.

=end original

ダブルクォートで PICTURE を囲む場合には、C<@> という文字が
配列名の始まりと解釈されますので、注意してください。
C<formline> は常に真を返します。
その他の例については L<perlform> を参照してください。

=begin original

If you are trying to use this instead of C<write> to capture the output,
you may find it easier to open a filehandle to a scalar
(C<< open $fh, ">", \$output >>) and write to that instead.

=end original

出力を捕捉するために C<write> の代わりにこれを使おうとした場合、
スカラにファイルハンドルを開いて (C<< open $fh, ">", \$output >>)、
代わりにここに出力する方が簡単であることに気付くでしょう。

=item getc FILEHANDLE
X<getc> X<getchar> X<character> X<file, read>

=item getc

=begin original

Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file or if there was an error (in
the latter case C<$!> is set).  If FILEHANDLE is omitted, reads from
STDIN.  This is not particularly efficient.  However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.  For that, try something more like:

=end original

FILEHANDLE につながれている入力ファイルから、次の一文字を返します。
ファイルの最後、またはエラーが発生した場合は、未定義値を返します
(後者の場合は C<$!> がセットされます)。
FILEHANDLE が省略された場合には、STDIN から読み込みを行ないます。
これは特に効率的ではありません。
しかし、これはユーザーがリターンキーを押すのを待つことなく
一文字を読み込む用途には使えません。
そのような場合には、以下のようなものを試して見てください:

    if ($BSD_STYLE) {
        system "stty cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
        system "stty", '-icanon', 'eol', "\001";
    }

    $key = getc(STDIN);

    if ($BSD_STYLE) {
        system "stty -cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
        system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL
    }
    print "\n";

=begin original

Determination of whether $BSD_STYLE should be set
is left as an exercise to the reader.

=end original

$BSD_STYLE をセットするべきかどうかを決定する方法については
読者への宿題として残しておきます。

=begin original

The C<POSIX::getattr> function can do this more portably on
systems purporting POSIX compliance.  See also the C<Term::ReadKey>
module from your nearest CPAN site; details on CPAN can be found under
L<perlmodlib/CPAN>.

=end original

C<POSIX::getattr> 関数は POSIX 準拠を主張するシステムでこれを
より移植性のある形で行います。
お近くの CPAN サイトから C<Term::ReadKey> モジュールも参照して下さい;
CPAN に関する詳細は L<perlmodlib/CPAN> にあります。

=item getlogin
X<getlogin> X<login>

=begin original

This implements the C library function of the same name, which on most
systems returns the current login from F</etc/utmp>, if any.  If it
returns the empty string, use C<getpwuid>.

=end original

これは同じ名前の C ライブラリ関数を実装していて、
多くのシステムでは、もしあれば、/etc/utmp から現在のログイン名を返します。
もし空文字列が返ってきた場合は、getpwuid() を使ってください。

    $login = getlogin || getpwuid($<) || "Kilroy";

=begin original

Do not consider C<getlogin> for authentication: it is not as
secure as C<getpwuid>.

=end original

C<getlogin> を認証に使ってはいけません。
これは C<getpwuid> のように安全ではありません。

=item getpeername SOCKET
X<getpeername> X<peer>

=begin original

Returns the packed sockaddr address of the other end of the SOCKET
connection.

=end original

SOCKET コネクションの向こう側のパックされた aockaddr アドレスを返します。

    use Socket;
    $hersockaddr    = getpeername(SOCK);
    ($port, $iaddr) = sockaddr_in($hersockaddr);
    $herhostname    = gethostbyaddr($iaddr, AF_INET);
    $herstraddr     = inet_ntoa($iaddr);

=item getpgrp PID
X<getpgrp> X<group>

=begin original

Returns the current process group for the specified PID.  Use
a PID of C<0> to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement getpgrp(2).  If PID is omitted, returns the process
group of the current process.  Note that the POSIX version of C<getpgrp>
does not accept a PID argument, so only C<PID==0> is truly portable.

=end original

指定された PID の現在のプロセスグループを返します。
PID に C<0> を与えるとカレントプロセスの指定となります。
getpgrp(2) を実装していないマシンで実行した場合には、例外が発生します。
PID を省略するとカレントプロセスのプロセスグループを返します。
POSIX 版の C<getpgrp> は PID 引数を受け付けないので、
C<PID==0> のみが完全に移植性があります。

=item getppid
X<getppid> X<parent> X<pid>

=begin original

Returns the process id of the parent process.

=end original

親プロセスのプロセス id を返します。

=begin original

Note for Linux users: on Linux, the C functions C<getpid()> and
C<getppid()> return different values from different threads. In order to
be portable, this behavior is not reflected by the Perl-level function
C<getppid()>, that returns a consistent value across threads. If you want
to call the underlying C<getppid()>, you may use the CPAN module
C<Linux::Pid>.

=end original

Linux ユーザーへの注意: Linux では C<getpid()> と C<getppid()> の C 関数は
スレッドが異なると異なった値を返します。
移植性のために、この振る舞いは Perl レベルの関数 C<getppid()> には
反映されず、スレッドをまたいで一貫性のある値を返します。
基礎となる C<getppid()> を呼び出したい場合は、CPAN モジュールである
C<Linux::Pid> を使ってください。

=item getpriority WHICH,WHO
X<getpriority> X<priority> X<nice>

=begin original

Returns the current priority for a process, a process group, or a user.
(See C<getpriority(2)>.)  Will raise a fatal exception if used on a
machine that doesn't implement getpriority(2).

=end original

プロセス、プロセスグループ、ユーザに対する現在の優先度を返します。
(C<getpriority(2)> を参照してください。)
getpriority(2) を実装していない
マシンで実行した場合には、致命的例外が発生します。

=item getpwnam NAME
X<getpwnam> X<getgrnam> X<gethostbyname> X<getnetbyname> X<getprotobyname>
X<getpwuid> X<getgrgid> X<getservbyname> X<gethostbyaddr> X<getnetbyaddr>
X<getprotobynumber> X<getservbyport> X<getpwent> X<getgrent> X<gethostent>
X<getnetent> X<getprotoent> X<getservent> X<setpwent> X<setgrent> X<sethostent>
X<setnetent> X<setprotoent> X<setservent> X<endpwent> X<endgrent> X<endhostent>
X<endnetent> X<endprotoent> X<endservent> 

=item getgrnam NAME

=item gethostbyname NAME

=item getnetbyname NAME

=item getprotobyname NAME

=item getpwuid UID

=item getgrgid GID

=item getservbyname NAME,PROTO

=item gethostbyaddr ADDR,ADDRTYPE

=item getnetbyaddr ADDR,ADDRTYPE

=item getprotobynumber NUMBER

=item getservbyport PORT,PROTO

=item getpwent

=item getgrent

=item gethostent

=item getnetent

=item getprotoent

=item getservent

=item setpwent

=item setgrent

=item sethostent STAYOPEN

=item setnetent STAYOPEN

=item setprotoent STAYOPEN

=item setservent STAYOPEN

=item endpwent

=item endgrent

=item endhostent

=item endnetent

=item endprotoent

=item endservent

=begin original

These routines are the same as their counterparts in the
system C library.  In list context, the return values from the
various get routines are as follows:

=end original

これらのルーチンは、システムの C ライブラリの同名の関数と同じです。
リストコンテキストでは、さまざまな
get ルーチンからの返り値は、次のようになります:

    ($name,$passwd,$uid,$gid,
       $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
    ($name,$passwd,$gid,$members) = getgr*
    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
    ($name,$aliases,$addrtype,$net) = getnet*
    ($name,$aliases,$proto) = getproto*
    ($name,$aliases,$port,$proto) = getserv*

=begin original

(If the entry doesn't exist you get an empty list.)

=end original

(エントリが存在しなければ、空リストが返されます。)

=begin original

The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.  Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L<perlsec>).  The $passwd and $shell, user's encrypted password and
login shell, are also tainted, for the same reason.

=end original

$gcos フィールドの正確な意味はさまざまですが、通常は(ログイン名ではなく)
ユーザーの実際の名前とユーザーに付随する情報を含みます。
但し、多くのシステムではユーザーがこの情報を変更できるので、この情報は
信頼できず、従って $gcos は汚染されます(L<perlsec> を参照してください)。
ユーザーの暗号化されたパスワードとログインシェルである $passwd と
$shell も、同様の理由で汚染されます。

=begin original

In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:

=end original

スカラコンテキストでは、*nam、*byname といった NAME で検索するもの以外は、
name を返し、NAME で検索するものは、何か別のものを返します。
(エントリが存在しなければ、未定義値が返ります。)
例:

    $uid   = getpwnam($name);
    $name  = getpwuid($num);
    $name  = getpwent();
    $gid   = getgrnam($name);
    $name  = getgrgid($num);
    $name  = getgrent();
    #etc.

=begin original

In I<getpw*()> the fields $quota, $comment, and $expire are special
in that they are unsupported on many systems.  If the
$quota is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the $comment field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.  In some systems the $comment field may be $class.  The $expire
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult getpwnam(3) and your system's 
F<pwd.h> file.  You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the C<Config> module and the values C<d_pwquota>, C<d_pwage>,
C<d_pwchange>, C<d_pwcomment>, and C<d_pwexpire>.  Shadow password
files are supported only if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the shadow(3) functions as found in System V (this includes Solaris
and Linux).  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.

=end original

I<getpw*()> では、$quota, $comment, $expire フィールドは、
多くのシステムでは対応していないので特別な処理がされます。
$quota が非対応の場合、空のスカラになります。
対応している場合、通常はディスククォータの値が入ります。
$comment フィールドが非対応の場合、空のスカラになります。
対応している場合、通常はユーザーに関する管理上のコメントが入ります。
$quota フィールドはパスワードの寿命を示す $change や $age である
システムもあります。
$comment フィールドは $class であるシステムもあります。
$expire フィールドがある場合は、アカウントやパスワードが時間切れになる
期間が入ります。
動作させるシステムでのこれらのフィールドの有効性と正確な意味については、
getpwnam(3) のドキュメントと F<pwd.h> ファイルを参照してください。
$quota と $comment フィールドが何を意味しているかと、$expire フィールドが
あるかどうかは、C<Config> モジュールを使って、C<d_pwquota>, C<d_pwage>,
C<d_pwchange>, C<d_pwcomment>, C<d_pwexpire> の値を調べることによって
Perl 自身で調べることも出来ます。
シャドウパスワードは、通常の C ライブラリルーチンを権限がある状態で
呼び出すことでシャドウ版が取得できるか、System V にあるような
(Solaris と Linux を含みます) shadow(3) 関数があるといった、
直感的な方法で実装されている場合にのみ対応されます。
独占的なシャドウパスワード機能を実装しているシステムでは、
それに対応されることはないでしょう。

=begin original

The $members value returned by I<getgr*()> is a space-separated list of
the login names of the members of the group.

=end original

I<getgr*()> によって返る値 $members は、グループのメンバの
ログイン名をスペースで区切ったものです。

=begin original

For the I<gethost*()> functions, if the C<h_errno> variable is supported in
C, it will be returned to you via C<$?> if the function call fails.  The
C<@addrs> value returned by a successful call is a list of raw
addresses returned by the corresponding library call.  In the
Internet domain, each address is four bytes long; you can unpack it
by saying something like:

=end original

I<gethost*()> 関数では、C で C<h_errno> 変数がサポートされていれば、
関数呼出が失敗したときに、C<$?> を通して、その値が返されます。
成功時に返される C<@addrs> 値は、対応するシステムコールが返す、
生のアドレスのリストです。
インターネットドメインでは、個々のアドレスは、4 バイト長です;
以下のようにして unpack することができます:

    ($a,$b,$c,$d) = unpack('W4',$addr[0]);

=begin original

The Socket library makes this slightly easier:

=end original

Socket ライブラリを使うともう少し簡単になります。

    use Socket;
    $iaddr = inet_aton("127.1"); # or whatever address
    $name  = gethostbyaddr($iaddr, AF_INET);

    # or going the other way
    $straddr = inet_ntoa($iaddr);

=begin original

In the opposite way, to resolve a hostname to the IP address
you can write this:

=end original

逆方向に、ホスト名から IP アドレスを解決するには以下のように書けます:

    use Socket;
    $packed_ip = gethostbyname("www.perl.org");
    if (defined $packed_ip) {
        $ip_address = inet_ntoa($packed_ip);
    }

=begin original

Make sure <gethostbyname()> is called in SCALAR context and that
its return value is checked for definedness.

=end original

C<gethostbyname()> はスカラコンテキストで呼び出すようにして、返り値が
定義されているかを必ずチェックしてください。

=begin original

If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: C<File::stat>, C<Net::hostent>, C<Net::netent>,
C<Net::protoent>, C<Net::servent>, C<Time::gmtime>, C<Time::localtime>,
and C<User::grent>.  These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.  For example:

=end original

返り値のリストの何番目がどの要素かを覚えるのに疲れたなら、
名前ベースのインターフェースが標準モジュールで提供されています:
C<File::stat>, C<Net::hostent>, C<Net::netent>,
C<Net::protoent>, C<Net::servent>, C<Time::gmtime>, C<Time::localtime>,
C<User::grent> です。
これらは通常の組み込みを上書きし、
それぞれのフィールドに適切な名前をつけたオブジェクトを返します。
例:

   use File::stat;
   use User::pwent;
   $is_his = (stat($filename)->uid == pwent($whoever)->uid);

=begin original

Even though it looks as though they're the same method calls (uid),
they aren't, because a C<File::stat> object is different from
a C<User::pwent> object.

=end original

同じメソッド(uid)を呼び出しているように見えますが、違います。
なぜなら C<File::stat> オブジェクトは C<User::pwent> オブジェクトとは
異なるからです。

=item getsockname SOCKET
X<getsockname>

=begin original

Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.

=end original

SOCKET 接続のこちら側の pack された sockaddr アドレスを返します。
複数の異なる IP から接続されるためにアドレスがわからない場合に使います。

    use Socket;
    $mysockaddr = getsockname(SOCK);
    ($port, $myaddr) = sockaddr_in($mysockaddr);
    printf "Connect to %s [%s]\n",
       scalar gethostbyaddr($myaddr, AF_INET),
       inet_ntoa($myaddr);

=item getsockopt SOCKET,LEVEL,OPTNAME
X<getsockopt>

=begin original

Queries the option named OPTNAME associated with SOCKET at a given LEVEL.
Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
C<Socket> module) will exist. To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied. For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using C<getprotobyname>.

=end original

与えられた LEVEL で SOCKET に関連付けられた OPTNAME と言う名前のオプションを
問い合わせます。
オプションはソケットの種類に依存しした複数のプロトコルレベルに存在することも
ありますが、少なくとも最上位ソケットレベル SOL_SOCKET (C<Socket> モジュールで
定義されています)は存在します。
その他のレベルのオプションを問い合わせるには、そのオプションを制御する
適切なプロトコルのプロトコル番号を指定します。
例えば、オプションが TCP プロトコルで解釈されるべきであることを示すためには、
LEVEL は C<getprotobyname> で得られる TCP のプロトコル番号を設定します。

=begin original

The function returns a packed string representing the requested socket
option, or C<undef> on error, with the reason for the error placed in
C<$!>. Just what is in the packed string depends on LEVEL and OPTNAME;
consult getsockopt(2) for details.  A common case is that the option is an
integer, in which case the result is a packed integer, which you can decode
using C<unpack> with the C<i> (or C<I>) format.

=end original

この関数は、要求されたソケットオプションの pack された文字列表現か、
あるいはエラーの場合は C<undef> を返し、エラーの理由は C<$!> にあります。
pack された文字列の中身は LEVEL と OPTNAME に依存します;
詳細については getsockopt(2) を確認してください。
一般的な場合はオプションが整数の場合で、この場合結果は C<unpack> の C<i>
(あるいは C<I>)フォーマットでデコードできる pack された整数です。

=begin original

Here's an example to test whether Nagle's algorithm is enabled on a socket:

=end original

あるソケットで Nagle のアルゴリズム有効かどうかを調べる例です:

    use Socket qw(:all);

    defined(my $tcp = getprotobyname("tcp"))
        or die "Could not determine the protocol number for tcp";
    # my $tcp = IPPROTO_TCP; # Alternative
    my $packed = getsockopt($socket, $tcp, TCP_NODELAY)
        or die "getsockopt TCP_NODELAY: $!";
    my $nodelay = unpack("I", $packed);
    print "Nagle's algorithm is turned ", $nodelay ? "off\n" : "on\n";


=item given EXPR BLOCK
X<given>

=item given BLOCK

=begin original

C<given> is analogous to the C<switch> keyword in other languages. C<given>
and C<when> are used in Perl to implement C<switch>/C<case> like statements.
Only available after Perl 5.10.  For example:

=end original

C<given> は他の言語での C<switch> キーワードと似ています。
C<given> と C<when> は C<switch>/C<case> 風の構文を実装するために Perl で
使われます。
Perl 5.10 以降でのみ利用可能です。
例えば:

    use v5.10;
    given ($fruit) {
        when (/apples?/) {
            print "I like apples."
        }
        when (/oranges?/) {
            print "I don't like oranges."
        }
        default {
            print "I don't like anything"
        }
    }

=begin original

See L<perlsyn/"Switch statements"> for detailed information.

=end original

詳しい情報については L<perlsyn/"Switch statements"> を参照してください。

=item glob EXPR
X<glob> X<wildcard> X<filename, expansion> X<expand>

=item glob

=begin original

In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the standard Unix shell F</bin/csh> would do. In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted. This is the internal function
implementing the C<< <*.c> >> operator, but you can use it directly. If
EXPR is omitted, C<$_> is used.  The C<< <*.c> >> operator is discussed in
more detail in L<perlop/"I/O Operators">.

=end original

リストコンテキストでは、
EXPR の値を、標準 Unix シェル F</bin/csh> が行なうように
ファイル名の展開を行なった結果のリスト(空かもしれません)を返します。
スカラコンテキストでは、glob はこのようなファイル名展開を繰り返し、
リストがなくなったら undef を返します。
これは、C<< <*.c> >> 演算子を実装する内部関数ですが、
直接使用することもできます。
EXPR を省略すると、C<$_>が使われます。
C<< <*.c> >>演算子については
L<perlop/"I/O Operators"> でより詳細に議論しています。

=begin original

Note that C<glob> splits its arguments on whitespace and treats
each segment as separate pattern.  As such, C<glob("*.c *.h")> 
matches all files with a F<.c> or F<.h> extension.  The expression
C<glob(".* *")> matches all files in the current working directory.

=end original

C<glob> は引数を空白で分割して、それぞれの部分を別々のパターンとして
扱うことに注意してください。
それにより、C<glob("*.c *.h")> は F<.c> と F<.h> の拡張子を持つ全ての
ファイルにマッチングします。
C<glob(".* *")> という式はカレントワーキングディレクトリの
全てのファイルにマッチングします。

=begin original

If non-empty braces are the only wildcard characters used in the
C<glob>, no filenames are matched, but potentially many strings
are returned.  For example, this produces nine strings, one for
each pairing of fruits and colors:

=end original

空でない中かっこが C<glob> で使われている唯一のワイルドカード文字列の
場合、ファイル名とはマッチングせず、可能性のある文字列が返されます。
例えば、これは 9 個の文字列を生成し、それぞれは果物と色の組み合わせに
なります:

    @many =  glob "{apple,tomato,cherry}={green,yellow,red}";

=begin original

Beginning with v5.6.0, this operator is implemented using the standard
C<File::Glob> extension.  See L<File::Glob> for details, including
C<bsd_glob> which does not treat whitespace as a pattern separator.

=end original

v5.6.0 から、この演算子は標準の C<File::Glob> 拡張を使って
実装されています。
空白をパターンのセパレータとして扱わない C<bsd_glob> を含めた
詳細は L<File::Glob> を参照して下さい。

=item gmtime EXPR
X<gmtime> X<UTC> X<Greenwich>

=item gmtime

=begin original

Works just like L<localtime> but the returned values are
localized for the standard Greenwich time zone.

=end original

L<localtime> と同様に働きますが、返り値はグリニッジ標準時に
ローカライズされています。

=begin original

Note: When called in list context, $isdst, the last value
returned by gmtime, is always C<0>.  There is no
Daylight Saving Time in GMT.

=end original

注意: リストコンテキストで呼び出した時、gmtime が返す末尾の値である
$isdst は常に C<0> です。
GMT には夏時間はありません。

=begin original

See L<perlport/gmtime> for portability concerns.

=end original

移植性の問題については L<perlport/gmtime> を参照してください。

=item goto LABEL
X<goto> X<jump> X<jmp>

=item goto EXPR

=item goto &NAME

=begin original

The C<goto-LABEL> form finds the statement labeled with LABEL and
resumes execution there. It can't be used to get out of a block or
subroutine given to C<sort>.  It can be used to go almost anywhere
else within the dynamic scope, including out of subroutines, but it's
usually better to use some other construct such as C<last> or C<die>.
The author of Perl has never felt the need to use this form of C<goto>
(in Perl, that is; C is another matter).  (The difference is that C
does not offer named loops combined with loop control.  Perl does, and
this replaces most structured uses of C<goto> in other languages.)

=end original

C<goto-LABEL> の形式は、LABEL というラベルの付いた文を
探して、そこへ実行を移すものです。
C<sort> で与えられたブロックやサブルーチンから外へ出ることはできません。
これ以外は、サブルーチンの外を含む、動的スコープ内の
ほとんどすべての場所へ行くために使用できますが、普通は、
C<last> や C<die> といった別の構造を使った方が良いでしょう。
Perl の作者はこの形式の C<goto> を使う必要を感じたことは、
1 度もありません (Perl では; C は別のお話です)。
(違いは、C にはループ制御と結びついた名前つきのループがないことです。
Perl にはあり、これが他の言語でのほとんどの構造的な C<goto> の使用法を
置き換えます。)

=begin original

The C<goto-EXPR> form expects a label name, whose scope will be resolved
dynamically.  This allows for computed C<goto>s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:

=end original

C<goto-EXPR> の形式はラベル名を予測し、このスコープは動的に解決されます。
これにより FORTRAN のような算術 C<goto> が可能になりますが、
保守性を重視するならお勧めしません。

    goto ("FOO", "BAR", "GLARCH")[$i];

=begin original

As shown in this example, C<goto-EXPR> is exempt from the "looks like a
function" rule. A pair of parentheses following it does not (necessarily)
delimit its argument. C<goto("NE")."XT"> is equivalent to C<goto NEXT>.

=end original

この例で示したように、C<goto-EXPR> は「関数のように見える」ルールから
除外されます。
これに引き続くかっこの組は引数の区切りとは(必ずしも)なりません。
C<goto("NE")."XT"> は C<goto NEXT> と等価です。

=begin original

Use of C<goto-LABEL> or C<goto-EXPR> to jump into a construct is
deprecated and will issue a warning.  Even then, it may not be used to
go into any construct that requires initialization, such as a
subroutine or a C<foreach> loop.  It also can't be used to go into a
construct that is optimized away.

=end original

構造の中に飛び込むために C<goto-LABEL> や C<goto-EXPR> を使うことは
非推奨で、警告が発生します。
それでも、サブルーチンや C<foreach> ループのような、初期化が必要な
構造の中に入るために使うことは出来ません。
また、最適化してなくなってしまった構造の中へ入るために使うことも出来ません。

=begin original

The C<goto-&NAME> form is quite different from the other forms of
C<goto>.  In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.  Instead, it
exits the current subroutine (losing any changes set by local()) and
immediately calls in its place the named subroutine using the current
value of @_.  This is used by C<AUTOLOAD> subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to C<@_>
in the current subroutine are propagated to the other subroutine.)
After the C<goto>, not even C<caller> will be able to tell that this
routine was called first.

=end original

C<goto-&NAME> の形式は、その他の C<goto> の形式とはかなり
異なったものです。
実際、これは普通の感覚でいうところのどこかへ行くものでは全くなく、
他の goto が持つ不名誉を持っていません。
現在のサブルーチンを終了し (local() による変更は失われます)、
直ちに現在の @_ の値を使って指定された名前のサブルーチンを呼び出します。
これは、C<AUTOLOAD> サブルーチンが別のサブルーチンをロードして、
その別のサブルーチンが最初に呼ばれたようにするために使われます
(ただし、現在のサブルーチンで C<@_> を修正した場合には、
その別のサブルーチンに伝えられます)。
C<goto> のあとは、C<caller> でさえも、現在のサブルーチンが
最初に呼び出されたと言うことができません。

=begin original

NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference or a block that evaluates to a code
reference.

=end original

NAME はサブルーチンの名前である必要はありません; コードリファレンスを
含むスカラ値や、コードリファレンスと評価されるブロックでも構いません。

=item grep BLOCK LIST
X<grep>

=item grep EXPR,LIST

=begin original

This is similar in spirit to, but not the same as, grep(1) and its
relatives.  In particular, it is not limited to using regular expressions.

=end original

これは grep(1) とその親類と同じようなものですが、同じではありません。
特に、正規表現の使用に制限されません。

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C<$_> to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.  In scalar
context, returns the number of times the expression was true.

=end original

LIST の個々の要素に対して、BLOCK か EXPR を評価し
(C<$_> は、ローカルに個々の要素が設定されます) 、
その要素のうち、評価した式が真となったものからなるリスト値が返されます。
スカラコンテキストでは、式が真となった回数を返します。　例:

    @foo = grep(!/^#/, @bar);    # weed out comments

=begin original

or equivalently,

=end original

あるいは等価な例として:

    @foo = grep {!/^#/} @bar;    # weed out comments

=begin original

Note that C<$_> is an alias to the list value, so it can be used to
modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.  That is, modifying an
element of a list returned by grep (for example, in a C<foreach>, C<map>
or another C<grep>) actually modifies the element in the original list.
This is usually something to be avoided when writing clear code.

=end original

C<$_> は、LIST の値へのエイリアスですので、LIST の要素を
変更するために使うことができます。
これは、便利でサポートされていますが、
LIST の要素が変数でないと、おかしな結果になります。
同様に、grep は元のリストへのエイリアスを返します。
for ループのインデックス変数がリスト要素のエイリアスであるのと
同様です。
つまり、grep で返されたリストの要素を
(C<foreach>, C<map>, または他の C<grep> で)修正すると
元のリストの要素が変更されます。
これはきれいなコードを書こうとする邪魔になることが多いです。

=begin original

If C<$_> is lexical in the scope where the C<grep> appears (because it has
been declared with C<my $_>) then, in addition to being locally aliased to
the list elements, C<$_> keeps being lexical inside the block; i.e., it
can't be seen from the outside, avoiding any potential side-effects.

=end original

(C<my $_> として宣言されることによって) C<$_> が C<grep> が現れるスコープ内で
レキシカルな場合は、ローカルではリスト要素へのエイリアスであることに加えて、
C<$_> はブロック内でレキシカルでありつづけます; つまり、外側からは見えず、
起こりうる副作用を回避します。

=begin original

See also L</map> for a list composed of the results of the BLOCK or EXPR.

=end original

BLOCK や EXPR の結果をリストの形にしたい場合は L</map> を参照してください。

=item hex EXPR
X<hex> X<hexadecimal>

=item hex

=begin original

Interprets EXPR as a hex string and returns the corresponding value.
(To convert strings that might start with either C<0>, C<0x>, or C<0b>, see
L</oct>.)  If EXPR is omitted, uses C<$_>.

=end original

EXPR を 16 進数の文字列と解釈して、対応する値を返します。
(C<0>, C<0x>, C<0b> で始まる文字列の変換には、L</oct> を
参照してください。)
EXPR が省略されると、C<$_> を使用します。

    print hex '0xAf'; # prints '175'
    print hex 'aF';   # same

=begin original

Hex strings may only represent integers.  Strings that would cause
integer overflow trigger a warning.  Leading whitespace is not stripped,
unlike oct(). To present something as hex, look into L</printf>,
L</sprintf>, and L</unpack>.

=end original

16 進文字列は整数のみを表現します。
整数オーバーフローを起こすような文字列は警告を引き起こします。
oct() とは違って、先頭の空白は除去されません。
何かを 16 進で表現したい場合は、L</printf>, L</sprintf>, L</unpack> を
参照してください。

=item import LIST
X<import>

=begin original

There is no builtin C<import> function.  It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.  The C<use> function calls the C<import> method
for the package used.  See also L</use>, L<perlmod>, and L<Exporter>.

=end original

組み込みの C<import> 関数というものはありません。
これは単に、別のモジュールに名前をエクスポートしたいモジュールが
定義した(または継承した)、通常のメソッド(サブルーチン)です。
C<use> 関数はパッケージを使う時に C<import> メソッドを呼び出します。
L</use>, L<perlmod>, L<Exporter> も参照してください。

=item index STR,SUBSTR,POSITION
X<index> X<indexOf> X<InStr>

=item index STR,SUBSTR

=begin original

The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.
It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.  If POSITION is omitted, starts searching from the
beginning of the string.  POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.  POSITION and the return value are based at C<0> (or whatever
you've set the C<$[> variable to--but don't do that).  If the substring
is not found, C<index> returns one less than the base, ordinarily C<-1>.

=end original

index 関数は ある文字列をもうひとつの文字列から検索しますが、
完全正規表現パターンマッチのワイルドカード的な振る舞いはしません。
STR の中の POSITION の位置以降で、最初に SUBSTR が見つかった位置を返します。
POSITION が省略された場合には、STR の最初から探し始めます。
POSITION が文字列の先頭より前、あるいは末尾より後ろを指定した場合は、
それぞれ先頭と末尾を指定されたものとして扱われます。
POSITION と返り値のベースは、C<0> (もしくは、変数 C<$[> に設定した値です --
しかし、これは使ってはいけません)。
SURSTR が見つからなかった場合には、C<index> はベースよりも 1 小さい値、
通常は C<-1> が返されます。

=item int EXPR
X<int> X<integer> X<truncate> X<trunc> X<floor>

=item int

=begin original

Returns the integer portion of EXPR.  If EXPR is omitted, uses C<$_>.
You should not use this function for rounding: one because it truncates
towards C<0>, and two because machine representations of floating-point
numbers can sometimes produce counterintuitive results.  For example,
C<int(-6.725/0.025)> produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.  Usually,
the C<sprintf>, C<printf>, or the C<POSIX::floor> and C<POSIX::ceil>
functions will serve you better than will int().

=end original

EXPR の整数部を返します。
EXPR を省略すると、C<$_> を使います。
この関数を丸めのために使うべきではありません。
第一の理由として C<0> の方向への切捨てを行うから、第二の理由として
浮動小数点数の機械表現は時々直感に反した結果を生み出すからです。
たとえば、C<int(-6.725/0.025)> は正しい結果である -269 ではなく
-268 を返します。
これは実際には -268.99999999999994315658 というような値になっているからです。
通常、C<sprintf>, C<printf>, C<POSIX::floor>, C<POSIX::ceil> の方が
int() より便利です。

=item ioctl FILEHANDLE,FUNCTION,SCALAR
X<ioctl>

=begin original

Implements the ioctl(2) function.  You'll probably first have to say

=end original

ioctl(2) 関数を実装します。
正しい関数の定義を得るために、おそらく最初に

    require "sys/ioctl.ph";  # probably in $Config{archlib}/sys/ioctl.ph

=begin original

to get the correct function definitions.  If F<sys/ioctl.ph> doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F<< <sys/ioctl.h> >>.
(There is a Perl script called B<h2ph> that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION; a C pointer to the string value of SCALAR
will be passed as the third argument of the actual C<ioctl> call.  (If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
true, add a C<0> to the scalar before using it.)  The C<pack> and C<unpack>
functions may be needed to manipulate the values of structures used by
C<ioctl>.

=end original

としなくてはならないでしょう。
F<sys/ioctl.ph> がないか、間違った定義をしている場合には、
F<< <sys/ioctl.ph> >>のような C のヘッダファイルをもとに、
自分で作らなければなりません。
(Perl の配布キットに入っている B<h2ph> という
Perl スクリプトがこれを手助けしてくれるでしょうが、これは重要です。)
FOUNCTION に応じて SCALAR が読み書きされます;
SCALAR の文字列値へのポインタが、実際の C<ioctl> コールの
3 番目の引数として渡されます。
(SCALAR が文字列値を持っておらず、数値を持っている場合には、
文字列値へのポインタの代わりに、その値が渡されます。
このことを保証するためには、使用する前に SCALAR にC<0> を足してください。)
C<ioctl> で使われる構造体の値を操作するには、
C<pack> 関数と C<unpack> 関数が必要となるでしょう。

=begin original

The return value of C<ioctl> (and C<fcntl>) is as follows:

=end original

C<ioctl> (と C<fcntl>) の返り値は、以下のようになります:

=begin original

    if OS returns:      then Perl returns:
        -1               undefined value
         0              string "0 but true"
    anything else           that number

=end original

    OS が返した値:      Perl が返す値:
        -1               未定義値
         0               「0 だが真」の文字列
    その他                  その値そのもの

=begin original

Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:

=end original

つまり Perl は、成功時に「真」、失敗時に「偽」を返す
ことになり、OS が実際に返した値も、以下のように簡単に知ることができます。

    $retval = ioctl(...) || -1;
    printf "System returned %d\n", $retval;

=begin original

The special string C<"0 but true"> is exempt from B<-w> complaints
about improper numeric conversions.

=end original

特別な文字列 C<"0 だが真"> は、不適切な数値変換に関する
B<-w> 警告を回避します。

=item join EXPR,LIST
X<join>

=begin original

Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.  Example:

=end original

LIST の個別の文字列を、EXPR の値で区切って
1 つの文字列につなげ、その文字列を返します。
例:

    $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

=begin original

Beware that unlike C<split>, C<join> doesn't take a pattern as its
first argument.  Compare L</split>.

=end original

C<split> と違って、C<join> は最初の引数にパターンは取れないことに
注意してください。
L</split> と比較してください。

=item keys HASH
X<keys> X<key>

=item keys ARRAY

=item keys EXPR

=begin original

Returns a list consisting of all the keys of the named hash, or the indices
of an array. (In scalar context, returns the number of keys or indices.)

=end original

指定したハッシュのすべてのキー、あるいは配列のインデックスからなるリストを
返します。
(スカラコンテキストでは、キーやインデックスの数を返します。)

=begin original

The keys of a hash are returned in an apparently random order.  The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C<values> or C<each>
function produces (given that the hash has not been modified).  Since
Perl 5.8.1 the ordering can be different even between different runs of
Perl for security reasons (see L<perlsec/"Algorithmic Complexity
Attacks">).

=end original

ハッシュのキーは見たところではランダムな順番に返されます。
実際のランダムな順番は Perl の将来のバージョンでは変わるかもしれませんが、
C<values> や C<each> 関数が同じ(変更されていない)ハッシュに対して
生成するのと同じ順番であることは保証されます。
Perl 5.8.1 以降ではセキュリティ上の理由により、
実行される毎に順番は変わります
(L<perlsec/"Algorithmic Complexity Attacks"> を参照してください)。

=begin original

As a side effect, calling keys() resets the internal interator of the HASH or ARRAY
(see L</each>).  In particular, calling keys() in void context resets
the iterator with no other overhead.

=end original

副作用として、HASH や ARRAY の反復子を初期化します
(L</each> を参照してください)。
特に、無効コンテキストで keys() を呼び出すと
オーバーヘッドなしで反復子を初期化します。

=begin original

Here is yet another way to print your environment:

=end original

環境変数を表示する別の例です:

    @keys = keys %ENV;
    @values = values %ENV;
    while (@keys) {
        print pop(@keys), '=', pop(@values), "\n";
    }

=begin original

or how about sorted by key:

=end original

key でソートしてもいいでしょう:

    foreach $key (sort(keys %ENV)) {
        print $key, '=', $ENV{$key}, "\n";
    }

=begin original

The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.  Compare L</values>.

=end original

返される値はハッシュにある元のキーのコピーなので、
これを変更しても元のハッシュには影響を与えません。
L</values> と比較してください。

=begin original

To sort a hash by value, you'll need to use a C<sort> function.
Here's a descending numeric sort of a hash by its values:

=end original

ハッシュを値でソートするためには、C<sort> 関数を使う必要があります。
以下ではハッシュの値を数値の降順でソートしています:

    foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
        printf "%4d %s\n", $hash{$key}, $key;
    }

=begin original

Used as an lvalue, C<keys> allows you to increase the number of hash buckets
allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say

=end original

左辺値として使うことで、C<keys> を使うことで与えられたハッシュに割り当てられた
ハッシュ表の大きさを増やすことができます。
これによって、ハッシュが大きくなっていくなっていくときの
効率の測定ができます。以下のようにすると:

    keys %hash = 200;

=begin original

then C<%hash> will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.  These
buckets will be retained even if you do C<%hash = ()>, use C<undef
%hash> if you want to free the storage while C<%hash> is still in scope.
You can't shrink the number of buckets allocated for the hash using
C<keys> in this way (but you needn't worry about doing this by accident,
as trying has no effect). C<keys @array> in an lvalue context is a syntax
error.

=end original

C<%hash> は少なくとも 200 の大きさの表が割り当てられます -- 
実際には 2 のべき乗に切り上げられるので、256 が割り当てられます。
この表はたとえ C<%hash = ()> としても残るので、
もし C<%hash> がスコープにいるうちにこの領域を開放したい場合は
C<undef %hash> を使います。
この方法で C<keys> を使うことで、表の大きさを小さくすることはできません
(間違えてそのようなことをしても何も起きないので気にすることはありません)。
左辺値コンテキストでの C<keys @array> は文法エラーとなります。

=begin original

Starting with Perl 5.14, C<keys> can take a scalar EXPR, which must contain
a reference to an unblessed hash or array.  The argument will be
dereferenced automatically.  This aspect of C<keys> is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<keys> はスカラの EXPR を取ることができるようになりました;
これは bless されていないハッシュや配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<keys> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

    for (keys $hashref) { ... }
    for (keys $obj->get_arrayref) { ... }

=begin original

See also C<each>, C<values>, and C<sort>.

=end original

C<each>, C<values>, C<sort> も参照してください。

=item kill SIGNAL, LIST
X<kill> X<signal>

=begin original

Sends a signal to a list of processes.  Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).

=end original

プロセスのリストにシグナルを送ります。シグナル送信に成功したプロセスの
数を返します
(実際に kill に成功したプロセスと同じとは限りません)。

    $cnt = kill 1, $child1, $child2;
    kill 9, @goners;

=begin original

If SIGNAL is zero, no signal is sent to the process, but C<kill>
checks whether it's I<possible> to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user).  This is useful to check that a child process is still
alive (even if only as a zombie) and hasn't changed its UID.  See
L<perlport> for notes on the portability of this construct.

=end original

SIGNAL がゼロの場合、プロセスにシグナルは送られませんが、
C<kill> は、シグナルを送ることが I<可能> かどうかを調べます
(これは、簡単に言うと、プロセスが同じユーザーに所有されているか、
自分がスーパーユーザーであることを意味します)。
これは子プロセスが(ゾンビとしてだけでも)まだ生きていて、 UID が
変わっていないことを調べる時に有用です。
この構成の移植性に関する注意については L<perlport> を参照して下さい。

=begin original

Unlike in the shell, if SIGNAL is negative, it kills process groups instead
of processes. That means you usually want to use positive not negative signals.
You may also use a signal name in quotes.

=end original

シェルとは異なり、シグナルに負の数を与えると、
プロセスではなくプロセスグループに対して kill を行ないます。
すなわち、通常は、負のシグナルは用いず、正のシグナルを使うことになります。
シグナル名をクォートして使うこともできます。

=begin original

The behavior of kill when a I<PROCESS> number is zero or negative depends on
the operating system.  For example, on POSIX-conforming systems, zero will
signal the current process group and -1 will signal all processes.

=end original

I<PROCESS> 番号が 0 あるいは負数の場合の kill の振る舞いは
オペレーティングシステムに依存します。
例えば、POSIX 準拠のシステムでは、0 は現在のプロセスグループにシグナルを送り、
-1 は全てのプロセスにシグナルを送ります。

=begin original

See L<perlipc/"Signals"> for more details.

=end original

詳細は L<perlipc/"Signals"> を参照してください。

=item last LABEL
X<last> X<break>

=item last

=begin original

The C<last> command is like the C<break> statement in C (as used in
loops); it immediately exits the loop in question.  If the LABEL is
omitted, the command refers to the innermost enclosing loop.  The
C<continue> block, if any, is not executed:

=end original

C<last> コマンドは、(ループ内で使った) C の C<break> 文と
同じようなもので、LABEL で指定されるループを即座に抜けます。
LABEL が省略されると、一番内側のループが対象となります。
C<continue> ブロックがあっても実行されません:

    LINE: while (<STDIN>) {
        last LINE if /^$/;  # exit when done with header
        #...
    }

=begin original

C<last> cannot be used to exit a block that returns a value such as
C<eval {}>, C<sub {}>, or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<last> は C<eval {}>, C<sub {}>, C<do {}> といった
値を返すブロックを終了するのには使えませんし、
grep() や map() 操作を終了するのに使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<last> can be used to effect an early
exit out of such a block.

=end original

ブロックはそれ自体文法的には一度だけ実行されるループと同等であることに
注意してください。従って、C<last> でそのようなブロックを
途中で抜け出すことができます。

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> がどのように働くかについては
L</continue> を参照して下さい。

=item lc EXPR
X<lc> X<lowercase>

=item lc

=begin original

Returns a lowercased version of EXPR.  This is the internal function
implementing the C<\L> escape in double-quoted strings.

=end original

EXPR を小文字に変換したものを返します。
これは、ダブルクォート文字列における、
C<\L> エスケープを実装する内部関数です。

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR が省略されると、C<$_>を使います。

=begin original

What gets returned depends on several factors:

=end original

返り値として得られるものは色々な要素に依存します:

=over

=item If C<use bytes> is in effect:

(C<use bytes> が有効の場合)

=over

=item On EBCDIC platforms

=begin original

The results are what the C language system call C<tolower()> returns.

=end original

結果は、C 言語のシステムコール C<tolower()> が返すものです。

=item On ASCII platforms

=begin original

The results follow ASCII semantics.  Only characters C<A-Z> change, to C<a-z>
respectively.

=end original

結果は ASCII の意味論に従います。
C<A-Z> のみが変換され、それぞれ C<a-z> になります。

=back

=item Otherwise, If EXPR has the UTF8 flag set

(その他の場合で、EXPR に UTF8 フラグがセットされている場合)

=begin original

If the current package has a subroutine named C<ToLower>, it will be used to
change the case
(See L<perlunicode/"User-Defined Case Mappings (for serious hackers only)">.)
Otherwise Unicode semantics are used for the case change.

=end original

現在のパッケージで C<ToLower> という名前のサブルーチンがある場合、
大文字小文字を変換するためにこれが使われます
(L<perlunicode/"User-Defined Case Mappings (for serious hackers only)"> を
参照してください)。
さもなければ、大文字小文字変換には Unicode の意味論が使われます。

=item Otherwise, if C<use locale> is in effect

(それ以外の場合で、C<use locale> が有効の場合)

=begin original

Respects current LC_CTYPE locale.  See L<perllocale>.

=end original

現在の LC_CTYPE ロケールに従います。
L<perllocale> を参照してください。

=item Otherwise, if C<use feature 'unicode_strings'> is in effect:

(それ以外の場合で、C<use feature 'unicode_strings'> が有効の場合)

=begin original

Unicode semantics are used for the case change.  Any subroutine named
C<ToLower> will be ignored.

=end original

大文字小文字変換には Unicode の意味論が使われます。
C<ToLower> という名前のサブルーチンは無視されます。

=item Otherwise:

(それ以外の場合)

=over

=item On EBCDIC platforms

=begin original

The results are what the C language system call C<tolower()> returns.

=end original

結果は、C 言語のシステムコール C<tolower()> が返すものです。

=item On ASCII platforms

=begin original

ASCII semantics are used for the case change.  The lowercase of any character
outside the ASCII range is the character itself.

=end original

大文字小文字変換には ASCII の意味論が使われます。
ASCII の範囲外の文字の「小文字」はその文字自身です。

=back

=back

=item lcfirst EXPR
X<lcfirst> X<lowercase>

=item lcfirst

=begin original

Returns the value of EXPR with the first character lowercased.  This
is the internal function implementing the C<\l> escape in
double-quoted strings.

=end original

最初の文字だけを小文字にした、EXPR を返します。
これは、ダブルクォート文字列における、C<\l> エスケープを
実装する内部関数です。

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR が省略されると、C<$_>を使います。

=begin original

This function behaves the same way under various pragmata, such as in a locale,
as L</lc> does.

=end original

この関数は、ロケールのような様々なプラグマの影響下では、
L</lc> と同様に振る舞います。

=item length EXPR
X<length> X<size>

=item length

=begin original

Returns the length in I<characters> of the value of EXPR.  If EXPR is
omitted, returns the length of C<$_>.  If EXPR is undefined, returns
C<undef>.

=end original

EXPR の値の I<文字> の長さを返します。
EXPR が省略されたときには、C<$_> の長さを返します。
EXPR が未定義値の場合、C<undef> を返します。

=begin original

This function cannot be used on an entire array or hash to find out how
many elements these have.  For that, use C<scalar @array> and C<scalar keys
%hash>, respectively.

=end original

この関数は配列やハッシュ全体に対してどれだけの要素を含んでいるかを
調べるためには使えません。
そのような用途には、それぞれ C<scalar @array> と C<scalar keys %hash> を
利用してください。

=begin original

Like all Perl character operations, length() normally deals in logical
characters, not physical bytes.  For how many bytes a string encoded as
UTF-8 would take up, use C<length(Encode::encode_utf8(EXPR))> (you'll have
to C<use Encode> first).  See L<Encode> and L<perlunicode>.

=end original

全ての Perl の文字操作と同様、length() は通常物理的なバイトではなく
論理文字を扱います。
UTF-8 でエンコードされた文字列が何バイトかを知るには、
C<length(Encode::encode_utf8(EXPR))> を使ってください (先に
C<use Encode> する必要があります)。
L<Encode> と L<perlunicode> を参照してください。

=item link OLDFILE,NEWFILE
X<link>

=begin original

Creates a new filename linked to the old filename.  Returns true for
success, false otherwise.

=end original

OLDFILE にリンクされた、新しいファイル NEWFILE を作ります。
成功時には true を、失敗時には false を返します。

=item listen SOCKET,QUEUESIZE
X<listen>

=begin original

Does the same thing that the listen(2) system call does.  Returns true if
it succeeded, false otherwise.  See the example in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

listen(2) システムコールと同じことをします。成功時には真を返し、
失敗時には偽を返します。
L<perlipc/"Sockets: Client/Server Communication">の例を参照してください。

=item local EXPR
X<local>

=begin original

You really probably want to be using C<my> instead, because C<local> isn't
what most people think of as "local".  See
L<perlsub/"Private Variables via my()"> for details.

=end original

あなたはが本当に望んでいるのは C<my> の方でしょう。
C<local> はほとんどの人々が「ローカル」と考えるものと違うからです。
詳細は L<perlsub/"Private Variables via my()"> を参照してください。

=begin original

A local modifies the listed variables to be local to the enclosing
block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See L<perlsub/"Temporary Values via local()">
for details, including issues with tied arrays and hashes.

=end original

"local" はリストアップされた変数を、囲っているブロック、
ファイル、eval の中で、ローカルなものにします。
複数の値を指定する場合は、リストは括弧でくくらなければなりません。
tie した配列とハッシュに関する事項を含む詳細については
L<perlsub/"Temporary Values via local()"> を参照してください。

=begin original

The C<delete local EXPR> construct can also be used to localize the deletion
of array/hash elements to the current block.
See L<perlsub/"Localized deletion of elements of composite types">.

=end original

C<delete local EXPR> 構文は、配列/ハッシュの要素の削除を現在の
ブロックにローカル化するためにも使われていました。
L<perlsub/"Localized deletion of elements of composite types"> を
参照してください。

=item localtime EXPR
X<localtime> X<ctime>

=item localtime

=begin original

Converts a time as returned by the time function to a 9-element list
with the time analyzed for the local time zone.  Typically used as
follows:

=end original

time 関数が返す時刻を、ローカルなタイムゾーンで測った時刻として、
9 要素の配列に変換します。
通常は、以下のようにして使用します。

    #  0    1    2     3     4    5     6     7     8
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);

=begin original

All list elements are numeric and come straight out of the C `struct
tm'.  C<$sec>, C<$min>, and C<$hour> are the seconds, minutes, and hours
of the specified time.

=end original

すべてのリスト要素は数値で、C の `struct tm' 構造体から
直接持ってきます。
C<$sec>, C<$min>, C<$hour> は指定された時刻の秒、分、時です。

=begin original

C<$mday> is the day of the month and C<$mon> the month in
the range C<0..11>, with 0 indicating January and 11 indicating December.
This makes it easy to get a month name from a list:

=end original

C<$mday> は月の何日目か、C<$mon> は月の値です。
月の値は C<0..11> で、0 が 1 月、11 が 12 月です。
これにより、リストから月の名前を得るのが簡単になります:

    my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
    print "$abbr[$mon] $mday";
    # $mon=9, $mday=18 gives "Oct 18"

=begin original

C<$year> is the number of years since 1900, B<not> just the last two digits
of the year.  That is, C<$year> is C<123> in year 2023.  The proper way
to get a 4-digit year is simply:

=end original

C<$year> は 1900 年からの年数であり、単に西暦の下 2 桁を表しているのでは
B<ありません>。
つまり、$year が C<123> なら 2023 年です。
4 桁の西暦を得るには単に以下のようにしてください:

    $year += 1900;

=begin original

Otherwise you create non-Y2K-compliant programs--and you wouldn't want
to do that, would you?

=end original

さもなければ、Y2K 問題を含んだプログラムを作ることになります -- 
それはお望みじゃないでしょう?

=begin original

To get the last two digits of the year (e.g., "01" in 2001) do:

=end original

西暦の下 2 桁(2001 年では "01")がほしい場合は以下のようにします:

    $year = sprintf("%02d", $year % 100);

=begin original

C<$wday> is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.  C<$yday> is the day of the year, in the range C<0..364>
(or C<0..365> in leap years.)

=end original

C<$wday> は曜日で、0 が日曜日、3 が木曜日です。
C<$yday> はその年の何日目かで、C<0..364> の値を取ります
(うるう年は C<0..365> です)。

=begin original

C<$isdst> is true if the specified time occurs during Daylight Saving
Time, false otherwise.

=end original

C<$isdst> は指定された時刻が夏時間の場合は真、そうでなければ偽です。

=begin original

If EXPR is omitted, C<localtime()> uses the current time (as returned
by time(3)).

=end original

EXPR が省略されると、C<localtime()> は(time(3) によって返される)
現在時刻を使います。

=begin original

In scalar context, C<localtime()> returns the ctime(3) value:

=end original

スカラコンテキストでは、C<localtime()> は ctime(3) の値を返します:

    $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"

=begin original

This scalar value is B<not> locale-dependent but is a Perl builtin. For GMT
instead of local time use the L</gmtime> builtin. See also the
C<Time::Local> module (for converting seconds, minutes, hours, and such back to
the integer value returned by time()), and the L<POSIX> module's strftime(3)
and mktime(3) functions.

=end original

スカラ値はロケール依存 B<ではなく>、Perl の組み込みの値です。
ローカル時刻ではなく GMT がほしい場合は L</gmtime> 組み込み関数を
使ってください。
また、(秒、分、時などの形から、time() が返す値である
1970 年 1 月 1 日の真夜中からの秒数に変換する) C<Time::Local> モジュール
及び POSIX モジュールで提供される strftime(3) と mktime(3) 関数も
参照してください。

=begin original

To get somewhat similar but locale-dependent date strings, set up your
locale environment variables appropriately (please see L<perllocale>) and
try for example:

=end original

似たような、しかしロケール依存の日付文字列がほしい場合は、
ロケール環境変数を適切に設定して(L<perllocale> を参照してください)、
以下の例を試してください:

    use POSIX qw(strftime);
    $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    # or for GMT formatted appropriately for your locale:
    $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

=begin original

Note that the C<%a> and C<%b>, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.

=end original

曜日と月の短い表現である C<%a> と C<%b> は、3 文字とは限らないことに
注意してください。

=begin original

See L<perlport/localtime> for portability concerns.

=end original

移植性については L<perlport/localtime> を参照してください。

=begin original

The L<Time::gmtime> and L<Time::localtime> modules provide a convenient,
by-name access mechanism to the gmtime() and localtime() functions,
respectively.

=end original

L<Time::gmtime> モジュールと L<Time::localtime> モジュールは、それぞれ
gmtime() 関数と localtime() 関数に、名前でアクセスする機構を提供する
便利なモジュールです。

=begin original

For a comprehensive date and time representation look at the
L<DateTime> module on CPAN.

=end original

包括的な日付と時刻の表現については、CPAN の L<DateTime> モジュールを
参照してください。

=item lock THING
X<lock>

=begin original

This function places an advisory lock on a shared variable or referenced
object contained in I<THING> until the lock goes out of scope.

=end original

この関数は I<THING> が含む共有変数またはリファレンスされたオブジェクトに、
スコープから出るまでアドバイサリロックを掛けます．

=begin original

lock() is a "weak keyword" : this means that if you've defined a function
by this name (before any calls to it), that function will be called
instead.  If you are not under C<use threads::shared> this does nothing.
See L<threads::shared>.

=end original

lock() は「弱いキーワード」です: もしユーザーが(呼び出し前に)
この名前で関数を定義すると、定義された関数の方が呼び出されます。
C<use threads::shared> の影響下でない場合は、これは何もしません。
L<threads::shared> を参照してください。

=item log EXPR
X<log> X<logarithm> X<e> X<ln> X<base>

=item log

=begin original

Returns the natural logarithm (base I<e>) of EXPR.  If EXPR is omitted,
returns the log of C<$_>.  To get the
log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:

=end original

EXPR の (I<e> を底とする) 自然対数を返します。
EXPR が省略されると、C<$_> の対数を返します。
底の異なる対数を求めるためには、基礎代数を利用してください:
ある数の N を底とする対数は、その数の自然対数を N の自然対数で割ったものです。
例:

    sub log10 {
        my $n = shift;
        return log($n)/log(10);
    }

=begin original

See also L</exp> for the inverse operation.

=end original

逆操作については L</exp> を参照して下さい。

=item lstat EXPR
X<lstat>

=item lstat

=begin original

Does the same thing as the C<stat> function (including setting the
special C<_> filehandle) but stats a symbolic link instead of the file
the symbolic link points to.  If symbolic links are unimplemented on
your system, a normal C<stat> is done.  For much more detailed
information, please see the documentation for C<stat>.

=end original

(特別なファイルハンドルである C<_> の設定を含めて)
C<stat> 関数と同じことをしますが、シンボリックリンクが
指しているファイルではなく、シンボリックリンク自体の stat をとります。
シンボリックリンクがシステムに実装されていないと、通常の C<stat> が行なわれます。
さらにより詳細な情報については、L<stat> の文書を参照してください。

=begin original

If EXPR is omitted, stats C<$_>.

=end original

EXPR が省略されると、C<$_> の stat をとります。

=item m//

=begin original

The match operator.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

マッチ演算子です。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item map BLOCK LIST
X<map>

=item map EXPR,LIST

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
C<$_> to each element) and returns the list value composed of the
results of each such evaluation.  In scalar context, returns the
total number of elements so generated.  Evaluates BLOCK or EXPR in
list context, so each element of LIST may produce zero, one, or
more elements in the returned value.

=end original

LIST の個々の要素に対して、BLOCK か EXPR を評価し
(C<$_> は、ローカルに個々の要素が設定されます) 、
それぞれの評価結果からなるリスト値が返されます。
スカラコンテキストでは、生成された要素の数を返します。
BLOCK や EXPR をリストコンテキストで評価しますので、LIST の
個々の要素によって作られる、返り値であるリストの要素数は、
0 個の場合もあれば、複数の場合もあります。

    @chars = map(chr, @numbers);

=begin original

translates a list of numbers to the corresponding characters.

=end original

は、数のリストを対応する文字に変換します。

    my @squares = map { $_ * $_ } @numbers;

=begin original

translates a list of numbers to their squared values.

=end original

これは数値のリストを、その 2 乗に変換します。

    my @squares = map { $_ > 5 ? ($_ * $_) : () } @numbers;

=begin original

shows that number of returned elements can differ from the number of
input elements. To omit an element, return an empty list ().
This could also be achieved by writing

=end original

shows that number of returned elements can differ from the number of
input elements.
要素を省略すると、空リスト () を返します。
これは以下のように書くことでも達成できて

    my @squares = map { $_ * $_ } grep { $_ > 5 } @numbers;

=begin original

which makes the intention more clear.

=end original

この方が目的がよりはっきりします。

=begin original

Map always returns a list, which can be
assigned to a hash such that the elements
become key/value pairs. See L<perldata> for more details.

=end original

map は常にリストを返し、要素がキー/値の組になるようなハッシュに
代入できます。
さらなる詳細については L<perldata> を参照してください。

    %hash = map { get_a_key_for($_) => $_ } @array;

=begin original

is just a funny way to write

=end original

は以下のものをちょっと変わった書き方で書いたものです。

    %hash = ();
    foreach (@array) {
        $hash{get_a_key_for($_)} = $_;
    }

=begin original

Note that C<$_> is an alias to the list value, so it can be used to
modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Using a regular C<foreach> loop for this purpose would be clearer in
most cases.  See also L</grep> for an array composed of those items of
the original list for which the BLOCK or EXPR evaluates to true.

=end original

C<$_> は、LIST の値へのエイリアスですので、LIST の要素を
変更するために使うことができます。
これは、便利でサポートされていますが、
LIST の要素が変数でないと、おかしな結果になります。
この目的には通常の C<foreach> ループを使うことで、ほとんどの場合は
より明確になります。
BLOCK や EXPR が真になる元のリストの要素からなる配列については、
L</grep> も参照してください。

=begin original

If C<$_> is lexical in the scope where the C<map> appears (because it has
been declared with C<my $_>), then, in addition to being locally aliased to
the list elements, C<$_> keeps being lexical inside the block; that is, it
can't be seen from the outside, avoiding any potential side-effects.

=end original

(C<my $_> として宣言されることによって) C<$_> が C<map> が現れるスコープ内で
レキシカルな場合は、ローカルではリスト要素へのエイリアスであることに加えて、
C<$_> はブロック内でレキシカルでありつづけます; つまり、外側からは見えず、
起こりうる副作用を回避します。

=begin original

C<{> starts both hash references and blocks, so C<map { ...> could be either
the start of map BLOCK LIST or map EXPR, LIST. Because Perl doesn't look
ahead for the closing C<}> it has to take a guess at which it's dealing with
based on what it finds just after the C<{>. Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the C<}> and
encounters the missing (or unexpected) comma. The syntax error will be
reported close to the C<}>, but you'll need to change something near the C<{>
such as using a unary C<+> to give Perl some help:

=end original

C<{> はハッシュリファレンスとブロックの両方の開始文字なので、
C<map { ...> は map BLOCK LIST の場合と map EXPR, LIST の場合があります。
Perl は終了文字の C<}> を先読みしないので、C<{> の直後の文字を見て
どちらとして扱うかを推測します。
通常この推測は正しいですが、もし間違った場合は、C<}> まで読み込んで
カンマが足りない(または多い)ことがわかるまで、何かがおかしいことに
気付きません。
C<}> の近くで文法エラーが出ますが、Perl を助けるために単項の C<+> を
使うというように、C<{> の近くの何かを変更する必要があります。

    %hash = map {  "\L$_" => 1  } @array  # perl guesses EXPR.  wrong
    %hash = map { +"\L$_" => 1  } @array  # perl guesses BLOCK. right
    %hash = map { ("\L$_" => 1) } @array  # this also works
    %hash = map {  lc($_) => 1  } @array  # as does this.
    %hash = map +( lc($_) => 1 ), @array  # this is EXPR and works!

    %hash = map  ( lc($_), 1 ),   @array  # evaluates to (1, @array)

=begin original

or to force an anon hash constructor use C<+{>:

=end original

または C<+{> を使って無名ハッシュコンストラクタを強制します:

   @hashes = map +{ lc($_) => 1 }, @array # EXPR, so needs comma at end

=begin original

to get a list of anonymous hashes each with only one entry apiece.

=end original

こうするとそれぞれ 1 要素だけの無名ハッシュのリストを得られます。

=item mkdir FILENAME,MASK
X<mkdir> X<md> X<directory, create>

=item mkdir FILENAME

=item mkdir

=begin original

Creates the directory specified by FILENAME, with permissions
specified by MASK (as modified by C<umask>).  If it succeeds it
returns true; otherwise it returns false and sets C<$!> (errno).
MASK defaults to 0777 if omitted, and FILENAME defaults
to C<$_> if omitted.

=end original

FILENAME で指定したディレクトリを、MASK で指定した許可モード(を
C<umask> で修正したもの) で作成します。
成功時には真を返します; 失敗時には偽を返して C<$!> (errno) を設定します。
MASK を省略すると、0777 とみなし、
FILENAME を省略すると、C<$_> を使います。

=begin original

In general, it is better to create directories with a permissive MASK
and let the user modify that with their C<umask> than it is to supply
a restrictive MASK and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The perlfunc(1) entry on
C<umask> discusses the choice of MASK in more detail.

=end original

一般的に、制限された MASK を使ってユーザーがより寛容にする方法を
与えないより、寛容な MASK でディレクトリを作り、ユーザーが自身の C<umask> で
修正するようにした方がよいです。
例外は、(例えばメールファイルのような)プライベートに保つべきファイルや
ディレクトリを書く場合です。
perlfunc(1) の C<umask> で、MASK の選択に関して詳細に議論しています。

=begin original

Note that according to the POSIX 1003.1-1996 the FILENAME may have any
number of trailing slashes.  Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.

=end original

POSIX 1003.1-1996 によれば、FILENAME には末尾に任意の数のスラッシュを
つけることができます。
このようには動かない OS やファイルシステムもあるので、Perl はみんなが
幸せになれるように、自動的に末尾のスラッシュを削除します。

=begin original

To recursively create a directory structure, look at
the C<mkpath> function of the L<File::Path> module.

=end original

ディレクトリ構造を再帰的に作成するには、L<File::Path> モジュールの
C<makepath> 関数を参照してください。

=item msgctl ID,CMD,ARG
X<msgctl>

=begin original

Calls the System V IPC function msgctl(2).  You'll probably have to say

=end original

System V IPC 関数 msgctl を呼び出します。正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<msqid_ds>
structure.  Returns like C<ioctl>: the undefined value for error,
C<"0 but true"> for zero, or the actual return value otherwise.  See also
L<perlipc/"SysV IPC"> and the documentation for C<IPC::SysV> and
C<IPC::Semaphore>.

=end original

と宣言する必要があるでしょう。
CMD が C<IPC_STAT> であれば、ARG は返される C<msqid_ds> 構造体を
納める変数でなければなりません。
C<ioctl> と同じように、エラー時には未定義値、
ゼロのときは C<"0 but true">、それ以外なら、その値そのものを返します。
L<perlipc/"SysV IPC"> および、C<IPC::SysV>, C<IPC::Semaphore> の文書も
参照してください。

=item msgget KEY,FLAGS
X<msgget>

=begin original

Calls the System V IPC function msgget(2).  Returns the message queue
id, or C<undef> on error.  See also
L<perlipc/"SysV IPC"> and the documentation for C<IPC::SysV> and
C<IPC::Msg>.

=end original

System V IPC 関数 msgget を呼び出します。
メッセージキューの ID か、エラー時には C<undef> を返します。
L<perlipc/"SysV IPC"> よよび、C<IPC::SysV>, C<IPC::Msg> の文書も
参照してください。

=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X<msgrcv>

=begin original

Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.  Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.  This packing may be opened with C<unpack("l! a*")>.
Taints the variable.  Returns true if successful, false 
on error.  See also L<perlipc/"SysV IPC"> and the documentation for
C<IPC::SysV> and C<IPC::SysV::Msg>.

=end original

System V IPC 関数 msgrcv を呼び出し、メッセージキュー ID から、
変数 VAR に最大メッセージ長 SIZE のメッセージを受信します。
メッセージが受信された時、ネイティブな long 整数のメッセージタイプが
VAR の先頭となり、実際のメッセージが続きます。
このパッキングは C<unpack("l! a*")> で展開できます。
変数は汚染されます。
成功時には真を返し、エラー時には偽を返します。
L<perlipc/"SysV IPC"> および、C<IPC::SysV>, C<IPC::SysV::Msg> の文書も
参照してください。

=item msgsnd ID,MSG,FLAGS
X<msgsnd>

=begin original

Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.  MSG must begin with the native long integer message
type, be followed by the length of the actual message, and then finally
the message itself.  This kind of packing can be achieved with
C<pack("l! a*", $type, $message)>.  Returns true if successful,
false on error.  See also the C<IPC::SysV>
and C<IPC::SysV::Msg> documentation.

=end original

System V IPC 関数 msgsnd を呼び出し、メッセージキュー ID に
メッセージ MSG を送信します。
MSG の先頭は、ネイティブなlong 整数のメッセージタイプでなければならず、
メッセージの長さ、メッセージ本体と続きます。
これは、C<pack("l! a*", $type, $message)> として生成できます。
成功時には真を、エラー時には偽を返します。
C<IPC::SysV> と C<IPC::SysV::Msg> の文書も参照してください。

=item my EXPR
X<my>

=item my TYPE EXPR

=item my EXPR : ATTRS

=item my TYPE EXPR : ATTRS

=begin original

A C<my> declares the listed variables to be local (lexically) to the
enclosing block, file, or C<eval>.  If more than one value is listed,
the list must be placed in parentheses.

=end original

C<my> はリストアップされた変数を、囲っているブロック、ファイル、
C<eval> の中でローカルな (レキシカルな) ものにします。
複数の値を並べる場合には、括弧で括る必要があります。

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE is currently bound to the use of the C<fields> pragma,
and attributes are handled using the C<attributes> pragma, or starting
from Perl 5.8.0 also via the C<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details, and L<fields>,
L<attributes>, and L<Attribute::Handlers>.

=end original

TYPE と ATTRS の正確な文法とインターフェースは今でも進化しています。
現在のところ、TYPE は C<fields> プラグマの使用と結び付けられていて、
属性は C<attributes> プラグマか、Perl 5.8.0 からは
C<Attribute::Handlers> モジュールと結び付けられています。
詳しくはL<perlsub/"Private Variables via my()">, L<fields>,
L<attributes>, L<Attribute::Handlers> を参照してください。

=item next LABEL
X<next> X<continue>

=item next

=begin original

The C<next> command is like the C<continue> statement in C; it starts
the next iteration of the loop:

=end original

C<next> コマンドは、C での C<continue> 文のようなもので、
ループの次の繰り返しを開始します:

    LINE: while (<STDIN>) {
        next LINE if /^#/;  # discard comments
        #...
    }

=begin original

Note that if there were a C<continue> block on the above, it would get
executed even on discarded lines.  If LABEL is omitted, the command
refers to the innermost enclosing loop.

=end original

C<continue> ブロックが存在すれば、たとえ捨てられる行に
あっても、それが実行されます。
LABEL が省略されると、このコマンドはもっとも内側のループを参照します。

=begin original

C<next> cannot be used to exit a block which returns a value such as
C<eval {}>, C<sub {}>, or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<next> は C<eval {}>, C<sub {}>, C<do {}> のように値を返す
ブロックから抜けるのには使えません。
また、grep() や map() 操作から抜けるのに使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<next> will exit such a block early.

=end original

ブロック自身は一回だけ実行されるループと文法的に同一であることに
注意してください。
従って、C<next> はそのようなブロックから早く抜けるのに使えます。

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> がどのように働くかについては
L</continue> も参照して下さい。

=item no MODULE VERSION LIST
X<no declarations>
X<unimporting>

=item no MODULE VERSION

=item no MODULE LIST

=item no MODULE

=item no VERSION

=begin original

See the C<use> function, of which C<no> is the opposite.

=end original

L<use> 関数を参照してください。C<no> は、その逆を行なうものです。

=item oct EXPR
X<oct> X<octal> X<hex> X<hexadecimal> X<binary> X<bin>

=item oct

=begin original

Interprets EXPR as an octal string and returns the corresponding
value.  (If EXPR happens to start off with C<0x>, interprets it as a
hex string.  If EXPR starts off with C<0b>, it is interpreted as a
binary string.  Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in standard
Perl notation:

=end original

EXPR を 8 進数文字列と解釈して、対応する値を返します。
(EXPR が C<0x> で始まるときには、16 進数文字列と解釈します。
EXPR が C<0b>で始まるときは、2 進数文字列と解釈します。
どの場合でも、先頭の空白は無視されます。)
以下の例は、標準的な Perl の記法での
10 進数、2 進数、8 進数、16 進数を扱います:

    $val = oct($val) if $val =~ /^0/;

=begin original

If EXPR is omitted, uses C<$_>.   To go the other way (produce a number
in octal), use sprintf() or printf():

=end original

EXPR を省略すると、C<$_> を使用します。
(8 進数を扱う)その他の方法としては sprintf() または printf()があります。

    $dec_perms = (stat("filename"))[2] & 07777;
    $oct_perm_str = sprintf "%o", $perms;

=begin original

The oct() function is commonly used when a string such as C<644> needs
to be converted into a file mode, for example.  Although Perl 
automatically converts strings into numbers as needed, this automatic
conversion assumes base 10.

=end original

oct() 関数は例えば、 C<644> といった文字列をファイルモードに変換する時に
よく使います。
Perl は必要に応じて自動的に文字列を数値に変換しますが、
この自動変換は十進数を仮定します。

=begin original

Leading white space is ignored without warning, as too are any trailing 
non-digits, such as a decimal point (C<oct> only handles non-negative
integers, not negative integers or floating point).

=end original

先頭の空白や、末尾の(小数点のような)非数字は警告なしに無視されます
(C<oct> は非負整数のみを扱えます; 負の整数や小数は扱えません)。

=item open FILEHANDLE,EXPR
X<open> X<pipe> X<file, open> X<fopen>

=item open FILEHANDLE,MODE,EXPR

=item open FILEHANDLE,MODE,EXPR,LIST

=item open FILEHANDLE,MODE,REFERENCE

=item open FILEHANDLE

=begin original

Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.

=end original

EXPR で与えられたファイル名のファイルを開き、FILEHANDLE と結び付けます。

=begin original

Simple examples to open a file for reading:

=end original

読み込みのためにファイルを開くための簡単な例は以下のもので:

    open(my $fh, "<", "input.txt") 
	or die "cannot open < input.txt: $!";

=begin original

and for writing:

=end original

書き込み用は以下のものです:

    open(my $fh, ">", "output.txt") 
	or die "cannot open > output.txt: $!";

=begin original

(The following is a comprehensive reference to open(): for a gentler
introduction you may consider L<perlopentut>.)

=end original

(以下は総合的な open() のリファレンスです: より親切な説明については
L<perlopentut> を参照してください。)

=begin original

If FILEHANDLE is an undefined scalar variable (or array or hash element), a
new filehandle is autovivified, meaning that the variable is assigned a
reference to a newly allocated anonymous filehandle.  Otherwise if
FILEHANDLE is an expression, its value is the real filehandle.  (This is
considered a symbolic reference, so C<use strict "refs"> should I<not> be
in effect.)

=end original

FILEHANDLE が未定義のスカラ変数(または配列かハッシュの要素)の場合、
新しいファイルハンドルが自動有効化され、その変数は新しく割り当てられた
無名ファイルハンドルへのリファレンスが代入されます。
さもなければ、もし FILEHANDLE が式なら、その値を求めている実際の
ファイルハンドルの名前として使います。
(これはシンボリックリファレンスとして扱われるので、
C<use strict "refs"> の影響を I<受けません>。)

=begin original

If EXPR is omitted, the global (package) scalar variable of the same
name as the FILEHANDLE contains the filename.  (Note that lexical 
variables--those declared with C<my> or C<state>--will not work for this
purpose; so if you're using C<my> or C<state>, specify EXPR in your
call to open.)

=end original

EXPR が省略された場合、FILEHANDLE と同じ名前のグローバル(パッケージ)
スカラ変数にファイル名が入っています。
(レキシカル変数 -- C<my> や C<state> で宣言されたもの -- はこの用途には
使えないことに注意してください; 従って、C<my> や C<state> を使っている場合は、
open を呼び出すときに EXPR を指定してください。)

=begin original

If three (or more) arguments are specified, the open mode (including
optional encoding) in the second argument are distinct from the filename in
the third.  If MODE is C<< < >> or nothing, the file is opened for input.
If MODE is C<< > >>, the file is opened for output, with existing files
first being truncated ("clobbered") and nonexisting files newly created.
If MODE is C<<< >> >>>, the file is opened for appending, again being
created if necessary.

=end original

3 (またはそれ以上)の引数が指定された場合、2 番目の引数の(オプションの
エンコーディングを含む)開く時のモードは、3 番目のファイル名と分離されます。
MODE が C<< < >> か空の場合、ファイルは入力用に開かれます。
MODE が C<< > >> の場合、ファイルは出力用に開かれ、既にファイルが
ある場合は切り詰められ(上書きされ)、ない場合は新しく作られます。
MODE が C<<< >> >>> の場合、ファイルは追加用に開かれ、やはり必要なら
作成されます。

=begin original

You can put a C<+> in front of the C<< > >> or C<< < >> to
indicate that you want both read and write access to the file; thus
C<< +< >> is almost always preferred for read/write updates--the 
C<< +> >> mode would clobber the file first.  You cant usually use
either read-write mode for updating textfiles, since they have
variable-length records.  See the B<-i> switch in L<perlrun> for a
better approach.  The file is created with permissions of C<0666>
modified by the process's C<umask> value.

=end original

ファイルに読み込みアクセスと書き込みアクセスの両方をしたいことを示すために、
C<< > >> や C<< < >> の前に C<+> を付けることができます:
従って、C<< +< >> ほとんど常に 読み書き更新のために使われます --
C<< +> >> モードはまずファイルを上書きします。
普通はこれらの読み書きモードをテキストファイルの更新のためには使えません;
なぜなら可変長のレコードで構成されているからです。
よりよい手法については L<perlrun> の B<-i> オプションを参照してください。
ファイルは C<0666> をプロセスの C<umask> 値で修正したパーミッションで
作成されます。

=begin original

These various prefixes correspond to the fopen(3) modes of C<r>,
C<r+>, C<w>, C<w+>, C<a>, and C<a+>.

=end original

これらの様々な前置詞は fopen(3) の C<r>, C<r+>,
C<w>, C<w+>, C<a>, C<a+> のモードに対応します。

=begin original

In the one- and two-argument forms of the call, the mode and filename
should be concatenated (in that order), preferably separated by white
space.  You can--but shouldn't--omit the mode in these forms when that mode
is C<< < >>.  It is always safe to use the two-argument form of C<open> if
the filename argument is a known literal.

=end original

1 引数 と 2 引数の形式ではモードとファイル名は(この順番で)
結合されます(空白によって分割されているかもしれません)。
この形式で、モードが C<< '<' >> の場合はモードを省略できます (が、
するべきではありません)。

=begin original

For three or more arguments if MODE is C<|->, the filename is
interpreted as a command to which output is to be piped, and if MODE
is C<-|>, the filename is interpreted as a command that pipes
output to us.  In the two-argument (and one-argument) form, one should
replace dash (C<->) with the command.
See L<perlipc/"Using open() for IPC"> for more examples of this.
(You are not allowed to C<open> to a command that pipes both in I<and>
out, but see L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication with Another Process"> for
alternatives.)

=end original

3 引数以上の形式で
MODE が C<|-> の場合、ファイル名は出力がパイプされるコマンドとして
解釈され、MODE が C<-|> の場合、ファイル名は出力がこちらに
パイプされるコマンドとして解釈されます。
2 引数(と 1 引数) の形式ではハイフン(C<->)をコマンドの代わりに
使えます。
これに関するさらなる例については L<perlipc/"Using open() for IPC"> を
参照してください。
(C<open> を入出力 I<両用> にパイプすることは出来ませんが
代替案としては L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication with Another Process"> を
参照してください。)

=begin original

In the form of pipe opens taking three or more arguments, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.  The meaning of
C<open> with more than three arguments for non-pipe modes is not yet
defined, but experimental "layers" may give extra LIST arguments
meaning.

=end original

パイプでの三つ以上の引数の形式では、LIST (コマンド名の後の追加の引数) が
指定されると、プラットフォームが対応していれば、LIST は起動される
コマンドへの引数となります。
パイプモードではない C<open> での三つ以上の引数の意味はまだ未定義ですが、
実験的な「層」は追加の LIST 引数の意味を与えます。

=begin original

In the two-argument (and one-argument) form, opening C<< <- >> 
or C<-> opens STDIN and opening C<< >- >> opens STDOUT.

=end original

2 引数(と 1 引数)で C<< <- >> か C<-> を open すると STDIN が
オープンされ、C<< >- >> を open すると STDOUT がオープンされます。

=begin original

You may (and usually should) use the three-argument form of open to specify
I/O layers (sometimes referred to as "disciplines") to apply to the handle
that affect how the input and output are processed (see L<open> and
L<PerlIO> for more details). For example:

=end original

open の 3 引数形式では、どのように入出力が処理されるかに影響を与える
I/O 層(「ディシプリン」とも呼ばれます)を指定できます
(そして普通はそうするべきです)
(詳細については L<open> と L<PerlIO> を参照してください)。
例えば:

  open(my $fh, "<:encoding(UTF-8)", "filename")
    || die "can't open UTF-8 encoded filename: $!";

=begin original

opens the UTF8-encoded file containing Unicode characters;
see L<perluniintro>. Note that if layers are specified in the
three-argument form, then default layers stored in ${^OPEN} (see L<perlvar>;
usually set by the B<open> pragma or the switch B<-CioD>) are ignored.

=end original

は、Unicode 文字を含む UTF8 エンコードされたファイルを開きます;
L<perluniintro> を参照してください。
3 引数形式で層を指定すると、${^OPEN} (L<perlvar> を参照してください;
通常はC<open> プラグマか B<-CioD> オプションでセットされます)
に保存されたデフォルト層は無視されることに注意してください。

=begin original

Open returns nonzero on success, the undefined value otherwise.  If
the C<open> involved a pipe, the return value happens to be the pid of
the subprocess.

=end original

open は、成功時にはゼロ以外を返し、失敗時には未定義値を返します。
パイプに関る C<open> のときには、返り値はサブプロセスの pid となります。

=begin original

If you're running Perl on a system that distinguishes between text
files and binary files, then you should check out L</binmode> for tips
for dealing with this.  The key distinction between systems that need
C<binmode> and those that don't is their text file formats.  Systems
like Unix, Mac OS, and Plan 9, that end lines with a single
character and encode that character in C as C<"\n"> do not
need C<binmode>.  The rest need it.

=end original

テキストファイルとバイナリファイルを区別するシステムで Perl を実行している
場合、これを扱うための小技のために L</binmode> をチェックするべきです。
動作させているシステムで C<binmode> が必要か不要化を区別する鍵は、テキスト
ファイルの形式です。
Unix, Mac OS, Plan 9 といった、行の境界を 1 文字で表現し、それが C では
C<"\n"> でエンコードされる場合、C<binmode> は不要です。
それ以外では必要です。

=begin original

When opening a file, it's seldom a good idea to continue 
if the request failed, so C<open> is frequently used with
C<die>.  Even if C<die> won't do what you want (say, in a CGI script,
where you want to format a suitable error message (but there are
modules that can help with that problem)) always check
the return value from opening a file.  

=end original

ファイルを開く時、開くのに失敗した時に通常の処理を続けるのは
普通は悪い考えですので、C<open> はしばしば C<die> と結び付けられて
使われます。
望むものが C<die> でない場合(例えば、CGI スクリプト のように
きれいにフォーマットされたエラーメッセージを作りたい場合
(但しこの問題を助けるモジュールがあります))でも、
ファイルを開いた時の返り値を常にチェックするべきです。

=begin original

As a special case the three-argument form with a read/write mode and the third
argument being C<undef>:

=end original

特別な場合として、3 引数の形で読み書きモードで 3 番目の引数が
C<undef> の場合:

    open(my $tmp, "+>", undef) or die ...

=begin original

opens a filehandle to an anonymous temporary file.  Also using C<< +< >>
works for symmetry, but you really should consider writing something
to the temporary file first.  You will need to seek() to do the
reading.

=end original

無名一時ファイルとしてファイルハンドルを開きます。
また C<< +< >> も対称性のために動作しますが、
一時ファイルにはまず何かを書き込みたいはずです。
読み込みを行うためには seek() が必要です。

=begin original

Since v5.8.0, Perl has built using PerlIO by default.  Unless you've
changed this (such as building Perl with C<Configure -Uuseperlio>), you can
open filehandles directly to Perl scalars via:

=end original

v5.8.0 から、Perl はデフォルトで PerlIO を使ってビルドされています。
(C<Configure -Uuseperlio> して Perl をビルドするなどして)これを
変更していない限り、以下のようにして、Perl スカラを直接ファイルハンドルで
開くことができます:

    open($fh, ">", \$variable) || ..

=begin original

To (re)open C<STDOUT> or C<STDERR> as an in-memory file, close it first:

=end original

C<STDOUT> や C<STDERR> を「オンメモリの」ファイルとして
再び開きたい場合は、先にそれを閉じます:

    close STDOUT;
    open(STDOUT, ">", \$variable)
	or die "Can't open STDOUT: $!";

=begin original

General examples:

=end original

一般的な例:

    $ARTICLE = 100;
    open(ARTICLE) or die "Can't find article $ARTICLE: $!\n";
    while (<ARTICLE>) {...

    open(LOG, ">>/usr/spool/news/twitlog");  # (log is reserved)
    # if the open fails, output is discarded

    open(my $dbase, "+<", "dbase.mine")      # open for update
        or die "Can't open 'dbase.mine' for update: $!";

    open(my $dbase, "+<dbase.mine")          # ditto
        or die "Can't open 'dbase.mine' for update: $!";

    open(ARTICLE, "-|", "caesar <$article")  # decrypt article
        or die "Can't start caesar: $!";

    open(ARTICLE, "caesar <$article |")      # ditto
        or die "Can't start caesar: $!";

    open(EXTRACT, "|sort >Tmp$$")            # $$ is our process id
        or die "Can't start sort: $!";

    # in-memory files
    open(MEMORY, ">", \$var)
        or die "Can't open memory file: $!";
    print MEMORY "foo!\n";                   # output will appear in $var

    # process argument list of files along with any includes

    foreach $file (@ARGV) {
        process($file, "fh00");
    }

    sub process {
        my($filename, $input) = @_;
        $input++;    # this is a string increment
        unless (open($input, "<", $filename)) {
            print STDERR "Can't open $filename: $!\n";
            return;
        }

        local $_;
        while (<$input>) {    # note use of indirection
            if (/^#include "(.*)"/) {
                process($1, $input);
                next;
            }
            #...          # whatever
        }
    }

=begin original

See L<perliol> for detailed info on PerlIO.

=end original

PerlIO に関する詳しい情報については L<perliol> を参照してください。

=begin original

You may also, in the Bourne shell tradition, specify an EXPR beginning
with C<< >& >>, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as C<dup(2)>) and opened.  You may use C<&> after C<< > >>,
C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>, and C<< +< >>.
The mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents
of IO buffers.) If you use the three-argument form, then you can pass either a
number, the name of a filehandle, or the normal "reference to a glob".

=end original

Bourne シェルの慣例にしたがって、EXPR の先頭に C<< >& >>
を付けると、EXPR の残りの文字列をファイルハンドル名
(数字であれば、ファイル記述子) と解釈して、それを (C<dup(2)> によって)
複製してオープンします。
C<&> は、C<< > >>, C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>,
C<< +< >>というモード指定に付けることができます。
指定するモード指定は、もとのファイルハンドルのモードと
合っていないといけません。
(ファイルハンドルの複製は既に存在する IO バッファの内容に含めません。)
3 引数形式を使う場合は、数値を渡すか、ファイルハンドルの名前を渡すか、
通常の「グロブへのリファレンス」を渡します。

=begin original

Here is a script that saves, redirects, and restores C<STDOUT> and
C<STDERR> using various methods:

=end original

C<STDOUT> と C<STDERR> 保存し、リダイレクトし、元に戻すスクリプトを示します:

    #!/usr/bin/perl
    open(my $oldout, ">&STDOUT")     or die "Can't dup STDOUT: $!";
    open(OLDERR,     ">&", \*STDERR) or die "Can't dup STDERR: $!";

    open(STDOUT, '>', "foo.out") or die "Can't redirect STDOUT: $!";
    open(STDERR, ">&STDOUT")     or die "Can't dup STDOUT: $!";

    select STDERR; $| = 1;  # make unbuffered
    select STDOUT; $| = 1;  # make unbuffered

    print STDOUT "stdout 1\n";  # this works for
    print STDERR "stderr 1\n";  # subprocesses too

    open(STDOUT, ">&", $oldout) or die "Can't dup \$oldout: $!";
    open(STDERR, ">&OLDERR")    or die "Can't dup OLDERR: $!";

    print STDOUT "stdout 2\n";
    print STDERR "stderr 2\n";

=begin original

If you specify C<< '<&=X' >>, where C<X> is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's C<fdopen> of
that file descriptor (and not call C<dup(2)>); this is more
parsimonious of file descriptors.  For example:

=end original

C<X> をファイル記述子の番号かファイルハンドルとして、
C<< '<&=X' >> と指定すると、Perl はそのファイル記述子に対する
C の C<fdopen> と同じことを行ないます(そして C<dup(2)> は呼び出しません);
これはファイル記述子をより節約します。
例:

    # open for input, reusing the fileno of $fd
    open(FILEHANDLE, "<&=$fd")

=begin original

or

=end original

または

    open(FILEHANDLE, "<&=", $fd)

=begin original

or

=end original

または

    # open for append, using the fileno of OLDFH
    open(FH, ">>&=", OLDFH)

=begin original

or

=end original

または

    open(FH, ">>&=OLDFH")

=begin original

Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using flock().  If you do just
C<< open(A, ">>&B") >>, the filehandle A will not have the same file
descriptor as B, and therefore flock(A) will not flock(B) nor vice
versa.  But with C<< open(A, ">>&=B") >>, the filehandles will share
the same underlying system file descriptor.

=end original

ファイルハンドルを倹約することは、何かがファイル記述子に依存している場合、
例えば flock() を使ったファイルロックといった場合に有用です
(しかも倹約できます)。
C<< open(A, ">>&B") >> とすると、ファイルハンドル A は B と同じ
ファイル記述子にはならないので、flock(A) と flock(B) は別々になります。
しかし C<< open(A, ">>&=B") >> ではファイルハンドルは基礎となシステムの
同じファイル記述子を共有します。

=begin original

Note that under Perls older than 5.8.0, Perl uses the standard C library's'
fdopen() to implement the C<=> functionality.  On many Unix systems,
fdopen() fails when file descriptors exceed a certain value, typically 255.
For Perls 5.8.0 and later, PerlIO is (most often) the default.

=end original

5.8.0 より前の Perl の場合、C<=> 機能の実装は
標準 C ライブラリの fdopen() を使っています。
多くの Unix システムでは、fdopen() はファイル記述子がある値
(典型的には 255)を超えた場合に失敗することが知られています。
5.8.0 以降の Perl では、(ほとんどの場合) PerlIO がデフォルトです。

=begin original

You can see whether your Perl was built with PerlIO by running C<perl -V>
and looking for the C<useperlio=> line.  If C<useperlio> is C<define>, you
have PerlIO; otherwise you don't.

=end original

Perl が PerlIO つきでビルドされているかどうかを確認するには、
C<perl -V> として C<useperlio=> の行を見ます。
C<useperlio> が C<define> なら PerlIO を使っています;
そうでなければ使っていません。

=begin original

If you open a pipe on the command C<-> (that is, specify either C<|-> or C<-|>
with the one- or two-argument forms of C<open>), 
an implicit C<fork> is done, so C<open> returns twice: in the parent
process it returns the pid
of the child process, and in the child process it returns (a defined) C<0>.
Use C<defined($pid)> or C<//> to determine whether the open was successful.

=end original

1 引数 または 2 引数の形の C<open()> で (C<-|> や C<|-> というふうに)
C<-> というコマンドにパイプを開くと、暗黙の C<fork> が行なわれるので、
C<open> は 2 回返ります;
親プロセスには子プロセスの pid が返され、子プロセスには (定義された) C<0> が
返されます。
open が成功したかどうかを調べるには、C<defined($pid)> または C<//> を
使います。

=begin original

For example, use either

=end original

例えば、これか

    $child_pid = open(FROM_KID, "|-") 	// die "can't fork: $!";

=begin original

or

=end original

これを使い、

    $child_pid = open(TO_KID,   "|-") 	// die "can't fork: $!";

=begin original

followed by 

=end original

後で以下のようにします。

    if ($child_pid) {
	# am the parent:
	# either write TO_KID or else read FROM_KID
	...
	wait $child_pid;
    } else {
	# am the child; use STDIN/STDOUT normally
	...
	exit;
    } 

=begin original

The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.

=end original

親プロセスでは、このファイルハンドルは
通常通りに動作しますが、行なわれる入出力は、
チャイルドプロセスの STDIN/STDOUT にパイプされます。
チャイルドプロセス側では、そのファイルハンドルは
オープンされず、入出力は新しい STDOUT か STDIN に対して行なわれます。
これは、setuid で実行して、シェルコマンドのメタ文字を
検索させたくないような場合に、パイプコマンドの起動の仕方を
制御したいとき、普通のパイプの open と同じように使います。

=begin original

The following blocks are more or less equivalent:

=end original

以下の組み合わせは、だいたい同じものです:

    open(FOO, "|tr '[a-z]' '[A-Z]'");
    open(FOO, "|-", "tr '[a-z]' '[A-Z]'");
    open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';
    open(FOO, "|-", "tr", '[a-z]', '[A-Z]');

    open(FOO, "cat -n '$file'|");
    open(FOO, "-|", "cat -n '$file'");
    open(FOO, "-|") || exec "cat", "-n", $file;
    open(FOO, "-|", "cat", "-n", $file);

=begin original

The last two examples in each block show the pipe as "list form", which is
not yet supported on all platforms.  A good rule of thumb is that if
your platform has a real C<fork()> (in other words, if your platform is
Unix, including Linux and MacOS X), you can use the list form.  You would 
want to use the list form of the pipe so you can pass literal arguments
to the command without risk of the shell interpreting any shell metacharacters
in them.  However, this also bars you from opening pipes to commands
that intentionally contain shell metacharacters, such as:

=end original

それぞれのブロックの末尾二つの例ではパイプを「リスト形式」にしていますが、
これはまだ全てのプラットフォームで対応しているわけではなりません。
よい経験則としては、もし実行しているプラットフォームで本当の C<fork()> が
あれば(言い換えると、プラットフォームが Linux や MacOS X を含む Unix なら)
リスト形式が使えます。
パイプのリスト形式を使うことで、コマンドへのリテラルな引数を、
シェルのメタ文字をシェルが解釈するリスクなしに渡すことができます。
しかし、これは以下のように意図的にシェルメタ文字を含むコマンドをパイプとして
開くことを妨げます:

    open(FOO, "|cat -n | expand -4 | lpr")
	// die "Can't open pipeline to lpr: $!";

=begin original

See L<perlipc/"Safe Pipe Opens"> for more examples of this.

=end original

これに関する更なる例については L<perlipc/"Safe Pipe Opens"> を参照して下さい。

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method
of C<IO::Handle> on any open handles.

=end original

v5.6.0 から、Perl は書き込み用に開いている全てのファイルに対して
fork を行う前にフラッシュしようとしますが、これに対応していない
プラットフォームもあります(L<perlport> を参照してください)。
安全のために、C<$|> (English モジュールでは $AUTOFLUSH) をセットするか、
全ての開いているハンドルに対して C<IO::Handle> の C<autoflush()> メソッドを
呼び出すようにしてください。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of C<$^F>.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは C<$^F> の値で決定される、新しくオープンされたファイル記述子に対して
セットされます。
L<perlvar/$^F> を参照してください。

=begin original

Closing any piped filehandle causes the parent process to wait for the
child to finish, then returns the status value in C<$?> and
C<${^CHILD_ERROR_NATIVE}>.

=end original

パイプのファイルハンドルを close することで、
親プロセスは、チャイルドプロセスの終了を待ち、それから C<$?> と
C<${^CHILD_ERROR_NATIVE}> にステータス値を返します。

=begin original

The filename passed to the one- and two-argument forms of open() will
have leading and trailing whitespace deleted and normal
redirection characters honored.  This property, known as "magic open",
can often be used to good effect.  A user could specify a filename of
F<"rsh cat file |">, or you could change certain filenames as needed:

=end original

1 引数 と 2 引数の形の open() に渡されたファイル名は、
はじめと終わりの空白が取り除かれ、
通常のリダイレクト文字列を受け付けます。
この機能は "magic open" として知られていますが、
普通いい効果をもたらします。
ユーザーは F<"rsh cat file |"> といったファイル名を指定できますし、
特定のファイル名を必要に応じて変更できます。

    $filename =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
    open(FH, $filename) or die "Can't open $filename: $!";

=begin original

Use the three-argument form to open a file with arbitrary weird characters in it,

=end original

妙な文字が含まれているようなファイル名をオープンするには、
3 引数の形を使います。

    open(FOO, "<", $file)
	|| die "can't open < $file: $!";

=begin original

otherwise it's necessary to protect any leading and trailing whitespace:

=end original

あるいは、次のようにして、最初と最後の空白を保護します:

    $file =~ s#^(\s)#./$1#;
    open(FOO, "< $file\0")
	|| die "open failed: $!";

=begin original

(this may not work on some bizarre filesystems).  One should
conscientiously choose between the I<magic> and I<three-argument> form
of open():

=end original

(これは奇妙なファイルシステムでは動作しないかもしれません)。
open() の I<magic> と I<3 引数> 形式を誠実に選択するべきです。

    open(IN, $ARGV[0]) || die "can't open $ARGV[0]: $!";

=begin original

will allow the user to specify an argument of the form C<"rsh cat file |">,
but will not work on a filename that happens to have a trailing space, while

=end original

とするとユーザーは C<"rsh cat file |"> という形の引数を指定できますが、
末尾にスペースがついてしまったファイル名では動作しません。一方:

    open(IN, "<", $ARGV[0])
	|| die "can't open < $ARGV[0]: $!";

=begin original

will have exactly the opposite restrictions.

=end original

はまったく逆の制限があります。

=begin original

If you want a "real" C C<open> (see C<open(2)> on your system), then you
should use the C<sysopen> function, which involves no such magic (but may
use subtly different filemodes than Perl open(), which is mapped to C
fopen()).  This is another way to protect your filenames from
interpretation.  For example:

=end original

もし「本当の」C 言語の C<open> (システムの C<open(2)> を参照してください)が
必要なら、このような副作用のない C<sysopen> 関数を使うべきです
(ただし、C の fopen() に割り付けられる Perl の open() とは
かすかに違うファイルモードを持ちます)。
これはファイル名を解釈から守るもう一つの方法です。
例えば:

    use IO::Handle;
    sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
        or die "sysopen $path: $!";
    $oldfh = select(HANDLE); $| = 1; select($oldfh);
    print HANDLE "stuff $$\n";
    seek(HANDLE, 0, 0);
    print "File contains: ", <HANDLE>;

=begin original

Using the constructor from the C<IO::Handle> package (or one of its
subclasses, such as C<IO::File> or C<IO::Socket>), you can generate anonymous
filehandles that have the scope of the variables used to hold them, then
automatically (but silently) close once their reference counts become
zero, typically at scope exit:

=end original

C<IO::Handle> パッケージ(または C<IO::File> や C<IO::Socket> といった
サブパッケージ)のコンストラクタを使うことで、
これらへのリファレンスを保持している変数のスコープを持ち、それから
参照カウントが 0 になると自動的に (しかし暗黙に) 閉じる
無名ファイルハンドルを作成できます:

    use IO::File;
    #...
    sub read_myfile_munged {
        my $ALL = shift;
	# or just leave it undef to autoviv
        my $handle = IO::File->new;
        open($handle, "<", "myfile") or die "myfile: $!";
        $first = <$handle>
            or return ();     # Automatically closed here.
        mung($first) or die "mung failed";  # Or here.
        return (first, <$handle>) if $ALL;  # Or here.
        return $first;                      # Or here.
    }

=begin original

B<WARNING:> The previous example has a bug because the automatic
close that happens when the refcount on C<handle> does not
properly detect and report failures.  I<Always> close the handle
yourself and inspect the return value.

=end original

B<警告:> 自動的に閉じると、C<handle> の参照カウントが適切に検出できない
ときに失敗が報告されるのでバグがあります。
I<常に> ハンドルを自分自身で閉じて、返り値を調べてください。

    close($handle) 
	|| warn "close failed: $!";

=begin original

See L</seek> for some details about mixing reading and writing.

=end original

読み書きを混ぜる場合の詳細については L</seek> を参照して下さい。

=item opendir DIRHANDLE,EXPR
X<opendir>

=begin original

Opens a directory named EXPR for processing by C<readdir>, C<telldir>,
C<seekdir>, C<rewinddir>, and C<closedir>.  Returns true if successful.
DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.  If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle; that is, it's autovivified.
DIRHANDLEs have their own namespace separate from FILEHANDLEs.

=end original

C<readdir>、C<telldir>、C<seekdir>、C<rewinddir>、C<closedir> で
処理するために、EXPR で指定された名前のディレクトリをオープンします。
成功時には真を返します。
DIRHANDLE は間接ディレクトリハンドルとして使える値(普通は実際のディレクトリ
ハンドルの名前)となる式でも構いません。
DIRHANDLE が未定義のスカラ値(または配列かハッシュの要素)の場合、その変数は
新しい無名ディレクトリハンドルへのリファレンスが代入されます; つまり、
自動有効化されます。
DIRHANDLE は、FILEHANDLE とは別に名前空間を持っています。

=begin original

See the example at C<readdir>.

=end original

C<readdir> の例を参照してください。

=item ord EXPR
X<ord> X<encoding>

=item ord

=begin original

Returns the numeric (the native 8-bit encoding, like ASCII or EBCDIC,
or Unicode) value of the first character of EXPR.  
If EXPR is an empty string, returns 0.  If EXPR is omitted, uses C<$_>.
(Note I<character>, not byte.)

=end original

EXPR の最初の文字の数値としての(ASCII, EBCDIC, Unicode のような 8-bit
ネイティブエンコーディングの)値を返します。
EXPR が空文字列の場合は、0 を返します。
EXPR を省略した場合は、C<$_> を使用します。
(バイトではなく I<文字> であることに注意してください。)

=begin original

For the reverse, see L</chr>.
See L<perlunicode> for more about Unicode.

=end original

逆のことをするには L</chr> を参照してください。
Unicode については L<perlunicode> を参照してください。

=item our EXPR
X<our> X<global>

=item our TYPE EXPR

=item our EXPR : ATTRS

=item our TYPE EXPR : ATTRS

=begin original

C<our> associates a simple name with a package variable in the current
package for use within the current scope.  When C<use strict 'vars'> is in
effect, C<our> lets you use declared global variables without qualifying
them with package names, within the lexical scope of the C<our> declaration.
In this way C<our> differs from C<use vars>, which is package-scoped.

=end original

C<our> は単純名を、現在のスコープ内で使うために、現在のパッケージの
パッケージ変数と結び付けます。
C<use strict 'vars'> が有効の場合は、C<our> を使うことで、C<our> 宣言の
レキシカルスコープ内で、宣言されたグローバル変数をパッケージ名で
修飾することなく使うことができます。
この意味では、C<use vars> はパッケージスコープなので、C<our> とは異なります。

=begin original

Unlike C<my> or C<state>, which allocates storage for a variable and
associates a simple name with that storage for use within the current
scope, C<our> associates a simple name with a package (read: global)
variable in the current package, for use within the current lexical scope.
In other words, C<our> has the same scoping rules as C<my> or C<state>, but
does not necessarily create a variable.

=end original

記憶領域を変数に割り当て、単純名を現在のスコープ内で使うためにその記憶領域に
割り当てる C<my> や C<state> と違って、C<our> は単純名を、現在のレキシカル
スコープ内で使うために、現在のパッケージの(読み込み: グローバル) パッケージ
変数と結び付けます。
言い換えると、C<our> は C<my> や C<state> と同じスコープルールを持ちますが、
変数を作る必要はありません。

=begin original

If more than one value is listed, the list must be placed
in parentheses.

=end original

二つ以上の値をリストする場合は、リストはかっこでくくる必要があります。

    our $foo;
    our($bar, $baz);

=begin original

An C<our> declaration declares a global variable that will be visible
across its entire lexical scope, even across package boundaries.  The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.  This means the following
behavior holds:

=end original

C<our> 宣言はレキシカルスコープ全体に対して(たとえパッケージ境界を
越えていても)見えるグローバル変数を宣言します。
この変数が入るパッケージは宣言した時点で定義され、
使用した時点ではありません。
これにより、以下のような振る舞いになります:

    package Foo;
    our $bar;      # declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    print $bar;    # prints 20, as it refers to $Foo::bar

=begin original

Multiple C<our> declarations with the same name in the same lexical
scope are allowed if they are in different packages.  If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple C<my> declarations.  Unlike a second
C<my> declaration, which will bind the name to a fresh variable, a
second C<our> declaration in the same package, in the same scope, is
merely redundant.

=end original

同じレキシカルスコープでも、パッケージが異なっていれば、同じ名前で複数の
C<our> 宣言ができます。
同じパッケージになっていると、警告が出力されるようになっていれば
複数の C<my> 宣言がある場合と同じように警告が出力されます。
新しい変数を名前に割り当てることになる 2 回目の C<my> 宣言と違って、
同じパッケージの同じスコープで 2 回 C<our> 宣言するのは単に冗長です。

    use warnings;
    package Foo;
    our $bar;      # declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    our $bar = 30; # declares $Bar::bar for rest of lexical scope
    print $bar;    # prints 30

    our $bar;      # emits warning but has no other effect
    print $bar;    # still prints 30

=begin original

An C<our> declaration may also have a list of attributes associated
with it.

=end original

C<our> 宣言には、それと結び付けられる属性のリストを持つこともあります。

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE is currently bound to the use of C<fields> pragma,
and attributes are handled using the C<attributes> pragma, or starting
from Perl 5.8.0 also via the C<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details, and L<fields>,
L<attributes>, and L<Attribute::Handlers>.

=end original

TYPE と ATTRS の正確な文法とインターフェースは今でも進化しています。
現在のところ、TYPE は C<fields> プラグマの使用と結び付けられていて、
属性は C<attributes> プラグマか、Perl 5.8.0 からは
C<Attribute::Handlers> モジュールと結び付けられています。
詳しくはL<perlsub/"Private Variables via my()">, L<fields>,
L<attributes>, L<Attribute::Handlers> を参照してください。

=item pack TEMPLATE,LIST
X<pack>

=begin original

Takes a LIST of values and converts it into a string using the rules
given by the TEMPLATE.  The resulting string is the concatenation of
the converted values.  Typically, each converted value looks
like its machine-level representation.  For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a string that's 4 characters long. 

=end original

LIST の値を TEMPLATE で与えられたルールを用いて文字列に変換します。
結果の文字列は変換した値を連結したものです。
典型的には、それぞれの変換された値はマシンレベルの表現のように見えます。
例えば、32-bit マシンでは、整数は 4 バイトで表現されるので、
Perl では 4 文字の文字列で表現されます。

=begin original

See L<perlpacktut> for an introduction to this function.

=end original

この関数の説明については L<perlpacktut> を参照してください。

=begin original

The TEMPLATE is a sequence of characters that give the order and type
of values, as follows:

=end original

TEMPLATE は、以下のような値の型と順番を指定する文字を並べたものです:

=begin original

    a  A string with arbitrary binary data, will be null padded.
    A  A text (ASCII) string, will be space padded.
    Z  A null-terminated (ASCIZ) string, will be null padded.

=end original

    a   任意のバイナリデータを含む文字列、ヌル文字で埋める
    A   テキスト (ASCII) 文字列、スペース文字で埋める
    Z	ヌル文字終端 (ASCIZ) 文字列、ヌル文字で埋める

=begin original

    b  A bit string (ascending bit order inside each byte, like vec()).
    B  A bit string (descending bit order inside each byte).
    h  A hex string (low nybble first).
    H  A hex string (high nybble first).

=end original

    b   ビット列 (バイトごとに昇ビット順、vec() と同じ)
    B   ビット列 (バイトごとに降ビット順)
    h   16 進数文字列 (低位ニブルが先)
    H   16 進数文字列 (高位ニブルが先)

=begin original

    c  A signed char (8-bit) value.
    C  An unsigned char (octet) value.
    W  An unsigned char value (can be greater than 255).

=end original

    c   signed char (8 ビット) 値
    C   unsigned char (オクテット) 値
    W   unsigned char 値 (255 より大きいかもしれません)

=begin original

    s  A signed short (16-bit) value.
    S  An unsigned short value.

=end original

    s   signed short (16 ビット) 値
    S   unsigned short 値

=begin original

    l  A signed long (32-bit) value.
    L  An unsigned long value.

=end original

    l   signed long (32 ビット) 値
    L   unsigned long 値

=begin original

    q  A signed quad (64-bit) value.
    Q  An unsigned quad value.
      (Quads are available only if your system supports 64-bit
       integer values _and_ if Perl has been compiled to support those.
           Raises an exception otherwise.)

=end original

    q  符号付き 64 ビット整数
    Q  符号なし 64 ビット整数
      (64 ビット整数は、システムが 64 ビット整数に対応していて、かつ Perl が
       64 ビット整数対応としてコンパイルされている場合にのみ使用可能です。
           それ以外の場合は例外が発生します。)

=begin original

    i  A signed integer value.
    I  A unsigned integer value.
      (This 'integer' is _at_least_ 32 bits wide.  Its exact
           size depends on what a local C compiler calls 'int'.)

=end original

    i  signed int 値
    I  unsigned int 値
      (ここでの 'integer' は 「最低」 32 bits 幅です。
           正確なサイズはローカルの C コンパイラの
           'int'のサイズに依存します)

=begin original

    n  An unsigned short (16-bit) in "network" (big-endian) order.
    N  An unsigned long (32-bit) in "network" (big-endian) order.
    v  An unsigned short (16-bit) in "VAX" (little-endian) order.
    V  An unsigned long (32-bit) in "VAX" (little-endian) order.

=end original

    n  "network" 順序 (ビッグエンディアン) の unsigned short (16 ビット)
    N  "network" 順序 (ビッグエンディアン) の unsigned long (32 ビット)
    v  "VAX" 順序 (リトルエンディアン) の unsigned short (16 ビット)
    V  "VAX" 順序 (リトルエンディアン) の unsigned long (32 ビット)

=begin original

    j   A Perl internal signed integer value (IV).
    J   A Perl internal unsigned integer value (UV).

=end original

    j   Perl 内部符号付き整数 (IV)
    J   Perl 内部符号なし整数 (UV)

=begin original

    f  A single-precision float in native format.
    d  A double-precision float in native format.

=end original

    f  機種依存の単精度浮動小数点数
    d  機種依存の倍精度浮動小数点数

=begin original

    F  A Perl internal floating-point value (NV) in native format
    D  A float of long-double precision in native format.
      (Long doubles are available only if your system supports long
       double values _and_ if Perl has been compiled to support those.
           Raises an exception otherwise.)

=end original

    F  ネイティブフォーマットの Perl 内部浮動小数点数 (NV)
    D  ネイティブフォーマットの長い倍精度浮動小数点数(long double)
      (long double は、システムが long double に対応していて、かつ Perl が
       long double 対応としてコンパイルされている場合にのみ使用可能です。
           それ以外の場合は例外が発生します。)

=begin original

    p  A pointer to a null-terminated string.
    P  A pointer to a structure (fixed-length string).

=end original

    p  ヌル文字で終端する文字列へのポインタ
    P  構造体 (固定長文字列) へのポインタ

=begin original

    u  A uuencoded string.
    U  A Unicode character number.  Encodes to a character in character mode
        and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in byte mode.

=end original

    u  uuencode 文字列
    U  Unicode 文字番号。文字モードでは文字に、バイトモードなら UTF-8 に
      (EBCDIC システムでは UTF-EBCDIC に)エンコードされます

=begin original

    w  A BER compressed integer (not an ASN.1 BER, see perlpacktut for
       details).  Its bytes represent an unsigned integer in base 128,
       most significant digit first, with as few digits as possible.  Bit
       eight (the high bit) is set on each byte except the last.

=end original

    w  A BER 圧縮変数(ASN.1 BER ではありません。詳細については perlpacktut を
       参照してください)。このバイト列はできるだけ少ない桁数で表現された
       128 を基とした符号なし整数で、最上位ビットから順に並びます。
       最後のバイト以外の各バイトのビット 8 (上位ビット) がセットされます。

=begin original

    x  A null byte (a.k.a ASCII NUL, "\000", chr(0))
    X  Back up a byte.
    @  Null-fill or truncate to absolute position, counted from the
       start of the innermost ()-group.
    .  Null-fill or truncate to absolute position specified by the value.
    (  Start of a ()-group.

=end original

    x  ヌル文字 (つまり ASCII NUL, "\000", chr(0))
    X  1 文字後退
    @  一番内側の () の組の開始位置から数えて、絶対位置までヌル文字で
       埋めるか切り詰める
    .  値で指定した絶対位置までヌル文字で埋めるか切り詰める
    (  () の組の開始

=begin original

One or more modifiers below may optionally follow certain letters in the
TEMPLATE (the second column lists letters for which the modifier is valid):

=end original

以下に示す一つまたは複数の修飾子を、TEMPLATE の文字のいくつかにオプションで
付けることができます(表の 2 列目は、その修飾子が有効な文字です):

=begin original

    !   sSlLiI     Forces native (short, long, int) sizes instead
                   of fixed (16-/32-bit) sizes.

=end original

    !   sSlLiI     固定の(16/32 ビット)サイズではなく、ネイティブな
                   (short, long, int)サイズを強制する。

=begin original

        xX         Make x and X act as alignment commands.

=end original

        xX         x と X をアライメントコマンドとして振舞わせる。

=begin original

        nNvV       Treat integers as signed instead of unsigned.

=end original

        nNvV       整数を符号なしではなく符号付きとして扱わせる。

=begin original

        @.         Specify position as byte offset in the internal
                   representation of the packed string. Efficient but
                   dangerous.

=end original

        @.         pack された内部表現のバイトオフセットとして位置を指定する。
                   効率的ですが危険です。

=begin original

    >   sSiIlLqQ   Force big-endian byte-order on the type.
        jJfFdDpP   (The "big end" touches the construct.)

=end original

    >   sSiIlLqQ   これらの型のバイト順をビッグエンディアンに強制します
        jJfFdDpP   (「大きい端」が構造に触れています)

=begin original

    <   sSiIlLqQ   Force little-endian byte-order on the type.
        jJfFdDpP   (The "little end" touches the construct.)

=end original

    <   sSiIlLqQ   これらの型のバイト順をリトルエンディアンに強制します
        jJfFdDpP   (「小さい端」が構造に触れています)

=begin original

The C<< > >> and C<< < >> modifiers can also be used on C<()> groups 
to force a particular byte-order on all components in that group, 
including all its subgroups.

=end original

C<< > >> と C<< < >> の修飾子は C<()>-グループでも使えます;
この場合はそのグループと全ての副グループ内の全ての要素を特定のバイト順に
強制します。

=begin original

The following rules apply:

=end original

以下の条件が適用されます:

=over 

=item *

=begin original

Each letter may optionally be followed by a number indicating the repeat
count.  A numeric repeat count may optionally be enclosed in brackets, as
in C<pack("C[80]", @arr)>.  The repeat count gobbles that many values from
the LIST when used with all format types other than C<a>, C<A>, C<Z>, C<b>,
C<B>, C<h>, C<H>, C<@>, C<.>, C<x>, C<X>, and C<P>, where it means
something else, dscribed below.  Supplying a C<*> for the repeat count
instead of a number means to use however many items are left, except for:

=end original

これらの文字の後には、繰り返し数を示す数字を付けることができます。
数値の繰り返し数は C<pack "C[80]", @arr> のように大かっこで
囲むこともできます。
C<a>, C<A>, C<Z>, C<b>, C<B>, C<h>, C<H>, C<@>, C<.>, C<x>, C<X>, C<P>
以外の全ての型では、LIST から繰り返し数の値を取り出して使います。
繰り返し数に C<*> を指定すると、以下の例外を除いて、
その時点で残っているすべての要素を意味します。



=over 

=item * 

=begin original

C<@>, C<x>, and C<X>, where it is equivalent to C<0>.

=end original

C<@>, C<x>, C<X> では C<0> と等価です。

=item * 

=begin original

<.>, where it means relative to the start of the string.

=end original

C<.> では文字列の先頭からの相対位置を意味します。

=item * 

=begin original

C<u>, where it is equivalent to 1 (or 45, which here is equivalent).

=end original

C<u> では 1 (あるいはここでは 45 でも等価です) と等価です。

=back 

=begin original

One can replace a numeric repeat count with a template letter enclosed in
brackets to use the packed byte length of the bracketed template for the
repeat count.

=end original

このテンプレートでパックされたバイト長を繰り返し数として使うために、
大かっこで囲まれたテンプレートで数値の繰り返し数を置き換えることが
できます。

=begin original

For example, the template C<x[L]> skips as many bytes as in a packed long,
and the template C<"$t X[$t] $t"> unpacks twice whatever $t (when
variable-expanded) unpacks.  If the template in brackets contains alignment
commands (such as C<x![d]>), its packed length is calculated as if the
start of the template had the maximal possible alignment.

=end original

例えば、テンプレート C<x[L]> は long でパックされたバイト数分だけスキップし、
テンプレート C<"$t X[$t] $t"> は $t (変数展開された場合)を
unpack したものの 2 倍を unpack します。
(C<x![d]> のように) 大かっこにアライメントコマンドが含まれている場合、
パックされた長さは、テンプレートの先頭で最大限可能なアライメントを
持っているものとして計算されます。

=begin original

When used with C<Z>, a C<*> as the repeat count is guaranteed to add a
trailing null byte, so the resulting string is always one byte longer than
the byte length of the item itself.

=end original

C<Z> で、繰り返し数として C<*> が使われた場合、末尾にヌルバイトが
保証されるので、パックされた結果は常に要素の C<length> の値より
1 大きくなります。

=begin original

When used with C<@>, the repeat count represents an offset from the start
of the innermost C<()> group.

=end original

C<@> で使うと、繰り返し数は一番内側の C<()> グループの先頭からのオフセットを
表現します。

=begin original

When used with C<.>, the repeat count determines the starting position to
calculate the value offset as follows:

=end original

C<.> で使われると、繰り返し数は以下のようにして、
値のオフセットを計算するための開始位置を決定するために使われます。

=over 

=item *

=begin original

If the repeat count is C<0>, it's relative to the current position.

=end original

繰り返し数が C<0> なら、現在位置からの相対位置となります。

=item *

=begin original

If the repeat count is C<*>, the offset is relative to the start of the
packed string.

=end original

繰り返し数が C<*> なら、オフセットは pack された文字列の先頭からの相対位置です。

=item *

=begin original

And if it's an integer I<n>, the offset is relative to the start of the
I<n>th innermost C<( )> group, or to the start of the string if I<n> is
bigger then the group level.

=end original

そして整数 I<n> なら、オフセットは一番内側から I<n> 番目の C<( )> グループの
先頭、あるいは I<n> がグループレベルより大きい場合は文字列の先頭からの
相対位置です。

=back

=begin original

The repeat count for C<u> is interpreted as the maximal number of bytes
to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat 
count should not be more than 65.

=end original

C<u> での繰り返し回数は、出力行毎に最大何バイトまでをエンコードするかを
示します。0, 1, 2 は 45 として扱われます。
繰り返し数は 65 を超えてはなりません。

=item *

=begin original

The C<a>, C<A>, and C<Z> types gobble just one value, but pack it as a
string of length count, padding with nulls or spaces as needed.  When
unpacking, C<A> strips trailing whitespace and nulls, C<Z> strips everything
after the first null, and C<a> returns data with no stripping at all.

=end original

C<a>, C<A>, C<Z> という型を使うと、値を一つだけ取り出して使いますが、
繰り返し数で示す長さの文字列となるように、必要に応じてヌル文字か
スペース文字を付け足します。
unpack するとき、C<A> は後続の空白やヌル文字を取り除きます。
C<Z> は最初のヌル文字以降の全てを取り除きます。
C<a> はデータを取り除くことなくそのまま返します。

=begin original

If the value to pack is too long, the result is truncated.  If it's too
long and an explicit count is provided, C<Z> packs only C<$count-1> bytes,
followed by a null byte.  Thus C<Z> always packs a trailing null, except
when the count is 0.

=end original

pack する値が長すぎる場合、結果は切り詰められます。
長すぎてかつ明示的に個数が指定されている場合、
C<Z> は C<$count-1> バイトまで pack し、その後にヌルバイトがつきます。
従って、C<Z> は、繰り返し数が 0 の場合を除いて、常に末尾にヌルバイトが
つきます。

=item *

=begin original

Likewise, the C<b> and C<B> formats pack a string that's that many bits long.
Each such format generates 1 bit of the result.  These are typically followed
by a repeat count like C<B8> or C<B64>.

=end original

同様に、C<b> や C<B> は、繰り返し数で示すビット長のビット列に pack します。
これらの各文字は結果の 1 ビットを生成します。
これらは典型的には C<B8> や C<B64> のような繰り返しカウントが引き続きます。

=begin original

Each result bit is based on the least-significant bit of the corresponding
input character, i.e., on C<ord($char)%2>.  In particular, characters C<"0">
and C<"1"> generate bits 0 and 1, as do characters C<"\000"> and C<"\001">.

=end original

結果ビットのそれぞれは対応する入力文字の最下位ビットを基にします
(つまり C<ord($char)%2>)。
特に、文字 C<"0"> と C<"1"> は文字 C<"\000"> と C<"\001"> と同様に、
ビット 0 と 1 を生成します。

=begin original

Starting from the beginning of the input string, each 8-tuple
of characters is converted to 1 character of output.  With format C<b>,
the first character of the 8-tuple determines the least-significant bit of a
character; with format C<B>, it determines the most-significant bit of
a character.

=end original

pack() の入力文字列の先頭から始めて、8 タプル毎に 1 文字の出力に
変換されます。
C<b> フォーマットでは 8 タプルの最初の文字が出力の最下位ビットとなります;
C<B> フォーマットでは出力の最上位ビットとなります。

=begin original

If the length of the input string is not evenly divisible by 8, the
remainder is packed as if the input string were padded by null characters
at the end.  Similarly during unpacking, "extra" bits are ignored.

=end original

もし入力文字列の長さが 8 で割り切れない場合、余りの部分は入力文字列の
最後にヌル文字がパッディングされているものとしてパックされます。
同様に、unpack 中は「余分な」ビットは無視されます。

=begin original

If the input string is longer than needed, remaining characters are ignored.

=end original

入力文字列が必要な分よりも長い場合、余分な文字は無視されます。

=begin original

A C<*> for the repeat count uses all characters of the input field.  
On unpacking, bits are converted to a string of C<0>s and C<1>s.

=end original

繰り返し数として C<*> が指定されると、入力フィールドの全ての文字が
使われます。
unpack 時にはビット列は C<0> と C<1> の文字列に変換されます。

=item *

=begin original

The C<h> and C<H> formats pack a string that many nybbles (4-bit groups,
representable as hexadecimal digits, C<"0".."9"> C<"a".."f">) long.

=end original

C<h> や C<H> は、多ニブル長(16 進文字である C<"0".."9"> C<"a".."f"> で
表現可能な 4 ビットグループ)のニブル列に pack します。

=begin original

For each such format, pack() generates 4 bits of result.
With non-alphabetical characters, the result is based on the 4 least-significant
bits of the input character, i.e., on C<ord($char)%16>.  In particular,
characters C<"0"> and C<"1"> generate nybbles 0 and 1, as do bytes
C<"\000"> and C<"\001">.  For characters C<"a".."f"> and C<"A".."F">, the result
is compatible with the usual hexadecimal digits, so that C<"a"> and
C<"A"> both generate the nybble C<0xA==10>.  Use only these specific hex 
characters with this format.

=end original

このようなフォーマット文字のそれぞれについて、pack() は
結果の 4 ビットを生成します。
英字でない文字の場合、結果は入力文字の下位 4 ビットを
基にします(つまり  C<ord($char)%16>)。
特に、文字 C<"0"> と C<"1"> はバイト C<"\000"> と C<"\001"> と同様に
ニブル 0 と 1 を生成します。
文字 C<"a".."f"> と C<"A".."F"> の場合は結果は通常の
16 進数と同じ結果になりますので、C<"a"> と C<"A"> はどちらも
ニブル C<0xa==10> を生成します。
これらの 16 進文字はこの特定のフォーマットでだけ使ってください。

=begin original

Starting from the beginning of the template to pack(), each pair
of characters is converted to 1 character of output.  With format C<h>, the
first character of the pair determines the least-significant nybble of the
output character; with format C<H>, it determines the most-significant
nybble.

=end original

pack() のテンプレートの先頭から始めて、2 文字毎に 1 文字の出力に
変換されます。
C<h> フォーマットでは 1 文字目が出力の最下位ニブルとなり、
C<H> フォーマットでは出力の最上位ニブルとなります。

=begin original

If the length of the input string is not even, it behaves as if padded by
a null character at the end.  Similarly, "extra" nybbles are ignored during
unpacking.

=end original

入力文字列の長さが偶数でない場合、最後にヌル文字でパッディングされて
いるかのように振る舞います。
同様に、unpack 中は「余分な」ニブルは無視されます。

=begin original

If the input string is longer than needed, extra characters are ignored.

=end original

入力文字列が必要な分より長い場合、余分な部分は無視されます。

=begin original

A C<*> for the repeat count uses all characters of the input field.  For
unpack(), nybbles are converted to a string of hexadecimal digits.

=end original

繰り返し数として C<*> が指定されると、入力フィールドの全ての
文字が使われます。
unpack() 時にはニブルは 16 進数の文字列に変換されます。

=item *

=begin original

The C<p> format packs a pointer to a null-terminated string.  You are
responsible for ensuring that the string is not a temporary value, as that
could potentially get deallocated before you got around to using the packed
result.  The C<P> format packs a pointer to a structure of the size indicated
by the length.  A null pointer is created if the corresponding value for
C<p> or C<P> is C<undef>; similarly with unpack(), where a null pointer
unpacks into C<undef>.

=end original

C<p> は、ヌル文字終端文字列へのポインタを pack します。
文字列が一時的な値でない(つまり pack された結果を使う前に文字列が
解放されない) ことに責任を持つ必要があります
C<P> は、指定した長さの構造体へのポインタを pack します。
C<p> または C<P> に対応する値が C<undef> だった場合、
ヌルポインタが作成されます; ヌルポインタが C<undef> に unpack される
unpack() と同様です。

=begin original

If your system has a strange pointer size--meaning a pointer is neither as
big as an int nor as big as a long--it may not be possible to pack or
unpack pointers in big- or little-endian byte order.  Attempting to do
so raises an exception.

=end original

システムのポインタが変わったサイズの場合--つまり、int の大きさでも
long の大きさでもない場合--ポインタをビッグエンディアンやリトルエンディアンの
バイト順で pack や unpack することはできません。
そうしようとすると例外が発生します。

=item *

=begin original

The C</> template character allows packing and unpacking of a sequence of
items where the packed structure contains a packed item count followed by
the packed items themselves.  This is useful when the structure you're
unpacking has encoded the sizes or repeat counts for some of its fields
within the structure itself as separate fields.

=end original

C</> テンプレート文字は、アイテムの数の後にアイテムそのものが入っている形の
アイテム列を pack 及び unpack します。
これは、unpack したい構造体が、サイズや繰り替え指数が構造体自身の中に
独立したフィールドとしてエンコードされている場合に有効です。

=begin original

For C<pack>, you write I<length-item>C</>I<sequence-item>, and the
I<length-item> describes how the length value is packed. Formats likely
to be of most use are integer-packing ones like C<n> for Java strings,
C<w> for ASN.1 or SNMP, and C<N> for Sun XDR.

=end original

C<pack> では I<length-item>C</>I<string-item> の形になり、
I<length-item> は長さの値がどのように pack されているかを指定します。
もっともよく使われるのは Java 文字列 のための C<n>、ASN.1 や SNMP のための
C<w>、Sun XDR のための C<N> といった整数型です。

=begin original

For C<pack>, I<sequence-item> may have a repeat count, in which case
the minimum of that and the number of available items is used as the argument
for I<length-item>. If it has no repeat count or uses a '*', the number
of available items is used.

=end original

C<pack> では、I<sequence-item> は繰り返し数を持つことがあり、その場合は
その最小値と利用可能なアイテムの数は I<length-item> のための引数として
使われます。
繰り返し数がなかったり、'*' を使うと、利用可能なアイテムの数が使われます。

=begin original

For C<unpack>, an internal stack of integer arguments unpacked so far is
used. You write C</>I<sequence-item> and the repeat count is obtained by
popping off the last element from the stack. The I<sequence-item> must not
have a repeat count.

=end original

C<unpack> では、今まで unpack した数値引数の内部スタックが使われます。
C</>I<sequence-item> と書いて、繰り返し数はスタックから最後の要素を
取り出すことで得ます。
I<sequence-item> は繰り返し数を持っていてはいけません。

=begin original

If I<sequence-item> refers to a string type (C<"A">, C<"a">, or C<"Z">),
the I<length-item> is the string length, not the number of strings.  With
an explicit repeat count for pack, the packed string is adjusted to that
length.  For example:

=end original

I<sequence-item> が文字列型 (C<"A">, C<"a">, C<"Z">) を参照している場合、
I<length-item> は文字列の数ではなく、文字列の長さです。
pack で明示的な繰り返し数があると、pack された文字列は与えられた
長さに調整されます。
例えば:

    unpack("W/a", "\004Gurusamy")           gives ("Guru")
    unpack("a3/A A*", "007 Bond  J ")       gives (" Bond", "J")
    unpack("a3 x2 /A A*", "007: Bond, J.")  gives ("Bond, J", ".")

    pack("n/a* w/a","hello,","world")       gives "\000\006hello,\005world"
    pack("a/W2", ord("a") .. ord("z"))      gives "2ab"

=begin original

The I<length-item> is not returned explicitly from C<unpack>.

=end original

I<length-item> は C<unpack> から明示的には返されません。

=begin original

Supplying a count to the I<length-item> format letter is only useful with
C<A>, C<a>, or C<Z>.  Packing with a I<length-item> of C<a> or C<Z> may
introduce C<"\000"> characters, which Perl does not regard as legal in
numeric strings.

=end original

I<length-item> 文字に繰り返し数をつけるのは、
文字が C<A>, C<a>, C<Z> でない限りは有用ではありません。
C<a> や C<Z> を I<length-item> として pack すると C<"\000"> 文字が
出力されることがあり、Perl はこれを有効な数値文字列として認識しません。

=item *

=begin original

The integer types C<s>, C<S>, C<l>, and C<L> may be
followed by a C<!> modifier to specify native shorts or
longs.  As shown in the example above, a bare C<l> means
exactly 32 bits, although the native C<long> as seen by the local C compiler
may be larger.  This is mainly an issue on 64-bit platforms.  You can
see whether using C<!> makes any difference this way:

=end original

C<s>, C<S>, C<l>, C<L> の整数タイプに引き続いて C<!> 修飾子を
つけることで、ネイティブの short や long を指定できます。
上述のように、C<l> は正確に 32 ビットですが、ネイティブな
(ローカルな C コンパイラによる)C<long> はもっと大きいかもしれません。
これは主に 64 ビットプラットフォームで意味があります。
C<!> を使うことによって違いがあるかどうかは以下のようにして調べられます:

    printf "format s is %d, s! is %d\n", 
	length pack("s"), length pack("s!");

    printf "format l is %d, l! is %d\n", 
	length pack("l"), length pack("l!");

=begin original

C<i!> and C<I!> are also allowed, but only for completeness' sake:
they are identical to C<i> and C<I>.

=end original

C<i!> と C<I!> も動作しますが、単に完全性のためだけです;
これは C<i> 及び C<I> と同じです。

=begin original

The actual sizes (in bytes) of native shorts, ints, longs, and long
longs on the platform where Perl was built are also available from
the command line:

=end original

Perl がビルドされたプラットフォームでの short, int, long, long long の
実際の(バイト数での)サイズはコマンドラインから:

    $ perl -V:{short,int,long{,long}}size
    shortsize='2';
    intsize='4';
    longsize='4';
    longlongsize='8';

=begin original

or programmatically via the C<Config> module:

=end original

あるいは C<Config> モジュールからプログラムで:

       use Config;
       print $Config{shortsize},    "\n";
       print $Config{intsize},      "\n";
       print $Config{longsize},     "\n";
       print $Config{longlongsize}, "\n";

=begin original

C<$Config{longlongsize}> is undefined on systems without 
long long support.

=end original

システムが long long に対応していない場合は C<$Config{longlongsize}> は
未定義値になります。

=item *

=begin original

The integer formats C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, and C<J> are
inherently non-portable between processors and operating systems because
they obey native byteorder and endianness.  For example, a 4-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged in and
handled by the CPU registers) into bytes as

=end original

整数フォーマット C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, C<J> は
ネイティブなバイト順序とエンディアンに従っているため、
本質的にプロセッサ間や OS 間で移植性がありません。
例えば 4 バイトの整数 0x12345678 (10 進数では 305419896) は
内部では(CPU レジスタによって変換され扱われる形では)
以下のようなバイト列に並べられます:

    0x12 0x34 0x56 0x78  # big-endian
    0x78 0x56 0x34 0x12  # little-endian

=begin original

Basically, Intel and VAX CPUs are little-endian, while everybody else,
including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are
big-endian.  Alpha and MIPS can be either: Digital/Compaq uses (well, used) 
them in little-endian mode, but SGI/Cray uses them in big-endian mode.

=end original

基本的に、Intel と VAX の CPU はリトルエンディアンです。
一方、Motorola m68k/88k, PPC, Sparc, HP PA, Power, Cray などを含む
その他の全てはビッグエンディアンです。
Alpha と MIPS は両方ともあります:
Digital/Compaq はリトルエンディアンモードで使っています (えーと、いました) が、
SGI/Cray はビッグエンディアンモードで使っています。

=begin original

The names I<big-endian> and I<little-endian> are comic references to the
egg-eating habits of the little-endian Lilliputians and the big-endian
Blefuscudians from the classic Jonathan Swift satire, I<Gulliver's Travels>.
This entered computer lingo via the paper "On Holy Wars and a Plea for
Peace" by Danny Cohen, USC/ISI IEN 137, April 1, 1980.

=end original

I<ビッグエンディアン> と I<リトルエンディアン> の名前は
古典である「ガリバー旅行記」とリリパット族の卵を食べる習慣から
取られています。
"On Holy Wars and a Plea for Peace" by Danny Cohen, USC/ISI IEN 137,
April 1, 1980 の文書からコンピュータ用語として取り入れられました。

=begin original

Some systems may have even weirder byte orders such as

=end original

以下のような、さらに変わったバイト順序を持つシステムもあるかもしれません:

   0x56 0x78 0x12 0x34
   0x34 0x12 0x78 0x56

=begin original

You can determine your system endianness with this incantation:

=end original

システムの設定は以下のようにして調べられます:

   printf("%#02x ", $_) for unpack("W*", pack L=>0x12345678); 

=begin original

The byteorder on the platform where Perl was built is also available
via L<Config>:

=end original

Perl がビルドされたプラットフォームでのバイト順序は
L<Config> 経由か:

    use Config;
    print "$Config{byteorder}\n";

=begin original

or from the command line:

=end original

あるいはコマンドラインで:

    $ perl -V:byteorder

=begin original

Byteorders C<"1234"> and C<"12345678"> are little-endian; C<"4321">
and C<"87654321"> are big-endian.

=end original

C<"1234"> と C<"12345678"> はリトルエンディアンです;
C<"4321"> と C<"87654321"> はビッグエンディアンです。

=begin original

For portably packed integers, either use the formats C<n>, C<N>, C<v>, 
and C<V> or else use the C<< > >> and C<< < >> modifiers described
immediately below.  See also L<perlport>.

=end original

移植性のあるパック化された整数がほしい場合は、
C<n>, C<N>, C<v>, C<V> フォーマットを使うか、
直後で説明する C<< > >> と C<< < >> の修飾子が使えます。
L<perlport> も参照して下さい。

=item *

=begin original

Starting with Perl 5.9.2, integer and floating-point formats, along with
the C<p> and C<P> formats and C<()> groups, may all be followed by the 
C<< > >> or C<< < >> endianness modifiers to respectively enforce big-
or little-endian byte-order.  These modifiers are especially useful 
given how C<n>, C<N>, C<v>, and C<V> don't cover signed integers, 
64-bit integers, or floating-point values.

=end original

Perl 5.9.2 から、C<p> と C<P> フォーマットや C<()> グループと同様、
全ての整数と浮動小数点数のフォーマットは、C<< > >> や C<< < >> の
エンディアン修飾子をつけることで、それぞれ
ビッグエンディアンとリトルエンディアンに強制させることができます。
C<n>, C<N>, C<v>, C<V> は符号付き整数、64 ビット整数、浮動小数点数に
対応していないので、これは特に有用です。

=begin original

Here are some concerns to keep in mind when using an endianness modifier:

=end original

エンディアン修飾子を使うときに心に留めておくべきことを記します:

=over

=item * 

=begin original

Exchanging signed integers between different platforms works only 
when all platforms store them in the same format.  Most platforms store
signed integers in two's-complement notation, so usually this is not an issue.

=end original

異なったプラットフォームで符号付き整数を交換することは、全ての
プラットフォームで同じフォーマットで保存されている場合にのみうまくいきます。
ほとんどのプラットフォームでは符号付き整数は 2 の補数記法で保存するので、
普通はこれは問題になりません。

=item * 

=begin original

The C<< > >> or C<< < >> modifiers can only be used on floating-point
formats on big- or little-endian machines.  Otherwise, attempting to
use them raises an exception.

=end original

C<< > >> や C<< < >> の修飾子はビッグエンディアンやリトルエンディアンの
マシンでの浮動小数点フォーマットでのみ使えます。
それ以外では、そのようなことをすると例外が発生します。

=item * 

=begin original

Forcing big- or little-endian byte-order on floating-point values for
data exchange can work only if all platforms use the same
binary representation such as IEEE floating-point.  Even if all
platforms are using IEEE, there may still be subtle differences.  Being able
to use C<< > >> or C<< < >> on floating-point values can be useful,
but also dangerous if you don't know exactly what you're doing.
It is not a general way to portably store floating-point values.

=end original

データ交換のために浮動小数点数のバイト順をビッグエンディアンかリトル
エンディアンに強制することは、全てのプラットフォームが
IEEE 浮動小数点フォーマットのような同じバイナリ表現の場合にのみ
うまくいきます。
たとえ全てのプラットフォームが IEEE を使っていても、そこには微妙な違いが
あるかもしれません。
浮動小数点数に C<< > >> や C<< < >> が使えることは便利な場合が
ありますが、もし自分が何をしているかを正確に理解していなければ、
危険です。
移植性のある浮動小数点数の保存のための一般的な方法はありません。

=item * 

=begin original

When using C<< > >> or C<< < >> on a C<()> group, this affects
all types inside the group that accept byte-order modifiers,
including all subgroups.  It is silently ignored for all other
types.  You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.

=end original

C<()> グループで C<< > >> や C<< < >> を使うと、これは、副グループを
含む全ての型のうち、バイト順修飾子を受け入れる全てのものに影響与えます。
その他の型については沈黙のうちに無視されます。
既にバイト順接尾辞を持っているグループ内のバイト順を上書きすることは
できません。

=back

=item *

=begin original

Real numbers (floats and doubles) are in native machine format only.
Due to the multiplicity of floating-point formats and the lack of a
standard "network" representation for them, no facility for interchange has been
made.  This means that packed floating-point data written on one machine
may not be readable on another, even if both use IEEE floating-point
arithmetic (because the endianness of the memory representation is not part
of the IEEE spec).  See also L<perlport>.

=end original

実数 (float と double) は、機種依存のフォーマットしかありません。
いろんな浮動小数点数のフォーマットが在り、標準的な
"network" 表現といったものがないため、データ交換のための機能は
用意してありません。
つまり、あるマシンで pack した浮動小数点数は、別のマシンでは
読めないかもしれないということです。
たとえ双方で IEEE フォーマットの浮動小数点数演算を行なっていてもです
(IEEE の仕様では、メモリ表現上のバイト順序までは、
規定されていないからです)。
L<perlport> も参照してください。

=begin original

If you know I<exactly> what you're doing, you can use the C<< > >> or C<< < >>
modifiers to force big- or little-endian byte-order on floating-point values.

=end original

もし何をしようとしているのかを I<正確に> 理解しているなら、浮動小数点数の
バイト順をビッグエンディアンやリトルエンディアンに強制するために、
C<< > >> と C<< < >> の修飾子が使えます。

=begin original

Because Perl uses doubles (or long doubles, if configured) internally for
all numeric calculation, converting from double into float and thence 
to double again loses precision, so C<unpack("f", pack("f", $foo)>)
will not in general equal $foo.

=end original

Perl では、すべての数値演算のために、内部的に double (または
設定によっては long double) を使用しているので、
double から float へ変換し、それから再び double に戻すと
精度が落ちることになり、C<unpack("f", pack("f", $foo)>) は、
一般には $foo と同じではありません。

=item *

=begin original

Pack and unpack can operate in two modes: character mode (C<C0> mode) where
the packed string is processed per character, and UTF-8 mode (C<U0> mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte-by-byte basis. Character mode is the default unless the format string 
starts with C<U>. You can always switch mode mid-format with an explicit 
C<C0> or C<U0> in the format.  This mode remains in effect until the next 
mode change, or until the end of the C<()> group it (directly) applies to.

=end original

pack と unpack は二つのモードで操作します: pack された文字列を文字単位で
処理する文字モード (C<C0> モード) と、pack された文字列を、バイト毎に、
その UTF-8 エンコードされた形式で処理するUTF-8 モード (C<U0> モード) です。
文字モードはフォーマット文字列が C<U> で始まっていない限りはデフォルトです。
モードはフォーマット中に明示的に C<C0> または C<U0> と書くことでいつでも
切り替えられます。
モードは次のモードに切り替えられるか、(直接)適用された () グループが
終了するまで有効です。

=begin original

Using C<C0> to get Unicode characters while using C<U0> to get I<non>-Unicode 
bytes is not necessarily obvious.   Probably only the first of these
is what you want:

=end original

Unicode 文字を取得するのに C<C0> を使い、I<非> Unicode バイトを取得するのに
C<U0> を使うというのは必ずしも明白ではありません。
おそらく、これらのうち最初のものだけが望みのものでしょう:

    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' | 
      perl -CS -ne 'printf "%v04X\n", $_ for unpack("C0A*", $_)'
    03B1.03C9
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' | 
      perl -CS -ne 'printf "%v02X\n", $_ for unpack("U0A*", $_)'
    CE.B1.CF.89
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' | 
      perl -C0 -ne 'printf "%v02X\n", $_ for unpack("C0A*", $_)'
    CE.B1.CF.89
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' | 
      perl -C0 -ne 'printf "%v02X\n", $_ for unpack("U0A*", $_)'
    C3.8E.C2.B1.C3.8F.C2.89

=begin original

Those examples also illustrate that you should not try to use
C<pack>/C<unpack> as a substitute for the L<Encode> module.

=end original

これらの例は、C<pack>/C<unpack> を L<Encode> モジュールの代わりとして
使おうとするべきではないということも示しています。

=item *

=begin original

You must yourself do any alignment or padding by inserting, for example,
enough C<"x">es while packing.  There is no way for pack() and unpack()
to know where characters are going to or coming from, so they 
handle their output and input as flat sequences of characters.

=end original

pack するときに、例えば十分な数の C<"x"> を挿入することによって
アライメントやパッディングを行うのは全て自分でしなければなりません。
文字列がどこへ行くかやどこから来たかを pack() や unpack() が
知る方法はないので、C<pack> (と C<unpack>) は出力と入力をフラットな
文字列として扱います。

=item *

=begin original

A C<()> group is a sub-TEMPLATE enclosed in parentheses.  A group may
take a repeat count either as postfix, or for unpack(), also via the C</>
template character.  Within each repetition of a group, positioning with
C<@> starts over at 0. Therefore, the result of

=end original

C<()> のグループはかっこで囲われた副テンプレートです。
グループは繰り返し数を取ることができます; 接尾辞によるか、unpack() の場合は
C</> テンプレート文字によります。
グループの繰り返し毎に、C<@> の位置は 0 になります。
従って、以下の結果は:

    pack("@1A((@2A)@3A)", qw[X Y Z])

=begin original

is the string C<"\0X\0\0YZ">.

=end original

文字列 C<"\0X\0\0YZ"> です。

=item *

=begin original

C<x> and C<X> accept the C<!> modifier to act as alignment commands: they
jump forward or back to the closest position aligned at a multiple of C<count>
characters. For example, to pack() or unpack() a C structure like

=end original

C<x> と C<X> にはアライメントコマンドとして C<!> 修飾子を付けることができます:
これは C<count> 文字の倍数のアライメントとなる、もっとも近い位置に移動します。
例えば、以下のような構造体を pack() または unpack() するためには

    struct {
	char   c;    /* one signed, 8-bit character */
	double d; 
	char   cc[2];
    }

=begin original

one may need to use the template C<c x![d] d c[2]>.  This assumes that
doubles must be aligned to the size of double.

=end original

C<W x![d] d W[2]> というテンプレートを使う必要があるかもしれません。
これは double が double のサイズでアライメントされていることを
仮定しています。

=begin original

For alignment commands, a C<count> of 0 is equivalent to a C<count> of 1;
both are no-ops.

=end original

アライメントコマンドに対しては、C<count> に 0 を指定するのは 1 を
指定するのと等価です; どちらも何もしません。

=item *

=begin original

C<n>, C<N>, C<v> and C<V> accept the C<!> modifier to
represent signed 16-/32-bit integers in big-/little-endian order.
This is portable only when all platforms sharing packed data use the
same binary representation for signed integers; for example, when all
platforms use two's-complement representation.

=end original

C<n>, C<N>, C<v>, C<V> は 
ビッグ/リトルエンディアンの順序で符号付き 16 または
32 ビット整数で表現するための C<!> 修飾子を受け入れます。
これは pack されたデータを共有する全てのプラットフォームが
符号付き整数について同じバイナリ表現を使う場合にのみ移植性があります;
例えば、全てのプラットフォームで 2 の補数表現を使う場合です。

=item *

=begin original

Comments can be embedded in a TEMPLATE using C<#> through the end of line.
White space can separate pack codes from each other, but modifiers and
repeat counts must follow immediately.  Breaking complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibility and maintainability of pack/unpack formats as C</x> can
for complicated pattern matches.

=end original

TEMPLATE の中の C<#> から行末まではコメントです。
空白は pack コードをそれぞれ分けるために使えますが、修飾子と
繰り返し数は直後に置かなければなりません。
複雑なテンプレートを個々の行単位の要素に分解して適切に注釈をつけると、
複雑なパターンマッチングに対する C</x> と同じぐらい、pack/unpack
フォーマットの読みやすさと保守性が向上します。

=item *

=begin original

If TEMPLATE requires more arguments than pack() is given, pack()
assumes additional C<""> arguments.  If TEMPLATE requires fewer arguments
than given, extra arguments are ignored.

=end original

TEMPLATE が要求する引数の数が pack() が実際に与えている数より多い場合、
pack() は追加の C<""> 引数があるものと仮定します。
TEMPLATE が要求する引数の数の方が少ない場合、余分の引数は無視されます。

=back

=begin original

Examples:

=end original

例:

    $foo = pack("WWWW",65,66,67,68);
    # foo eq "ABCD"
    $foo = pack("W4",65,66,67,68);
    # same thing
    $foo = pack("W4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters.
    $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters. You don't get the UTF-8
    # bytes because the U at the start of the format caused a switch to
    # U0-mode, so the UTF-8 bytes get joined into characters
    $foo = pack("C0U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # foo eq "\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9"
    # This is the UTF-8 encoding of the string in the previous example

    $foo = pack("ccxxcc",65,66,67,68);
    # foo eq "AB\0\0CD"

    # NOTE: The examples above featuring "W" and "c" are true
    # only on ASCII and ASCII-derived systems such as ISO Latin 1
    # and UTF-8.  On EBCDIC systems, the first example would be
    #      $foo = pack("WWWW",193,194,195,196);

    $foo = pack("s2",1,2);
    # "\001\000\002\000" on little-endian
    # "\000\001\000\002" on big-endian

    $foo = pack("a4","abcd","x","y","z");
    # "abcd"

    $foo = pack("aaaa","abcd","x","y","z");
    # "axyz"

    $foo = pack("a14","abcdefg");
    # "abcdefg\0\0\0\0\0\0\0"

    $foo = pack("i9pl", gmtime);
    # a real struct tm (on my system anyway)

    $utmp_template = "Z8 Z8 Z16 L";
    $utmp = pack($utmp_template, @utmp1);
    # a struct utmp (BSDish)

    @utmp2 = unpack($utmp_template, $utmp);
    # "@utmp1" eq "@utmp2"

    sub bintodec {
        unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
    }

    $foo = pack('sx2l', 12, 34);
    # short 12, two zero bytes padding, long 34
    $bar = pack('s@4l', 12, 34);
    # short 12, zero fill to position 4, long 34
    # $foo eq $bar
    $baz = pack('s.l', 12, 4, 34);
    # short 12, zero fill to position 4, long 34

    $foo = pack('nN', 42, 4711);
    # pack big-endian 16- and 32-bit unsigned integers
    $foo = pack('S>L>', 42, 4711);
    # exactly the same
    $foo = pack('s<l<', -42, 4711);
    # pack little-endian 16- and 32-bit signed integers
    $foo = pack('(sl)<', -42, 4711);
    # exactly the same

=begin original

The same template may generally also be used in unpack().

=end original

一般には、pack で使用したものと同じテンプレートが、
unpack() 関数でも使用できます。

=item package NAMESPACE

=item package NAMESPACE VERSION
X<package> X<module> X<namespace> X<version>

=item package NAMESPACE BLOCK

=item package NAMESPACE VERSION BLOCK
X<package> X<module> X<namespace> X<version>

=begin original

Declares the BLOCK or the rest of the compilation unit as being in the
given namespace.  The scope of the package declaration is either the
supplied code BLOCK or, in the absence of a BLOCK, from the declaration
itself through the end of current scope (the enclosing block, file, or
C<eval>).  That is, the forms without a BLOCK are operative through the end
of the current scope, just like the C<my>, C<state>, and C<our> operators.
All unqualified dynamic identifiers in this scope will be in the given
namespace, except where overridden by another C<package> declaration or
when they're one of the special identifiers that qualify into C<main::>,
like C<STDOUT>, C<ARGV>, C<ENV>, and the punctuation variables.

=end original

BLOCK や残りのコンパイル単位を与えられた名前空間として宣言します。
パッケージ宣言のスコープは、宣言自体から、閉じたブロック、ファイル、
eval の終わりまでです(C<my> 演算子と同じです)。
全てのさらなる修飾されてない動的識別子はこの名前空間になります。
パッケージ宣言のスコープは BLOCK か、BLOCK がないばあいは宣言自身から
現在のスコープの末尾 (閉じたブロック、ファイル、C<eval>) です。
つまり、BLOCK なしの形式は、C<my>, C<state>, C<our> 演算子と同様に
現在のスコープの末尾にまで作用します。
このスコープ内の、全ての完全修飾されていない動的識別子は、他の
C<package> 宣言によって上書きされるか、
C<STDOUT>, C<ARGV>, C<ENV> や句読点変数のように C<main::> に
割り当てられる特殊変数でない限り、指定された
名前空間になります。

=begin original

A package statement affects dynamic variables only, including those
you've used C<local> on, but I<not> lexical variables, which are created
with C<my>, C<state>, or C<our>.  Typically it would be the first 
declaration in a file included by C<require> or C<use>.  You can switch into a
package in more than one place, since this only determines which default 
symbol table the compiler uses for the rest of that block.  You can refer to
identifiers in other packages than the current one by prefixing the identifier
with the package name and a double colon, as in C<$SomePack::var>
or C<ThatPack::INPUT_HANDLE>.  If package name is omitted, the C<main>
package as assumed.  That is, C<$::sail> is equivalent to
C<$main::sail> (as well as to C<$main'sail>, still seen in ancient
code, mostly from Perl 4).

=end original

package 文は動的変数にのみ影響します(C<local> で使ったものも
含みます)が、C<my>, C<state>, C<our> のいずれかで作成された
レキシカル変数には I<影響しません>。
典型的にはこれは C<require> や C<use> 演算子でインクルードされるファイルの
最初に宣言されます。
パッケージを複数の場所で切り替えることができます;
なぜならこれは単にコンパイラがこのブロックの残りに対してどの
シンボルテーブルを使うかにのみ影響するからです。
他のパッケージの識別子は、C<$SomePack::var> や
C<ThatPack::INPUT_HANDLE> のように、識別子にパッケージ名と
コロン二つをつけることで参照できます。
パッケージ名が省略された場合、C<main> パッケージが仮定されます。
つまり、C<$::sail> は C<$main::sail> と等価です(ほとんどは Perl 4 からの、
古いコードでは C<$main'sail> もまだ見られます)。

=begin original

If VERSION is provided, C<package> sets the C<$VERSION> variable in the given
namespace to a L<version> object with the VERSION provided.  VERSION must be a
"strict" style version number as defined by the L<version> module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v-string with a leading 'v' character and at least three
components.  You should set C<$VERSION> only once per package.

=end original

VERSION が指定されると、C<package> は与えられた名前空間の C<$VERSION> 変数に、
指定された VERSION の L<version> オブジェクトをセットします。
VERSION は L<version> で定義されている「厳密な」形式のバージョン番号で
なければなりません: 指数のない正の 10 進数 (整数か 10 進小数) か、
さもなければ先頭に 'v' の文字が付いて、少なくとも三つの部分から
構成されるドット付き 10 進v-文字列です。
C<$VERSION> はパッケージ毎に 1 回だけセットするべきです。

=begin original

See L<perlmod/"Packages"> for more information about packages, modules,
and classes.  See L<perlsub> for other scoping issues.

=end original

パッケージ、モジュール、クラスに関するさらなる情報については
L<perlmod/"Packages"> を参照してください。
その他のスコープに関する話題については L<perlsub> を参照してください。

=item pipe READHANDLE,WRITEHANDLE
X<pipe>

=begin original

Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
IO buffering, so you may need to set C<$|> to flush your WRITEHANDLE
after each command, depending on the application.

=end original

対応するシステムコールと同じように、
接続されたパイプのペアをオープンします。
パイプでプロセスをループにするときには、よほど気を付けないと、
デッドロックが起こり得ます。
さらに、Perl のパイプでは、IO のバッファリングを使いますから、
アプリケーションによっては、コマンドごとに WRITEHANDLE を
フラッシュするように、C<$|> を設定することが必要になるかもしれません。

=begin original

See L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication with Another Process">
for examples of such things.

=end original

これらに関する例については、L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication with Another Process"> を
参照して下さい。

=begin original

On systems that support a close-on-exec flag on files, that flag is set
on all newly opened file descriptors whose C<fileno>s are I<higher> than 
the current value of $^F (by default 2 for C<STDERR>).  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
新しくオープンされたファイル記述子のうち、
C<fileno> が現在の $^F の値(デフォルトでは C<STDERR> の 2)
I<よりも大きい> ものに対してフラグがセットされます。
L<perlvar/$^F> を参照してください。

=item pop ARRAY
X<pop> X<stack>

=item pop EXPR

=item pop

=begin original

Pops and returns the last value of the array, shortening the array by
one element.

=end original

配列の最後の値をポップして返し、配列の大きさを 1 だけ小さくします。

=begin original

Returns the undefined value if the array is empty, although this may also
happen at other times.  If ARRAY is omitted, pops the C<@ARGV> array in the
main program, but the C<@_> array in subroutines, just like C<shift>.

=end original

指定された配列に要素がなければ未定義値が返されますが、
しかしこれは他の場合にも起こり得ます。
ARRAY が省略されると、C<shift> と同様に、メインプログラムでは C<@ARGV> が
使われますが、サブルーチンでは C<@_> が使われます。

=begin original

Starting with Perl 5.14, C<pop> can take a scalar EXPR, which must hold a
reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of C<pop> is considered highly experimental.
The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<pop> はスカラの EXPR を取ることができるようになりました;
これは bless されていない配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<pop> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

=item pos SCALAR
X<pos> X<match, position>

=item pos

=begin original

Returns the offset of where the last C<m//g> search left off for the
variable in question (C<$_> is used when the variable is not
specified). Note that 0 is a valid match offset. C<undef> indicates
that the search position is reset (usually due to match failure, but
can also be because no match has yet been run on the scalar).

=end original

対象の変数に対して、前回の C<m//g> が終了した場所の
オフセットを返します(変数が指定されなかった場合は C<$_> が使われます)。
0 は有効なマッチオフセットであることに注意してください。
C<undef> は検索位置がリセットされることを意味します (通常はマッチ失敗が
原因ですが、このスカラ値にまだマッチングが行われていないためかもしれません)。

=begin original

C<pos> directly accesses the location used by the regexp engine to
store the offset, so assigning to C<pos> will change that offset, and
so will also influence the C<\G> zero-width assertion in regular
expressions. Both of these effects take place for the next match, so
you can't affect the position with C<pos> during the current match,
such as in C<(?{pos() = 5})> or C<s//pos() = 5/e>.

=end original

C<pos> は正規表現エンジンがオフセットを保存するために使う場所を直接
アクセスするので、C<pos> への代入はオフセットを変更し、そのような変更は
正規表現における C<\G> ゼロ幅アサートにも影響を与えます。
これらの効果の両方は次のマッチングのために行われるので、
C<(?{pos() = 5})> や C<s//pos() = 5/e> のように現在のマッチング中の
C<pos> の位置には影響を与えません。

=begin original

Setting C<pos> also resets the I<matched with zero-length> flag, described
under L<perlre/"Repeated Patterns Matching a Zero-length Substring">.

=end original

C<pos> を設定すると、
L<perlre/"Repeated Patterns Matching a Zero-length Substring"> に
記述されている、I<長さ 0 でマッチング> フラグもリセットされます。

=begin original

Because a failed C<m//gc> match doesn't reset the offset, the return
from C<pos> won't change either in this case.  See L<perlre> and
L<perlop>.

=end original

C<m//gc> マッチに失敗してもオフセットはリセットしないので、
C<pos> からの返り値はどちらの場合も変更されません。
L<perlre> と L<perlop> を参照してください。

=item print FILEHANDLE LIST
X<print>

=item print FILEHANDLE

=item print LIST

=item print

=begin original

Prints a string or a list of strings.  Returns true if successful.
FILEHANDLE may be a scalar variable containing the name of or a reference
to the filehandle, thus introducing one level of indirection.  (NOTE: If
FILEHANDLE is a variable and the next token is a term, it may be
misinterpreted as an operator unless you interpose a C<+> or put
parentheses around the arguments.) If FILEHANDLE is omitted, prints to the
last selected (see L</select>) output handle.  If LIST is omitted, prints
C<$_> to the currently selected output handle.  To use FILEHANDLE alone to
print the content of C<$_> to it, you must use a real filehandle like
C<FH>, not an indirect one like C<$fh>.  To set the default output handle
to something other than STDOUT, use the select operation.

=end original

文字列か文字列のリストを出力します。
成功時には、真を返します。FILEHANDLE は、
ファイルハンドル名またはそのリファレンスが
入っているスカラ変数名でもよいので、一段階の間接指定が行なえます。
(注: FILEHANDLE に変数を使い、次のトークンが「項」のときには、
間に C<+> を置くか、引数の前後を括弧で括らなければ、
誤って解釈されることがあります。)
FILEHANDLE を省略した場合には、最後に選択された (L</select> 参照) 出力
チャネルに出力します。
LIST を省略すると、C<$_> が現在選択されている出力ハンドルに出力されます。
C<$_> の内容を表示するために FILEHANDLE のみを使用するには、
C<$fh> のような間接ファイルハンドルではなく、C<FH> のような実際の
ファイルハンドルを使わなければなりません。
デフォルトの出力チャネルを STDOUT 以外にするには、select 演算子を
使ってください。

=begin original

The current value of C<$,> (if any) is printed between each LIST item.  The
current value of C<$\> (if any) is printed after the entire LIST has been
printed.  Because print takes a LIST, anything in the LIST is evaluated in
list context, including any subroutines whose return lists you pass to
C<print>.  Be careful not to follow the print keyword with a left
parenthesis unless you want the corresponding right parenthesis to
terminate the arguments to the print; put parentheses around all arguments
(or interpose a C<+>, but that doesn't look as good).

=end original

C<$,> の値が(もしあれば)各 LIST 要素の間に出力されます。
LIST 全体が出力された後、(もしあれば) C<$\> の現在の値が出力されます。
print の引数は LIST なので、LISTの中のものは、
すべてリストコンテキストで評価されます。
サブルーチンの呼び出しがあれば、リストコンテキストでは、
複数の値を返すかもしれません。
また、すべての引数を括弧で括るのでなければ、print というキーワードの
次に開き括弧を書いてはいけません; すべての引数を括弧で括ってください
(あるいは "print" と引数の間に C<+> を書きますが、これはあまり
よくありません)。

=begin original

If you're storing handles in an array or hash, or in general whenever
you're using any expression more complex than a bareword handle or a plain,
unsubscripted scalar variable to retrieve it, you will have to use a block
returning the filehandle value instead, in which case the LIST may not be
omitted:

=end original

もし FILESHANDLE を配列、ハッシュあるいは一般的には裸の単語のハンドルや
普通のスカラ変数よりも複雑な表現を使っている場合、代わりにその値を返す
ブロックを使う必要があります; この場合 LIST は省略できません:

    print { $files[$i] } "stuff\n";
    print { $OK ? STDOUT : STDERR } "stuff\n";

=begin original

Printing to a closed pipe or socket will generate a SIGPIPE signal.  See
L<perlipc> for more on signal handling.

=end original

閉じたパイプやソケットに print すると SIGPIPE シグナルが生成されます。
さらなるシグナル操作については L<perlipc> を参照してください。

=item printf FILEHANDLE FORMAT, LIST
X<printf>

=item printf FILEHANDLE

=item printf FORMAT, LIST

=item printf

=begin original

Equivalent to C<print FILEHANDLE sprintf(FORMAT, LIST)>, except that C<$\>
(the output record separator) is not appended.  The first argument of the
list will be interpreted as the C<printf> format. See C<sprintf> for an
explanation of the format argument.    If you omit the LIST, C<$_> is used;
to use FILEHANDLE without a LIST, you must use a real filehandle like
C<FH>, not an indirect one like C<$fh>.  If C<use locale> is in effect and
POSIX::setlocale() has been called, the character used for the decimal
separator in formatted floating-point numbers is affected by the LC_NUMERIC
locale setting.  See L<perllocale> and L<POSIX>.

=end original

C<$\>(出力レコードセパレータ)を追加しないことを除けば、
C<print FILEHANDLE sprintf(FORMAT, LIST)> と等価です。
リストの最初の要素は、C<printf> フォーマットと解釈されます。
フォーマット引数の説明については C<sprintf> を参照してください。
LIST を省略すると、C<$_> が使われます; 
LIST なしで FILEHANDLE を使用するには、
C<$fh> のような間接ファイルハンドルではなく、C<FH> のような実際の
ファイルハンドルを使わなければなりません。
C<use locale> が効力をもっていて、POSIX::setlocale() が呼び出されていれば、
小数点に使われる文字は LC_NUMERIC ロケール設定の影響を受けます。
L<perllocale> と L<POSIX> を参照してください。

=begin original

Don't fall into the trap of using a C<printf> when a simple
C<print> would do.  The C<print> is more efficient and less
error prone.

=end original

単純な C<print> を使うべきところで C<printf> を使ってしまう
罠にかからないようにしてください。
C<print> はより効率的で、間違いが起こりにくいです。

=item prototype FUNCTION
X<prototype>

=begin original

Returns the prototype of a function as a string (or C<undef> if the
function has no prototype).  FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.

=end original

関数のプロトタイプを文字列として返します(関数にプロトタイプがない場合は
C<undef> を返します)。
FUNCTION はプロトタイプを得たい関数の名前、またはリファレンスです。

=begin original

If FUNCTION is a string starting with C<CORE::>, the rest is taken as a
name for a Perl builtin.  If the builtin is not I<overridable> (such as
C<qw//>) or if its arguments cannot be adequately expressed by a prototype
(such as C<system>), prototype() returns C<undef>, because the builtin
does not really behave like a Perl function.  Otherwise, the string
describing the equivalent prototype is returned.

=end original

FUNCTION が C<CORE::> で始まっている場合、残りは Perl ビルドインの名前として
扱われます。
このビルドインが(C<qw//> のように) I<オーバーライド可能> でない、
またはこの引数が(C<system> のように)プロトタイプとして適切に記述できない場合、
prototype() は C<undef> を返します;
なぜならビルドインは実際に Perl 関数のように振舞わないからです。
それ以外では、等価なプロトタイプを表現した文字列が返されます。

=item push ARRAY,LIST
X<push> X<stack>

=item push EXPR,LIST

=begin original

Treats ARRAY as a stack by appending the values of LIST to the end of
ARRAY.  The length of ARRAY increases by the length of LIST.  Has the same
effect as

=end original

ARRAY をスタックとして扱い、LIST 内の値を ARRAY の終わりに追加します。
ARRAY の大きさは、LIST の長さ分だけ大きくなります。
これは、

    for $value (LIST) {
        $ARRAY[++$#ARRAY] = $value;
    }

=begin original

but is more efficient.  Returns the number of elements in the array following
the completed C<push>.

=end original

とするのと同じ効果がありますが、より効率的です。
C<push> の処理終了後の配列の要素数を返します。

=begin original

Starting with Perl 5.14, C<push> can take a scalar EXPR, which must hold a
reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of C<push> is considered highly experimental.
The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<push> はスカラの EXPR を取ることができるようになりました;
これは bless されていない配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<push> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

=item q/STRING/

=item qq/STRING/

=item qx/STRING/

=item qw/STRING/

=begin original

Generalized quotes.  See L<perlop/"Quote-Like Operators">.

=end original

汎用のクォートです。
L<perlop/"Quote-Like Operators"> を参照してください。

=item qr/STRING/

=begin original

Regexp-like quote.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

正規表現風のクォートです。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item quotemeta EXPR
X<quotemeta> X<metacharacter>

=item quotemeta

=begin original

Returns the value of EXPR with all non-"word"
characters backslashed.  (That is, all characters not matching
C</[A-Za-z_0-9]/> will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the C<\Q> escape in double-quoted strings.

=end original

EXPR の中のすべての非英数字キャラクタをバックスラッシュで
エスケープしたものを返します
(つまり、C</[A-Za-z_0-9]/> にマッチしない全ての文字の前には
ロケールに関わらずバックスラッシュが前置されます)。
これは、ダブルクォート文字列での C<\Q> エスケープを
実装するための内部関数です。

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR が省略されると、C<$_> を使います。

=begin original

quotemeta (and C<\Q> ... C<\E>) are useful when interpolating strings into
regular expressions, because by default an interpolated variable will be
considered a mini-regular expression. For example:

=end original

クォートメタ (と C<\Q> ... C<\E>) は、文字列を正規表現に展開するのに
便利です; なぜなら、デフォルトでは展開された変数は小さな正規表現として
扱われるからです。
例えば:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    $sentence =~ s{$substring}{big bad wolf};

=begin original

Will cause C<$sentence> to become C<'The big bad wolf jumped over...'>.

=end original

とすると、C<$sentence> は C<'The big bad wolf jumped over...'> になります。

=begin original

On the other hand:

=end original

一方:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    $sentence =~ s{\Q$substring\E}{big bad wolf};

=begin original

Or:

=end original

あるいは:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    my $quoted_substring = quotemeta($substring);
    $sentence =~ s{$quoted_substring}{big bad wolf};

=begin original

Will both leave the sentence as is. Normally, when accepting literal string
input from the user, quotemeta() or C<\Q> must be used.

=end original

とすると、両方ともそのままです。
普通は、ユーザーからのリテラルな文字列入力を受け付ける場合は、
必ず quotemeta() か C<\Q> を使わなければなりません。

=begin original

In Perl 5.14, all characters whose code points are above 127 are not
quoted in UTF8-encoded strings, but all are quoted in UTF-8 strings.
It is planned to change this behavior in 5.16, but the exact rules
haven't been determined yet.

=end original

Perl 5.14 では、符号位置が 127 を超える全ての文字は UTF-8 エンコードされた
文字列ではクォートされませんが、UTF-8 文字列では全てクォートされます。
この振る舞いは 5.16 で変更が計画されていますが、正確な規則はまだ
決定していません。

=item rand EXPR
X<rand> X<random>

=item rand

=begin original

Returns a random fractional number greater than or equal to C<0> and less
than the value of EXPR.  (EXPR should be positive.)  If EXPR is
omitted, the value C<1> is used.  Currently EXPR with the value C<0> is
also special-cased as C<1> (this was undocumented before Perl 5.8.0
and is subject to change in future versions of Perl).  Automatically calls
C<srand> unless C<srand> has already been called.  See also C<srand>.

=end original

C<0> 以上 EXPR の値未満の小数の乱数値を返します。
(EXPR は正の数である必要があります。)
EXPR を省略すると、C<1> とみなします。
現在のところ、EXPR に値 C<0> をセットすると C<1> として特別扱いされます
(これは Perl 5.8.0 以前には文書化されておらず、将来のバージョンの perl では
変更される可能性があります)。
C<srand> が既に呼ばれている場合以外は、自動的に C<srand> 関数を
呼び出します。
C<srand> も参照してください。

=begin original

Apply C<int()> to the value returned by C<rand()> if you want random
integers instead of random fractional numbers.  For example,

=end original

ランダムな小数ではなく、ランダムな整数がほしい場合は、C<rand()> から
返された値に C<int()> を適用してください。

    int(rand(10))

=begin original

returns a random integer between C<0> and C<9>, inclusive.

=end original

これは C<0> から C<9> の値をランダムに返します。

=begin original

(Note: If your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of RANDBITS.)

=end original

(注: もし、rand 関数が、常に大きい値ばかりや、小さい数ばかりを
返すようなら、お使いになっている Perl が、
良くない RANDBITS を使ってコンパイルされている可能性があります。)

=begin original

B<C<rand()> is not cryptographically secure.  You should not rely
on it in security-sensitive situations.>  As of this writing, a
number of third-party CPAN modules offer random number generators
intended by their authors to be cryptographically secure,
including: L<Math::Random::Secure>, L<Math::Random::MT::Perl>, and
L<Math::TrulyRandom>.

=end original

B<C<rand()> は暗号学的に安全ではありません。
セキュリティ的に重要な状況でこれに頼るべきではありません。>
これを書いている時点で、いくつかのサードパーティ CPAN モジュールが
作者によって暗号学的に安全であることを目的とした乱数生成器を
提供しています: L<Math::Random::Secure>, L<Math::Random::MT::Perl>, 
L<Math::TrulyRandom> などです。

=item read FILEHANDLE,SCALAR,LENGTH,OFFSET
X<read> X<file, read>

=item read FILEHANDLE,SCALAR,LENGTH

=begin original

Attempts to read LENGTH I<characters> of data into variable SCALAR
from the specified FILEHANDLE.  Returns the number of characters
actually read, C<0> at end of file, or undef if there was an error (in
the latter case C<$!> is also set).  SCALAR will be grown or shrunk 
so that the last character actually read is the last character of the
scalar after the read.

=end original

指定した FILEHANDLE から、変数 SCALAR に LENGTH I<文字> の
データを読み込みます。
実際に読み込まれた文字数、
ファイル終端の場合は C<0>、エラーの場合は undef のいずれかを返します
(後者の場合、C<$!> もセットされます)。
SCALAR は伸び縮みするので、
読み込み後は、実際に読み込んだ最後の文字がスカラの最後の文字になります。

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET を指定すると、文字列の先頭以外の場所から、
読み込みを行なうことができます。
負の数の OFFSET を指定すると、文字列の最後から逆方向に何文字目かを数えます。
SCALAR の長さよりも大きい、正の数の OFFSET を指定すると、文字列は
読み込みの結果が追加される前に、必要なサイズまで C<"\0"> のバイトで
パッディングされます。

=begin original

The call is implemented in terms of either Perl's or your system's native
fread(3) library function.  To get a true read(2) system call, see C<sysread>.

=end original

この関数は、Perl か システムの fread(3) ライブラリ関数を使って実装しています。
本当の read(2) システムコールを利用するには、C<sysread> を参照してください。

=begin original

Note the I<characters>: depending on the status of the filehandle,
either (8-bit) bytes or characters are read.  By default, all
filehandles operate on bytes, but for example if the filehandle has
been opened with the C<:utf8> I/O layer (see L</open>, and the C<open>
pragma, L<open>), the I/O will operate on UTF8-encoded Unicode
characters, not bytes.  Similarly for the C<:encoding> pragma:
in that case pretty much any characters can be read.

=end original

I<文字> に関する注意: ファイルハンドルの状態によって、(8 ビットの) バイトか
文字が読み込まれます。
デフォルトでは全てのファイルハンドルはバイトを処理しますが、
例えばファイルハンドルが C<:utf8> I/O 層(L</open>, C<open> プラグマ、
L<open> を参照してください) で開かれた場合、I/O はバイトではなく、
UTF8 エンコードされた Unicode 文字を操作します。
C<:encoding> プラグマも同様です:
この場合、ほとんど大体全ての文字が読み込めます。

=item readdir DIRHANDLE
X<readdir>

=begin original

Returns the next directory entry for a directory opened by C<opendir>.
If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns the undefined value in
scalar context and the empty list in list context.

=end original

C<opendir> でオープンしたディレクトリで、
次のディレクトリエントリを返します。
リストコンテキストで用いると、
そのディレクトリの残りのエントリを、すべて返します。
エントリが残っていない場合には、スカラコンテキストでは未定義値を、
リストコンテキストでは空リストを返します。

=begin original

If you're planning to filetest the return values out of a C<readdir>, you'd
better prepend the directory in question.  Otherwise, because we didn't
C<chdir> there, it would have been testing the wrong file.

=end original

C<readdir> の返り値をファイルテストに使おうと計画しているなら、
頭にディレクトリをつける必要があります。
さもなければ、ここでは C<chdir> はしないので、
間違ったファイルをテストしてしまうことになるでしょう。

    opendir(my $dh, $some_dir) || die "can't opendir $some_dir: $!";
    @dots = grep { /^\./ && -f "$some_dir/$_" } readdir($dh);
    closedir $dh;

=begin original

As of Perl 5.11.2 you can use a bare C<readdir> in a C<while> loop,
which will set C<$_> on every iteration.

=end original

Perl 5.11.2 から裸の C<readdir> を C<while> で使うことができ、
この場合繰り返し毎に C<$_> にセットされます。

    opendir(my $dh, $some_dir) || die;
    while(readdir $dh) {
        print "$some_dir/$_\n";
    }
    closedir $dh;

=item readline EXPR

=item readline
X<readline> X<gets> X<fgets>

=begin original

Reads from the filehandle whose typeglob is contained in EXPR (or from
C<*ARGV> if EXPR is not provided).  In scalar context, each call reads and
returns the next line until end-of-file is reached, whereupon the
subsequent call returns C<undef>.  In list context, reads until end-of-file
is reached and returns a list of lines.  Note that the notion of "line"
used here is whatever you may have defined with C<$/> or
C<$INPUT_RECORD_SEPARATOR>).  See L<perlvar/"$/">.

=end original

型グロブが EXPR (EXPR がない場合は C<*ARGV>) に含まれている
ファイルハンドルから読み込みます。
スカラコンテキストでは、呼び出し毎に一行読み込んで返します。
ファイルの最後まで読み込んだら、以後の呼び出しでは C<undef> を返します。
リストコンテキストでは、ファイルの最後まで読み込んで、
行のリストを返します。
ここでの「行」とは、C<$/> または C<$INPUT_RECORD_SEPARATOR> で
定義されることに注意してください。
L<perlvar/"$/"> を参照して下さい。

=begin original

When C<$/> is set to C<undef>, when C<readline> is in scalar
context (i.e., file slurp mode), and when an empty file is read, it
returns C<''> the first time, followed by C<undef> subsequently.

=end original

C<$/> に C<undef> を設定した場合は、C<readline> はスカラコンテキスト
(つまりファイル吸い込みモード)となり、
空のファイルを読み込んだ場合は、最初は C<''> を返し、
それ以降は C<undef> を返します。

=begin original

This is the internal function implementing the C<< <EXPR> >>
operator, but you can use it directly.  The C<< <EXPR> >>
operator is discussed in more detail in L<perlop/"I/O Operators">.

=end original

これは C<< <EXPR> >> 演算子を実装している内部関数ですが、
直接使うこともできます。
C<< <EXPR> >> 演算子についてのさらなる詳細については
L<perlop/"I/O Operators"> で議論されています。

    $line = <STDIN>;
    $line = readline(*STDIN);    # same thing

=begin original

If C<readline> encounters an operating system error, C<$!> will be set
with the corresponding error message.  It can be helpful to check
C<$!> when you are reading from filehandles you don't trust, such as a
tty or a socket.  The following example uses the operator form of
C<readline> and dies if the result is not defined.

=end original

C<readline> が OS のシステムエラーになると、C<$!> に対応するエラーメッセージが
セットされます。
tty やソケットといった、信頼できないファイルハンドルから読み込む時には
C<$!> をチェックするのが助けになります。
以下の例は演算子の形の C<readline> を使っており、結果が
未定義の場合は die します。

    while ( ! eof($fh) ) {
        defined( $_ = <$fh> ) or die "readline failed: $!";
        ...
    }

=begin original

Note that you have can't handle C<readline> errors that way with the
C<ARGV> filehandle. In that case, you have to open each element of
C<@ARGV> yourself since C<eof> handles C<ARGV> differently.

=end original

C<readline> のエラーは C<ARGV> ファイルハンドルの方法では扱えないことに
注意してください。
この場合、C<eof> は C<ARGV> を異なった方法で扱うので、
C<@ARGV> のそれぞれの要素を自分でオープンする必要があります。

    foreach my $arg (@ARGV) {
        open(my $fh, $arg) or warn "Can't open $arg: $!";

        while ( ! eof($fh) ) {
            defined( $_ = <$fh> )
                or die "readline failed for $arg: $!";
            ...
        }
    }

=item readlink EXPR
X<readlink>

=item readlink

=begin original

Returns the value of a symbolic link, if symbolic links are
implemented.  If not, raises an exception.  If there is a system
error, returns the undefined value and sets C<$!> (errno).  If EXPR is
omitted, uses C<$_>.

=end original

シンボリックリンクが実装されていれば、
シンボリックリンクの値を返します。
実装されていないときには、例外が発生します。
何らかのシステムエラーが検出されると、未定義値を返し、
C<$!> (errno) を設定します。
EXPR を省略すると、C<$_> を使用します。

=item readpipe EXPR

=item readpipe
X<readpipe>

=begin original

EXPR is executed as a system command.
The collected standard output of the command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines with C<$/> or C<$INPUT_RECORD_SEPARATOR>).
This is the internal function implementing the C<qx/EXPR/>
operator, but you can use it directly.  The C<qx/EXPR/>
operator is discussed in more detail in L<perlop/"I/O Operators">.
If EXPR is omitted, uses C<$_>.

=end original

EXPR がシステムコマンドとして実行されます。
コマンドの標準出力の内容が返されます。
スカラコンテキストでは、単一の(内部的に複数行の)文字列を返します。
リストコンテキストでは、行のリストを返します
(但し、行は C<$/> または C<$INPUT_RECORD_SEPARATOR> で定義されます)。
これは C<qx/EXPR/> 演算子を実装する内部関数ですが、
直接使うことも出来ます。
C<qx/EXPR/> 演算子は L<perlop/"I/O Operators"> でより詳細に
述べられています。
EXPR を省略すると、C<$_> を使用します。

=item recv SOCKET,SCALAR,LENGTH,FLAGS
X<recv>

=begin original

Receives a message on a socket.  Attempts to receive LENGTH characters
of data into variable SCALAR from the specified SOCKET filehandle.
SCALAR will be grown or shrunk to the length actually read.  Takes the
same flags as the system call of the same name.  Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.  If there's an error, returns the undefined value.
This call is actually implemented in terms of recvfrom(2) system call.
See L<perlipc/"UDP: Message Passing"> for examples.

=end original

ソケット上のメッセージを受信します。
指定されたファイルハンドル SOCKET から、変数 SCALAR に
LENGTH 文字のデータを読み込もうとします。
SCALAR は、実際に読まれた長さによって、大きくなったり、
小さくなったりします。
同名のシステムコールと同じ FLAGS を使います。
SOCKET のプロトコルが対応していれば、送信側のアドレスを返します。
エラー発生時には、未定義値を返します。
実際には、C のrecvfrom(2) を呼びます。
例についてはL<perlipc/"UDP: Message Passing">を参照してください。

=begin original

Note the I<characters>: depending on the status of the socket, either
(8-bit) bytes or characters are received.  By default all sockets
operate on bytes, but for example if the socket has been changed using
binmode() to operate with the C<:encoding(utf8)> I/O layer (see the
C<open> pragma, L<open>), the I/O will operate on UTF8-encoded Unicode
characters, not bytes.  Similarly for the C<:encoding> pragma: in that
case pretty much any characters can be read.

=end original

I<文字> に関する注意: ソケットの状態によって、(8 ビットの) バイトか
文字を受信します。
デフォルトでは全てのソケットはバイトを処理しますが、
例えばソケットが binmode() で C<:encoding(utf8)> I/O 層(C<open> プラグマ、
L<open> を参照してください) を使うように指定された場合、I/O はバイトではなく、
UTF8 エンコードされた Unicode 文字を操作します。
C<:encoding> プラグマも同様です:
この場合、ほとんど大体全ての文字が読み込めます。

=item redo LABEL
X<redo>

=item redo

=begin original

The C<redo> command restarts the loop block without evaluating the
conditional again.  The C<continue> block, if any, is not executed.  If
the LABEL is omitted, the command refers to the innermost enclosing
loop.  Programs that want to lie to themselves about what was just input 
normally use this command:

=end original

C<redo> コマンドは、条件を再評価しないで、ループブロックの始めからもう一度
実行を開始します。
C<continue> ブロックがあっても、実行されません。
LABEL が省略されると、このコマンドは、もっとも内側のループを参照します。
このコマンドは通常、自分への入力を欺くために使用します:

    # a simpleminded Pascal comment stripper
    # (warning: assumes no { or } in strings)
    LINE: while (<STDIN>) {
        while (s|({.*}.*){.*}|$1 |) {}
        s|{.*}| |;
        if (s|{.*| |) {
            $front = $_;
            while (<STDIN>) {
                if (/}/) {  # end of comment?
                    s|^|$front\{|;
                    redo LINE;
                }
            }
        }
        print;
    }

=begin original

C<redo> cannot be used to retry a block that returns a value such as
C<eval {}>, C<sub {}>, or C<do {}>, and should not be used to exit
a grep() or map() operation.

=end original

C<redo> は C<eval {}>, C<sub {}>, C<do {}> のように値を返す
ブロックを繰り返すのには使えません。
また、grep() や map() 操作から抜けるのに使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<redo> inside such a block will effectively
turn it into a looping construct.

=end original

ブロック自身は一回だけ実行されるループと文法的に同一であることに
注意してください。
従って、ブロックの中で C<redo> を使うことで効果的に
ループ構造に変換します。

=begin original

See also L</continue> for an illustration of how C<last>, C<next>, and
C<redo> work.

=end original

C<last>, C<next>, C<redo> がどのように働くかについては
L</continue> を参照して下さい。

=item ref EXPR
X<ref> X<reference>

=item ref

=begin original

Returns a non-empty string if EXPR is a reference, the empty
string otherwise. If EXPR
is not specified, C<$_> will be used.  The value returned depends on the
type of thing the reference is a reference to.
Builtin types include:

=end original

EXPR がリファレンスであれば、空でない文字列を返し、さもなくば、
空文字列を返します。
EXPR が指定されなければ、C<$_> が使われます。
返される値は、リファレンスが参照するものの型に依存します。
組み込みの型には、以下のものがあります。

    SCALAR
    ARRAY
    HASH
    CODE
    REF
    GLOB
    LVALUE
    FORMAT
    IO
    VSTRING
    Regexp

=begin original

If the referenced object has been blessed into a package, then that package
name is returned instead.  You can think of C<ref> as a C<typeof> operator.

=end original

参照されるオブジェクトが、何らかのパッケージに
bless されたものであれば、これらの代わりに、
そのパッケージ名が返されます。
C<ref> は、C<typeof> 演算子のように考えることができます。

    if (ref($r) eq "HASH") {
        print "r is a reference to a hash.\n";
    }
    unless (ref($r)) {
        print "r is not a reference at all.\n";
    }

=begin original

The return value C<LVALUE> indicates a reference to an lvalue that is not
a variable. You get this from taking the reference of function calls like
C<pos()> or C<substr()>. C<VSTRING> is returned if the reference points
to a L<version string|perldata/"Version Strings">.

=end original

返り値 C<LVALUE> は、変数ではない左辺値へのリファレンスを示します。
これは、C<pos()> や C<substr()> のようの関数呼び出しのリファレンスから
得られます。
C<VSTRING> は、リファレンスが L<version string|perldata/"Version Strings"> を
指している場合に返されます。

=begin original

The result C<Regexp> indicates that the argument is a regular expression
resulting from C<qr//>.

=end original

C<Regexp> という結果は、ｈ奇数が C<qr//> からの結果である
正規表現であることを意味します。

=begin original

See also L<perlref>.

=end original

L<perlref> も参照してください。

=item rename OLDNAME,NEWNAME
X<rename> X<move> X<mv> X<ren>

=begin original

Changes the name of a file; an existing file NEWNAME will be
clobbered.  Returns true for success, false otherwise.

=end original

ファイルの名前を変更します。
NEWNAME というファイルが既に存在した場合、上書きされるかもしれません。
成功時には真、失敗時には偽を返します。

=begin original

Behavior of this function varies wildly depending on your system
implementation.  For example, it will usually not work across file system
boundaries, even though the system I<mv> command sometimes compensates
for this.  Other restrictions include whether it works on directories,
open files, or pre-existing files.  Check L<perlport> and either the
rename(2) manpage or equivalent system documentation for details.

=end original

この関数の振る舞いはシステムの実装に大きく依存して異なります。
普通はファイルシステムにまたがってパス名を付け替えることはできません。
システムの I<mv> がこれを補完している場合でもそうです。
その他の制限には、ディレクトリ、オープンしているファイル、既に存在している
ファイルに対して使えるか、といったことを含みます。
詳しくは、L<perlport> および rename(2) man ページあるいは同様の
システムドキュメントを参照してください。

=begin original

For a platform independent C<move> function look at the L<File::Copy>
module.

=end original

プラットフォームに依存しない C<move> 関数については L<File::Copy> モジュールを
参照してください。

=item require VERSION
X<require>

=item require EXPR

=item require

=begin original

Demands a version of Perl specified by VERSION, or demands some semantics
specified by EXPR or by C<$_> if EXPR is not supplied.

=end original

VERSION で指定される Perl のバージョンを要求するか、
EXPR (省略時には C<$_>) によって指定されるいくつかの動作を要求します。

=begin original

VERSION may be either a numeric argument such as 5.006, which will be
compared to C<$]>, or a literal of the form v5.6.1, which will be compared
to C<$^V> (aka $PERL_VERSION).  An exception is raised if
VERSION is greater than the version of the current Perl interpreter.
Compare with L</use>, which can do a similar check at compile time.

=end original

VERSION は 5.006 のような数値(C<$]> と比較されます)か、v5.6.1 の形
(C<$^V> (またの名を $PERL_VERSION) と比較されます)で指定します。
VERSION が Perl の現在のバージョンより大きいと、例外が発生します。
L</use> と似ていますが、これはコンパイル時にチェックされます。

=begin original

Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.  The equivalent numeric
version should be used instead.

=end original

VERSION に v5.6.1 の形のリテラルを指定することは一般的には避けるべきです;
なぜなら、この文法に対応していない Perl の初期のバージョンでは
誤解させるようなエラーメッセージが出るからです。
代わりに等価な数値表現を使うべきです。

=begin original

    require v5.6.1;     # run time version check
    require 5.6.1;      # ditto
    require 5.006_001;  # ditto; preferred for backwards compatibility

=end original

    require v5.6.1;     # 実行時バージョンチェック
    require 5.6.1;      # 同様
    require 5.006_001;  # 同様; 後方互換性のためには望ましい

=begin original

Otherwise, C<require> demands that a library file be included if it
hasn't already been included.  The file is included via the do-FILE
mechanism, which is essentially just a variety of C<eval> with the
caveat that lexical variables in the invoking script will be invisible
to the included code.  Has semantics similar to the following subroutine:

=end original

それ以外の場合には、C<require> は、既に読み込まれていないときに読み込む
ライブラリファイルを要求するものとなります。
そのファイルは、基本的には C<eval> の一種である、do-FILE によって
読み込まれますが、起動したスクリプトのレキシカル変数は読み込まれたコードから
見えないという欠点があります。
意味的には、次のようなサブルーチンと同じようなものです:

    sub require {
       my ($filename) = @_;
       if (exists $INC{$filename}) {
           return 1 if $INC{$filename};
           die "Compilation failed in require";
       }
       my ($realfilename,$result);
       ITER: {
           foreach $prefix (@INC) {
               $realfilename = "$prefix/$filename";
               if (-f $realfilename) {
                   $INC{$filename} = $realfilename;
                   $result = do $realfilename;
                   last ITER;
               }
           }
           die "Can't find $filename in \@INC";
       }
       if ($@) {
           $INC{$filename} = undef;
           die $@;
       } elsif (!$result) {
           delete $INC{$filename};
           die "$filename did not return true value";
       } else {
           return $result;
       }
    }

=begin original

Note that the file will not be included twice under the same specified
name.

=end original

ファイルは、同じ名前で 2 回読み込まれることはないことに注意してください。

=begin original

The file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with C<1;> unless you're sure it'll return true
otherwise.  But it's better just to put the C<1;>, in case you add more
statements.

=end original

初期化コードの実行がうまくいったことを示すために、
ファイルは真を返さなければなりませんから、
真を返すようになっている自信がある場合を除いては、
ファイルの最後に C<1;> と書くのが習慣です。
実行文を追加するような場合に備えて、C<1;> と書いておいた方が
良いでしょう。

=begin original

If EXPR is a bareword, the require assumes a "F<.pm>" extension and
replaces "F<::>" with "F</>" in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace.

=end original

EXPR が裸の単語であるときには、標準モジュールのロードを
簡単にするように、require は拡張子が "F<.pm>" であり、
"F<::>" を "F</>" に変えたものがファイル名であると仮定します。
この形式のモジュールロードは、
名前空間を変更してしまう危険はありません。

=begin original

In other words, if you try this:

=end original

言い換えると、以下のようにすると:

        require Foo::Bar;     # a splendid bareword

=begin original

The require function will actually look for the "F<Foo/Bar.pm>" file in the
directories specified in the C<@INC> array.

=end original

require 関数は C<@INC> 配列で指定されたディレクトリにある
"F<Foo/Bar.pm>" ファイルを探します。

=begin original

But if you try this:

=end original

しかし、以下のようにすると:

        $class = 'Foo::Bar';
        require $class;       # $class is not a bareword
    #or
        require "Foo::Bar";   # not a bareword because of the ""

=begin original

The require function will look for the "F<Foo::Bar>" file in the @INC array and
will complain about not finding "F<Foo::Bar>" there.  In this case you can do:

=end original

require 関数は @INC 配列の "F<Foo::Bar>" ファイルを探し、
おそらくそこに "F<Foo::Bar>" がないと文句をいうことになるでしょう。
このような場合には、以下のようにします:

        eval "require $class";

=begin original

Now that you understand how C<require> looks for files with a
bareword argument, there is a little extra functionality going on behind
the scenes.  Before C<require> looks for a "F<.pm>" extension, it will
first look for a similar filename with a "F<.pmc>" extension. If this file
is found, it will be loaded in place of any file ending in a "F<.pm>"
extension.

=end original

引数が裸の単語の場合、C<require> がどのようにファイルを探すかを
理解してください; 水面下でちょっとした追加の機能があります。
C<require> が拡張子 "F<.pm>" のファイルを探す前に、まず拡張子 "F<.pmc>" を
持つファイルを探します。
このファイルが見つかると、このファイルが拡張子 "F<.pm>" の代わりに
読み込まれます。

=begin original

You can also insert hooks into the import facility by putting Perl code
directly into the @INC array.  There are three forms of hooks: subroutine
references, array references, and blessed objects.

=end original

@INC 配列に直接 Perl コードを入れることで、インポート機能にフックを
挿入できます。
3 種類のフックがあります: サブルーチンリファレンス、配列リファレンス、
bless されたオブジェクトです。

=begin original

Subroutine references are the simplest case.  When the inclusion system
walks through @INC and encounters a subroutine, this subroutine gets
called with two parameters, the first a reference to itself, and the
second the name of the file to be included (e.g., "F<Foo/Bar.pm>").  The
subroutine should return either nothing or else a list of up to three 
values in the following order:

=end original

サブルーチンへのリファレンスは一番単純な場合です。
インクルード機能が @INC を走査してサブルーチンに出会った場合、この
サブルーチンは二つの引数と共に呼び出されます;
一つ目は自身へのリファレンス、二つ目はインクルードされるファイル名
("F<Foo/Bar.pm>" など)です。
サブルーチンは C<undef> か、インクルードするファイルが読み込まれる
ファイルハンドルを返します。
サブルーチンは何も返さないか、以下の順で最大三つの値のリストを
返します。

=over

=item 1

=begin original

A filehandle, from which the file will be read.  

=end original

ファイルが読み込まれるファイルハンドル。

=item 2

=begin original

A reference to a subroutine. If there is no filehandle (previous item),
then this subroutine is expected to generate one line of source code per
call, writing the line into C<$_> and returning 1, then finally at end of
file returning 0.  If there is a filehandle, then the subroutine will be
called to act as a simple source filter, with the line as read in C<$_>.
Again, return 1 for each valid line, and 0 after all lines have been
returned.

=end original

サブルーチンへのリファレンス。
(一つ前のアイテムである)ファイルハンドルがない場合、
サブルーチンは呼び出し毎に一行のソースコードを生成し、その行を C<$_> に
書き込んで 1 を返し、それから最終的にファイル終端で 0 を返すものと
想定されます。
ファイルハンドルがある場合、サブルーチンは単純なソースフィルタとして
振舞うように呼び出され、行は C<$_> から読み込まれます。
再び、有効な行ごとに 1 を返し、全ての行を返した後では 0 を返します。

=item 3

=begin original

Optional state for the subroutine. The state is passed in as C<$_[1]>. A
reference to the subroutine itself is passed in as C<$_[0]>.

=end original

サブルーチンのための状態(オプション)。
状態は C<$_[1]> として渡されます。
サブルーチンへのリファレンス自身は C<$_[0]> として渡されます。

=back

=begin original

If an empty list, C<undef>, or nothing that matches the first 3 values above
is returned, then C<require> looks at the remaining elements of @INC.
Note that this filehandle must be a real filehandle (strictly a typeglob
or reference to a typeglob, whether blessed or unblessed); tied filehandles 
will be ignored and processing will stop there.

=end original

空リスト、C<undef>、または上記の最初の三つの値のどれとも一致しないものが
返されると、C<require> は @INC の残りの要素を見ます。
このファイルハンドルは実際のファイルハンドル(厳密には型グロブ、型グロブへの
リファレンス、bless されているかに関わらず)でなければなりません;
tie されたファイルハンドルは無視され、返り値の処理はそこで停止します。

=begin original

If the hook is an array reference, its first element must be a subroutine
reference.  This subroutine is called as above, but the first parameter is
the array reference.  This lets you indirectly pass arguments to
the subroutine.

=end original

フックが配列のリファレンスの場合、その最初の要素はサブルーチンへの
リファレンスでなければなりません。
このサブルーチンは上述のように呼び出されますが、その最初の引数は
配列のリファレンスです。
これによって、間接的にサブルーチンに引数を渡すことが出来ます。

=begin original

In other words, you can write:

=end original

言い換えると、以下のように書いたり:

    push @INC, \&my_sub;
    sub my_sub {
        my ($coderef, $filename) = @_;  # $coderef is \&my_sub
        ...
    }

=begin original

or:

=end original

または以下のように書けます:

    push @INC, [ \&my_sub, $x, $y, ... ];
    sub my_sub {
        my ($arrayref, $filename) = @_;
        # Retrieve $x, $y, ...
        my @parameters = @$arrayref[1..$#$arrayref];
        ...
    }

=begin original

If the hook is an object, it must provide an INC method that will be
called as above, the first parameter being the object itself.  (Note that
you must fully qualify the sub's name, as unqualified C<INC> is always forced
into package C<main>.)  Here is a typical code layout:

=end original

フックがオブジェクトの場合、INC メソッドを提供している必要があります;
それが、最初の引数をオブジェクト自身として上述のように呼び出されます。
(修飾されていない C<INC> は常にパッケージ C<main> に強制されるため、
サブルーチン名は完全修飾する必要があることに注意してください。)
以下は典型的なコードレイアウトです:

    # In Foo.pm
    package Foo;
    sub new { ... }
    sub Foo::INC {
        my ($self, $filename) = @_;
        ...
    }

    # In the main program
    push @INC, Foo->new(...);

=begin original

These hooks are also permitted to set the %INC entry
corresponding to the files they have loaded. See L<perlvar/%INC>.

=end original

これらのフックは、読み込まれるファイルに対応する %INC エントリを
セットすることも許可します。
L<perlvar/%INC> を参照してください。

=begin original

For a yet-more-powerful import facility, see L</use> and L<perlmod>.

=end original

より強力な import 機能については、このドキュメントの
L</use> の項と、L<perlmod> を参照してください。

=item reset EXPR
X<reset>

=item reset

=begin original

Generally used in a C<continue> block at the end of a loop to clear
variables and reset C<??> searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (C<?pattern?>) are reset to match again.  
Only resets variables or searches in the current package.  Always returns
1.  Examples:

=end original

通常、ループの最後に、変数をクリアし、C<??> 検索を再び
動作するようにリセットするため、C<continue> ブロックで使われます。
EXPR は、文字を並べたもの (範囲を指定するのに、ハイフンが使えます) と
解釈されます。
名前がその文字のいずれかで始まる変数や配列は、
最初の状態にリセットされます。
EXPR を省略すると、1 回検索 (C<?PATTERN?>) を再びマッチするように
リセットできます。
カレントパッケージの変数もしくは検索だけがリセットされます。
常に 1 を返します。
例:

    reset 'X';      # reset all X variables
    reset 'a-z';    # reset lower case variables
    reset;          # just reset ?one-time? searches

=begin original

Resetting C<"A-Z"> is not recommended because you'll wipe out your
C<@ARGV> and C<@INC> arrays and your C<%ENV> hash.  Resets only package
variables; lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.
See L</my>.

=end original

reset C<"A-Z"> とすると、C<@ARGV>, C<@INC> 配列や C<%ENV> ハッシュも
なくなってしまいますから、止めた方が良いでしょう。
パッケージ変数だけがリセットされます;
レキシカル変数は、影響を受けませんが、スコープから外れれば、
自動的に綺麗になりますので、これからは、こちらを使うようにした方が
よいでしょう。
L</my> を参照してください。

=item return EXPR
X<return>

=item return

=begin original

Returns from a subroutine, C<eval>, or C<do FILE> with the value
given in EXPR.  Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see C<wantarray>).  If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in void context.

=end original

サブルーチン, C<eval>, C<do FILE>  から EXPR で与えられた値をもって、
リターンします。
EXPR の評価は、返り値がどのように使われるかによって
リスト、スカラ、無効コンテキストになります。
またコンテキストは実行毎に変わります(C<wantarray> を参照してください)。
EXPR が指定されなかった場合は、リストコンテキストでは空リストを、
スカラコンテキストでは未定義値を返します。
そして(もちろん)無効コンテキストでは何も返しません。

=begin original

(In the absence of an explicit C<return>, a subroutine, eval,
or do FILE automatically returns the value of the last expression
evaluated.)

=end original

(サブルーチン, eval, do FILE に明示的に C<return> が
なければ、最後に評価された値で、自動的にリターンします。)

=item reverse LIST
X<reverse> X<rev> X<invert>

=begin original

In list context, returns a list value consisting of the elements
of LIST in the opposite order.  In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.

=end original

リストコンテキストでは、LIST を構成するよ要素を逆順に並べた
リスト値を返します。
スカラコンテキストでは、LIST の要素を連結して、
全ての文字を逆順にした文字列を返します。

    print join(", ", reverse "world", "Hello"); # Hello, world

    print scalar reverse "dlrow ,", "olleH";    # Hello, world

=begin original

Used without arguments in scalar context, reverse() reverses C<$_>.

=end original

スカラコンテキストで引数なしで使うと、reverse() は C<$_> を逆順にします。

    $_ = "dlrow ,olleH";
    print reverse;                              # No output, list context
    print scalar reverse;                       # Hello, world

=begin original

Note that reversing an array to itself (as in C<@a = reverse @a>) will
preserve non-existent elements whenever possible, i.e., for non magical
arrays or tied arrays with C<EXISTS> and C<DELETE> methods.

=end original

(C<@a = reverse @a> のように) 反転した配列を自分自身に代入すると、
存在しない要素は可能なら(つまりマジカルでない配列や
C<EXISTS> と C<DELETE> メソッドがある tie された配列)
いつでも保存されることに注意してください。

=begin original

This operator is also handy for inverting a hash, although there are some
caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.

=end original

この演算子はハッシュの逆順にするのにも便利ですが、いくつかの弱点があります。
元のハッシュで値が重複していると、それらのうち一つだけが
逆順になったハッシュのキーとして表現されます。
また、これは一つのハッシュをほどいて完全に新しいハッシュを作るので、
DBM ファイルからのような大きなハッシュでは少し時間がかかります。

    %by_name = reverse %by_address;  # Invert the hash

=item rewinddir DIRHANDLE
X<rewinddir>

=begin original

Sets the current position to the beginning of the directory for the
C<readdir> routine on DIRHANDLE.

=end original

DIRHANDLE に対する C<readdir> ルーチンの現在位置を
ディレクトリの最初に設定します。

=item rindex STR,SUBSTR,POSITION
X<rindex>

=item rindex STR,SUBSTR

=begin original

Works just like index() except that it returns the position of the I<last>
occurrence of SUBSTR in STR.  If POSITION is specified, returns the
last occurrence beginning at or before that position.

=end original

STR 中で I<最後に> 見つかった SUBSTR の位置を返すことを除いて、
index() と同じように動作します。
POSITION を指定すると、その位置から始まるか、その位置より前の、
最後の位置を返します。

=item rmdir FILENAME
X<rmdir> X<rd> X<directory, remove>

=item rmdir

=begin original

Deletes the directory specified by FILENAME if that directory is
empty.  If it succeeds it returns true; otherwise it returns false and
sets C<$!> (errno).  If FILENAME is omitted, uses C<$_>.

=end original

FILENAME で指定したディレクトリが空であれば、
そのディレクトリを削除します。
成功時には真を返します; さもなければ偽を返し、C<$!> (errno) を設定します。
FILENAME を省略した場合には、C<$_> を使用します。

=begin original

To remove a directory tree recursively (C<rm -rf> on Unix) look at
the C<rmtree> function of the L<File::Path> module.

=end original

ディレクトリツリーを再帰的に削除したい (Unix での C<rm -rf>) 場合、
L<File::Path> モジュールの C<rmtree> 関数を参照してください。

=item s///

=begin original

The substitution operator.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

置換演算子。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item say FILEHANDLE LIST
X<say>

=item say FILEHANDLE

=item say LIST

=item say

=begin original

Just like C<print>, but implicitly appends a newline.  C<say LIST> is
simply an abbreviation for C<{ local $\ = "\n"; print LIST }>.  To use
FILEHANDLE without a LIST to print the contents of C<$_> to it, you must
use a real filehandle like C<FH>, not an indirect one like C<$fh>.

=end original

C<print> と同様ですが、暗黙に改行が追加されます。
C<say LIST> は単に C<{ local $\ = "\n"; print LIST }> の省略形です。
C<$_> の内容を表示するために LIST なしで FILEHANDLE を使用するには、
C<$fh> のような間接ファイルハンドルではなく、C<FH> のような実際の
ファイルハンドルを使わなければなりません。

=begin original

This keyword is available only when the C<"say"> feature is enabled; see
L<feature>.  Alternately, include a C<use v5.10> or later to the current
scope.

=end original

このキーワードは、C<"say"> 機能が有効の場合にのみ利用可能です;
L<feature> を参照してください。
あるいは、現在のスコープに C<use v5.10> 以降を含めてください。

=item scalar EXPR
X<scalar> X<context>

=begin original

Forces EXPR to be interpreted in scalar context and returns the value
of EXPR.

=end original

EXPR を強制的にスカラコンテキストで解釈されるようにして、
EXPR の値を返します。

    @counts = ( scalar @a, scalar @b, scalar @c );

=begin original

There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.  If you really wanted to do so, however, you could use
the construction C<@{[ (some expression) ]}>, but usually a simple
C<(some expression)> suffices.

=end original

式を強制的にリストコンテキストで解釈させるようにする演算子はありません。
理論的には不要だからです。
それでも、もしそうしたいのなら、C<@{[ (some expression) ]}> という構造を
使えます。
しかし、普通は単に C<(some expression)> とすれば十分です。

=begin original

Because C<scalar> is a unary operator, if you accidentally use a
parenthesized list for the EXPR, this behaves as a scalar comma expression,
evaluating all but the last element in void context and returning the final
element evaluated in scalar context.  This is seldom what you want.

=end original

C<scalar> は単項演算子なので、EXPR として括弧でくくったリストを使った場合、
これはスカラカンマ表現として振舞い、最後以外の全ては無効コンテキストとして
扱われ、最後の要素をスカラコンテキストとして扱った結果が返されます。
これがあなたの望むものであることはめったにないでしょう。

=begin original

The following single statement:

=end original

以下の一つの文は:

    print uc(scalar(&foo,$bar)),$baz;

=begin original

is the moral equivalent of these two:

=end original

以下の二つの文と等価です。

    &foo;
    print(uc($bar),$baz);

=begin original

See L<perlop> for more details on unary operators and the comma operator.

=end original

単項演算子とカンマ演算子に関する詳細については L<perlop> を参照して下さい。

=item seek FILEHANDLE,POSITION,WHENCE
X<seek> X<fseek> X<filehandle, position>

=begin original

Sets FILEHANDLE's position, just like the C<fseek> call of C<stdio>.
FILEHANDLE may be an expression whose value gives the name of the
filehandle.  The values for WHENCE are C<0> to set the new position
I<in bytes> to POSITION; C<1> to set it to the current position plus
POSITION; and C<2> to set it to EOF plus POSITION, typically
negative.  For WHENCE you may use the constants C<SEEK_SET>,
C<SEEK_CUR>, and C<SEEK_END> (start of the file, current position, end
of the file) from the L<Fcntl> module.  Returns C<1> on success, false
otherwise.

=end original

C<stdio> ライブラリの C<fseek> 関数のように、FILEHANDLE の
ファイルポインタを任意の位置に設定します。
FILEHANDLE は、実際のファイルハンドル名を与える式でもかまいません。
WHENCE の値が、C<0> ならば、新しい位置を I<バイト単位で> POSITION の位置へ
設定します; C<1> ならば、現在位置から I<バイト数で> POSITION 加えた位置へ
設定します; C<2> ならば、EOF からPOSITION だけ加えた位置へ、新しい位置を
設定します。
この値には、L<Fcntl> モジュールで使われている C<SEEK_SET>、C<SEEK_CUR>、
C<SEEK_END> (ファイルの先頭、現在位置、ファイルの最後)という定数を
使うこともできます。
成功時には、C<1> を、失敗時には C<0> を返します。

=begin original

Note the I<in bytes>: even if the filehandle has been set to
operate on characters (for example by using the C<:encoding(utf8)> open
layer), tell() will return byte offsets, not character offsets
(because implementing that would render seek() and tell() rather slow).

=end original

I<バイト単位> に関する注意: ファイルハンドルが (例えば C<:encoding(utf8)> 層を
使って)文字を操作するように設定されていたとしても、tell() は文字の
オフセットではなくバイトのオフセットを返すことに注意してください
(なぜならこれを実装すると seek() と tell() が遅くなってしまうからです)。

=begin original

If you want to position the file for C<sysread> or C<syswrite>, don't use
C<seek>, because buffering makes its effect on the file's read-write position
unpredictable and non-portable.  Use C<sysseek> instead.

=end original

C<sysread> や C<syswrite> のためにファイルの位置を指定したい場合は、
C<seek> は使えません; なぜならバッファリングのためにファイルの読み込み位置は
動作は予測不能で移植性のないものになってしまいます。
代わりに C<sysseek> を使ってください。

=begin original

Due to the rules and rigors of ANSI C, on some systems you have to do a
seek whenever you switch between reading and writing.  Amongst other
things, this may have the effect of calling stdio's clearerr(3).
A WHENCE of C<1> (C<SEEK_CUR>) is useful for not moving the file position:

=end original

ANSI C の規則と困難により、システムによっては読み込みと書き込みを
切り替える度にシークしなければならない場合があります。
その他のことの中で、これは stdio の clearerr(3) を呼び出す効果があります。
WHENCE の C<1> (C<SEEK_CUR>) が、ファイル位置を変えないので有用です:

    seek(TEST,0,1);

=begin original

This is also useful for applications emulating C<tail -f>.  Once you hit
EOF on your read and then sleep for a while, you (probably) have to stick in a
dummy seek() to reset things.  The C<seek> doesn't change the position,
but it I<does> clear the end-of-file condition on the handle, so that the
next C<< <FILE> >> makes Perl try again to read something.  (We hope.)

=end original

これはアプリケーションで C<tail -f> をエミュレートするのにも有用です。
一度読み込み時に EOF に到達すると、しばらくスリープし、
(おそらく) ダミーの seek() をすることでリセットする必要があります。
C<seek> は現在の位置を変更しませんが、ハンドルの EOF 状態を
I<クリアします> ので、次の C<< <FILE> >> で Perl は再び何かを
読み込もうとします。(そのはずです。)

=begin original

If that doesn't work (some I/O implementations are particularly
cantankerous), you might need something like this:

=end original

これが動かない場合(特に意地の悪い I/O 実装もあります)、
以下のようなことをする必要があります:

    for (;;) {
        for ($curpos = tell(FILE); $_ = <FILE>;
             $curpos = tell(FILE)) {
            # search for some stuff and put it into files
        }
        sleep($for_a_while);
        seek(FILE, $curpos, 0);
    }

=item seekdir DIRHANDLE,POS
X<seekdir>

=begin original

Sets the current position for the C<readdir> routine on DIRHANDLE.  POS
must be a value returned by C<telldir>.  C<seekdir> also has the same caveats
about possible directory compaction as the corresponding system library
routine.

=end original

DIRHANDLE での C<readdir> ルーチンの現在位置を設定します。
POS は、C<telldir> が返す値でなければなりません。
C<seekdir> は同名のシステムライブラリルーチンと同じく、
ディレクトリ縮小時の問題が考えられます。

=item select FILEHANDLE
X<select> X<filehandle, default>

=item select

=begin original

Returns the currently selected filehandle.  If FILEHANDLE is supplied,
sets the new current default filehandle for output.  This has two
effects: first, a C<write> or a C<print> without a filehandle 
default to this FILEHANDLE.  Second, references to variables related to
output will refer to this output channel.  

=end original

その時点で、選択されていたファイルハンドルを返します。
FILEHANDLE を指定した場合には、その値を出力のデフォルト
ファイルハンドルに設定します。
これには、2 つの効果があります。
まず、ファイルハンドルを指定しないで
C<write> や C<print> を行なった場合のデフォルトが、
この FILEHANDLE になります。
もう一つは、出力関連の変数への参照は、
この出力チャネルを参照するようになります。

=begin original

For example, to set the top-of-form format for more than one
output channel, you might do the following:

=end original

例えば、複数の出力チャネルに対して、ページ先頭フォーマットを
設定するには:

    select(REPORT1);
    $^ = 'report1_top';
    select(REPORT2);
    $^ = 'report2_top';

=begin original

FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.  Thus:

=end original

FILEHANDLE は、実際のファイルハンドルの名前を示す式でもかまいません。
つまり、以下のようなものです:

    $oldfh = select(STDERR); $| = 1; select($oldfh);

=begin original

Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:

=end original

ファイルハンドルはメソッドを持ったオブジェクトであると
考えることを好むプログラマもいるかもしれません。
そのような場合のための最後の例は以下のようなものです。

    use IO::Handle;
    STDERR->autoflush(1);

=item select RBITS,WBITS,EBITS,TIMEOUT
X<select>

=begin original

This calls the select(2) syscall with the bit masks specified, which
can be constructed using C<fileno> and C<vec>, along these lines:

=end original

これは、select(2) システムコールを、指定したビットマスクで呼び出します。
ビットマスクは、C<fileno> と C<vec> を使って、以下のようにして
作成できます:

    $rin = $win = $ein = '';
    vec($rin,fileno(STDIN),1) = 1;
    vec($win,fileno(STDOUT),1) = 1;
    $ein = $rin | $win;

=begin original

If you want to select on many filehandles, you may wish to write a
subroutine like this:

=end original

複数のファイルハンドルに select を行ないたいのであれば、
以下のようにします:

    sub fhbits {
        my(@fhlist) = split(' ',$_[0]);
        my($bits);
        for (@fhlist) {
            vec($bits,fileno($_),1) = 1;
        }
        $bits;
    }
    $rin = fhbits('STDIN TTY SOCK');

=begin original

The usual idiom is:

=end original

通常は、

    ($nfound,$timeleft) =
      select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

=begin original

or to block until something becomes ready just do this

=end original

のように使い、いずれかの準備が整うまでブロックするには、
以下のようにします。

    $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

=begin original

Most systems do not bother to return anything useful in $timeleft, so
calling select() in scalar context just returns $nfound.

=end original

ほとんどのシステムではわざわざ意味のある値を $timeleft に返さないので、
select() をスカラコンテキストで呼び出すと、単に $nfound を返します。

=begin original

Any of the bit masks can also be undef.  The timeout, if specified, is
in seconds, which may be fractional.  Note: not all implementations are
capable of returning the $timeleft.  If not, they always return
$timeleft equal to the supplied $timeout.

=end original

どのビットマスクにも undef を設定することができます。
TIMEOUT を指定するときは、秒数で指定し、小数でかまいません。
注: すべての実装で、$timeleft が返せるものではありません。
その場合、$timeleft には、常に指定した TIMEOUT と同じ値が返されます。

=begin original

You can effect a sleep of 250 milliseconds this way:

=end original

250 ミリ秒の sleep と同じ効果が、以下のようにして得られます。

    select(undef, undef, undef, 0.25);

=begin original

Note that whether C<select> gets restarted after signals (say, SIGALRM)
is implementation-dependent.  See also L<perlport> for notes on the
portability of C<select>.

=end original

C<select> がシグナル (例えば、SIGALRM) の後に再起動するかどうかは
実装依存であることに注意してください。
C<select> の移植性に関する注意については L<perlport> も参照してください。

=begin original

On error, C<select> behaves like select(2): it returns
-1 and sets C<$!>.

=end original

エラー時は、C<select> は select(2) のように振舞います:
-1 を返し、C<$!> をセットします。

=begin original

On some Unixes, select(2) may report a socket file descriptor as "ready for
reading" even when no data is available, and thus any subsequent C<read>
would block. This can be avoided if you always use O_NONBLOCK on the
socket. See select(2) and fcntl(2) for further details.

=end original

Unix の中には、実際に利用可能なデータがないために引き続く C<read> が
ブロックされる場合でも、select(2) が、ソケットファイル記述子が
「読み込み準備中」であると報告するものもあります。
これは、ソケットに対して常に O_NONBLOCK フラグを使うことで回避できます。
さらなる詳細については select(2) と fcntl(2) を参照してください。

=begin original

B<WARNING>: One should not attempt to mix buffered I/O (like C<read>
or <FH>) with C<select>, except as permitted by POSIX, and even
then only on POSIX systems.  You have to use C<sysread> instead.

=end original

B<警告>: バッファ付き I/O (C<read> や <FH>) と C<select> を
混ぜて使ってはいけません(例外: POSIX で認められている形で使い、
POSIX システムでだけ動かす場合を除きます)。
代わりに C<sysread> を使わなければなりません。

=item semctl ID,SEMNUM,CMD,ARG
X<semctl>

=begin original

Calls the System V IPC function semctl(2).  You'll probably have to say

=end original

System V IPC 関数 semctl(2) を呼び出します。
正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is IPC_STAT or
GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.  Returns like C<ioctl>:
the undefined value for error, "C<0 but true>" for zero, or the actual
return value otherwise.  The ARG must consist of a vector of native
short integers, which may be created with C<pack("s!",(0)x$nsem)>.
See also L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::Semaphore>
documentation.

=end original

と宣言する必要があるでしょう。
CMD が、IPC_STAT か GETALL のときには、ARG は、返される
semid_ds 構造体か、セマフォ値の配列を納める変数でなければなりません。
C<ioctl> と同じように、エラー時には未定義値、
ゼロのときは C<"0 だが真">、それ以外なら、その値そのものを返します。
ARG はネイティブな short int のベクターから成っていなければなりません。
これは C<pack("s!",(0)x$nsem)> で作成できます。
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::Semaphore> も参照してください。

=item semget KEY,NSEMS,FLAGS
X<semget>

=begin original

Calls the System V IPC function semget(2).  Returns the semaphore id, or
the undefined value on error.  See also
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore>
documentation.

=end original

System V IPC 関数 semget(2) を呼び出します。
セマフォ ID か、エラー時には未定義値を返します。
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore> も
参照してください。

=item semop KEY,OPSTRING
X<semop>

=begin original

Calls the System V IPC function semop(2) for semaphore operations
such as signalling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with
C<pack("s!3", $semnum, $semop, $semflag)>.  The length of OPSTRING 
implies the number of semaphore operations.  Returns true if
successful, false on error.  As an example, the
following code waits on semaphore $semnum of semaphore id $semid:

=end original

シグナルを送信や、待ち合わせなどのセマフォ操作を行なうために、
System V IPC 関数 semop(2) を呼び出します。
OPSTRING は、semop 構造体の pack された配列でなければなりません。
semop 構造体は、それぞれ、
C<pack("s!3", $semnum, $semop, $semflag)> のように作ることができます。
セマフォ操作の数は、OPSTRING の長さからわかります。
成功時には真を、エラー時には偽を返します。
以下の例は、セマフォ ID $semid のセマフォ $semnum で
待ち合わせを行ないます。

    $semop = pack("s!3", $semnum, -1, 0);
    die "Semaphore trouble: $!\n" unless semop($semid, $semop);

=begin original

To signal the semaphore, replace C<-1> with C<1>.  See also
L<perlipc/"SysV IPC">, C<IPC::SysV>, and C<IPC::SysV::Semaphore>
documentation.

=end original

セマフォにシグナルを送るには、C<-1> を C<1> に変更してください。
L<perlipc/"SysV IPC">, C<IPC::SysV>, C<IPC::SysV::Semaphore> も
参照してください。

=item send SOCKET,MSG,FLAGS,TO
X<send>

=item send SOCKET,MSG,FLAGS

=begin original

Sends a message on a socket.  Attempts to send the scalar MSG to the SOCKET
filehandle.  Takes the same flags as the system call of the same name.  On
unconnected sockets, you must specify a destination to I<send to>, in which
case it does a sendto(2) syscall.  Returns the number of characters sent,
or the undefined value on error.  The sendmsg(2) syscall is currently
unimplemented.  See L<perlipc/"UDP: Message Passing"> for examples.

=end original

ソケットにメッセージを送ります。
スカラ MSG を ファイルハンドル SOCKET に送ろうとします。
同名のシステムコールと同じフラグが指定できます。
接続していないソケットには、I<send to> に接続先を指定しなければならず、
この場合、sendto(2) を実行します。
送信した文字数か、エラー時には、未定義値を返します。
システムコール sendmsg(2) は現在実装されていません。
例については L<perlipc/"UDP: Message Passing"> を参照してください。

=begin original

Note the I<characters>: depending on the status of the socket, either
(8-bit) bytes or characters are sent.  By default all sockets operate
on bytes, but for example if the socket has been changed using
binmode() to operate with the C<:encoding(utf8)> I/O layer (see
L</open>, or the C<open> pragma, L<open>), the I/O will operate on UTF-8
encoded Unicode characters, not bytes.  Similarly for the C<:encoding>
pragma: in that case pretty much any characters can be sent.

=end original

I<文字> に関する注意: ソケットの状態によって、(8 ビットの) バイトか
文字を送信します。
デフォルトでは全てのソケットはバイトを処理しますが、
例えばソケットが binmode() で C<:encoding(utf8)> I/O 層(L</open>、
C<open> プラグマ、L<open> を参照してください) を使うように指定された場合、
I/O はバイトではなく、UTF-8 エンコードされた Unicode 文字を操作します。
C<:encoding> プラグマも同様です:
この場合、ほとんど大体全ての文字が書き込めます。

=item setpgrp PID,PGRP
X<setpgrp> X<group>

=begin original

Sets the current process group for the specified PID, C<0> for the current
process.  Raises an exception when used on a machine that doesn't
implement POSIX setpgid(2) or BSD setpgrp(2).  If the arguments are omitted,
it defaults to C<0,0>.  Note that the BSD 4.2 version of C<setpgrp> does not
accept any arguments, so only C<setpgrp(0,0)> is portable.  See also
C<POSIX::setsid()>.

=end original

指定した PID (C<0> を指定するとカレントプロセス) に
対するプロセスグループを設定します。
POSIX setpgrp(2) または BSD setpgrp(2) が実装されていないマシンでは、
例外が発生します。
引数が省略された場合は、C<0,0>が使われます。
BSD 4.2 版の C<setpgrp> は引数を取ることができないので、
C<setpgrp(0,0)> のみが移植性があることに注意してください。
C<POSIX::setsid()> も参照してください。

=item setpriority WHICH,WHO,PRIORITY
X<setpriority> X<priority> X<nice> X<renice>

=begin original

Sets the current priority for a process, a process group, or a user.
(See setpriority(2).)  Raises an exception when used on a machine
that doesn't implement setpriority(2).

=end original

プロセス、プロセスグループ、ユーザに対する優先順位を設定します。
(setpriority(2) を参照してください。)
setpriority(2) が実装されていないマシンでは、
例外が発生します。

=item setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
X<setsockopt>

=begin original

Sets the socket option requested.  Returns C<undef> on error.
Use integer constants provided by the C<Socket> module for
LEVEL and OPNAME.  Values for LEVEL can also be obtained from
getprotobyname.  OPTVAL might either be a packed string or an integer.
An integer OPTVAL is shorthand for pack("i", OPTVAL).

=end original

要求したソケットオプションを設定します。
エラー時には、C<undef> を返します。
LEVEL と OPNAME には C<Socket> モジュールが提供する整数定数を使います。
LEVEL の値は getprotobyname から得ることもできます。
OPTVAL は pack された文字列か整数です。
整数の OPTVAL は pack("i", OPTVAL) の省略表現です。

=begin original

An example disabling Nagle's algorithm on a socket:

=end original

ソケットに対する Nagle のアルゴリズムを無効にする例です:

    use Socket qw(IPPROTO_TCP TCP_NODELAY);
    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);

=item shift ARRAY
X<shift>

=item shift EXPR

=item shift

=begin original

Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.  If there are no elements in the
array, returns the undefined value.  If ARRAY is omitted, shifts the
C<@_> array within the lexical scope of subroutines and formats, and the
C<@ARGV> array outside a subroutine and also within the lexical scopes
established by the C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}>,
C<UNITCHECK {}>, and C<END {}> constructs.

=end original

配列の最初の値を取り出して、その値を返し、配列を一つ
短くして、すべての要素を前へずらします。
配列に要素がなければ、未定義値を返します。
ARRAY を省略すると、
サブルーチンやフォーマットのレキシカルスコープでは C<@_> を、
サブルーチンの外側で、C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}>,
C<UNITCHECK {}>, C<END {}> で作成されたレキシカルスコープでは
C<@ARGV> が用いられます。

=begin original

Starting with Perl 5.14, C<shift> can take a scalar EXPR, which must hold a
reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of C<shift> is considered highly experimental.
The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<shift> はスカラの EXPR を取ることができるようになりました;
これは bless されていない配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<shift> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

=begin original

See also C<unshift>, C<push>, and C<pop>.  C<shift> and C<unshift> do the
same thing to the left end of an array that C<pop> and C<push> do to the
right end.

=end original

C<unshift>、C<push>、C<pop> も参照してください。
C<shift> と C<unshift> は、C<pop> と
C<push> が配列の右端で行なうことを、左端で行ないます。

=item shmctl ID,CMD,ARG
X<shmctl>

=begin original

Calls the System V IPC function shmctl.  You'll probably have to say

=end original

System V IPC 関数 shmctl を呼び出します。正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<shmid_ds>
structure.  Returns like ioctl: C<undef> for error; "C<0> but
true" for zero; and the actual return value otherwise.
See also L<perlipc/"SysV IPC"> and C<IPC::SysV> documentation.

=end original

と宣言する必要があるでしょう。
CMD が、C<IPC_STAT> ならば、ARG は、返される C<shmid_ds> 構造体を
納める変数でなければなりません。
ioctl と同様です: エラー時には C<undef>; ゼロのときは "C<0> だが真";
それ以外なら、その値そのものを返します。
L<perlipc/"SysV IPC"> と C<IPC::SysV> も参照してください。

=item shmget KEY,SIZE,FLAGS
X<shmget>

=begin original

Calls the System V IPC function shmget.  Returns the shared memory
segment id, or C<undef> on error.
See also L<perlipc/"SysV IPC"> and C<IPC::SysV> documentation.

=end original

System V IPC 関数 shmget を呼び出します。
共有メモリのセグメント ID か、エラー時には C<undef> を返します。
L<perlipc/"SysV IPC"> と C<IPC::SysV> も参照してください。

=item shmread ID,VAR,POS,SIZE
X<shmread>
X<shmwrite>

=item shmwrite ID,STRING,POS,SIZE

=begin original

Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable that will
hold the data read.  When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.  Return true if successful, false on error.
shmread() taints the variable. See also L<perlipc/"SysV IPC">,
C<IPC::SysV>, and the C<IPC::Shareable> module from CPAN.

=end original

System V 共有メモリセグメント ID に対し、アタッチして、
コピーを行ない、デタッチするという形で、位置 POS から、
サイズ SIZE だけ、読み込みか書き込みを行ないます。
読み込み時には、VAR は読み込んだデータを納める
変数でなければなりません。
書き込み時には、STRING が長すぎても、SIZE バイトだけが使われます。
STRING が短すぎる場合には、SIZE バイトを埋めるために、
ヌル文字が書き込まれます。
成功時には真を、エラー時には偽を返します。
shmread() は変数を汚染します。
L<perlipc/"SysV IPC"> および C<IPC::SysV> と、
CPAN の C<IPC::Shareable> も参照してください。

=item shutdown SOCKET,HOW
X<shutdown>

=begin original

Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the syscall of the same name.

=end original

同名のシステムコールと同じように解釈される HOW によって、
指定された方法でソケット接続のシャットダウンを行ないます。

    shutdown(SOCKET, 0);    # I/we have stopped reading data
    shutdown(SOCKET, 1);    # I/we have stopped writing data
    shutdown(SOCKET, 2);    # I/we have stopped using this socket

=begin original

This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.
It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.

=end original

これは、こちらがソケットを書き終わったが読み終わっていない、
またはその逆を相手側に伝えたいときに便利です。
これはその他のプロセスでフォークしたファイル記述子のコピーも
無効にするので、よりしつこい閉じ方です。

=begin original

Returns C<1> for success; on error, returns C<undef> if
the first argument is not a valid filehandle, or returns C<0> and sets
C<$!> for any other failure.

=end original

成功時には C<1> を返します;
エラーの場合、最初の引数が有効なファイルハンドルでない場合は C<undef> を
返し、その他のエラーの場合は C<0> を返してC<$!> をセットします。

=item sin EXPR
X<sin> X<sine> X<asin> X<arcsine>

=item sin

=begin original

Returns the sine of EXPR (expressed in radians).  If EXPR is omitted,
returns sine of C<$_>.

=end original

(ラジアンで示した) EXPR の正弦を返します。
EXPR が省略されたときには、C<$_> の正弦を返します。

=begin original

For the inverse sine operation, you may use the C<Math::Trig::asin>
function, or use this relation:

=end original

逆正弦を求めるためには、C<Math::Trig::asin> 関数を使うか、
以下の関係を使ってください:

    sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }

=item sleep EXPR
X<sleep> X<pause>

=item sleep

=begin original

Causes the script to sleep for (integer) EXPR seconds, or forever if no 
argument is given.  Returns the integer number of seconds actually slept.  

=end original

スクリプトを(整数の) EXPR で指定した秒数 (省略時には、永久に)
スリープさせます。
実際にスリープした秒数を返します。

=begin original

May be interrupted if the process receives a signal such as C<SIGALRM>.

=end original

そのプロセスが C<SIGALRM>のようなシグナルを受信すると、
割り込みがかかります。

    eval {
        local $SIG{ALARM} = sub { die "Alarm!\n" };
        sleep;
    };
    die $@ unless $@ eq "Alarm!\n";

=begin original

You probably cannot mix C<alarm> and C<sleep> calls, because C<sleep>
is often implemented using C<alarm>.

=end original

C<sleep> は、C<alarm> を使って実装されることが多いので、C<alarm> と
C<sleep> は、混ぜて使用することはおそらくできません。

=begin original

On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.  They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.

=end original

古いシステムでは、どのように秒を数えるかによって、要求した秒数に完全に
満たないうちに、スリープから抜ける場合があります。
最近のシステムでは、常に完全にスリープします。
しかし、負荷の高いマルチタスクシステムでは
正しくスケジューリングされないがために
より長い時間スリープすることがあります。

=begin original

For delays of finer granularity than one second, the Time::HiRes module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides usleep().  You may also use Perl's four-argument
version of select() leaving the first three arguments undefined, or you
might be able to use the C<syscall> interface to access setitimer(2) if
your system supports it. See L<perlfaq8> for details.

=end original

1 秒より精度の高いスリープを行なうには、
Time::HiRes モジュール(CPAN から、また Perl 5.8 からは
標準配布されています) が usleep() を提供します。
Perl の 4 引数版 select() を最初の 3 引数を未定義にして使うか、
setitimer(2) をサポートしているシステムでは、Perl の
C<syscall> インタフェースを使ってアクセスすることもできます。
詳しくは L<perlfaq8> を参照してください。

=begin original

See also the POSIX module's C<pause> function.

=end original

POSIX モジュールの C<pause> 関数も参照して下さい。

=item socket SOCKET,DOMAIN,TYPE,PROTOCOL
X<socket>

=begin original

Opens a socket of the specified kind and attaches it to filehandle
SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified the same as for
the syscall of the same name.  You should C<use Socket> first
to get the proper definitions imported.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

指定した種類のソケットをオープンし、ファイルハンドル
SOCKET にアタッチします。
DOMAIN、TYPE、PROTOCOL は、
同名のシステムコールと同じように指定します。
適切な定義を import するために、まず、C<use Socket> と
するとよいでしょう。
例については L<perlipc/"Sockets: Client/Server Communication"> を
参照してください。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは $^F の値で決定される、新しくオープンされたファイル記述子に対して
セットされます。
L<perlvar/$^F> を参照してください。

=item socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
X<socketpair>

=begin original

Creates an unnamed pair of sockets in the specified domain, of the
specified type.  DOMAIN, TYPE, and PROTOCOL are specified the same as
for the syscall of the same name.  If unimplemented, raises an exception.
Returns true if successful.

=end original

指定した DOMAIN に、指定した TYPE で名前の無いソケットのペアを生成します。
DOMAIN、TYPE、PROTOCOL は、同名のシステムコールと同じように指定します。
実装されていない場合には、例外が発生します。
成功時には真を返します。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptors, as determined by the value
of $^F.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは $^F の値で決定される、新しくオープンされたファイル記述子に対して
セットされます。
L<perlvar/$^F> を参照してください。

=begin original

Some systems defined C<pipe> in terms of C<socketpair>, in which a call
to C<pipe(Rdr, Wtr)> is essentially:

=end original

C<pipe> を C<socketpair> を使って定義しているシステムもあります;
C<pipe(Rdr, Wtr)> は本質的には以下のようになります:

    use Socket;
    socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    shutdown(Rdr, 1);        # no more writing for reader
    shutdown(Wtr, 0);        # no more reading for writer

=begin original

See L<perlipc> for an example of socketpair use.  Perl 5.8 and later will
emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.

=end original

socketpair の使用例については L<perlipc> を参照してください。
Perl 5.8 以降では、システムがソケットを実装しているが socketpair を
実装していない場合、localhost に対して IP ソケットを使うことで
socketpair をエミュレートします。

=item sort SUBNAME LIST
X<sort> X<qsort> X<quicksort> X<mergesort>

=item sort BLOCK LIST

=item sort LIST

=begin original

In list context, this sorts the LIST and returns the sorted list value.
In scalar context, the behaviour of C<sort()> is undefined.

=end original

リストコンテキストでは、LIST をソートし、ソートされたリスト値を返します。
スカラコンテキストでは、C<sort()> の振る舞いは未定義です。

=begin original

If SUBNAME or BLOCK is omitted, C<sort>s in standard string comparison
order.  If SUBNAME is specified, it gives the name of a subroutine
that returns an integer less than, equal to, or greater than C<0>,
depending on how the elements of the list are to be ordered.  (The 
C<< <=> >> and C<cmp> operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.  In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.

=end original

SUBNAME や BLOCK を省略すると、標準の文字列比較の順番でソートが
行なわれます。
SUBNAME を指定すると、それは、リストの要素をどのような順番に並べるかに
応じて、負、ゼロ、正の整数を返すサブルーチンの名前であると解釈されます。
(このようなルーチンには、C<< <=> >> 演算子や cmp 演算子が、
たいへん便利です。)
SUBNAME は、スカラ変数名(添字なし)でもよく、
その場合には、その値が使用する実際のサブルーチンの
名前(またはそのリファレンス)と解釈されます。
SUBNAME の代わりに、無名のインライン
ソートルーチンとして、BLOCK を書くことができます。

=begin original

If the subroutine's prototype is C<($$)>, the elements to be compared are
passed by reference in C<@_>, as for a normal subroutine.  This is slower
than unprototyped subroutines, where the elements to be compared are passed
into the subroutine as the package global variables $a and $b (see example
below).  Note that in the latter case, it is usually highly counter-productive
to declare $a and $b as lexicals.

=end original

サブルーチンのプロトタイプが C<($$)>の場合、
比較する要素は通常のサブルーチンと同じように C<@_> の中に
リファレンスとして渡されます。
これはプロトタイプなしのサブルーチンより遅いです。
この場合は比較のためサブルーチンに渡される二つの
要素は、パッケージのグローバル変数 $a と $b で渡されます
(次の例を参照してください)。
後者の場合、レキシカルに $a と $b を宣言するのは普通とても逆効果になります。

=begin original

The values to be compared are always passed by reference and should not
be modified.

=end original

$a や $b はリファレンスによって渡されるので、変更するべきではありません。

=begin original

You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in L<perlsyn> or with C<goto>.

=end original

また、ソートブロックやサブルーチンから L<perlsyn> で説明されている
ループ制御子や C<goto> を使って抜けてはいけません。

=begin original

When C<use locale> is in effect, C<sort LIST> sorts LIST according to the
current collation locale.  See L<perllocale>.

=end original

C<use locale> が有効の場合、C<sort LIST> は LIST を現在の比較ロケールに
従ってソートします。L<perllocale> を参照して下さい。

=begin original

sort() returns aliases into the original list, much as a for loop's index
variable aliases the list elements.  That is, modifying an element of a
list returned by sort() (for example, in a C<foreach>, C<map> or C<grep>)
actually modifies the element in the original list.  This is usually
something to be avoided when writing clear code.

=end original

sort() は元のリストへのエイリアスを返します; for ループのインデックス変数が
リスト要素へのエイリアスと同様です。
つまり、sort() で返されるリストの要素を(例えば、C<foreach> や C<map> や
C<grep> で)変更すると、実際に元のリストの要素が変更されます。
これはきれいなコードを書くことで普通は回避できます。

=begin original

Perl 5.6 and earlier used a quicksort algorithm to implement sort.
That algorithm was not stable, so I<could> go quadratic.  (A I<stable> sort
preserves the input order of elements that compare equal.  Although
quicksort's run time is O(NlogN) when averaged over all arrays of
length N, the time can be O(N**2), I<quadratic> behavior, for some
inputs.)  In 5.7, the quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).
But benchmarks indicated that for some inputs, on some platforms,
the original quicksort was faster.  5.8 has a sort pragma for
limited control of the sort.  Its rather blunt control of the
underlying algorithm may not persist into future Perls, but the
ability to characterize the input or output in implementation
independent ways quite probably will.  See L<the sort pragma|sort>.

=end original

Perl 5.6 以前ではソートの実装にクイックソートアルゴリズムを使っていました。
このアルゴリズムは安定していないので、2 乗の時間が掛かる
I<可能性があります>。
(I<安定した> ソートは、比較した時に同じ要素の入力順が保存されます。
クイックソートの実行時間は、長さ N の全ての配列の平均では
O(NlogN) ですが、入力によっては O(N**2) という I<2 乗の> 振る舞いを
することがあります。)
5.7 では、クイックソートによる実装は、最悪の場合の振る舞いも
O(NlogN) である、安定したマージソートアルゴリズムに置き換えられました。
しかし、入力とプラットフォームによっては、ベンチマークはクイックソートの
方が速くなります。
5.8 ではソートを限定的に制御できる sort プラグマがあります。
この、アルゴリズムの直接的な制御方法は将来の perl では引き継がれないかも
しれませんが、実装に依存しない形で入力や出力を性格付ける機能は
おそらくあります。
L<the sort pragma|sort> を参照してください。

=begin original

Examples:

=end original

例:

    # sort lexically
    @articles = sort @files;
    
    # same thing, but with explicit sort routine
    @articles = sort {$a cmp $b} @files;
    
    # now case-insensitively
    @articles = sort {uc($a) cmp uc($b)} @files;
    
    # same thing in reversed order
    @articles = sort {$b cmp $a} @files;
    
    # sort numerically ascending
    @articles = sort {$a <=> $b} @files;
    
    # sort numerically descending
    @articles = sort {$b <=> $a} @files;
    
    # this sorts the %age hash by value instead of key
    # using an in-line function
    @eldest = sort { $age{$b} <=> $age{$a} } keys %age;
    
    # sort using explicit subroutine name
    sub byage {
    $age{$a} <=> $age{$b};  # presuming numeric
    }
    @sortedclass = sort byage @class;
    
    sub backwards { $b cmp $a }
    @harry  = qw(dog cat x Cain Abel);
    @george = qw(gone chased yz Punished Axed);
    print sort @harry;
        # prints AbelCaincatdogx
    print sort backwards @harry;
        # prints xdogcatCainAbel
    print sort @george, 'to', @harry;
        # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

    # inefficiently sort by descending numeric compare using
    # the first integer after the first = sign, or the
    # whole record case-insensitively otherwise

    my @new = sort {
        ($b =~ /=(\d+)/)[0] <=> ($a =~ /=(\d+)/)[0]
            ||
        uc($a)  cmp  uc($b)
    } @old;

    # same thing, but much more efficiently;
    # we'll build auxiliary indices instead
    # for speed
    my @nums = @caps = ();
    for (@old) {
        push @nums, ( /=(\d+)/ ? $1 : undef );
        push @caps, uc($_);
    }

    my @new = @old[ sort {
        $nums[$b] <=> $nums[$a]
            ||
        $caps[$a] cmp $caps[$b]
        } 0..$#old
    ];

    # same thing, but without any temps
    @new = map { $_->[0] }
           sort { $b->[1] <=> $a->[1]
               ||
           $a->[2] cmp $b->[2]
    } map { [$_, /=(\d+)/, uc($_)] } @old;

    # using a prototype allows you to use any comparison subroutine
    # as a sort subroutine (including other package's subroutines)
    package other;
    sub backwards ($$) { $_[1] cmp $_[0]; }  # $a and $b are not set here
    
    package main;
    @new = sort other::backwards @old;
    
    # guarantee stability, regardless of algorithm
    use sort 'stable';
    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;
    
    # force use of mergesort (not portable outside Perl 5.8)
    use sort '_mergesort';  # note discouraging _
    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;

=begin original

Warning: syntactical care is required when sorting the list returned from
a function. If you want to sort the list returned by the function call
C<find_records(@key)>, you can use:

=end original

警告: 関数からかえされたリストをソートするときには文法上の注意が必要です。
関数呼び出し C<find_records(@key)> から返されたリストをソートしたい場合、
以下のように出来ます:

    @contact = sort { $a cmp $b } find_records @key;
    @contact = sort +find_records(@key);
    @contact = sort &find_records(@key);
    @contact = sort(find_records(@key));

=begin original

If instead you want to sort the array @key with the comparison routine
C<find_records()> then you can use:

=end original

一方、配列 @key を比較ルーチン C<find_records()> でソートしたい場合は、
以下のように出来ます:

    @contact = sort { find_records() } @key;
    @contact = sort find_records(@key);
    @contact = sort(find_records @key);
    @contact = sort(find_records (@key));

=begin original

If you're using strict, you I<must not> declare $a
and $b as lexicals.  They are package globals.  That means
that if you're in the C<main> package and type

=end original

use strict している場合、$a と $b をレキシカルとして
宣言しては I<いけません>。
これはパッケージグローバルです。
つまり、C<main> パッケージで以下のように書いた場合:

    @articles = sort {$b <=> $a} @files;

=begin original

then C<$a> and C<$b> are C<$main::a> and C<$main::b> (or C<$::a> and C<$::b>),
but if you're in the C<FooPack> package, it's the same as typing

=end original

C<$a> と C<$b> は C<$main::a> と C<$main::b> (または C<$::a> と C<$::b>) を
意味しますが、C<FooPack> パッケージ内の場合、これは以下と同じになります:

    @articles = sort {$FooPack::b <=> $FooPack::a} @files;

=begin original

The comparison function is required to behave.  If it returns
inconsistent results (sometimes saying C<$x[1]> is less than C<$x[2]> and
sometimes saying the opposite, for example) the results are not
well-defined.

=end original

比較関数は一貫した振る舞いをすることが求められます。
一貫しない結果を返す(例えば、あるときは C<$x[1]> が C<$x[2]> より
小さいと返し、またあるときは逆を返す)場合、結果は未定義です。

=begin original

Because C<< <=> >> returns C<undef> when either operand is C<NaN>
(not-a-number), and laso because C<sort> raises an exception unless the
result of a comparison is defined, be careful when sorting with a
comparison function like C<< $a <=> $b >> any lists that might contain a
C<NaN>.  The following example takes advantage that C<NaN != NaN> to
eliminate any C<NaN>s from the input list.

=end original

C<< <=> >> はどちらかのオペランドが C<NaN> (not-a-number) のときに
C<undef> を返し、C<sort> は比較の結果が未定義値だと例外が発生するので、
C<< $a <=> $b >> といった比較関数でソートする場合はリストに C<NaN> が
含まれないように注意してください。
以下の例は 入力リストから C<NaN> を取り除くために C<NaN != NaN> という性質を
利用しています。

    @result = sort { $a <=> $b } grep { $_ == $_ } @input;

=item splice ARRAY or EXPR,OFFSET,LENGTH,LIST
X<splice>

=item splice ARRAY or EXPR,OFFSET,LENGTH

=item splice ARRAY or EXPR,OFFSET

=item splice ARRAY or EXPR

=begin original

Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.  In list context,
returns the elements removed from the array.  In scalar context,
returns the last element removed, or C<undef> if no elements are
removed.  The array grows or shrinks as necessary.
If OFFSET is negative then it starts that far from the end of the array.
If LENGTH is omitted, removes everything from OFFSET onward.
If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.
If both OFFSET and LENGTH are omitted, removes everything. If OFFSET is
past the end of the array, Perl issues a warning, and splices at the
end of the array.

=end original

ARRAY から OFFSET、LENGTH で指定される要素を取り除き、
LIST があれば、それを代わりに挿入します。
リストコンテキストでは、配列から取り除かれた要素を返します。
スカラコンテキストでは、取り除かれた最後の要素を返します。
要素が取り除かれなかった場合は C<undef> を返します。
配列は、必要に応じて、大きくなったり、小さくなったりします。
OFFSET が負の数の場合は、配列の最後からの距離を示します。
LENGTH が省略されると、OFFSET 以降のすべての要素を取り除きます。
LENGTH が負の数の場合は、OFFSET から前方へ、配列の最後から -LENGTH 要素を
除いて取り除きます。
OFFSET と LENGTH の両方が省略されると、全ての要素を取り除きます。
OFFSET が配列の最後より後ろの場合、Perl は警告を出し、配列の最後に対して
処理します。

=begin original

The following equivalences hold (assuming C<< $[ == 0 and $#a >= $i >> )

=end original

以下は、(C<< $[ == 0 と $#a >= $i >> と仮定すると) それぞれ、等価です。

    push(@a,$x,$y)      splice(@a,@a,0,$x,$y)
    pop(@a)             splice(@a,-1)
    shift(@a)           splice(@a,0,1)
    unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
    $a[$i] = $y         splice(@a,$i,1,$y)

=begin original

Example, assuming array lengths are passed before arrays:

=end original

次の例では、配列の前に、それぞれの配列の大きさが渡されるものとしています:

    sub aeq {  # compare two list values
        my(@a) = splice(@_,0,shift);
        my(@b) = splice(@_,0,shift);
        return 0 unless @a == @b;  # same len?
        while (@a) {
            return 0 if pop(@a) ne pop(@b);
        }
        return 1;
    }
    if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

=begin original

Starting with Perl 5.14, C<splice> can take scalar EXPR, which must hold a
reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of C<splice> is considered highly experimental.
The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<splice> はスカラの EXPR を取ることができるようになりました;
これは bless されていない配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<splice> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

=item split /PATTERN/,EXPR,LIMIT
X<split>

=item split /PATTERN/,EXPR

=item split /PATTERN/

=item split

=begin original

Splits the string EXPR into a list of strings and returns that list.  By
default, empty leading fields are preserved, and empty trailing ones are
deleted.  (If all fields are empty, they are considered to be trailing.)

=end original

文字列 EXPR を文字列のリストに分割して、リストを返します。
デフォルトでは、行頭の空白は保存され、末尾の空白は削除されます。
(全てのフィールドが空の場合、これらは末尾であるとして扱われます。)

=begin original

In scalar context, returns the number of fields found.

=end original

スカラコンテキストでは、見つかったフィールドの数を返します。

=begin original

If EXPR is omitted, splits the C<$_> string.  If PATTERN is also omitted,
splits on whitespace (after skipping any leading whitespace).  Anything
matching PATTERN is taken to be a delimiter separating the fields.  (Note
that the delimiter may be longer than one character.)

=end original

EXPR を省略すると、文字列 C<$_> を split します。
もし、PATTERN も省略すると、
(先頭の空白文字をスキップした後) 空白で split します。
PATTERN にマッチするものは、フィールドを分割するデリミタとして扱われます。
(デリミタは、1 文字とは限りません。)

=begin original

If LIMIT is specified and positive, it represents the maximum number
of fields the EXPR will be split into, though the actual number of
fields returned depends on the number of times PATTERN matches within
EXPR.  If LIMIT is unspecified or zero, trailing null fields are
stripped (which potential users of C<pop> would do well to remember).
If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.  Note that splitting an EXPR that evaluates to the
empty string always returns the empty list, regardless of the LIMIT
specified.

=end original

正の数の LIMIT を指定した場合には、EXPR が分割されるフィールドの最大数を
表しますが、実際に返されるフィールドの数は EXPR の中で何回 PATTERN が
マッチするかに依存します。
LIMIT を指定しないかゼロなら、末尾の空フィールドを捨ててしまいます
(C<pop> を行なうときには気を付けないといけません)。
LIMIT が負ならば、LIMIT に任意の大きな数を指定したのと同じことになります。
空文字列に評価される EXPR を分割する場合、LIMIT での指定に関わらず
常に空のリストが返ることに注意してください。

=begin original

A pattern matching the empty string (not to be confused with
an empty pattern C<//>, which is just one member of the set of patterns
matching the epmty string), splits EXPR into individual
characters.  For example:

=end original

空文字列にマッチするパターン (空パターン C<//> と混同しないでください。
これは、空文字列にマッチするパターンの一つでしかありません) は、
どの場所にもマッチし、EXPR を 1 文字ずつに分割します。
例えば:

    print join(':', split(/ */, 'hi there')), "\n";

=begin original

produces the output 'h:i:t:h:e:r:e'.

=end original

は、'h:i:t:h:e:r:e' という出力になります。

=begin original

As a special case for C<split>, the empty pattern C<//> specifically
matches the empty string; this is not be confused with the normal use
of an empty pattern to mean the last successful match.  So to split
a string into individual characters, the following:

=end original

C<split> に関する特別な場合として、特に空パターン C<//> は空文字列に
マッチするので、最後に成功したマッチングを意味する通常の C<//> の
使用法と混乱しないようにしてください。
それで、文字列を個々の文字に分割する場合は、以下のようにすると:

    print join(':', split(//, 'hi there')), "\n";

=begin original

produces the output 'h:i: :t:h:e:r:e'.

=end original

'h:i: :t:h:e:r:e' という出力になります。

=begin original

Empty leading fields are produced when there are positive-width matches at
the beginning of the string; a zero-width match at the beginning of
the string does not produce an empty field. For example:

=end original

先頭の空フィールドは、文字列の先頭で 0 でない幅でマッチした場合は
生成されます。
幅 0 でマッチした場合は生成されません。
例えば:

   print join(':', split(/(?=\w)/, 'hi there!'));

=begin original

produces the output 'h:i :t:h:e:r:e!'. Empty trailing fields, on the other
hand, are produced when there is a match at the end of the string (and
when LIMIT is given and is not 0), regardless of the length of the match.
For example:

=end original

これの出力は 'h:i :t:h:e:r:e!' となります。
一方、末尾の空フィールドは、マッチングの長さに関わらず、文字列の最後に
マッチングした(そして LIMIT が与えられてそれが 0 でなかった)場合に
生成されます。
例えば:

   print join(':', split(//,   'hi there!', -1)), "\n";
   print join(':', split(/\W/, 'hi there!', -1)), "\n";

=begin original

produce the output 'h:i: :t:h:e:r:e:!:' and 'hi:there:', respectively,
both with an empty trailing field.

=end original

これの出力はそれぞれ 'h:i :t:h:e:r:e:!:' および 'hi:there:' となり、
両方とも末尾に空フィールドが付きます。

=begin original

The LIMIT parameter can be used to split a line partially

=end original

LIMIT を使うと、行を部分的に split することができます。

    ($login, $passwd, $remainder) = split(/:/, $_, 3);

=begin original

When assigning to a list, if LIMIT is omitted, or zero, Perl supplies
a LIMIT one larger than the number of variables in the list, to avoid
unnecessary work.  For the list above LIMIT would have been 4 by
default.  In time critical applications it behooves you not to split
into more fields than you really need.

=end original

リストへ代入するとき、LIMIT を省略するか 0 の場合、Perl は、
無駄な仕事を避けるため、そのリストの変数の数より、1 つだけ大きい
LIMIT が与えられたものとして処理を行ないます。
上のリストの場合には、LIMIT はデフォルトで 4 になります。
時間が問題となるアプリケーションでは、
必要以上のフィールドに分けないようにする必要があります。

=begin original

If the PATTERN contains parentheses, additional list elements are
created from each matching substring in the delimiter.

=end original

PATTERN に括弧が含まれていると、デリミタ内の部分文字列にマッチするものも、
リスト要素に含まれるようになります。

    split(/([,-])/, "1-10,20", 3);

=begin original

produces the list value

=end original

は、以下のリスト値を生成します。

    (1, '-', 10, ',', 20)

=begin original

If you had the entire header of a normal Unix email message in $header,
you could split it up into fields and their values this way:

=end original

$header に Unix E メールメッセージヘッダ全体が入っているとすると、
以下のようにしてフィールドとその値に分割できます:

    $header =~ s/\n(?=\s)//g;  # fix continuation lines
    %hdrs   =  (UNIX_FROM => split /^(\S*?):\s*/m, $header);

=begin original

The pattern C</PATTERN/> may be replaced with an expression to specify
patterns that vary at runtime.  (To do runtime compilation only once,
use C</$variable/o>.)

=end original

/PATTERN/ は、実行時に変わるパターンを指定する式で置き換えることができます。
(実行時のコンパイルを 1 度にするために、/$variable/o を使ってください。)

=begin original

As a special case, specifying a PATTERN of space (S<C<' '>>) will split on
white space just as C<split> with no arguments does.  Thus, S<C<split(' ')>> can
be used to emulate B<awk>'s default behavior, whereas S<C<split(/ /)>>
will give you as many initial null fields (empty string) as there are leading spaces.
A C<split> on C</\s+/> is like a S<C<split(' ')>> except that any leading
whitespace produces a null first field.  A C<split> with no arguments
really does a S<C<split(' ', $_)>> internally.

=end original

特別な場合として、PATTERN にスペース (S<C<' '>>) を指定すると、
引数なしの C<split> のように空白で split を行ないます。
つまり、S<C<split(' ')>> は B<awk> のデフォルトの動作をエミュレートするために
使うことができ、S<C<split(/ /)>> は行頭のスペースの数に応じた空フィールド
(空文字列)ができます。
C<split /\s+/> は S<C<split(' ')>> と同様ですが、
先頭の空白は先頭の空フィールドとなります。
引数なしの C<split> は内部的には S<C<split(' ', $_)>> を実行します。

=begin original

A PATTERN of C</^/> is treated as if it were C</^/m>, since it isn't
much use otherwise.

=end original

PATTERN に C</^/> を指定すると C</^/m> として扱われます。
他の意味に使われることはまずないからです。

=begin original

Example:

=end original

例:

    open(PASSWD, '/etc/passwd');
    while (<PASSWD>) {
        chomp;
        ($login, $passwd, $uid, $gid,
         $gcos, $home, $shell) = split(/:/);
        #...
    }

=begin original

As with regular pattern matching, any capturing parentheses that are not
matched in a C<split()> will be set to C<undef> when returned:

=end original

通常のパターンマッチングで、C<split()> でマッチしない全てのかっこは
返される時には C<undef> がセットされます。

    @fields = split /(A)|B/, "1A2B3";
    # @fields is (1, 'A', 2, undef, 3)

=item sprintf FORMAT, LIST
X<sprintf>

=begin original

Returns a string formatted by the usual C<printf> conventions of the C
library function C<sprintf>.  See below for more details
and see C<sprintf(3)> or C<printf(3)> on your system for an explanation of
the general principles.

=end original

普通の C 言語の C<printf> 記法のフォーマットで、整形された文字列を返します。
一般的な原則の説明については以下の説明と、システムの
C<sprintf(3)> または C<printf(3)> の説明を参照してください。

=begin original

For example:

=end original

例:

        # Format number with up to 8 leading zeroes
        $result = sprintf("%08d", $number);

        # Round number to 3 digits after decimal point
        $rounded = sprintf("%.3f", $number);

=begin original

Perl does its own C<sprintf> formatting: it emulates the C
function sprintf(3), but doesn't use it except for floating-point
numbers, and even then only standard modifiers are allowed.  
Non-standard extensions in your local sprintf(3) are 
therefore unavailable from Perl.

=end original

Perl は C<sprintf> フォーマット処理を自力で行います:
これは C の sprintf(3) 関数をエミュレートしますが、
C の関数は使いません(浮動小数点を除きますが、それでも標準の
記述子のみが利用できます)。
従って、ローカルな非標準の C<sprintf> 拡張機能は Perl では使えません。

=begin original

Unlike C<printf>, C<sprintf> does not do what you probably mean when you
pass it an array as your first argument. The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.

=end original

C<printf> と違って、 C<sprintf> の最初の引数に配列を渡しても
あなたが多分望むとおりには動作しません。
配列はスカラコンテキストで渡されるので、配列の 0 番目の要素ではなく、
配列の要素数をフォーマットとして扱います。
これはほとんど役に立ちません。

=begin original

Perl's C<sprintf> permits the following universally-known conversions:

=end original

Perl の C<sprintf> は以下の一般に知られている変換に対応しています:

=begin original

   %%    a percent sign
   %c    a character with the given number
   %s    a string
   %d    a signed integer, in decimal
   %u    an unsigned integer, in decimal
   %o    an unsigned integer, in octal
   %x    an unsigned integer, in hexadecimal
   %e    a floating-point number, in scientific notation
   %f    a floating-point number, in fixed decimal notation
   %g    a floating-point number, in %e or %f notation

=end original

   %%    パーセントマーク
   %c    与えられた番号の文字
   %s    文字列
   %d    符号付き 10 進数
   %u    符号なし 10 進数
   %o    符号なし 8 進数
   %x    符号なし 16 進数
   %e    科学的表記の浮動小数点数
   %f    固定 10 進数表記の浮動小数点数
   %g    %e か %f の表記の浮動小数点数

=begin original

In addition, Perl permits the following widely-supported conversions:

=end original

さらに、Perl では以下のよく使われている変換に対応しています:

=begin original

   %X    like %x, but using upper-case letters
   %E    like %e, but using an upper-case "E"
   %G    like %g, but with an upper-case "E" (if applicable)
   %b    an unsigned integer, in binary
   %B    like %b, but using an upper-case "B" with the # flag
   %p    a pointer (outputs the Perl value's address in hexadecimal)
   %n    special: *stores* the number of characters output so far
        into the next variable in the parameter list

=end original

   %X    %x と同様だが大文字を使う
   %E    %e と同様だが大文字の "E" を使う
   %G    %g と同様だが(適切なら)大文字の "E" を使う
   %b    符号なし 2 進数
   %B    %b と同様だが、# フラグで大文字の "B" を使う
   %p    ポインタ (Perl の値のアドレスを 16 進数で出力する)
   %n    特殊: 出力文字数を引数リストの次の変数に「格納」する

=begin original

Finally, for backward (and we do mean "backward") compatibility, Perl
permits these unnecessary but widely-supported conversions:

=end original

最後に、過去との互換性(これは「過去」だと考えています)のために、
Perl は以下の不要ではあるけれども広く使われている変換に対応しています。

=begin original

   %i    a synonym for %d
   %D    a synonym for %ld
   %U    a synonym for %lu
   %O    a synonym for %lo
   %F    a synonym for %f

=end original

   %i    %d の同義語
   %D    %ld の同義語
   %U    %lu の同義語
   %O    %lo の同義語
   %F    %f の同義語

=begin original

Note that the number of exponent digits in the scientific notation produced
by C<%e>, C<%E>, C<%g> and C<%G> for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).  In other words, 1.23 times ten to the
99th may be either "1.23e99" or "1.23e099".

=end original

C<%e>, C<%E>, C<%g>, C<%G> において、指数部が 100 未満の場合の
指数部の科学的な表記法はシステム依存であることに注意してください:
3 桁かもしれませんし、それ以下かもしれません(必要に応じて 0 で
パッディングされます)。
言い換えると、 1.23 掛ける 10 の 99 乗は "1.23e99" かもしれませんし
"1.23e099" かもしれません。

=begin original

Between the C<%> and the format letter, you may specify several
additional attributes controlling the interpretation of the format.
In order, these are:

=end original

C<%> とフォーマット文字の間に、フォーマットの解釈を制御するための、
いくつかの追加の属性を指定できます。
順番に、以下のものがあります:

=over 4

=item format parameter index

(フォーマットパラメータインデックス)

=begin original

An explicit format parameter index, such as C<2$>. By default sprintf
will format the next unused argument in the list, but this allows you
to take the arguments out of order:

=end original

C<2$> のような明示的なフォーマットパラメータインデックス。
デフォルトでは sprintf はリストの次の使われていない引数を
フォーマットしますが、これによって異なった順番の引数を使えるようにします:

  printf '%2$d %1$d', 12, 34;      # prints "34 12"
  printf '%3$d %d %1$d', 1, 2, 3;  # prints "3 1 1"

=item flags

(フラグ)

=begin original

one or more of:

=end original

以下のうちの一つまたは複数指定できます:

=begin original

   space   prefix non-negative number with a space
   +       prefix non-negative number with a plus sign
   -       left-justify within the field
   0       use zeros, not spaces, to right-justify
   #       ensure the leading "0" for any octal,
           prefix non-zero hexadecimal with "0x" or "0X",
           prefix non-zero binary with "0b" or "0B"

=end original

   space   非負数の前に空白をつける
   +       非負数の前にプラス記号をつける
   -       フィールド内で左詰めする
   0       右詰めに空白ではなくゼロを使う
   #       8 進数では確実に先頭に "0" をつける;
           非 0 の 16 進数では "0x" か "0X" をつける;
           非 0 の 2 進数では "0b" か "0B" をつける

=begin original

For example:

=end original

例:

  printf '<% d>',  12;   # prints "< 12>"
  printf '<%+d>',  12;   # prints "<+12>"
  printf '<%6s>',  12;   # prints "<    12>"
  printf '<%-6s>', 12;   # prints "<12    >"
  printf '<%06s>', 12;   # prints "<000012>"
  printf '<%#o>',  12;   # prints "<014>"
  printf '<%#x>',  12;   # prints "<0xc>"
  printf '<%#X>',  12;   # prints "<0XC>"
  printf '<%#b>',  12;   # prints "<0b1100>"
  printf '<%#B>',  12;   # prints "<0B1100>"

=begin original

When a space and a plus sign are given as the flags at once,
a plus sign is used to prefix a positive number.

=end original

空白とプラス記号がフラグとして同時に与えられると、プラス記号は正の数に
前置するために使われます。

  printf '<%+ d>', 12;   # prints "<+12>"
  printf '<% +d>', 12;   # prints "<+12>"

=begin original

When the # flag and a precision are given in the %o conversion,
the precision is incremented if it's necessary for the leading "0".

=end original

%o 変換に # フラグと精度が与えられると、先頭の "0" が必要な場合は
精度に 1 が加えられます。

  printf '<%#.5o>', 012;      # prints "<00012>"
  printf '<%#.5o>', 012345;   # prints "<012345>"
  printf '<%#.0o>', 0;        # prints "<0>"

=item vector flag

(ベクタフラグ)

=begin original

This flag tells Perl to interpret the supplied string as a vector of
integers, one for each character in the string. Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot C<.> by default). This can be useful for displaying ordinal values of
characters in arbitrary strings:

=end original

このフラグは Perl に、与えられた文字列を、文字毎に一つの整数のベクタとして
解釈させます。
Perl は各数値をフォーマットし、それから結果の文字列をセパレータ
(デフォルトでは C<.>)で連結します。
これは任意の文字列の文字を順序付きの値として表示するのに便利です:

  printf "%vd", "AB\x{100}";           # prints "65.66.256"
  printf "version is v%vd\n", $^V;     # Perl's version

=begin original

Put an asterisk C<*> before the C<v> to override the string to
use to separate the numbers:

=end original

アスタリスク C<*> を C<v> の前に置くと、数値を分けるために使われる文字列を
上書きします:

  printf "address is %*vX\n", ":", $addr;   # IPv6 address
  printf "bits are %0*v8b\n", " ", $bits;   # random bitstring

=begin original

You can also explicitly specify the argument number to use for
the join string using something like C<*2$v>; for example:

=end original

また、C<*2$v> のように、連結する文字列として使う引数の番号を明示的に
指定できます; 例えば:

  printf '%*4$vX %*4$vX %*4$vX', @addr[1..3], ":";   # 3 IPv6 addresses

=item (minimum) width

((最小)幅)

=begin original

Arguments are usually formatted to be only as wide as required to
display the given value. You can override the width by putting
a number here, or get the width from the next argument (with C<*>)
or from a specified argument (e.g., with C<*2$>):

=end original

引数は、普通は値を表示するのに必要なちょうどの幅でフォーマットされます。
ここに数値を置くか、(C<*> で)次の引数か(C<*2$> で)明示的に指定した引数で
幅を上書きできます。

  printf "<%s>", "a";       # prints "<a>"
  printf "<%6s>", "a";      # prints "<     a>"
  printf "<%*s>", 6, "a";   # prints "<     a>"
  printf "<%*2$s>", "a", 6; # prints "<     a>"
  printf "<%2s>", "long";   # prints "<long>" (does not truncate)

=begin original

If a field width obtained through C<*> is negative, it has the same
effect as the C<-> flag: left-justification.

=end original

C<*> を通して得られたフィールドの値が負数の場合、C<-> フラグと
同様の効果 (左詰め) があります。

=item precision, or maximum width
X<precision>

(精度あるいは最大幅)

=begin original

You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C<.> followed by a number.
For floating-point formats except C<g> and C<G>, this specifies
how many places right of the decimal point to show (the default being 6).
For example:

=end original

C<.> の後に数値を指定することで、(数値変換の場合)精度や(文字列変換の場合)
最大幅を指定できます。
小数点数フォーマットの場合、C<g> と C<G> を除いて、表示する小数点以下の
桁数を指定します(デフォルトは 6 です)。
例:

  # these examples are subject to system-specific variation
  printf '<%f>', 1;    # prints "<1.000000>"
  printf '<%.1f>', 1;  # prints "<1.0>"
  printf '<%.0f>', 1;  # prints "<1>"
  printf '<%e>', 10;   # prints "<1.000000e+01>"
  printf '<%.1e>', 10; # prints "<1.0e+01>"

=begin original

For "g" and "G", this specifies the maximum number of digits to show,
including thoe prior to the decimal point and those after it; for 
example:

=end original

"g" と "G" の場合、これは表示する数値の数を指定します;
これには小数点の前の数値と後の数値を含みます; 例えば:

  # These examples are subject to system-specific variation.
  printf '<%g>', 1;        # prints "<1>"
  printf '<%.10g>', 1;     # prints "<1>"
  printf '<%g>', 100;      # prints "<100>"
  printf '<%.1g>', 100;    # prints "<1e+02>"
  printf '<%.2g>', 100.01; # prints "<1e+02>"
  printf '<%.5g>', 100.01; # prints "<100.01>"
  printf '<%.4g>', 100.01; # prints "<100>"

=begin original

For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:

=end original

整数変換の場合、精度を指定すると、数値自体の出力はこの幅に 0 で
パッディングするべきであることを暗に示すことになり、0 フラグは
無視されます:

  printf '<%.6d>', 1;      # prints "<000001>"
  printf '<%+.6d>', 1;     # prints "<+000001>"
  printf '<%-10.6d>', 1;   # prints "<000001    >"
  printf '<%10.6d>', 1;    # prints "<    000001>"
  printf '<%010.6d>', 1;   # prints "<    000001>"
  printf '<%+10.6d>', 1;   # prints "<   +000001>"

  printf '<%.6x>', 1;      # prints "<000001>"
  printf '<%#.6x>', 1;     # prints "<0x000001>"
  printf '<%-10.6x>', 1;   # prints "<000001    >"
  printf '<%10.6x>', 1;    # prints "<    000001>"
  printf '<%010.6x>', 1;   # prints "<    000001>"
  printf '<%#10.6x>', 1;   # prints "<  0x000001>"

=begin original

For string conversions, specifying a precision truncates the string
to fit the specified width:

=end original

文字列変換の場合、精度を指定すると、指定された幅に収まるように文字列を
切り詰めます:

  printf '<%.5s>', "truncated";   # prints "<trunc>"
  printf '<%10.5s>', "truncated"; # prints "<     trunc>"

=begin original

You can also get the precision from the next argument using C<.*>:

=end original

C<.*> を使って精度を次の引数から取ることも出来ます:

  printf '<%.6x>', 1;       # prints "<000001>"
  printf '<%.*x>', 6, 1;    # prints "<000001>"

=begin original

If a precision obtained through C<*> is negative, it counts
as having no precision at all.

=end original

C<*> によって得られた精度が負数の場合、精度が指定されなかった場合と
同じ効果となります。

  printf '<%.*s>',  7, "string";   # prints "<string>"
  printf '<%.*s>',  3, "string";   # prints "<str>"
  printf '<%.*s>',  0, "string";   # prints "<>"
  printf '<%.*s>', -1, "string";   # prints "<string>"

  printf '<%.*d>',  1, 0;   # prints "<0>"
  printf '<%.*d>',  0, 0;   # prints "<>"
  printf '<%.*d>', -1, 0;   # prints "<0>"

=begin original

You cannot currently get the precision from a specified number,
but it is intended that this will be possible in the future, for
example using C<.*2$>:

=end original

現在のところ精度を指定した数値から得ることはできませんが、
将来は 例えば C<.*2$> のようにして可能にしようとしています:

  printf "<%.*2$x>", 1, 6;   # INVALID, but in future will print "<000001>"

=item size

(サイズ)

=begin original

For numeric conversions, you can specify the size to interpret the
number as using C<l>, C<h>, C<V>, C<q>, C<L>, or C<ll>. For integer
conversions (C<d u o x X b i D U O>), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:

=end original

数値変換では、C<l>, C<h>, C<V>, C<q>, C<L>, C<ll> を使って解釈する数値の
大きさを指定できます。
整数変換 (C<d u o x X b i D U O>) では、数値は通常プラットフォームの
デフォルトの整数のサイズ (通常は 32 ビットか 64 ビット) を仮定しますが、
これを Perl がビルドされたコンパイラが対応している標準 C の型の一つで
上書きできます:

=begin original

   hh          interpret integer as C type "char" or "unsigned char"
	       on Perl 5.14 or later
   h           interpret integer as C type "short" or "unsigned short"
   j	       intepret integer as C type "intmax_t" on Perl 5.14 
	       or later, and only with a C99 compiler (unportable)
   l           interpret integer as C type "long" or "unsigned long"
   q, L, or ll interpret integer as C type "long long", "unsigned long long",
               or "quad" (typically 64-bit integers)
   t	       intepret integer as C type "ptrdiff_t" on Perl 5.14 or later
   z	       intepret integer as C type "size_t" on Perl 5.14 or later

=end original

   l           整数を C の "long" または "unsigned long" と解釈する
   h           整数を C の "short" または "unsigned short" と解釈する
   q, L or ll  整数を C の "long long", "unsigned long long",
               "quads"(典型的には 64 ビット整数) のどれかと解釈する

=begin original

As of 5.14, none of these raises an exception if they are not supported on
your platform.  However, if warnings are enabled, a warning of the
C<printf> warning class is issued on an unsupported conversion flag.  
Should you instead prefer an exception, do this:

=end original

5.14 から、プラットフォームがこれらに対応していないときでも例外が
発生しなくなりました。
しかし、もし警告が有効になっているなら、
非対応変換フラグに関して C<printf> 警告クラスの警告が発生します。
例外の方がお好みなら、以下のようにします:

    use warnings FATAL => "printf";

=begin original

If you would like to know about a version dependency before you
start running the program, put something like this at its top:

=end original

プログラムの実行開始前にバージョン依存について知りたいなら、先頭に
以下のようなものを書きます:

    use 5.014;  # for hh/j/t/z/ printf modifiers

=begin original

You can find out whether your Perl supports quads via L<Config>:

=end original

Perl が 64 ビット整数に対応しているかどうかは L<Config> を使って
調べられます:

    use Config;
    if ($Config{use64bitint} eq "define" || $Config{longsize} >= 8) {
        print "Nice quads!\n";
    }

=begin original

For floating-point conversions (C<e f g E F G>), numbers are usually assumed
to be the default floating-point size on your platform (double or long double),
but you can force "long double" with C<q>, C<L>, or C<ll> if your
platform supports them. You can find out whether your Perl supports long
doubles via L<Config>:

=end original

浮動小数点数変換 (C<e f g E F G>) では、普通はプラットフォームのデフォルトの
不動小数点数のサイズ (double か long double) を仮定します。
Perl が long double に対応しているかどうかは L<Config> を使って
調べられます:

    use Config;
    print "long doubles\n" if $Config{d_longdbl} eq "define";

=begin original

You can find out whether Perl considers "long double" to be the default
floating-point size to use on your platform via L<Config>:

=end original

Perl が "long double" をデフォルトの浮動小数点数として扱っているかどうかは
L<Config> を使って調べられます:

    use Config;
    if ($Config{uselongdouble} eq "define") {
	print "long doubles by default\n";
    }

=begin original

It can also be that long doubles and doubles are the same thing:

=end original

long double と double が同じ場合もあります:

        use Config;
        ($Config{doublesize} == $Config{longdblsize}) &&
                print "doubles are long doubles\n";

=begin original

The size specifier C<V> has no effect for Perl code, but is supported for
compatibility with XS code.  It means "use the standard size for a Perl
integer or floating-point number", which is the default.

=end original

サイズ指定子 C<V> は Perl のコードには何の影響もありませんが、これは
XS コードとの互換性のために対応しています。
これは「Perl 整数 (または浮動小数点数) として標準的なサイズを使う」ことを
意味し、これはデフォルトです。

=item order of arguments

(引数の順序)

=begin original

Normally, sprintf() takes the next unused argument as the value to
format for each format specification. If the format specification
uses C<*> to require additional arguments, these are consumed from
the argument list in the order they appear in the format
specification I<before> the value to format.  Where an argument is
specified by an explicit index, this does not affect the normal
order for the arguments, even when the explicitly specified index
would have been the next argument.

=end original

通常、sprintf() は各フォーマット指定について、使われていない次の引数を
フォーマットする値として使います。
追加の引数を要求するためにフォーマット指定 C<*> を使うと、
これらはフォーマットする値の I<前> のフォーマット指定に現れる順番に
引数リストから消費されます。
引数の位置が明示的なインデックスを使って指定された場合、
(明示的に指定したインデックスが次の引数の場合でも)
これは通常の引数の順番に影響を与えません。

=begin original

So:

=end original

それで:

    printf "<%*.*s>", $a, $b, $c;

=begin original

uses C<$a> for the width, C<$b> for the precision, and C<$c>
as the value to format; while:

=end original

とすると C<$a> を幅に、C<$b> を精度に、C<$c> をフォーマットの値に
使います; 一方:

  printf "<%*1$.*s>", $a, $b;

=begin original

would use C<$a> for the width and precision, and C<$b> as the
value to format.

=end original

とすると C<$a> を幅と精度に、C<$b> をフォーマットの値に使います。

=begin original

Here are some more examples; be aware that when using an explicit
index, the C<$> may need escaping:

=end original

以下にさらなる例を示します; 明示的にインデックスを使う場合、C<$> は
エスケープする必要があることに注意してください:

  printf "%2\$d %d\n",    12, 34;        # will print "34 12\n"
  printf "%2\$d %d %d\n", 12, 34;        # will print "34 12 34\n"
  printf "%3\$d %d %d\n", 12, 34, 56;    # will print "56 12 34\n"
  printf "%2\$*3\$d %d\n", 12, 34, 3;    # will print " 34 12\n"

=back

=begin original

If C<use locale> is in effect and POSIX::setlocale() has been called,
the character used for the decimal separator in formatted floating-point
numbers is affected by the LC_NUMERIC locale.  See L<perllocale>
and L<POSIX>.

=end original

C<use locale> が有効で、POSIX::setlocale() が呼び出されている場合、
フォーマットされた浮動小数点数の小数点として使われる文字は
LC_NUMERIC ロケールの影響を受けます。
L<perllocale> と L<POSIX> を参照してください。

=item sqrt EXPR
X<sqrt> X<root> X<square root>

=item sqrt

=begin original

Return the positive square root of EXPR.  If EXPR is omitted, uses
C<$_>.  Works only for non-negative operands unless you've
loaded the C<Math::Complex> module.

=end original

EXPR の正の平方根を返します。
EXPR を省略すると、C<$_> を使います。
C<Math::Complex> モジュールを使わない場合は、負の数の引数は扱えません。

    use Math::Complex;
    print sqrt(-4);    # prints 2i

=item srand EXPR
X<srand> X<seed> X<randseed>

=item srand

=begin original

Sets and returns the random number seed for the C<rand> operator.

=end original

C<rand> 演算子のためのシード値を設定して返します。

=begin original

The point of the function is to "seed" the C<rand> function so that
C<rand> can produce a different sequence each time you run your
program.  When called with a parameter, C<srand> uses that for the seed;
otherwise it (semi-)randomly chooses a seed.  In either case, starting with
Perl 5.14, it returns the seed.

=end original

この関数のポイントは、プログラムを実行するごとに C<rand> 関数が
異なる乱数列を生成できるように C<rand> 関数の「種」を設定することです。
C<srand> を引数付きで呼び出すと、これを種として使います; さもなければ
(だいたい)ランダムに種を選びます。
どちらの場合でも、Perl 5.14 からは種を返します。

=begin original

If C<srand()> is not called explicitly, it is called implicitly without a
parameter at the first use of the C<rand> operator.  However, this was not true
of versions of Perl before 5.004, so if your script will run under older
Perl versions, it should call C<srand>; otherwise most programs won't call
C<srand()> at all.

=end original

C<srand()> が明示的に呼び出されなかった場合、最初に C<rand> 演算子を使った
時点で暗黙に引数なしで呼び出されます。
しかし、これは Perl のバージョンが 5.004 より前では行われませんので、
プログラムが古い Perl で実行される場合は、C<srand> を呼ぶべきです;
さもなければ、ほとんどのプログラムは C<srand()> を一切呼び出す必要は
ありません。

=begin original

But there are a few situations in recent Perls where programs are likely to
want to call C<srand>.  One is for generating predictable results generally for
testing or debugging.  There, you use C<srand($seed)>, with the same C<$seed>
each time.  Another other case is where you need a cryptographically-strong
starting point rather than the generally acceptable default, which is based on
time of day, process ID, and memory allocation, or the F</dev/urandom> device
if available.  And still another case is that you may want to call C<srand()>
after a C<fork()> to avoid child processes sharing the same seed value as the
parent (and consequently each other).

=end original

しかし、最近の Perl でプログラムが C<srand> を呼び出したいであろう状況が
いくつかあります。
一つはテストやデバッグのために予測可能な結果を生成するためです。
この場合、C<srand($seed)> (C<$seed> は毎回同じ値を使う) を使います。
もう一つの場合は、時刻、プロセス ID、メモリ配置、(利用可能なら) F</dev/urandom>
デバイスといった、一般的に受け入れられるデフォルトよりも暗号学的に
強力な開始点が必要な場合です。
もう一つの場合としては、子プロセスが親や他の子プロセスと同じ種の値を
共有することを避けるために、C<fork()> の後に C<srand()> を
呼び出したいかもしれません。

=begin original

Do B<not> call C<srand()> (i.e., without an argument) more than once per
process.  The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
C<srand()> again actually I<loses> randomness.

=end original

C<srand()> (引数なし)をプロセス中で複数回呼び出しては B<いけません>。
乱数生成器の内部状態はどのような種によって提供されるものよりも
高いエントロピーを持っているので、C<srand()> を再び呼び出すと
ランダム性が I<失われます>。

=begin original

Most implementations of C<srand> take an integer and will silently
truncate decimal numbers.  This means C<srand(42)> will usually
produce the same results as C<srand(42.1)>.  To be safe, always pass
C<srand> an integer.

=end original

C<srand> のほとんどの実装では整数を取り、小数を暗黙に切り捨てます。
これは、C<srand(42)> は普通 C<srand(42.1)> と同じ結果になることを
意味します。
安全のために、C<srand> には常に整数を渡しましょう。

=begin original

In versions of Perl prior to 5.004 the default seed was just the
current C<time>.  This isn't a particularly good seed, so many old
programs supply their own seed value (often C<time ^ $$> or C<time ^
($$ + ($$ << 15))>), but that isn't necessary any more.

=end original

5.004 以前の Perl では、デフォルトのシード値は現在の C<time> でした。
これは特によいシード値ではありませんでしたので、
多くの古いプログラムは自力でシード値を指定しています
(C<time ^ $$> または C<time ^ ($$ + ($$ << 15))> がよく使われました)が、
もはやこれは必要ありません。

=begin original

For cryptographic purposes, however, you need something much more random 
than the default seed.  Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.  For
example:

=end original

しかし、暗号処理にはもっとランダムな値を使う必要があります。
急激に変化する OS のステータス値プログラムの出力をひとつまたは複数用い、
圧縮してチェックサムをとる、というようなことが普通行なわれます。
例えば:

    srand (time ^ $$ ^ unpack "%L*", `ps axww | gzip -f`);

=begin original

If you're particularly concerned with this, search the CPAN for
random number generator modules instead of rolling out your own.

=end original

特にこのようなことに関心がある場合は、自分で処理せずに、
CPAN の乱数発生モジュールを探してください。

=begin original

Frequently called programs (like CGI scripts) that simply use

=end original

(CGI スクリプトのような)頻繁に呼び出されるプログラムで単純に

    time ^ $$

=begin original

for a seed can fall prey to the mathematical property that

=end original

を種として使うと、3 回に 1 回は以下の数学特性

    a^b == (a+1)^(b+1)

=begin original

one-third of the time.  So don't do that.

=end original

の餌食になります。
従ってこのようなことはしてはいけません。

=begin original

A typical use of the returned seed is for a test program which has too many
combinations to test comprehensively in the time available to it each run.  It
can test a random subset each time, and should there be a failure, log the seed
used for that run so that it can later be used to reproduce the same results.

=end original

返された種の典型的な利用法は、実行毎のテストを利用可能な時間内に完全に
行うには組み合わせが多すぎるテストプログラム用です。
毎回ランダムなサブセットをテストし、もし失敗したら、その実行で使った
種をログに出力することで、後で同じ結果を再現するために使えます。

=item stat FILEHANDLE
X<stat> X<file, status> X<ctime>

=item stat EXPR

=item stat DIRHANDLE

=item stat

=begin original

Returns a 13-element list giving the status info for a file, either
the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.  If EXPR is 
omitted, it stats C<$_> (not C<_>!).  Returns the empty list if C<stat> fails.  Typically
used as follows:

=end original

FILEHANDLE か DIRHANDLE を通じてオープンされているファイルか、
EXPR で指定されるファイルの情報を与える、13 要素のリストを返します。
EXPR が省略されると、 C<$_> が用いられます (C<_> ではありません!)。
C<stat> に失敗した場合には、空リストを返します。
普通は、以下のようにして使います:

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);

=begin original

Not all fields are supported on all filesystem types.  Here are the
meanings of the fields:

=end original

全てのファイルシステムで全てのフィールドに対応しているわけではありません。
フィールドの意味は以下の通りです。

=begin original

  0 dev      device number of filesystem
  1 ino      inode number
  2 mode     file mode  (type and permissions)
  3 nlink    number of (hard) links to the file
  4 uid      numeric user ID of file's owner
  5 gid      numeric group ID of file's owner
  6 rdev     the device identifier (special files only)
  7 size     total size of file, in bytes
  8 atime    last access time in seconds since the epoch
  9 mtime    last modify time in seconds since the epoch
 10 ctime    inode change time in seconds since the epoch (*)
 11 blksize  preferred block size for file system I/O
 12 blocks   actual number of blocks allocated

=end original

  0 dev      ファイルシステムのデバイス番号
  1 ino      inode 番号
  2 mode     ファイルモード (タイプとパーミッション)
  3 nlink    ファイルへの(ハード)リンクの数
  4 uid      ファイル所有者のユーザー ID の数値
  5 gid      ファイル所有者のグループ ID の数値
  6 rdev     デバイス識別子(特殊ファイルのみ)
  7 size     ファイルサイズ(バイト単位)
  8 atime    紀元から、最後にアクセスされた時刻までの秒数
  9 mtime    紀元から、最後に修正(modify)された時刻までの秒数
 10 ctime    紀元から、inode 変更(change)された時刻までの秒数 (*)
 11 blksize  ファイルシステム I/O に適したブロックサイズ
 12 blocks   実際に割り当てられているブロックの数

=begin original

(The epoch was at 00:00 January 1, 1970 GMT.)

=end original

(紀元は GMT で 1970/01/01 00:00:00)

=begin original

(*) Not all fields are supported on all filesystem types. Notably, the
ctime field is non-portable.  In particular, you cannot expect it to be a
"creation time"; see L<perlport/"Files and Filesystems"> for details.

=end original

(*) 全てのフィールドが全てのファイルシステムタイプで対応しているわけでは
ありません。
明らかに、ctime のフィールドは移植性がありません。
特に、これから「作成時刻」を想定することは出来ません;
詳細については L<perlport/"Files and Filesystems"> を参照してください。

=begin original

If C<stat> is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last C<stat>, C<lstat>, or filetest are returned.  Example:

=end original

下線だけの _ という特別なファイルハンドルを C<stat> に渡すと、
実際には stat を行なわず、stat 構造体に残っている
前回の stat やファイルテストの情報が返されます。
例:

    if (-x $file && (($d) = stat(_)) && $d < 0) {
        print "$file is executable NFS file\n";
    }

=begin original

(This works on machines only for which the device number is negative
under NFS.)

=end original

(これは、NFS のもとでデバイス番号が負になるマシンで
のみ動作します。)

=begin original

Because the mode contains both the file type and its permissions, you
should mask off the file type portion and (s)printf using a C<"%o">
if you want to see the real permissions.

=end original

モードにはファイルタイプとその権限の両方が含まれているので、
本当の権限を見たい場合は、(s)printf で C<"%"> を使うことで
ファイルタイプをマスクするべきです。

    $mode = (stat($filename))[2];
    printf "Permissions are %04o\n", $mode & 07777;

=begin original

In scalar context, C<stat> returns a boolean value indicating success
or failure, and, if successful, sets the information associated with
the special filehandle C<_>.

=end original

スカラコンテキストでは、C<stat> は成功か失敗を表す真偽値を返し、
成功した場合は、特別なファイルハンドル C<_> に結び付けられた
情報をセットします。

=begin original

The L<File::stat> module provides a convenient, by-name access mechanism:

=end original

L<File::stat> モジュールは、便利な名前によるアクセス機構を提供します。

    use File::stat;
    $sb = stat($filename);
    printf "File is %s, size is %s, perm %04o, mtime %s\n",
           $filename, $sb->size, $sb->mode & 07777,
           scalar localtime $sb->mtime;

=begin original

You can import symbolic mode constants (C<S_IF*>) and functions
(C<S_IS*>) from the Fcntl module:

=end original

モード定数 (C<S_IF*>) と関数 (C<S_IS*>) を Fcntl モジュールから
インポートできます。

    use Fcntl ':mode';

    $mode = (stat($filename))[2];

    $user_rwx      = ($mode & S_IRWXU) >> 6;
    $group_read    = ($mode & S_IRGRP) >> 3;
    $other_execute =  $mode & S_IXOTH;

    printf "Permissions are %04o\n", S_IMODE($mode), "\n";

    $is_setuid     =  $mode & S_ISUID;
    $is_directory  =  S_ISDIR($mode);

=begin original

You could write the last two using the C<-u> and C<-d> operators.
Commonly available C<S_IF*> constants are:

=end original

最後の二つは C<-u> と C<-d> 演算子を使っても書けます。
一般に利用可能な C<S_IF*> 定数は以下のものです。

    # Permissions: read, write, execute, for user, group, others.

    S_IRWXU S_IRUSR S_IWUSR S_IXUSR
    S_IRWXG S_IRGRP S_IWGRP S_IXGRP
    S_IRWXO S_IROTH S_IWOTH S_IXOTH

    # Setuid/Setgid/Stickiness/SaveText.
    # Note that the exact meaning of these is system dependent.

    S_ISUID S_ISGID S_ISVTX S_ISTXT

    # File types.  Not necessarily all are available on your system.

    S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT

    # The following are compatibility aliases for S_IRUSR, S_IWUSR, S_IXUSR.

    S_IREAD S_IWRITE S_IEXEC

=begin original

and the C<S_IF*> functions are

=end original

一般に利用可能な C<S_IF*> 関数は以下のものです。

    S_IMODE($mode)    the part of $mode containing the permission bits
            and the setuid/setgid/sticky bits

    S_IFMT($mode)    the part of $mode containing the file type
            which can be bit-anded with (for example) S_IFREG
                        or with the following functions

    # The operators -f, -d, -l, -b, -c, -p, and -S.

    S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)
    S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)

    # No direct -X operator counterpart, but for the first one
    # the -g operator is often equivalent.  The ENFMT stands for
    # record flocking enforcement, a platform-dependent feature.

    S_ISENFMT($mode) S_ISWHT($mode)

=begin original

See your native chmod(2) and stat(2) documentation for more details
about the C<S_*> constants.  To get status info for a symbolic link
instead of the target file behind the link, use the C<lstat> function.

=end original

C<S_*> 定数に関する詳細についてはネイティブの chmod(2) と stat(2) の
ドキュメントを参照して下さい。
リンクの先にあるファイルではなく、シンボリックリンクそのものの情報を
得たい場合は、C<lstat> 関数を使ってください。

=item state EXPR
X<state>

=item state TYPE EXPR

=item state EXPR : ATTRS

=item state TYPE EXPR : ATTRS

=begin original

C<state> declares a lexically scoped variable, just like C<my> does.
However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.

=end original

C<state> は C<my> と同様に、レキシカルスコープの変数を宣言します。
しかし、ブロックに入る毎に再初期化されるレキシカル変数と違って、
これらの変数は決して再初期化されません。

=begin original

C<state> variables are enabled only when the C<use feature "state"> pragma 
is in effect.  See L<feature>.

=end original

C<state> 変数は C<feature 'state'> プラグマが有効の場合のみ有効です。
L<feature> を参照してください。

=item study SCALAR
X<study>

=item study

=begin original

Takes extra time to study SCALAR (C<$_> if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of
patterns you are searching and the distribution of character
frequencies in the string to be searched; you probably want to compare
run times with and without it to see which is faster.  Those loops
that scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.  You may have only
one C<study> active at a time: if you study a different scalar the first
is "unstudied".  (The way C<study> works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the C<'k'> characters are.  From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.  Only those places
that contain this "rarest" character are examined.)

=end original

次に変更される前に、何回も文字列に対するパターンマッチを
行なうアプリケーションで、
そのような文字列 SCALAR(省略時には C<$_>) を予め学習しておきます。
これは、検索のために、どのようなパターンを何回使うかによって、
また、検索される文字列内の文字頻度の分布によって、
時間を節約することになるかもしれませんし、逆に浪費する
ことになるかもしれません。
予習をした場合と、しない場合の実行時間を比較して、
どちらが速いか調べることが、必要でしょう。
短い固定文字列 (複雑なパターンの固定部分を含みます) をたくさん
検索するループで、もっとも効果があるでしょう。
同時には、一つの C<study>だけが有効です。
別のスカラを study した場合には、以前に学習した内容は
「忘却」されてしまいます。
(この C<study> の仕組みは、まず、検索される文字列内の
すべての文字のリンクされたリストが作られ、たとえば、
すべての C<'k'> がどこにあるかがわかるようになります。
各々の検索文字列から、C プログラムや英語のテキストから作られた
頻度の統計情報に基づいて、もっとも珍しい文字が選ばれます。
この「珍しい」文字を含む場所だけが調べられるのです。)

=begin original

For example, here is a loop that inserts index producing entries
before any line containing a certain pattern:

=end original

たとえば、特定のパターンを含む行の前にインデックスを
付けるエントリを入れる例を示します。

    while (<>) {
        study;
        print ".IX foo\n"    if /\bfoo\b/;
        print ".IX bar\n"    if /\bbar\b/;
        print ".IX blurfl\n" if /\bblurfl\b/;
        # ...
        print;
    }

=begin original

In searching for C</\bfoo\b/>, only locations in C<$_> that contain C<f>
will be looked at, because C<f> is rarer than C<o>.  In general, this is
a big win except in pathological cases.  The only question is whether
it saves you more time than it took to build the linked list in the
first place.

=end original

C<f> は C<o> よりも珍しいので、C</\bfoo\b/> を探すとき、C<$_> で C<f> を
含む場所だけが探されます。
一般に、病的な場合を除いて、かなりの結果が得られます。
唯一の問題は、節約できる時間が、最初にリンクリストを作る
時間よりも多いかどうかです、

=begin original

Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and C<eval> that to
avoid recompiling all your patterns all the time.  Together with
undefining C<$/> to input entire files as one record, this can be quite
fast, often faster than specialized programs like fgrep(1).  The following
scans a list of files (C<@files>) for a list of words (C<@words>), and prints
out the names of those files that contain a match:

=end original

実行時まで、探そうとする文字列がわからないときには、
ループ全体を文字列として組み立てて、C<eval> すれば、
いつも、すべてのパターンを再コンパイルするという事態は避けられます。
ファイル全体を一つのレコードとして入力するために、
C<$/> を未定義にすれば、かなり速くなり、
多くの場合 fgrep(1) のような専用のプログラムより速くなります。
以下の例は、ファイルのリスト (C<@files>) から単語のリスト (C<@words>) を
探して、マッチするものがあったファイル名を出力します。

    $search = 'while (<>) { study;';
    foreach $word (@words) {
        $search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
    }
    $search .= "}";
    @ARGV = @files;
    undef $/;
    eval $search;        # this screams
    $/ = "\n";        # put back to normal input delimiter
    foreach $file (sort keys(%seen)) {
        print $file, "\n";
    }

=item sub NAME BLOCK
X<sub>

=item sub NAME (PROTO) BLOCK

=item sub NAME : ATTRS BLOCK

=item sub NAME (PROTO) : ATTRS BLOCK

=begin original

This is subroutine definition, not a real function I<per se>.  Without a
BLOCK it's just a forward declaration.  Without a NAME, it's an anonymous
function declaration, so does return a value: the CODE ref of the closure
just created.

=end original

これはサブルーチン定義であり、I<本質的には> 実際の関数ではありません。
NAME なしの場合は、無名関数定義であり、値(作成したブロックの
コードリファレンス)を返します: 単にクロージャの CODE リファレンスが
作成されます。

=begin original

See L<perlsub> and L<perlref> for details about subroutines and
references; see L<attributes> and L<Attribute::Handlers> for more
information about attributes.

=end original

サブルーチンとリファレンスに関する詳細については、L<perlsub> と
L<perlref> を参照してください; 属性に関する更なる情報については
L<attributes> と L<Attribute::Handlers> を参照してください。

=item substr EXPR,OFFSET,LENGTH,REPLACEMENT
X<substr> X<substring> X<mid> X<left> X<right>

=item substr EXPR,OFFSET,LENGTH

=item substr EXPR,OFFSET

=begin original

Extracts a substring out of EXPR and returns it.  First character is at
offset C<0> (or whatever you've set C<$[> to (but B<<don't do that>)).
If OFFSET is negative (or more precisely, less than C<$[>), starts
that far back from the end of the string.  If LENGTH is omitted, returns
everything through the end of the string.  If LENGTH is negative, leaves that
many characters off the end of the string.

=end original

EXPR から、部分文字列を取り出して返します。
最初の文字がオフセット C<0> (もしくは、C<$[> に設定した値
(しかしこれを使ってはいけません))となります。
OFFSET に負の値(より厳密には、C<$[>より小さい値)を設定すると、
EXPR の終わりからのオフセットとなります。
LENGTH を省略すると、EXPR の最後まですべてが返されます。
LENGTH が負の値だと、文字列の最後から指定された数だけ文字を取り除きます。

    my $s = "The black cat climbed the green tree";
    my $color  = substr $s, 4, 5;      # black
    my $middle = substr $s, 4, -11;    # black cat climbed the
    my $end    = substr $s, 14;        # climbed the green tree
    my $tail   = substr $s, -4;        # tree
    my $z      = substr $s, -4, 2;     # tr

=begin original

You can use the substr() function as an lvalue, in which case EXPR
must itself be an lvalue.  If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.  To keep the string the same
length, you may need to pad or chop your value using C<sprintf>.

=end original

substr() を左辺値として使用することも可能で、その場合には、
EXPR が自身左辺値でなければなりません。
LENGTH より短いものを代入したときには、
EXPR は短くなり、LENGTH より長いものを代入したときには、
EXPR はそれに合わせて伸びることになります。
EXPR の長さを一定に保つためには、C<sprintf> を使って、
代入する値の長さを調整することが、必要になるかもしれません。

=begin original

If OFFSET and LENGTH specify a substring that is partly outside the
string, only the part within the string is returned.  If the substring
is beyond either end of the string, substr() returns the undefined
value and produces a warning.  When used as an lvalue, specifying a
substring that is entirely outside the string raises an exception.
Here's an example showing the behavior for boundary cases:

=end original

OFFSET と LENGTH として文字列の外側を含むような部分文字列が指定されると、
文字列の内側の部分だけが返されます。
部分文字列が文字列の両端の外側の場合、substr() は未定義値を返し、
警告が出力されます。
左辺値として使った場合、文字列の完全に外側を部分文字列として指定すると
例外が発生します。
以下は境界条件の振る舞いを示す例です:

    my $name = 'fred';
    substr($name, 4) = 'dy';         # $name is now 'freddy'
    my $null = substr $name, 6, 2;   # returns "" (no warning)
    my $oops = substr $name, 7;      # returns undef, with warning
    substr($name, 7) = 'gap';        # raises an exception

=begin original

An alternative to using substr() as an lvalue is to specify the
replacement string as the 4th argument.  This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with splice().

=end original

substr() を左辺値として使う代わりの方法は、置き換える文字列を 4 番目の
引数として指定することです。
これにより、EXPR の一部を置き換え、置き換える前が何であったかを返す、
ということを(splice() と同様) 1 動作で行えます。

    my $s = "The black cat climbed the green tree";
    my $z = substr $s, 14, 7, "jumped from";    # climbed
    # $s is now "The black cat jumped from the green tree"

=begin original

Note that the lvalue returned by the three-argument version of substr() acts as
a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:

=end original

3 引数の substr() によって返された左辺値は「魔法の弾丸」のように振舞うことに
注意してください; これが代入される毎に、元の文字列のどの部分が変更されたかが
思い出されます; 例えば:

    $x = '1234';
    for (substr($x,1,2)) {
        $_ = 'a';   print $x,"\n";    # prints 1a4
        $_ = 'xyz'; print $x,"\n";    # prints 1xyz4
        $x = '56789';
        $_ = 'pq';  print $x,"\n";    # prints 5pq9
    }

=begin original

Prior to Perl version 5.9.1, the result of using an lvalue multiple times was
unspecified.

=end original

バージョン 5.9.1 以前の Perl では、複数回左辺値を使った場合の結果は
未定義でした。

=item symlink OLDFILE,NEWFILE
X<symlink> X<link> X<symbolic link> X<link, symbolic>

=begin original

Creates a new filename symbolically linked to the old filename.
Returns C<1> for success, C<0> otherwise.  On systems that don't support
symbolic links, raises an exception.  To check for that,
use eval:

=end original

NEWFILE として、OLDFILE へのシンボリックリンクを生成します。
成功時には C<1> を返し、失敗時には C<0> を返します。
シンボリックリンクをサポートしていないシステムでは、
例外が発生します。
これをチェックするには、eval を使用します:

    $symlink_exists = eval { symlink("",""); 1 };

=item syscall NUMBER, LIST
X<syscall> X<system call>

=begin original

Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.  If
unimplemented, raises an exception.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  You can't use a
string literal (or other read-only string) as an argument to C<syscall>
because Perl has to assume that any string pointer might be written
through.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add C<0> to them to force them to look
like numbers.  This emulates the C<syswrite> function (or vice versa):

=end original

LIST の最初の要素で指定するシステムコールを、残りの要素をその
システムコールの引数として呼び出します。
実装されていないときには、例外が発生します。
引数は、以下のように解釈されます: 引数が数字であれば、int として
引数を渡します。
そうでなければ、文字列値へのポインタが渡されます。
文字列に結果を受け取るときには、その結果を受け取るのに十分なくらいに、
文字列を予め伸ばしておく必要があります。
文字列リテラル(あるいはその他の読み込み専用の文字列)を C<syscall> の
引数として使うことはできません。
Perl は全ての文字列ポインタは書き込まれると仮定しなければならないからです。
整数引数が、リテラルでなく、数値コンテキストで評価されたことの
ないものであれば、数値として解釈されるように、
C<0> を足しておく必要があるかもしれません。
以下は C<syswrite> 関数(あるいはその逆)をエミュレートします。

    require 'syscall.ph';        # may need to run h2ph
    $s = "hi there\n";
    syscall(&SYS_write, fileno(STDOUT), $s, length $s);

=begin original

Note that Perl supports passing of up to only 14 arguments to your syscall,
which in practice should (usually) suffice.

=end original

Perl は、システムコールに最大 14 個の引数しか渡せませんが、
(普通は)実用上問題はないでしょう。

=begin original

Syscall returns whatever value returned by the system call it calls.
If the system call fails, C<syscall> returns C<-1> and sets C<$!> (errno).
Note that some system calls I<can> legitimately return C<-1>.  The proper
way to handle such calls is to assign C<$!=0> before the call, then
check the value of C<$!> if C<syscall> returns C<-1>.

=end original

syscall は、呼び出したシステムコールが返した値を返します。
システムコールが失敗すると、C<syscall> は C<-1> を返し、
C<$!>(errno) を設定します。
システムコールが正常に C<-1> を返す I<場合がある> ことに注意してください。
このようなシステムコールを正しく扱うには、
C<$!=0> をシステムコールの前に実行し、それから
C<syscall> が C<-1> を返した時には C<$!> の値を調べてください。

=begin original

There's a problem with C<syscall(&SYS_pipe)>: it returns the file
number of the read end of the pipe it creates, but there is no way
to retrieve the file number of the other end.  You can avoid this
problem by using C<pipe> instead.

=end original

C<syscall(&SYS_pipe)> には問題があり、
作ったパイプの、読み出し側のファイル番号を返しますが、
もう一方のファイル番号を得る方法がありません。
この問題を避けるためには、代わりに C<pipe> を使ってください。

=item sysopen FILEHANDLE,FILENAME,MODE
X<sysopen>

=item sysopen FILEHANDLE,FILENAME,MODE,PERMS

=begin original

Opens the file whose filename is given by FILENAME, and associates it with
FILEHANDLE.  If FILEHANDLE is an expression, its value is used as the real
filehandle wanted; an undefined scalar will be suitably autovivified. This
function calls the underlying operating system's I<open>(2) function with the
parameters FILENAME, MODE, and PERMS.

=end original

FILENAME で与えられたファイル名のファイルをオープンし、
FILEHANDLE と結び付けます。
FILEHANDLE が式の場合、その値は実際の求めているファイルハンドルの名前として
扱われます; 未定義のスカラは適切に自動有効化されます。
この関数呼び出しはシステムの I<open>(2) 関数を FILENAME, MODE, PERMS の
引数で呼び出すことを基礎としています。

=begin original

The possible values and flag bits of the MODE parameter are
system-dependent; they are available via the standard module C<Fcntl>.  See
the documentation of your operating system's I<open>(2) syscall to see
which values and flag bits are available.  You may combine several flags
using the C<|>-operator.

=end original

MODE パラメータに指定できるフラグビットと値はシステム依存です;
これは標準モジュール C<Fcntl> 経由で利用可能です。
どのようなフラグビットと値が利用可能であるかについては、
OS の I<open>(2) システムコールに関する文書を参照してください。
C<|> 演算子を使って複数のフラグを結合することができます。

=begin original

Some of the most common values are C<O_RDONLY> for opening the file in
read-only mode, C<O_WRONLY> for opening the file in write-only mode,
and C<O_RDWR> for opening the file in read-write mode.
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=end original

もっともよく使われる値は、ファイルを読み込み専用で開く C<O_RDONLY>、
ファイルを書き込み専用で開く C<O_WRONLY>、
ファイルを読み書き両用で開く C<O_RDWR> です。
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=begin original

For historical reasons, some values work on almost every system
supported by Perl: 0 means read-only, 1 means write-only, and 2
means read/write.  We know that these values do I<not> work under
OS/390 & VM/ESA Unix and on the Macintosh; you probably don't want to
use them in new code.

=end original

歴史的な理由により、Perl が対応しているほとんどのシステムで
使える値があります。
0 は読み込み専用、1 は書き込み専用、2 は読み書き両用を意味します。
OS/390 & VM/ESA Unix と Macintosh では動作 I<しない> ことが分かっています;
新しく書くコードではこれらは使わないほうがよいでしょう。

=begin original

If the file named by FILENAME does not exist and the C<open> call creates
it (typically because MODE includes the C<O_CREAT> flag), then the value of
PERMS specifies the permissions of the newly created file.  If you omit
the PERMS argument to C<sysopen>, Perl uses the octal value C<0666>.
These permission values need to be in octal, and are modified by your
process's current C<umask>.
X<O_CREAT>

=end original

FILENAME という名前のファイルが存在せず、(典型的には MODE が
C<O_CREAT> フラグを含んでいたために) C<open> 呼び出しがそれを作った場合、
PERMS の値は新しく作られたファイルの権限を指定します。
C<sysopen> の PERMS 引数を省略した場合、Perl は 8 進数 C<0666> を使います。
これらの権限は 8 進数である必要があり、プロセスの現在の C<umask> で
修正されます。

=begin original

In many systems the C<O_EXCL> flag is available for opening files in
exclusive mode.  This is B<not> locking: exclusiveness means here that
if the file already exists, sysopen() fails.  C<O_EXCL> may not work
on network filesystems, and has no effect unless the C<O_CREAT> flag
is set as well.  Setting C<O_CREAT|O_EXCL> prevents the file from
being opened if it is a symbolic link.  It does not protect against
symbolic links in the file's path.
X<O_EXCL>

=end original

多くのシステムではファイルを排他モードで開くために C<O_EXCL> が
利用可能です。
これはロック B<ではありません>: 排他性というのは既にファイルが
存在していた場合、sysopen() が失敗することを意味します。
C<O_EXCL> はネットワークファイルシステムでは動作せず、
またC<O_CREAT> フラグも有効でない限りは効果がありません。
C<O_CREAT|O_EXCL> をセットすると、これがシンボリックリンクだった場合は
ファイルを開くことを妨げます。
これはファイルパス中のシンボリックリンクは守りません。
X<O_EXCL>

=begin original

Sometimes you may want to truncate an already-existing file.  This
can be done using the C<O_TRUNC> flag.  The behavior of
C<O_TRUNC> with C<O_RDONLY> is undefined.
X<O_TRUNC>

=end original

既に存在しているファイルを切り詰めたい場合もあるかもしれません。
これは C<O_TRUNC> フラグを使うことで行えます。
C<O_RDONLY> と C<O_TRUNC> を同時に指定したときの振る舞いは未定義です。
X<O_TRUNC>

=begin original

You should seldom if ever use C<0644> as argument to C<sysopen>, because
that takes away the user's option to have a more permissive umask.
Better to omit it.  See the perlfunc(1) entry on C<umask> for more
on this.

=end original

めったなことでは C<sysopen> の引数に C<0644> を指定するべきではないでしょう:
ユーザーがより寛大な umask を指定する選択肢を奪うからです。
省略した方がいいです。
これに関するさらなる情報については perlfunc(1) の C<umask> を
参照してください。

=begin original

Note that C<sysopen> depends on the fdopen() C library function.
On many Unix systems, fdopen() is known to fail when file descriptors
exceed a certain value, typically 255. If you need more file
descriptors than that, consider rebuilding Perl to use the C<sfio>
library, or perhaps using the POSIX::open() function.

=end original

C<sysopen> は C の fdopen() ライブラリ関数に依存していることに注意してください。
多くの Unix システムでは、fdopen() はファイル記述子がある値(例えば 255)を超えると
失敗することが知られています。
これより多くのファイル記述子が必要な場合は、
Perl を C<sfio> ライブラリを使って再ビルドするか、
POSIX::open() 関数を使うことを健闘してください。

=begin original

See L<perlopentut> for a kinder, gentler explanation of opening files.

=end original

ファイル操作に関するより親切な説明については L<perlopentut> を参照して下さい。

=item sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
X<sysread>

=item sysread FILEHANDLE,SCALAR,LENGTH

=begin original

Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using the read(2).  It bypasses
buffered IO, so mixing this with other kinds of reads, C<print>,
C<write>, C<seek>, C<tell>, or C<eof> can cause confusion because the
perlio or stdio layers usually buffers data.  Returns the number of
bytes actually read, C<0> at end of file, or undef if there was an
error (in the latter case C<$!> is also set).  SCALAR will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.

=end original

read(2) を用いて、指定した FILEHANDLE から、変数 SCALAR へ、LENGTH バイトの
データの読み込みを試みます。
これは、バッファ付き IO ルーチンを通りませんから、
他の入力関数, C<print>, C<write>,
C<seek>, C<tell>, C<eof> と混ぜて使うと、入力がおかしくなるかも
しれません。
perlio 層や stdio 層は普通データをバッファリングするからです。
ファイルの最後では C<0>が、エラー時には undef が、
それ以外では実際に読み込まれたデータの長さが返されます
(後者の場合は C<$!> もセットされます)。
実際に読み込んだ最後のバイトが read した後の最後のバイトになるので、
SCALAR は伸び縮みします。

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET を指定すると、SCALAR の先頭以外の場所から、読み込みを行なうことが
できます。
OFFSET に負の値を指定すると、文字列の最後から逆向きに何文字目かで
位置を指定します。
OFFSET が正の値で、SCALAR の長さよりも大きかった場合、
必要なサイズになるまで C<"\0"> でパッディングされ、その後に
読み込み結果が追加されます。

=begin original

There is no syseof() function, which is ok, since eof() doesn't work
well on device files (like ttys) anyway.  Use sysread() and check
for a return value for 0 to decide whether you're done.

=end original

syseof() 関数はありませんが、問題ありません。
どちらにしろ eof() は(tty のような)デバイスファイルに対しては
うまく動作しないからです。
sysread() を使って、 返り値が 0 かどうかで最後まで読んだかを
判断してください。

=begin original

Note that if the filehandle has been marked as C<:utf8> Unicode
characters are read instead of bytes (the LENGTH, OFFSET, and the
return value of sysread() are in Unicode characters).
The C<:encoding(...)> layer implicitly introduces the C<:utf8> layer.
See L</binmode>, L</open>, and the C<open> pragma, L<open>.

=end original

ファイルハンドルが C<:utf8> であるとマークが付けられると、バイトではなく
Unicode 文字が読み込まれます (sysread() の LENGTH, OFFSET および返り値は
Unicode 文字になります)。
C<:encoding(...)> 層は暗黙のうちに C<:utf8> 層が導入されます。
L</binmode>, L</open>, C<open> プラグマ, L<open> を参照してください。

=item sysseek FILEHANDLE,POSITION,WHENCE
X<sysseek> X<lseek>

=begin original

Sets FILEHANDLE's system position in bytes using lseek(2).  FILEHANDLE may
be an expression whose value gives the name of the filehandle.  The values
for WHENCE are C<0> to set the new position to POSITION; C<1> to set the it
to the current position plus POSITION; and C<2> to set it to EOF plus
POSITION, typically negative.

=end original

FILEHANDLE のシステム位置をバイト単位で lseek(2) を使って設定します。
FILEHANDLE は式でも構いません。
その場合はその値がファイルハンドルの名前となります。
WHENCE の値が、C<0> ならば、新しい位置を POSITION の位置へ設定します;
C<1> ならば、現在位置から POSITION 加えた位置へ設定します; C<2> ならば、
EOF から POSITION だけ(普通は負の数です)加えた位置へ、新しい位置を
設定します。

=begin original

Note the I<in bytes>: even if the filehandle has been set to operate
on characters (for example by using the C<:encoding(utf8)> I/O layer),
tell() will return byte offsets, not character offsets (because
implementing that would render sysseek() unacceptably slow).

=end original

I<バイト単位> に関する注意: 文字単位で扱うようにファイルハンドルが
設定されている場合(C<:encoding(utf8)> I/O 層を使っている場合など)でも、
tell() は文字のオフセットではなくバイトのオフセットを返します
(なぜならこれを実装すると sysseek() が受け入れられないほど
遅くなるからです)。

=begin original

sysseek() bypasses normal buffered IO, so mixing it with reads other
than C<sysread> (for example C<< <> >> or read()) C<print>, C<write>,
C<seek>, C<tell>, or C<eof> may cause confusion.

=end original

sysseek() は普通のバッファ付き IO をバイパスしますので、
C<sysread> 以外の (例えば C<< <> >> や read() の)読み込み、
C<print>, C<write>, C<seek>, C<tell>, C<eof> と混ぜて使うと
混乱を引き起こします。

=begin original

For WHENCE, you may also use the constants C<SEEK_SET>, C<SEEK_CUR>,
and C<SEEK_END> (start of the file, current position, end of the file)
from the Fcntl module.  Use of the constants is also more portable
than relying on 0, 1, and 2.  For example to define a "systell" function:

=end original

この値には、Fcntl モジュールで使われている C<SEEK_SET>、
C<SEEK_CUR>、C<SEEK_END> 
(ファイルの先頭、現在位置、ファイルの最後)という定数を使うこともできます。

    use Fcntl 'SEEK_CUR';
    sub systell { sysseek($_[0], 0, SEEK_CUR) }

=begin original

Returns the new position, or the undefined value on failure.  A position
of zero is returned as the string C<"0 but true">; thus C<sysseek> returns
true on success and false on failure, yet you can still easily determine
the new position.

=end original

新しい位置を返します。
失敗したときは未定義値を返します。
位置がゼロの場合は、C<"0 but true"> の文字列として返されます。
従って C<sysseek> は成功時に真を返し、失敗時に偽を返しますが、
簡単に新しい位置を判定できます。

=item system LIST
X<system> X<shell>

=item system PROGRAM LIST

=begin original

Does exactly the same thing as C<exec LIST>, except that a fork is
done first and the parent process waits for the child process to
exit.  Note that argument processing varies depending on the
number of arguments.  If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.  If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is C</bin/sh -c> on Unix platforms, but varies on other
platforms).  If there are no shell metacharacters in the argument,
it is split into words and passed directly to C<execvp>, which is
more efficient.

=end original

C<exec LIST> とほとんど同じですが、まず fork を行ない、
親プロセスではチャイルドプロセスが終了するのを wait します。
exec の項で述べたように、引数の処理は、引数の数によって異なることに
注意してください。
LIST に複数の引数がある場合、または LIST が複数の要素からなる配列の場合、
リストの最初の要素で与えられるプログラムを、リストの残りの要素を
引数として起動します。
スカラの引数が一つだけの場合、
引数はシェルのメタ文字をチェックされ、もしあれば
パーズのために引数全体がシステムコマンドシェル
(これは Unix プラットフォームでは C</bin/sh -c> ですが、
他のプラットフォームでは異なります)に渡されます。
シェルのメタ文字がなかった場合、
引数は単語に分解されて直接 C<execvp> に渡されます。
この方がより効率的です。

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method
of C<IO::Handle> on any open handles.

=end original

v5.6.0 から、Perl は fork を行うようなあらゆる動作の前に
出力用にオープンしていた全てのファイルをフラッシュしようとします。
しかしこれをサポートしていないプラットフォームもあります(L<perlport> 参照)。
安全のためには、C<$l>(English モジュールを使っているなら $AUTOFLUSH)を
設定するか、あらゆるオープン済みハンドルにおいて C<IO::Handle> の C<autoflush()>
メソッドが必要となるかもしれません。

=begin original

The return value is the exit status of the program as returned by the
C<wait> call.  To get the actual exit value, shift right by eight (see
below). See also L</exec>.  This is I<not> what you want to use to capture
the output from a command; for that you should use merely backticks or
C<qx//>, as described in L<perlop/"`STRING`">.  Return value of -1
indicates a failure to start the program or an error of the wait(2) system
call (inspect $! for the reason).

=end original

返り値は、C<wait> が返すプログラムの exit 状態です。
実際の exit 値を得るには 右に 8 ビットシフトしてください(後述)。
L</exec> も参照してください。
これはコマンドからの出力を捕らえるために使うものI<ではありません>;
そのような用途には、L<perlop/"`STRING`"> に記述されている
逆クォートや C<qx//> を使用してください。
-1 の返り値はプログラムを開始させることに失敗したか、wait(2) 
システムコールがエラーを出したことを示します
(理由は $! を調べてください)。

=begin original

If you'd like to make C<system> (and many other bits of Perl) die on error,
have a look at the L<autodie> pragma.

=end original

もし C<system> (及び Perl のその他の多くの部分) でエラー時に
die したいなら、L<autodie> プラグマを見てみてください。

=begin original

Like C<exec>, C<system> allows you to lie to a program about its name if
you use the C<system PROGRAM LIST> syntax.  Again, see L</exec>.

=end original

C<exec> と同様に、C<system> でも C<system PROGRAM LIST> の文法を
使うことで、プログラムに対してその名前を嘘をつくことができます。
再び、L</exec> を参照して下さい。

=begin original

Since C<SIGINT> and C<SIGQUIT> are ignored during the execution of
C<system>, if you expect your program to terminate on receipt of these
signals you will need to arrange to do so yourself based on the return
value.

=end original

C<SIGINT> と C<SIGQUIT> は C<system> の実行中は無視されるので、
これらのシグナルを受信して終了させることを想定したプログラムの場合、
返り値を利用するように変更する必要があります。

    @args = ("command", "arg1", "arg2");
    system(@args) == 0
        or die "system @args failed: $?"

=begin original

If you'd like to manually inspect C<system>'s failure, you can check all
possible failure modes by inspecting C<$?> like this:

=end original

C<system> の失敗を手動で検査したいなら、
以下のように C<$?> を調べることで、全ての失敗の可能性を
チェックできます:

    if ($? == -1) {
        print "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        printf "child died with signal %d, %s coredump\n",
            ($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
        printf "child exited with value %d\n", $? >> 8;
    }

=begin original

Alternatively, you may inspect the value of C<${^CHILD_ERROR_NATIVE}>
with the C<W*()> calls from the POSIX module.

=end original

または、POSIX モジュールの C<W*()> 呼び出しを使って
C<${^CHILD_ERROR_NATIVE}> の値を調べることもできます。

=begin original

When C<system>'s arguments are executed indirectly by the shell, 
results and return codes are subject to its quirks.
See L<perlop/"`STRING`"> and L</exec> for details.

=end original

C<system> の引数がシェルによって間接的に実行された場合、
結果と返り値はシェルの癖によって変更されることがあります。
詳細については L<perlop/"`STRING`"> と L</exec> を参照して下さい。

=begin original

Since C<system> does a C<fork> and C<wait> it may affect a C<SIGCHLD>
handler. See L<perlipc> for details.

=end original

C<system> は C<fork> と C<wait> を行うので、C<SIGCHLD> ハンドラの影響を
受けます。
詳しくは L<perlipc> を参照してください。

=item syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
X<syswrite>

=item syswrite FILEHANDLE,SCALAR,LENGTH

=item syswrite FILEHANDLE,SCALAR

=begin original

Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using write(2).  If LENGTH is
not specified, writes whole SCALAR.  It bypasses buffered IO, so
mixing this with reads (other than C<sysread())>, C<print>, C<write>,
C<seek>, C<tell>, or C<eof> may cause confusion because the perlio and
stdio layers usually buffer data.  Returns the number of bytes
actually written, or C<undef> if there was an error (in this case the
errno variable C<$!> is also set).  If the LENGTH is greater than the
data available in the SCALAR after the OFFSET, only as much data as is
available will be written.

=end original

write(2) を使って、指定した FILEHANDLEへ、
変数 SCALAR から、LENGTH バイトのデータの書き込みを試みます。
LENGTH が指定されなかった場合、 SCALAR 全体を書き込みます。
これは、バッファ付き IO ルーチンを通りませんから、
他の入力関数(C<sysread()> 以外), C<print>, C<write>,
C<seek>, C<tell>, or C<eof>と混ぜて使うと、
出力がおかしくなるかもしれません。
perlio 層と stdio 層は普通データをバッファリングするからです。
実際に読み込まれたデータの長さか、エラー時には C<undef> が返されます
(この場合エラー変数 C<$!> もセットされます)。
LENGTH が OFFSET 以降の SCALAR の利用可能なデータより大きかった場合、
利用可能なデータのみが書き込まれます。

=begin original

An OFFSET may be specified to write the data from some part of the
string other than the beginning.  A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.
If SCALAR is of length zero, you can only use an OFFSET of 0.

=end original

OFFSET を指定すると、SCALAR の先頭以外の場所から、
データを取り出して、書き込みを行なうことができます。
OFFSET に負の値を指定すると、文字列の最後から逆向きに数えて
何バイト目から書き込むかを示します。
SCALAR の長さが 0 の場合、OFFSET は 0 のみ使用できます。

=begin original

B<WARNING>: If the filehandle is marked C<:utf8>, Unicode characters
encoded in UTF-8 are written instead of bytes, and the LENGTH, OFFSET, and
return value of syswrite() are in (UTF8-encoded Unicode) characters.
The C<:encoding(...)> layer implicitly introduces the C<:utf8> layer.
Alternately, if the handle is not marked with an encoding but you
attempt to write characters with code points over 255, raises an exception.
See L</binmode>, L</open>, and the C<open> pragma, L<open>.

=end original

B<警告>: ファイルハンドルが C<:utf8> であるとマークが付けられると、
バイトではなく UTF-8 エンコードされた Unicode 文字が読み込まれ、
syswrite() の LENGTH, OFFSET および返り値は (UTF8 エンコードされた
Unicode) 文字単位になります。
C<:encoding(...)> 層は暗黙のうちに C<:utf8> 層が導入されます。
または、もしハンドルにエンコーディングが記録されていない状態で
255 を超える符号位置の文字を書き込もうとすると、例外が発生します。
L</binmode>, L</open>, C<open> プラグマ, L<open> を参照してください。

=item tell FILEHANDLE
X<tell>

=item tell

=begin original

Returns the current position I<in bytes> for FILEHANDLE, or -1 on
error.  FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.  If FILEHANDLE is omitted, assumes the file
last read.

=end original

FILEHANDLE の現在の位置を I<バイト数で> 返します。
エラーの場合は -1 を返します。
FILEHANDLE は、実際のファイルハンドル名を示す式でもかまいません。
FILEHANDLE が省略された場合には、
最後に読み込みを行なったファイルについて調べます。

=begin original

Note the I<in bytes>: even if the filehandle has been set to
operate on characters (for example by using the C<:encoding(utf8)> open
layer), tell() will return byte offsets, not character offsets (because
that would render seek() and tell() rather slow).

=end original

I<バイト単位> に関する注意: ファイルハンドルが (例えば
C<:encoding(utf8)> 層を使って)
文字を操作するように設定されていたとしても、tell() は文字の
オフセットではなくバイトのオフセットを返すことに注意してください
(なぜならこれは seek() と tell() が遅くなってしまうからです)。

=begin original

The return value of tell() for the standard streams like the STDIN
depends on the operating system: it may return -1 or something else.
tell() on pipes, fifos, and sockets usually returns -1.

=end original

STDIN のような標準ストリームに対する tell() の返り値は OS に依存します。
-1 やその他の値が返ってくるかもしれません。
パイプ、FIFO、ソケットに対して tell() を使うと、普通は -1 が返ります。

=begin original

There is no C<systell> function.  Use C<sysseek(FH, 0, 1)> for that.

=end original

C<systell> 関数はありません。
代わりに C<sysseek(FH, 0, 1)> を使ってください。

=begin original

Do not use tell() (or other buffered I/O operations) on a filehandle
that has been manipulated by sysread(), syswrite(), or sysseek().
Those functions ignore the buffering, while tell() does not.

=end original

sysread(), syswrite(), sysseek() で操作されたファイルハンドルに tell()
(またはその他のバッファリング I/O 操作) を使わないでください。
これらの関数はバッファリングを無視しますが、tell() は違います。

=item telldir DIRHANDLE
X<telldir>

=begin original

Returns the current position of the C<readdir> routines on DIRHANDLE.
Value may be given to C<seekdir> to access a particular location in a
directory.  C<telldir> has the same caveats about possible directory
compaction as the corresponding system library routine.

=end original

DIRHANDLE 上の C<readdir> ルーチンに対する現在位置を返します。
値は、そのディレクトリで特定の位置をアクセスするため、
C<seekdir> に渡すことができます。
C<telldir> は同名のシステムライブラリルーチンと同じく、
ディレクトリ縮小時の問題が考えられます。

=item tie VARIABLE,CLASSNAME,LIST
X<tie>

=begin original

This function binds a variable to a package class that will provide the
implementation for the variable.  VARIABLE is the name of the variable
to be enchanted.  CLASSNAME is the name of a class implementing objects
of correct type.  Any additional arguments are passed to the C<new>
method of the class (meaning C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>,
or C<TIEHASH>).  Typically these are arguments such as might be passed
to the C<dbm_open()> function of C.  The object returned by the C<new>
method is also returned by the C<tie> function, which would be useful
if you want to access other methods in CLASSNAME.

=end original

この関数は、変数を、その変数の実装を行なうクラスと結び付けます。
VARIABLE は、魔法をかける変数の名前です。
CLASSNAME は、正しい型のオブジェクトを実装するクラスの名前です。
他に引数があれば、そのクラスの C<new> メソッドに渡されます
(つまり C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>, C<TIEHASH>)。
通常、これらは、C の C<dbm_open> などの関数に渡す引数となります。
C<new> メソッドで返されるオブジェクトはまた C<tie> 関数でも返されます。
これは CLASSNAME の他のメソッドにアクセスしたいときに便利です。

=begin original

Note that functions such as C<keys> and C<values> may return huge lists
when used on large objects, like DBM files.  You may prefer to use the
C<each> function to iterate over such.  Example:

=end original

DBM ファイルのような大きなオブジェクトでは、C<keys> や C<values> のような
関数は、大きなリストを返す可能性があります。
そのような場合では、C<each> 関数を使って繰り返しを行なった方が
よいかもしれません。
例:

    # print out history file offsets
    use NDBM_File;
    tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    untie(%HIST);

=begin original

A class implementing a hash should have the following methods:

=end original

ハッシュを実装するクラスでは、次のようなメソッドを用意します:

    TIEHASH classname, LIST
    FETCH this, key
    STORE this, key, value
    DELETE this, key
    CLEAR this
    EXISTS this, key
    FIRSTKEY this
    NEXTKEY this, lastkey
    SCALAR this
    DESTROY this
    UNTIE this

=begin original

A class implementing an ordinary array should have the following methods:

=end original

通常の配列を実装するクラスでは、次のようなメソッドを用意します:

    TIEARRAY classname, LIST
    FETCH this, key
    STORE this, key, value
    FETCHSIZE this
    STORESIZE this, count
    CLEAR this
    PUSH this, LIST
    POP this
    SHIFT this
    UNSHIFT this, LIST
    SPLICE this, offset, length, LIST
    EXTEND this, count
    DESTROY this
    UNTIE this

=begin original

A class implementing a filehandle should have the following methods:

=end original

ファイルハンドルを実装するクラスでは、次のようなメソッドを用意します:

    TIEHANDLE classname, LIST
    READ this, scalar, length, offset
    READLINE this
    GETC this
    WRITE this, scalar, length, offset
    PRINT this, LIST
    PRINTF this, format, LIST
    BINMODE this
    EOF this
    FILENO this
    SEEK this, position, whence
    TELL this
    OPEN this, mode, LIST
    CLOSE this
    DESTROY this
    UNTIE this

=begin original

A class implementing a scalar should have the following methods:

=end original

スカラ変数を実装するクラスでは、次のようなメソッドを用意します:

    TIESCALAR classname, LIST
    FETCH this,
    STORE this, value
    DESTROY this
    UNTIE this

=begin original

Not all methods indicated above need be implemented.  See L<perltie>,
L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>, and L<Tie::Handle>.

=end original

上記の全てのメソッドを実装する必要はありません。
L<perltie>, L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>,
L<Tie::Handle> を参照して下さい。

=begin original

Unlike C<dbmopen>, the C<tie> function will not C<use> or C<require> a module
for you; you need to do that explicitly yourself.  See L<DB_File>
or the F<Config> module for interesting C<tie> implementations.

=end original

C<dbmopen> と違い、C<tie> 関数はモジュールを C<use> したり
C<require> したりしません; 自分で明示的に行う必要があります。
C<tie> の興味深い実装については L<DB_File> や F<Config> モジュールを
参照して下さい。

=begin original

For further details see L<perltie>, L<"tied VARIABLE">.

=end original

更なる詳細については L<perltie> や L<"tied VARIABLE"> を参照して下さい。

=item tied VARIABLE
X<tied>

=begin original

Returns a reference to the object underlying VARIABLE (the same value
that was originally returned by the C<tie> call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.

=end original

VARIABLE の基となるオブジェクトへのリファレンスを返します
(変数をパッケージに結びつけるために C<tie> 呼び出しをしたときの
返り値と同じものです)。
VARIABLE がパッケージと結び付けられていない場合は未定義値を返します。

=item time
X<time> X<epoch>

=begin original

Returns the number of non-leap seconds since whatever time the system
considers to be the epoch, suitable for feeding to C<gmtime> and
C<localtime>. On most systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.

=end original

C<gmtime> や C<localtime> への入力形式に合っている、
システムが紀元と考える時点からの連続秒数を返します。
ほとんどのシステムでは紀元は UTC 1970 年 1 月 1 日 00:00:00 です;
特徴的な例外としては、古い Mac OS ではローカルタイムゾーンの
1904 年 1 月 1 日 00:00:00 を紀元として使います。

=begin original

For measuring time in better granularity than one second, use the
L<Time::HiRes> module from Perl 5.8 onwards (or from CPAN before then), or,
if you have gettimeofday(2), you may be able to use the C<syscall>
interface of Perl.  See L<perlfaq8> for details.

=end original

1 秒よりも細かい時間を計測するためには、Perl 5.8 以降(それ以前では
CPANから)の L<Time::HiRes> モジュールを使うか、
gettimeofday(2) があるなら、Perl の C<syscall> インターフェースを
使ってください。
詳しくは L<perlfaq8> を参照して下さい。

=begin original

For date and time processing look at the many related modules on CPAN.
For a comprehensive date and time representation look at the
L<DateTime> module.

=end original

日付と時刻の処理は、多くの関連するモジュールが CPAN にあります。
包括的な日付と時刻の表現については、CPAN の L<DateTime> モジュールを
参照してください。

=item times
X<times>

=begin original

Returns a four-element list giving the user and system times in
seconds for this process and any exited children of this process.

=end original

現プロセス及び終了したその子プロセスに対する、ユーザ時間とシステム時間を
秒で示した、4 要素のリスト値を返します。

    ($user,$system,$cuser,$csystem) = times;

=begin original

In scalar context, C<times> returns C<$user>.

=end original

スカラコンテキストでは、C<times> は C<$user> を返します。

=begin original

Children's times are only included for terminated children.

=end original

子プロセスに対する times は、終了した子プロセスのみ含められます。

=item tr///

=begin original

The transliteration operator.  Same as C<y///>.  See
L<perlop/"Quote and Quote-like Operators">.

=end original

変換演算子。
C<y///> と同じです。
L<perlop/"Quote and Quote-like Operators"> を参照してください。

=item truncate FILEHANDLE,LENGTH
X<truncate>

=item truncate EXPR,LENGTH

=begin original

Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.  Raises an exception if truncate isn't implemented
on your system.  Returns true if successful, C<undef> on error.

=end original

FILEHANDLE 上にオープンされたファイルか、EXPR で名前を表わしたファイルを、
指定した長さに切り詰めます。
システム上に truncate が実装されていなければ、例外が発生します。
成功すれば真を、エラー時には C<undef> を返します。

=begin original

The behavior is undefined if LENGTH is greater than the length of the
file.

=end original

LENGTH がファイルの長さより大きい場合の振る舞いは未定義です。

=begin original

The position in the file of FILEHANDLE is left unchanged.  You may want to
call L<seek|/"seek FILEHANDLE,POSITION,WHENCE"> before writing to the file.

=end original

FILEHANDLE のファイルの位置は変わりません。
ファイルに書き込む前に L<seek|/"seek FILEHANDLE,POSITION,WHENCE"> を
呼び出したいかもしれません。

=item uc EXPR
X<uc> X<uppercase> X<toupper>

=item uc

=begin original

Returns an uppercased version of EXPR.  This is the internal function
implementing the C<\U> escape in double-quoted strings.
It does not attempt to do titlecase mapping on initial letters.  See
L</ucfirst> for that.

=end original

EXPR を大文字に変換したものを返します。
これは、ダブルクォート文字列における、C<\U> エスケープを
実装する内部関数です。
先頭文字の タイトル文字マッピングは試みません。
このためには L</ucfirst> を参照してください。

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR が省略されると、C<$_> を使います。

=begin original

This function behaves the same way under various pragma, such as in a locale,
as L</lc> does.

=end original

この関数は、ロケールのようなさまざまなプラグマの影響下では、
L</lc> と同様に振る舞います。

=item ucfirst EXPR
X<ucfirst> X<uppercase>

=item ucfirst

=begin original

Returns the value of EXPR with the first character in uppercase
(titlecase in Unicode).  This is the internal function implementing
the C<\u> escape in double-quoted strings.

=end original

最初の文字だけを大文字にした、EXPR を返します
(Unicode では titlecase)。
これは、ダブルクォート文字列における、C<\u> エスケープを
実装する内部関数です。

=begin original

If EXPR is omitted, uses C<$_>.

=end original

EXPR が省略されると、C<$_> を使います。

=begin original

This function behaves the same way under various pragma, such as in a locale,
as L</lc> does.

=end original

この関数は、ロケールのようなさまざまなプラグマの影響下では、
L</lc> と同様に振る舞います。

=item umask EXPR
X<umask>

=item umask

=begin original

Sets the umask for the process to EXPR and returns the previous value.
If EXPR is omitted, merely returns the current umask.

=end original

現在のプロセスの umask を EXPR に設定し、以前の値を返します。
EXPR が省略されると、単にその時点の umask の値を返します。

=begin original

The Unix permission C<rwxr-x---> is represented as three sets of three
bits, or three octal digits: C<0750> (the leading 0 indicates octal
and isn't one of the digits).  The C<umask> value is such a number
representing disabled permissions bits.  The permission (or "mode")
values you pass C<mkdir> or C<sysopen> are modified by your umask, so
even if you tell C<sysopen> to create a file with permissions C<0777>,
if your umask is C<0022>, then the file will actually be created with
permissions C<0755>.  If your C<umask> were C<0027> (group can't
write; others can't read, write, or execute), then passing
C<sysopen> C<0666> would create a file with mode C<0640> (because 
C<0666 &~ 027> is C<0640>).

=end original

Unix パーミッション C<rwxr-x---> は 3 ビットの三つの組、
または 3 桁の 8 進数として表現されます:
C<0750> (先頭の 0 は 8 進数を意味し、実際の値ではありません)。
C<umask> の値は無効にするパーミッションビットのこのような数値表現です。
C<mkdir> や C<sysopen> で渡されたパーミッション(または「モード」)の値は
umask で修正され、たとえ C<sysopen> で C<0777> のパーミッションで
ファイルを作るように指定しても、umask が C<0022> なら、
結果としてファイルは C<0755> のパーミッションで作成されます。
C<umask> が C<0027> (グループは書き込めない; その他は読み込み、書き込み、
実行できない) のとき、C<sysopen> に C<0666> を渡すと、
ファイルはモード C<0640> (なぜなら C<0666 &~ 027> は C<0640>)で作成されます。

=begin original

Here's some advice: supply a creation mode of C<0666> for regular
files (in C<sysopen>) and one of C<0777> for directories (in
C<mkdir>) and executable files.  This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of C<022>, C<027>, or even the particularly antisocial mask of C<077>.
Programs should rarely if ever make policy decisions better left to
the user.  The exception to this is when writing files that should be
kept private: mail files, web browser cookies, I<.rhosts> files, and
so on.

=end original

以下は助言です: 作成モードとして、(C<sysopen> による)通常ファイルでは
C<0666> を、(C<mkdir> による)ディレクトリでは C<0777> を指定しましょう。
これにより、ユーザーに選択の自由を与えます: もしファイルを守りたいなら、
プロセスの umask として C<022>, C<027>, あるいは特に非社交的な
C<077> を選択できます。
プログラムがユーザーより適切なポリシー選択ができることは稀です。
例外は、プライベートに保つべきファイル(メール、ウェブブラウザのクッキー、
I<.rhosts> ファイルなど)を書く場合です。

=begin original

If umask(2) is not implemented on your system and you are trying to
restrict access for I<yourself> (i.e., C<< (EXPR & 0700) > 0 >>), 
raises an exception.  If umask(2) is not implemented and you are
not trying to restrict access for yourself, returns C<undef>.

=end original

umask(2) が実装されていないシステムで、I<自分自身> へのアクセスを
制限しようとした(つまり C<< (EXPR & 0700) > 0 >>)場合、例外が発生します。
umask(2) が実装されていないシステムで、自分自身へのアクセスは
制限しようとしなかった場合、C<undef> を返します。

=begin original

Remember that a umask is a number, usually given in octal; it is I<not> a
string of octal digits.  See also L</oct>, if all you have is a string.

=end original

umask は通常 8 進数で与えられる数値であることを忘れないでください。
8 進数の文字列 I<ではありません>。
文字列しかない場合、 L</oct> も参照して下さい。

=item undef EXPR
X<undef> X<undefine>

=item undef

=begin original

Undefines the value of EXPR, which must be an lvalue.  Use only on a
scalar value, an array (using C<@>), a hash (using C<%>), a subroutine
(using C<&>), or a typeglob (using C<*>).  Saying C<undef $hash{$key}>
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see L<delete>.  Always returns the
undefined value.  You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable, or pass as a
parameter.  Examples:

=end original

左辺値である EXPR の値を未定義にします。
スカラ値、(C<@> を使った)配列、(C<%> を使った)ハッシュ、(C<&> を使った) 
サブルーチン、(C<*> を使った)型グロブだけに使用します。
特殊変数や DBM リスト値に C<undef $hash{$key}> などとしても
おそらく期待通りの結果にはなりませんから、しないでください;
L</delete> を参照してください。
常に未定義値を返します。
EXPR は省略することができ、その場合には何も未定義にされませんが
未定義値は返されますので、それをたとえば、
サブルーチンの返り値、変数への割り当て、引数などとして使うことができます。
例:

    undef $foo;
    undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};
    undef @ary;
    undef %hash;
    undef &mysub;
    undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
    return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;
    select undef, undef, undef, 0.25;
    ($a, $b, undef, $c) = &foo;       # Ignore third value returned

=begin original

Note that this is a unary operator, not a list operator.

=end original

これはリスト演算子ではなく、単項演算子であることに注意してください。

=item unlink LIST
X<unlink> X<delete> X<remove> X<rm> X<del>

=item unlink

=begin original

Deletes a list of files. On success, it returns the number of files
it successfully deleted. On failure, it returns false and sets C<$!>
(errno):

=end original

LIST に含まれるファイルを削除します。
成功時は削除に成功したファイルの数を返します。
失敗時は偽を返し、C<$!> (error) をセットします:

    my $unlinked = unlink 'a', 'b', 'c';
    unlink @goners;
    unlink glob "*.bak";

=begin original

On error, C<unlink> will not tell you which files it could not remove.
If you want to know which files you could not remove, try them one
at a time:

=end original

エラーの場合、C<unlink> はどのファイルが削除できなかったかを知らせません。
どのファイルが削除できなかったかを知りたい場合は、一つずつ削除してください:

     foreach my $file ( @goners ) {
         unlink $file or warn "Could not unlink $file: $!";
     }

=begin original

Note: C<unlink> will not attempt to delete directories unless you are
superuser and the B<-U> flag is supplied to Perl. Even if these
conditions are met, be warned that unlinking a directory can inflict
damage on your filesystem.  Finally, using C<unlink> on directories is
not supported on many operating systems.  Use C<rmdir> instead.

=end original

注: スーパーユーザ権限で、Perl に -U を付けて実行した場合でなければ、
C<unlink> はディレクトリを削除しようとすることはありません。
この条件にあう場合にも、ディレクトリの削除は、
ファイルシステムに多大な損害を与える可能性があります。
最後に、C<unlink> をディレクトリに使うのはほとんどの OS では
対応していません。
代わりに C<rmdir> を使ってください。

=begin original

If LIST is omitted, C<unlink> uses C<$_>.

=end original

LIST が省略されると、C<unlink> は C<$_> を使います。

=item unpack TEMPLATE,EXPR
X<unpack>

=item unpack TEMPLATE

=begin original

C<unpack> does the reverse of C<pack>: it takes a string
and expands it out into a list of values.
(In scalar context, it returns merely the first value produced.)

=end original

C<unpack> は C<pack> の逆を行ないます: 構造体を表わす文字列をとり、
リスト値に展開し、その配列値を返します。
(スカラコンテキストでは、単に最初の値を返します。)

=begin original

If EXPR is omitted, unpacks the C<$_> string.
See L<perlpacktut> for an introduction to this function.

=end original

EXPR が省略されると、C<$_> の文字列を unpack します。
この関数についての説明については L<perlpacktut> を参照してください。

=begin original

The string is broken into chunks described by the TEMPLATE.  Each chunk
is converted separately to a value.  Typically, either the string is a result
of C<pack>, or the characters of the string represent a C structure of some
kind.

=end original

文字列は TEMPLATE で示された固まりに分割されます。
それぞれの固まりは別々に値に変換されます。
典型的には、文字列は C<pack> の結果あるいはある種の C の構造体の
文字列表現の文字列です。

=begin original

The TEMPLATE has the same format as in the C<pack> function.
Here's a subroutine that does substring:

=end original

TEMPLATE は、C<pack> 関数と同じフォーマットを使います。
部分文字列を取り出すうサブルーチンの例を示します:

    sub substr {
        my($what,$where,$howmuch) = @_;
        unpack("x$where a$howmuch", $what);
    }

=begin original

and then there's

=end original

これもそうです。

    sub ordinal { unpack("W",$_[0]); } # same as ord()

=begin original

In addition to fields allowed in pack(), you may prefix a field with
a %<number> to indicate that
you want a <number>-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  Checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
C<ord($char)> is taken; for bit fields the sum of zeroes and ones).

=end original

pack() で利用可能なフィールドの他に、
フィールドの前に %<数値> というものを付けて、
項目自身の代わりに、その項目の <数値>-ビットのチェックサムを
計算させることができます。
デフォルトは、16-ビットチェックサムです。
チェックサムは展開された値の数値としての値の合計
(文字列フィールドの場合は C<ord($char)> の合計;
ビットフィールドの場合は 0 と 1 の合計) が用いられます。

=begin original

For example, the following
computes the same number as the System V sum program:

=end original

たとえば、以下のコードは
System V の sum プログラムと同じ値を計算します。

    $checksum = do {
        local $/;  # slurp!
        unpack("%32W*",<>) % 65535;
    };

=begin original

The following efficiently counts the number of set bits in a bit vector:

=end original

以下は、効率的にビットベクターの設定されているビットを
数えるものです。

    $setbits = unpack("%32b*", $selectmask);

=begin original

The C<p> and C<P> formats should be used with care.  Since Perl
has no way of checking whether the value passed to C<unpack()>
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.

=end original

C<p> と C<P> は注意深く使うべきです。
Perl は C<unpack()> に渡された値が有効なメモリ位置を指しているかどうかを
確認する方法がないので、有効かどうかわからないポインタ値を渡すと
悲惨な結果を引き起こすかもしれません。

=begin original

If there are more pack codes or if the repeat count of a field or a group
is larger than what the remainder of the input string allows, the result
is not well defined: the repeat count may be decreased, or
C<unpack()> may produce empty strings or zeros, or it may raise an exception.
If the input string is longer than one described by the TEMPLATE,
the remainder of that input string is ignored.

=end original

多くの pack コードがある場合や、フィールドやグループの繰り返し回数が
入力文字列の残りより大きい場合、結果は未定義です:
繰り返し回数が減らされる場合もありますし、C<unpack()> が空文字列や 0 を
返すこともありますし、例外が発生します。
もし入力文字列が TEMPLATE で表現されているものより大きい場合、
入力文字列の残りは無視されます。

=begin original

See L</pack> for more examples and notes.

=end original

さらなる例と注意に関しては L</pack> を参照してください。

=item untie VARIABLE
X<untie>

=begin original

Breaks the binding between a variable and a package.  (See C<tie>.)
Has no effect if the variable is not tied.

=end original

変数とパッケージの間の結合を解きます。
(L<tie> を参照してください。)
結合されていない場合は何も起きません。

=item unshift ARRAY,LIST
X<unshift>

=item unshift EXPR,LIST

=begin original

Does the opposite of a C<shift>.  Or the opposite of a C<push>,
depending on how you look at it.  Prepends list to the front of the
array and returns the new number of elements in the array.

=end original

C<shift> の逆操作を行ないます。
見方を変えれば、C<push> の逆操作とも考えられます。
LIST を ARRAY の先頭に入れて、新しくできた配列の要素の数を返します。

    unshift(@ARGV, '-e') unless $ARGV[0] =~ /^-/;

=begin original

Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.  Use C<reverse> to do the
reverse.

=end original

LIST は、はらばらにではなく、一度に登録されるので、順番はそのままです。
逆順に登録するには、C<reverse> を使ってください。

=begin original

Starting with Perl 5.14, C<unshift> can take a scalar EXPR, which must hold
a reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of C<unshift> is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<unshift> はスカラの EXPR を取ることができるようになりました;
これは bless されていない配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<unshift> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

=item use Module VERSION LIST
X<use> X<module> X<import>

=item use Module VERSION

=item use Module LIST

=item use Module

=item use VERSION

=begin original

Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to

=end original

指定したモジュールから、現在のパッケージにさまざまな内容を
インポートします。
多くは、パッケージのサブルーチン名や、変数名に別名を付けることで、
実現されています。これは、
以下は等価ですが:

    BEGIN { require Module; Module->import( LIST ); }

=begin original

except that Module I<must> be a bareword.
The importation can be made conditional; see L<if>.

=end original

Module が I<裸の単語でなければならない> ことを除けば、です。
インポートは条件付きで行うことができます; L<if> を参照してください。

=begin original

In the peculiar C<use VERSION> form, VERSION may be either a positive
decimal fraction such as 5.006, which will be compared to C<$]>, or a v-string
of the form v5.6.1, which will be compared to C<$^V> (aka $PERL_VERSION).  An
exception is raised if VERSION is greater than the version of the
current Perl interpreter; Perl will not attempt to parse the rest of the
file.  Compare with L</require>, which can do a similar check at run time.
Symmetrically, C<no VERSION> allows you to specify that you want a version
of Perl older than the specified one.

=end original

特に C<use VERSION> の形式では、
VERSION は 5.006 のような正の 10 進小数 (C<$]> と比較されます)か、v5.6.1 の形
(C<$^V> (またの名を $PERL_VERSION) と比較されます) のv-文字列で指定します。
VERSION が Perl の現在のバージョンより大きいと、例外が発生します;
Perl はファイルの残りを読み込みません。
L</require> と似ていますが、これは実行時にチェックされます。
対称的に、C<no VERSION> は指定されたバージョンより古いバージョンの Perl で
動作させたいことを意味します。

=begin original

Specifying VERSION as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl (that is, prior to 5.6.0) that do not support this
syntax.  The equivalent numeric version should be used instead.

=end original

VERSION に v5.6.1 の形のリテラルを指定することは一般的には避けるべきです;
なぜなら、この文法に対応していない Perl の初期のバージョン
(つまり、 5.6.0 以前) では誤解させるようなエラーメッセージが出るからです。
代わりに等価な数値表現を使うべきです。

    use v5.6.1;     # compile time version check
    use 5.6.1;      # ditto
    use 5.006_001;  # ditto; preferred for backwards compatibility

=begin original

This is often useful if you need to check the current Perl version before
C<use>ing library modules that won't work with older versions of Perl.
(We try not to do this more than we have to.)

=end original

これは古いバージョンの Perl で動かなくなったライブラリ
モジュール(我々は必要な場合以外にそのようなことがないように
努力していますが)を C<use> する前に、現在の Perl のバージョンを
調べたい場合に有用です。

=begin original

Also, if the specified Perl version is greater than or equal to 5.9.5,
C<use VERSION> will also load the C<feature> pragma and enable all
features available in the requested version.  See L<feature>.
Similarly, if the specified Perl version is greater than or equal to
5.11.0, strictures are enabled lexically as with C<use strict> (except
that the F<strict.pm> file is not actually loaded).

=end original

また、指定された Perl のバージョンが 5.9.5 以上の場合、C<use VERSION> は
C<feature> プラグマも読み込み、要求されたバージョンで利用可能な全ての機能を
有効にします。
L<feature> を参照してください。
同様に、指定された Perl のバージョンが 5.11.0 以上の場合、
制限は C<use strict> と同様にレキシカルに有効になります
(但し F<strict.pm> ファイルは実際には読み込まれません)。

=begin original

The C<BEGIN> forces the C<require> and C<import> to happen at compile time.  The
C<require> makes sure the module is loaded into memory if it hasn't been
yet.  The C<import> is not a builtin; it's just an ordinary static method
call into the C<Module> package to tell the module to import the list of
features back into the current package.  The module can implement its
C<import> method any way it likes, though most modules just choose to
derive their C<import> method via inheritance from the C<Exporter> class that
is defined in the C<Exporter> module.  See L<Exporter>.  If no C<import>
method can be found then the call is skipped, even if there is an AUTOLOAD
method.

=end original

C<BEGIN> によって、C<require> や C<import> は、コンパイル時に
実行されることになります。
C<require> は、モジュールがまだメモリにロードされていなければ、ロードします。
C<import> は、組込みの関数ではありません; さまざまな機能を現在のパッケージに
インポートするように C<Module> パッケージに伝えるために呼ばれる、
通常の静的メソッドです。
モジュール側では、C<import> メソッドをどのようにでも実装することが
できますが、多くのモジュールでは、C<Exporter> モジュールで定義された、
C<Exporter> クラスからの継承によって、C<import> メソッドを行なうように
しています。
L<Exporter>モジュールを参照してください。
C<import>メソッドが見つからなかった場合、AUTOLOAD メソッドがあったとしても
呼び出しはスキップされます。

=begin original

If you do not want to call the package's C<import> method (for instance,
to stop your namespace from being altered), explicitly supply the empty list:

=end original

パッケージの C<import> メソッドを呼び出したくない場合(例えば、名前空間を
変更したくない場合など)は、明示的に空リストを指定してください:

    use Module ();

=begin original

That is exactly equivalent to

=end original

これは以下と完全に等価です:

    BEGIN { require Module }

=begin original

If the VERSION argument is present between Module and LIST, then the
C<use> will call the VERSION method in class Module with the given
version as an argument.  The default VERSION method, inherited from
the UNIVERSAL class, croaks if the given version is larger than the
value of the variable C<$Module::VERSION>.

=end original

Module と LIST の間に VERSION 引数がある場合、C<use> は Module クラスの
VERSION メソッドを、与えられたバージョンを引数として呼び出します。
デフォルトの VERSION メソッドは、 UNIVERSAL クラスから継承したもので、
与えられたバージョンが 変数 C<$Module::VERSION> の値より大きい場合に
警告を出します。

=begin original

Again, there is a distinction between omitting LIST (C<import> called
with no arguments) and an explicit empty LIST C<()> (C<import> not
called).  Note that there is no comma after VERSION!

=end original

繰り返すと、LIST を省略する(C<import> が引数なしで呼び出される)ことと
明示的に空の LIST C<()> を指定する (C<import> は呼び出されない)ことは
違います。
VERSION の後ろにカンマが不要なことに注意してください!

=begin original

Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.  Currently implemented pragmas are:

=end original

これは、広く公開されているインタフェースですので、
プラグマ (コンパイラディレクティブ) も、この方法で実装されています。
現在実装されているプラグマには、以下のものがあります:

    use constant;
    use diagnostics;
    use integer;
    use sigtrap  qw(SEGV BUS);
    use strict   qw(subs vars refs);
    use subs     qw(afunc blurfl);
    use warnings qw(all);
    use sort     qw(stable _quicksort _mergesort);

=begin original

Some of these pseudo-modules import semantics into the current
block scope (like C<strict> or C<integer>, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).

=end original

通常のモジュールが、現在のパッケージにシンボルをインポートする
(これは、ファイルの終わりまで有効です) のに対して、
これらの擬似モジュールの一部(C<strict> や C<integer> など)は、
現在のブロックスコープにインポートを行ないます。

=begin original

Because C<use> takes effect at compile time, it doesn't respect the
ordinary flow control of the code being compiled.  In particular, putting
a C<use> inside the false branch of a conditional doesn't prevent it
from being processed.  If a module or pragma only needs to be loaded 
conditionally, this can be done using the L<if> pragma:

=end original

C<use> はコンパイル時に有効なので、コードがコンパイルされる際の通常の
流れ制御には従いません。
特に、条件文のうち成立しない側の中に C<use> を書いても、
処理を妨げられません。
モジュールやプラグマを条件付きでのみ読み込みたい場合、
L<if> プラグマを使って実現できます:

    use if $] < 5.008, "utf8";
    use if WANT_WARNINGS, warnings => qw(all);

=begin original

There's a corresponding C<no> declaration that unimports meanings imported
by C<use>, i.e., it calls C<unimport Module LIST> instead of C<import>.
It behaves just as C<import> does with VERSION, an omitted or empty LIST, 
or no unimport method being found.

=end original

これに対して、C<no> 宣言という、C<use> によってインポートされたものを、
インポートされていないことにするものがあります。
つまり、C<import> の代わりに C<unimport Module LIST> を呼び出します。
これは VERSION、省略された LIST、空の LIST、unimport メソッドが見つからない
場合などの観点では、C<import> と同様に振る舞います。

    no integer;
    no strict 'refs';
    no warnings;

=begin original

Care should be taken when using the C<no VERSION> form of C<no>.  It is
I<only> meant to be used to assert that the running Perl is of a earlier
version than its argument and I<not> to undo the feature-enabling side effects
of C<use VERSION>.

=end original

C<no> の C<no VERSION> 形式を使うときには注意を払うべきです。
これは引数で指定されたバージョンよりも前の Perl で実行されたときに
アサートされることを意味する I<だけ> で、C<use VERSION> によって
有効にされた副作用をなかったことにするもの I<ではありません>。

=begin original

See L<perlmodlib> for a list of standard modules and pragmas.  See L<perlrun>
for the C<-M> and C<-m> command-line options to Perl that give C<use>
functionality from the command-line.

=end original

標準モジュールやプラグマの一覧は、L<perlmodlib> を参照してください。
コマンドラインから C<use> 機能を指定するための C<-M> と C<-m> の
コマンドラインオプションについては L<perlrun> を参照して下さい。

=item utime LIST
X<utime>

=begin original

Changes the access and modification times on each file of a list of
files.  The first two elements of the list must be the NUMERIC access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode change time of each file is set
to the current time.  For example, this code has the same effect as the
Unix touch(1) command when the files I<already exist> and belong to
the user running the program:

=end original

ファイルのアクセス時刻と修正(modification) 時刻を変更します。
LIST の最初の二つの要素に、数値で表わしたアクセス時刻と修正時刻を
順に指定します。
LIST の残りの要素が、変更の対象となるファイルです。
変更に成功したファイルの数を返します。
各ファイルの inode 変更(change)時刻には、その時点の時刻が設定されます。
例えば、このコードはファイルが I<既に存在して> いて、ユーザーが
実行しているプログラムに従っているなら、
Unix の touch(1) コマンドと同じ効果があります。

    #!/usr/bin/perl
    $atime = $mtime = time;
    utime $atime, $mtime, @ARGV;

=begin original

Since Perl 5.7.2, if the first two elements of the list are C<undef>, 
the utime(2) syscall from your C library is called with a null second
argument. On most systems, this will set the file's access and
modification times to the current time (i.e., equivalent to the example
above) and will work even on files you don't own provided you have write
permission:

=end original

Perl 5.7.2 から、リストの最初の二つの要素が C<undef> である場合、
C ライブラリの utime(2) システムコールを、秒の引数を null として
呼び出します。
ほとんどのシステムでは、これによってファイルのアクセス時刻と修正時刻を
現在の時刻にセットし(つまり、上記の例と等価です)、
書き込み権限があれば他のユーザーのファイルに対しても動作します。

    for $file (@ARGV) {
	utime(undef, undef, $file) 
	    || warn "couldn't touch $file: $!";
    } 

=begin original

Under NFS this will use the time of the NFS server, not the time of
the local machine.  If there is a time synchronization problem, the
NFS server and local machine will have different times.  The Unix
touch(1) command will in fact normally use this form instead of the
one shown in the first example.

=end original

NFS では、これはローカルマシンの時刻ではなく、NFS サーバーの時刻が
使われます。
時刻同期に問題がある場合、NFS サーバーとローカルマシンで違う時刻に
なっている場合があります。
実際のところ、Unix の touch(1) コマンドは普通、最初の例ではなく、
この形を使います。

=begin original

Passing only one of the first two elements as C<undef> is
equivalent to passing a 0 and will not have the effect 
described when both are C<undef>.  This also triggers an
uninitialized warning.

=end original

最初の二つの要素のうち、一つだけに C<undef> を渡すと、その要素は 0 を
渡すのと等価となり、上述の、両方に C<undef> を渡した時と同じ
効果ではありません。
この場合は、未初期化の警告が出ます。

=begin original

On systems that support futimes(2), you may pass filehandles among the
files.  On systems that don't support futimes(2), passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

futimes(2) に対応しているシステムでは、ファイルハンドルを引数として
渡せます。
futimes(2) に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません; 裸の単語はファイル名として扱われます。

=item values HASH
X<values>

=item values ARRAY

=item values EXPR

=begin original

Returns a list consisting of all the values of the named hash, or the values
of an array. (In scalar context, returns the number of values.)

=end original

指定したハッシュのすべての値、あるいは配列の全ての値からなるリストを
返します。
(スカラコンテキストでは、値の数を返します。)

=begin original

The values are returned in an apparently random order.  The actual
random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the C<keys> or C<each>
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see L<perlsec/"Algorithmic Complexity Attacks">).

=end original

返される value の順序は、見た目にばらばらなものです。
実際のランダムな順序は将来のバージョンの Perl では変わる可能性が
ありますが、同じ(変更されていない)ハッシュに対して、
C<keys>関数や C<each>関数が返すものと同じ順序であることは保証されます。
Perl 5.8.1 以降ではセキュリティ上の理由により、
実行される毎に順番は変わります
(L<perlsec/"Algorithmic Complexity Attacks"> を参照してください)。

=begin original

As a side effect, calling values() resets the HASH or ARRAY's internal
iterator;
see L</each>. (In particular, calling values() in void context resets
the iterator with no other overhead. Apart from resetting the iterator,
C<values @array> in list context is the same as plain C<@array>.
We recommend that you use void context C<keys @array> for this, but reasoned
that it taking C<values @array> out would require more documentation than
leaving it in.)

=end original

副作用として、values() を呼び出すと HASH や ARRAY の内部反復子を
リセットします;
C</each> を参照してください。
(特に、values() を無効コンテキストで呼び出すとその他のオーバーヘッドなしで
反復子をリセットします。
反復子をリセットするということを除けば、
リストコンテキストでの C<values @array> は単なる C<@array> と同じです。
この目的のためには無効コンテキストで C<keys @array> を使うことを
お勧めしますが、C<values @array> を取り出すにはそのままにするよりも
より多くの文書が必要だと判断しました。)

=begin original

Note that the values are not copied, which means modifying them will
modify the contents of the hash:

=end original

値はコピーされないので、返されたリストを変更すると
ハッシュの中身が変更されることに注意してください。

    for (values %hash)      { s/foo/bar/g }   # modifies %hash values
    for (@hash{keys %hash}) { s/foo/bar/g }   # same

=begin original

Starting with Perl 5.14, C<values> can take a scalar EXPR, which must hold
a reference to an unblessed hash or array.  The argument will be
dereferenced automatically.  This aspect of C<values> is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

=end original

Perl 5.14 から、C<values> はスカラの EXPR を取ることができるようになりました;
これは bless されていないハッシュや配列へのリファレンスでなければなりません。
引数は自動的にデリファレンスされます。
C<values> のこの動作は高度に実験的であると考えられています。
正確な振る舞いは将来のバージョンの Perl で変わるかも知れません。

    for (values $hashref) { ... }
    for (values $obj->get_arrayref) { ... }

=begin original

See also C<keys>, C<each>, and C<sort>.

=end original

C<keys>, C<each>, C<sort> も参照してください。

=item vec EXPR,OFFSET,BITS
X<vec> X<bit> X<bit vector>

=begin original

Treats the string in EXPR as a bit vector made up of elements of
width BITS and returns the value of the element specified by OFFSET
as an unsigned integer.  BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.  This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).

=end original

文字列 EXPR を BITS 幅の要素からなるビットベクターとして扱い、
OFFSET で指定される要素の値を返します。
OFFSET で指定された要素を符号なし整数として返します。
従って、 BITS はビットベクターの中の各要素について予約されるビット数です。
BIT は、1 から 32 まで(プラットホームが
対応していれば 64 まで) の 2 のべき乗でなければなりません。

=begin original

If BITS is 8, "elements" coincide with bytes of the input string.

=end original

BITS が 8 の場合、「要素」は入力文字列の各バイトと一致します。

=begin original

If BITS is 16 or more, bytes of the input string are grouped into chunks
of size BITS/8, and each group is converted to a number as with
pack()/unpack() with big-endian formats C<n>/C<N> (and analogously
for BITS==64).  See L<"pack"> for details.

=end original

BITS が 16 以上の場合、入力のバイト列は BITS/8 のサイズの固まりに
グループ化され、各グループは pack()/unpack() のビッグエンディアン
フォーマット C<n>/C<N> を用いて(BITS==64 の類似として)数値に変換されます。
詳細は L<"pack"> を参照してください。

=begin original

If bits is 4 or less, the string is broken into bytes, then the bits
of each byte are broken into 8/BITS groups.  Bits of a byte are
numbered in a little-endian-ish way, as in C<0x01>, C<0x02>,
C<0x04>, C<0x08>, C<0x10>, C<0x20>, C<0x40>, C<0x80>.  For example,
breaking the single input byte C<chr(0x36)> into two groups gives a list
C<(0x6, 0x3)>; breaking it into 4 groups gives C<(0x2, 0x1, 0x3, 0x0)>.

=end original

BITS が 4 以下の場合、文字列はバイトに分解され、バイトの各ビットは
8/BITS 個のグループに分割されます。
ビットはリトルエンディアン風に、C<0x01>, C<0x02>,
C<0x04>, C<0x08>, C<0x10>, C<0x20>, C<0x40>, C<0x80> の順になります。
例えば、入力バイト C<chr(0x36)> を二つのグループに分割すると、
C<(0x6, 0x3)> になります。
4 つに分割すると C<(0x2, 0x1, 0x3, 0x0)> になります。

=begin original

C<vec> may also be assigned to, in which case parentheses are needed
to give the expression the correct precedence as in

=end original

左辺値として、代入の対象にすることもできます。
この場合、式を正しく先行させるために以下のように括弧が必要です。

    vec($image, $max_x * $x + $y, 8) = 3;

=begin original

If the selected element is outside the string, the value 0 is returned.
If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.   It is an error
to try to write off the beginning of the string (i.e., negative OFFSET).

=end original

選択された要素が文字列の外側だった場合、値 0 が返されます。
文字列の最後よりも後ろの要素に書き込もうとした場合、
Perl はまず文字列を必要な分だけ 0 のバイトで拡張します。
文字列の先頭より前に書き込もうとした(つまり OFFSET が負の数だった)
場合はエラーとなります。

=begin original

If the string happens to be encoded as UTF-8 internally (and thus has
the UTF8 flag set), this is ignored by C<vec>, and it operates on the
internal byte string, not the conceptual character string, even if you
only have characters with values less than 256. 

=end original

文字列がなぜか内部で UTF-8 でエンコードされている場合(したがって UTF8 フラグが
セットされている場合)、これは C<vec> では無視され、たとえ値が 256 未満の
文字だけであったとしても、概念的な
文字列ではなく内部バイト文字列で操作されます。

=begin original

Strings created with C<vec> can also be manipulated with the logical
operators C<|>, C<&>, C<^>, and C<~>.  These operators will assume a bit
vector operation is desired when both operands are strings.
See L<perlop/"Bitwise String Operators">.

=end original

vec() で作られた文字列は、論理演算子 C<|>、C<&>、C<^> で扱うこともできます。
これらの演算子は、両方の被演算子に文字列を使うと、
ビットベクター演算を行ないます。

=begin original

The following code will build up an ASCII string saying C<'PerlPerlPerl'>.
The comments show the string after each step.  Note that this code works
in the same way on big-endian or little-endian machines.

=end original

次のコードは C<'PerlPerlPerl'> という ASCII 文字列を作成します。
コメントは各行の実行後の文字列を示します。
このコードはビッグエンディアンでもリトルエンディアンでも同じように
動作することに注意してください。

    my $foo = '';
    vec($foo,  0, 32) = 0x5065726C; # 'Perl'

    # $foo eq "Perl" eq "\x50\x65\x72\x6C", 32 bits
    print vec($foo, 0, 8);  # prints 80 == 0x50 == ord('P')

    vec($foo,  2, 16) = 0x5065; # 'PerlPe'
    vec($foo,  3, 16) = 0x726C; # 'PerlPerl'
    vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'
    vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'
    vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . "\x02"
    vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' is "\x72"
    vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . "\x0c"
    vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . "\x2c"
    vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' is "\x6c"

=begin original

To transform a bit vector into a string or list of 0's and 1's, use these:

=end original

ビットベクターを、0 と 1 の文字列や配列に変換するには、
以下のようにします。

    $bits = unpack("b*", $vector);
    @bits = split(//, unpack("b*", $vector));

=begin original

If you know the exact length in bits, it can be used in place of the C<*>.

=end original

ビット長が分かっていれば、* の代わりにその長さを使うことができます。

=begin original

Here is an example to illustrate how the bits actually fall in place:

=end original

これはビットが実際にどのような位置に入るかを図示する例です。

    #!/usr/bin/perl -wl

    print <<'EOT';
                                      0         1         2         3
                       unpack("V",$_) 01234567890123456789012345678901
    ------------------------------------------------------------------
    EOT

    for $w (0..3) {
        $width = 2**$w;
        for ($shift=0; $shift < $width; ++$shift) {
            for ($off=0; $off < 32/$width; ++$off) {
                $str = pack("B*", "0"x32);
                $bits = (1<<$shift);
                vec($str, $off, $width) = $bits;
                $res = unpack("b*",$str);
                $val = unpack("V", $str);
                write;
            }
        }
    }

    format STDOUT =
    vec($_,@#,@#) = @<< == @######### @>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    $off, $width, $bits, $val, $res
    .
    __END__

=begin original

Regardless of the machine architecture on which it runs, the 
example above should print the following table:

=end original

実行するマシンのアーキテクチャに関わらず、
上記の例は以下の表を出力します。

                                      0         1         2         3
                       unpack("V",$_) 01234567890123456789012345678901
    ------------------------------------------------------------------
    vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000
    vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000
    vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000
    vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000
    vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000
    vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000
    vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
    vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
    vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
    vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
    vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
    vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
    vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
    vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
    vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
    vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
    vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
    vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
    vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
    vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
    vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
    vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
    vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
    vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
    vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
    vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
    vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
    vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
    vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
    vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
    vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
    vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
    vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
    vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
    vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
    vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
    vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
    vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
    vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
    vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
    vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
    vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
    vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
    vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
    vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
    vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
    vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
    vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
    vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
    vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
    vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
    vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
    vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
    vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
    vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
    vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
    vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
    vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
    vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
    vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
    vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
    vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
    vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
    vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
    vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
    vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
    vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
    vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
    vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
    vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
    vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
    vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
    vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
    vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
    vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
    vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
    vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
    vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
    vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
    vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
    vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
    vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
    vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
    vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
    vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
    vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
    vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
    vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
    vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
    vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
    vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
    vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
    vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
    vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
    vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
    vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
    vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
    vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
    vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
    vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
    vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
    vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
    vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
    vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
    vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
    vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
    vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
    vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
    vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
    vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
    vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
    vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
    vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
    vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
    vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
    vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
    vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001

=item wait
X<wait>

=begin original

Behaves like wait(2) on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C<-1> if there are no child processes.  The status is returned in C<$?>
and C<${^CHILD_ERROR_NATIVE}>.
Note that a return value of C<-1> could mean that child processes are
being automatically reaped, as described in L<perlipc>.

=end original

wait(2) と同様に振る舞います。
チャイルドプロセスが終了するのを待ち、消滅したプロセスの pid を返します。
チャイルドプロセスが存在しないときには、C<-1> を返します。
ステータスは C<$?> と C<${^CHILD_ERROR_NATIVE}> に返されます。
L<perlipc> に書いているように、返り値が C<-1> の場合は子プロセスが
自動的に刈り取られたことを意味するかもしれないことに注意してください。

=begin original

If you use wait in your handler for $SIG{CHLD} it may accidentally for the
child created by qx() or system(). See L<perlipc> for details.

=end original

wait を $SIG{CHLD} のハンドラで使うと、誤って qx() や system() に
適用されるかも知れません。
詳しくは L<perlipc> を参照してください。

=item waitpid PID,FLAGS
X<waitpid>

=begin original

Waits for a particular child process to terminate and returns the pid of
the deceased process, or C<-1> if there is no such child process.  On some
systems, a value of 0 indicates that there are processes still running.
The status is returned in C<$?> and C<${^CHILD_ERROR_NATIVE}>.  If you say

=end original

特定のチャイルドプロセスが終了するのを待ち、消滅した
プロセスの pid を返します。
指定したチャイルドプロセスが存在しないときには、C<-1> を返します。
値 0 がプロセスがまだ実行中であることを示すシステムもあります。
ステータスは C<$?> と C<${^CHILD_ERROR_NATIVE}> に返されます。

    use POSIX ":sys_wait_h";
    #...
    do {
        $kid = waitpid(-1, WNOHANG);
    } while $kid > 0;

=begin original

then you can do a non-blocking wait for all pending zombie processes.
Non-blocking wait is available on machines supporting either the
waitpid(2) or wait4(2) syscalls.  However, waiting for a particular
pid with FLAGS of C<0> is implemented everywhere.  (Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)

=end original

とすると、ブロックが起こらないようにして、全ての待機中ゾンビプロセスを
wait します。
ブロックなしの wait は、システムコール wait_pid(2) か、
システムコール wait4(2) をサポートしているマシンで利用可能です。
しかしながら、特定の pid を C<0> の FLAGS での wait はどこでも
実装されています。
(exit したプロセスのステータス値を覚えておいて、Perl がシステムコールを
エミュレートしますが、Perl スクリプトには取り入れられていません。)

=begin original

Note that on some systems, a return value of C<-1> could mean that child
processes are being automatically reaped.  See L<perlipc> for details,
and for other examples.

=end original

システムによっては、返り値が C<-1> の場合は子プロセスが自動的に
刈り取られたことを意味するかもしれないことに注意してください。
詳細やその他の例については L<perlipc> を参照してください。

=item wantarray
X<wantarray> X<context>

=begin original

Returns true if the context of the currently executing subroutine or
C<eval> is looking for a list value.  Returns false if the context is
looking for a scalar.  Returns the undefined value if the context is
looking for no value (void context).

=end original

現在実行中のサブルーチンか eval() ブロックのコンテキストが、リスト値を
要求するものであれば、真を返します。
スカラを要求するコンテキストであれば、偽を返します。
何も値を要求しない(無効コンテキスト)場合は未定義値を返します。

    return unless defined wantarray; # don't bother doing more
    my @a = complex_calculation();
    return wantarray ? @a : "@a";

=begin original

C<wantarray()>'s result is unspecified in the top level of a file,
in a C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> or C<END> block, or
in a C<DESTROY> method.

=end original

ファイルのトップレベル、C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT>, C<END>
ブロック内、C<DESTROY> メソッド内では C<wantarray()> の結果は未定義です。

=begin original

This function should have been named wantlist() instead.

=end original

この関数は wantlist() という名前にするべきでした。

=item warn LIST
X<warn> X<warning> X<STDERR>

=begin original

Prints the value of LIST to STDERR.  If the last element of LIST does
not end in a newline, it appends the same file/line number text as C<die>
does.

=end original

LIST の値を STDERR に出力します。
LIST の最後の要素が改行で終わっていない場合、C<die> が行うのと同様の
ファイル/行番号のテキストが追加されます。

=begin original

If the output is empty and C<$@> already contains a value (typically from a
previous eval) that value is used after appending C<"\t...caught">
to C<$@>.  This is useful for staying almost, but not entirely similar to
C<die>.

=end original

出力が空かつ、(典型的には以前の eval によって) C<$@> に既に値が入っている
場合、C<$@> に C<"\t...caught"> を追加した値が用いられます。
これはほとんどそのままにするときに便利ですが、
C<die> と全体的に似ているわけではありません。

=begin original

If C<$@> is empty then the string C<"Warning: Something's wrong"> is used.

=end original

C<$@> が空の場合は、C<"Warning: Something's wrong"> という文字列が
使われます。

=begin original

No message is printed if there is a C<$SIG{__WARN__}> handler
installed.  It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a C<die>).  Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling C<warn>
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since C<__WARN__> hooks are not called from
inside one.

=end original

C<$SIG{__WARN__}> ハンドラが設定されている場合は何のメッセージも
表示されません。
メッセージをどう扱うか(例えば C<die> に変換するか)はハンドラの
責任ということです。
従ってほとんどのハンドラは、扱おうと準備していない警告を表示するために、
ハンドラの中で C<warn> を再び呼び出します。
C<__WARN__> フックはハンドラ内では呼び出されないので、これは十分安全で、
無限ループを引き起こすことはないということに注意してください。

=begin original

You will find this behavior is slightly different from that of
C<$SIG{__DIE__}> handlers (which don't suppress the error text, but can
instead call C<die> again to change it).

=end original

この振る舞いは C<$SIG{__DIE__}> ハンドラ(エラーテキストは削除しませんが、
代わりに C<die> をもう一度呼び出すことで変更できます)とは
少し違うことに気付くことでしょう。

=begin original

Using a C<__WARN__> handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).  An example:

=end original

C<__WARN__> ハンドラを使うと、(いわゆる必須のものを含む)全ての
警告を黙らせる強力な手段となります。
例:

    # wipe out *all* compile-time warnings
    BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
    my $foo = 10;
    my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!
    # no compile-time or run-time warnings before here
    $DOWARN = 1;

    # run-time warnings enabled after here
    warn "\$foo is alive and $foo!";     # does show up

=begin original

See L<perlvar> for details on setting C<%SIG> entries and for more
examples.  See the Carp module for other kinds of warnings using its
carp() and cluck() functions.

=end original

C<%SIG> エントリのセットに関する詳細とさらなる例に関しては
L<perlvar> を参照して下さい。
carp() 関数と cluck() 関数を用いた警告の方法に関しては
Carp モジュールを参照して下さい。

=item when EXPR BLOCK
X<when>

=item when BLOCK

=begin original

C<when> is analogous to the C<case> keyword in other languages. Used with a
C<foreach> loop or the experimental C<given> block, C<when> can be used in
Perl to implement C<switch>/C<case> like statements.  Available as a
statement after Perl 5.10 and as a statement modifier after 5.14.  
Here are three examples:

=end original

C<when> は他の言語での C<case> キーワードと似ています。
C<foreach> ループか実験的な C<given> で使って、C<when> は Perl で
C<switch>/C<case> 風の文を実装するのに使われます。
文としては Perl 5.10 から利用可能で、文修飾子としては 5.14 から
利用可能です。
以下に三つ例を示します:

    use v5.10;
    foreach (@fruits) {
        when (/apples?/) {
            say "I like apples."
        }
        when (/oranges?/) {
            say "I don't like oranges."
        }
        default {
            say "I don't like anything"
        }
    }

    # require 5.14 for when as statement modifier
    use v5.14;
    foreach (@fruits) {
	say "I like apples." 	    when /apples?/; 
	say "I don't like oranges." when /oranges?;
        default { say "I don't like anything" }
    }

    use v5.10;
    given ($fruit) {
        when (/apples?/) {
            say "I like apples."
        }
        when (/oranges?/) {
            say "I don't like oranges."
        }
        default {
            say "I don't like anything"
        }
    }

=begin original

See L<perlsyn/"Switch statements"> for detailed information.

=end original

詳しい情報については L<perlsyn/"Switch statements"> を参照してください。

=item write FILEHANDLE
X<write>

=item write EXPR

=item write

=begin original

Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the C<select> function) may be set
explicitly by assigning the name of the format to the C<$~> variable.

=end original

指定された FILEHANDLE に対して、そのファイルに対応させた
フォーマットを使って、(複数行の場合もある) 整形された
レコードを書き出します。
デフォルトでは、ファイルに対応するフォーマットは、ファイルハンドルと
同じ名前のものですが、その時点の出力チャネル (C<select> 関数の項を
参照してください) のフォーマットは、その名前を明示的に変数 C<$~> に
代入することで、変更が可能です。　

=begin original

Top of form processing is handled automatically:  if there is insufficient
room on the current page for the formatted record, the page is advanced by
writing a form feed, a special top-of-page format is used to format the new
page header before the record is written.  By default, the top-of-page
format is the name of the filehandle with "_TOP" appended. This would be a
problem with autovivified filehandles, but it may be dynamically set to the
format of your choice by assigning the name to the C<$^> variable while
that filehandle is selected.  The number of lines remaining on the current
page is in variable C<$->, which can be set to C<0> to force a new page.

=end original

ページの先頭の処理は、自動的に行なわれます。
現在のページに整形されたレコードを出力するだけのスペースがない場合には、
改ページを行なってページを進め、新しいページヘッダを整形するため、
ページ先頭フォーマットが使われ、その後でレコードが書かれます。
デフォルトでは、ページ先頭フォーマットは、ファイルハンドルの名前に
"_TOP" をつなげたものです。
これは自動有効化されたファイルハンドルで問題になる可能性がありますが、
ファイルハンドルが選択されている間に、
変数 C<$^> に名前を設定すれば、動的にフォーマットを
変更することができます。
そのページの残り行数は、変数 C<$-> に入っており、この変数を 0 に
設定することで、強制的に改ページを行なうことができます。

=begin original

If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
C<select> operator.  If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see L<perlform>.

=end original

FILEHANDLE を指定しないと、出力はその時点のデフォルト
出力チャネルに対して行なわれます。
これは、スクリプトの開始時点では STDOUT ですが、select() 演算子で
変更することができます。
FILEHANDLE が EXPR ならば、式が評価され、その結果の文字列が
実行時に FILEHANDLE の名前として見られます。
フォーマットについて、さらには、L<perlform> を参照してください。

=begin original

Note that write is I<not> the opposite of C<read>.  Unfortunately.

=end original

残念ながら、write は C<read> の反対のことをするもの
I<ではありません>。

=item y///

=begin original

The transliteration operator.  Same as C<tr///>.  See
L<perlop/"Quote and Quote-like Operators">.

=end original

文字変換演算子です。
C<tr///> と同じです。
L<perlop/"Quote and Quote-like Operators"> を参照してください。

=back

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: Kentaro Shirakata <argrath@ub32.org> (5.6.1-)

=end meta

=cut

