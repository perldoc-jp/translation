=head1 名前

perluniintro - Perl Unicode の手引き

=head1 説明

This document gives a general idea of Unicode and how to use Unicode
in Perl.

このドキュメントは、Unicode の一般的な考えと、
PerlでUnicodeをどのように使うかを書いています。

=head2 Unicode

Unicode is a character set standard which plans to codify all of the
writing systems of the world, plus many other symbols.

Unicode は、キャラクタセットの標準です。世界の全ての書記体系と、それに加えて、
他の多くのシンボルを体系化することを計画しています。

Unicode and ISO/IEC 10646 are coordinated standards that provide code
points for characters in almost all modern character set standards,
covering more than 30 writing systems and hundreds of languages,
including all commercially-important modern languages.  All characters
in the largest Chinese, Japanese, and Korean dictionaries are also
encoded. The standards will eventually cover almost all characters in
more than 250 writing systems and thousands of languages.
Unicode 1.0 was released in October 1991, and 4.0 in April 2003.

Unicode と、ISO/IEC 10646 は、よく調整された、コードポイントを提供する標準です。
Unicode は、ほとんど全ての現代のキャラクタセット標準、30以上の書記体系と、
100以上の言語を網羅します。全ての商業的に重要な現代の言語を含みます。
もっとも大きい中国語、日本語、韓国語、それぞれの辞書の全ての文字もまた、
符号化されています。この標準は、最終的には、250の書記体系と、
1000以上の言語のほとんどすべてのキャラクタを網羅する予定です。
Unicode 1.0 は、1991年10月にリリースされ、Unicode 4.0 は、
2003年4月にリリースされました。

A Unicode I<character> is an abstract entity.  It is not bound to any
particular integer width, especially not to the C language C<char>.
Unicode is language-neutral and display-neutral: it does not encode the
language of the text and it does not define fonts or other graphical
layout details.  Unicode operates on characters and on text built from
those characters.

Unicode のI<キャラクタ>は、抽象的な存在です。Unicode のキャラクタは、
どんな特定の整数幅にも、特に、C 言語のC<char>にも束縛されません。
Unicode は、language-neutral で、display-neutral です:
Unicode は、テキストの言語をエンコードしませんし、
フォントや他のグラフィカルなレイアウトの詳細を定義しません。
Unicode は、キャラクタと、それらのキャラクタからなるテキストを操作します。

Unicode defines characters like C<LATIN CAPITAL LETTER A> or C<GREEK
SMALL LETTER ALPHA> and unique numbers for the characters, in this
case 0x0041 and 0x03B1, respectively.  These unique numbers are called
I<code points>.

Unicode は、C<LATIN CAPITAL LETTER A> や
C<GREEK SMALL LETTER ALPHA>のようなキャラクタと、
そのキャラクタについて固有の番号を定義します。
この場合は、それぞれ、0x0041 と、0x03B1 になります。
このような固有の番号は、I<コードポイント>と呼ばれます。

The Unicode standard prefers using hexadecimal notation for the code
points.  If numbers like C<0x0041> are unfamiliar to you, take a peek
at a later section, L</"Hexadecimal Notation">.  The Unicode standard
uses the notation C<U+0041 LATIN CAPITAL LETTER A>, to give the
hexadecimal code point and the normative name of the character.

Unicode 標準は、コードポイントに16進法を使うのを好みます。
C<0x0041>のような番号に馴染みがなければ、
後のセクション、L</"16進法">を覗いて見て下さい。
Unicode 標準は、L<U+0041 LATIN CAPITAL LETTER A>という表記を使って、
16進法のコードポイントと標準的なキャラクタの名前を書きます。

Unicode also defines various I<properties> for the characters, like
"uppercase" or "lowercase", "decimal digit", or "punctuation";
these properties are independent of the names of the characters.
Furthermore, various operations on the characters like uppercasing,
lowercasing, and collating (sorting) are defined.

Unicode はまた、様々なキャラクタのI<性質>を定義します。
"大文字"、"小文字"、"10進数字"、"句読点"など;
これらの性質は、キャラクタの名前と独立です。
更に、様々なキャラクタに対する操作、
大文字化や小文字化や並び替えが定義されています。

A Unicode character consists either of a single code point, or a
I<base character> (like C<LATIN CAPITAL LETTER A>), followed by one or
more I<modifiers> (like C<COMBINING ACUTE ACCENT>).  This sequence of
base character and modifiers is called a I<combining character
sequence>.

Unicode キャラクタは、1つのコードポイントか、または、
(C<LATIN CAPITAL LETTER A>のような)、I<基本キャラクタ>に続いて、
1つ以上の(C<COMBINING ACUTE ACCENT>のような)I<修飾語句>の、
どちらか一方から成っています。この基本キャラクタと修飾語句の順番は、
I<combining character sequence> と呼ばれます。

Whether to call these combining character sequences "characters"
depends on your point of view. If you are a programmer, you probably
would tend towards seeing each element in the sequences as one unit,
or "character".  The whole sequence could be seen as one "character",
however, from the user's point of view, since that's probably what it
looks like in the context of the user's language.

これらの combining character sequence を "複数のキャラクタ"と呼ぶかどうかは、
考え方によります。プログラマならば、おそらく、この順番のそれぞれの要素を、
1つの単位か"キャラクタ"として、見ようとするでしょう。
全ての順番を一つの"キャラクタ"として見ることができます。 ですが、
ユーザの考え方からは、おそらくユーザの言語の文脈でみえるようなものでしょう。

With this "whole sequence" view of characters, the total number of
characters is open-ended. But in the programmer's "one unit is one
character" point of view, the concept of "characters" is more
deterministic.  In this document, we take that second  point of view:
one "character" is one Unicode code point, be it a base character or
a combining character.

この、キャラクタの"すべての順番"の見え方では、キャラクタの総数には、
制限がありません。
ですが、プログラマーの"一つの単位は一つのキャラクタ"という考え方では、
"キャラクタ"の概念は、より決定論的です。
このドキュメントでは、2番目の考え方を取ります:
1つの"キャラクタ"は、1つの Unicode のコードポイントであり、
それは、基本キャラクタか、 combining character であるとします。

For some combinations, there are I<precomposed> characters.
C<LATIN CAPITAL LETTER A WITH ACUTE>, for example, is defined as
a single code point.  These precomposed characters are, however,
only available for some combinations, and are mainly
meant to support round-trip conversions between Unicode and legacy
standards (like the ISO 8859).  In the general case, the composing
method is more extensible.  To support conversion between
different compositions of the characters, various I<normalization
forms> to standardize representations are also defined.

いくつかの組合せにとって、I<まだ構成されていない>キャラクタがあります。
たとえば、C<LATIN CAPITAL LETTER A WITH ACUTE>は、
単一のコードポイントとして定義されています。
しかし、これらの、まだ構成されていないキャラクタは、
いくつかの組合せで可能でしかありません。そして、それらは、
主に、Unicode と、レガシー標準(ISO 8859のような)との間の相互変換を
サポートすることを意味します。一般的なケースでは、構成する方法はより広がります。
違った構成間の変換をサポートするために、
表現を標準化する、様々なI<normalization froms>もまた定義されています。

Because of backward compatibility with legacy encodings, the "a unique
number for every character" idea breaks down a bit: instead, there is
"at least one number for every character".  The same character could
be represented differently in several legacy encodings.  The
converse is also not true: some code points do not have an assigned
character.  Firstly, there are unallocated code points within
otherwise used blocks.  Secondly, there are special Unicode control
characters that do not represent true characters.

レガシーエンコーディングとの後方互換性のために、
"全てのキャラクタに固有の番号"とうい考えは、少々壊れています:
その代わりに、"少なくとも全てのキャラクタに1つの番号"があります。
同じキャラクタが、いくつかのレガシーエンコーディングの中で、違うように表現されていました。
逆は真でもなく: コードポイントには、キャラクタが割り当てられていないものもあります。
1番目に、使われているブロック内にもかかわらず、割り当てられていないコードポイントがあります。
2番目に、特別なUnicode のコントロールキャラクタがあり、それらは、本物のキャラクタを表現しません。

A common myth about Unicode is that it would be "16-bit", that is,
Unicode is only represented as C<0x10000> (or 65536) characters from
C<0x0000> to C<0xFFFF>.  B<This is untrue.>  Since Unicode 2.0 (July
1996), Unicode has been defined all the way up to 21 bits (C<0x10FFFF>),
and since Unicode 3.1 (March 2001), characters have been defined
beyond C<0xFFFF>.  The first C<0x10000> characters are called the
I<Plane 0>, or the I<Basic Multilingual Plane> (BMP).  With Unicode
3.1, 17 (yes, seventeen) planes in all were defined--but they are
nowhere near full of defined characters, yet.

Unicode について、よく知られている神話は、Unicode が、"16-ビット"である、
というものです。Unicode は、C<0x0000>から、C<0xFFFF>までで、
C<0x10000>(か、65536)のキャラクタを表現するだけ、というものです。B<これは真実ではありません>。
Unicode 2.0(1996年7月)から、Unicode は、21ビット(C<0x10FFFF>)まで、
様々に定義されています。Unicode 3.1(2001年3月)から、キャラクタは、
C<0xFFFF>を超えて、定義されました。最初のC<0x10000>キャラクタは、
I<Plane 0>、または、I<Basime Multilingual Plane>(BMP)と、と呼ばれました。
Unicode 3.1で、全部で17(そう、17)のPlaneが定義されました -- ですが、
まだ、定義された全キャラクタのどこにも、まだ近くにありません。

Another myth is that the 256-character blocks have something to
do with languages--that each block would define the characters used
by a language or a set of languages.  B<This is also untrue.>
The division into blocks exists, but it is almost completely
accidental--an artifact of how the characters have been and
still are allocated.  Instead, there is a concept called I<scripts>,
which is more useful: there is C<Latin> script, C<Greek> script, and
so on.  Scripts usually span varied parts of several blocks.
For further information see L<Unicode::UCD>.

もう1つの神話は256キャラクタブロックが、何か言語を取り扱うことがある--
それぞれのブロックは言語か言語のセットで使われているキャラクタを定義するということです。
B<これもまた真実ではありません>。ブロックに分割されたものはありますが、
それは、ほとんど完全に、予想外のものです。代わりに、I<scripts>と呼ばれる、
より有益なコンセプトがあります: C<Latin> script と、C<Greek> script と、
その他のものがあります。scripts は、ふつう、いくつかのブロックの変えられた部分
を測っています。詳しくは、L<Unicode::UCD>を見て下さい。

The Unicode code points are just abstract numbers.  To input and
output these abstract numbers, the numbers must be I<encoded> or
I<serialised> somehow.  Unicode defines several I<character encoding
forms>, of which I<UTF-8> is perhaps the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 6
bytes (only 4 with the currently defined characters).  Other encodings
include UTF-16 and UTF-32 and their big- and little-endian variants
(UTF-8 is byte-order independent) The ISO/IEC 10646 defines the UCS-2
and UCS-4 encoding forms.

Unicode のコードポイントは、抽象的な数字です。
この抽象的な数字を入出力するために、数字は、I<エンコードされる>必要があるか、
I<シリアライズされる>か、どうか、しなければなりません。
Unicode は、複数のI<character encoding forms>を定義していますが、
その中で、I<UTF-8>は、たぶん、もっとも有名です。
UTF-8は、可変長のエンコーディングで、Unicode キャラクタを1から6バイト
(only 4 with the currently defined characters)。
他のエンコーディングは、UTF-16とUTF-32と、
それらの大小のエンディアンの変形(UTF-8は、バイトオーダーと独立です)を含みます。
ISO/IEC 10646 は、UCS-2 と UCS-4の encoding forms を定義しています。

For more information about encodings--for instance, to learn what
I<surrogates> and I<byte order marks> (BOMs) are--see L<perlunicode>.

エンコーディングについて -- たとえば、I<surrogates>とI<byte order marks>(BOMs) --
もっと知りたければ L<perlunicode>を見て下さい。

=head2 Perl の Unicode のサポート

Starting from Perl 5.6.0, Perl has had the capacity to handle Unicode
natively.  Perl 5.8.0, however, is the first recommended release for
serious Unicode work.  The maintenance release 5.6.1 fixed many of the
problems of the initial Unicode implementation, but for example
regular expressions still do not work with Unicode in 5.6.1.

Perl 5.6.0 から、Perlは、Unicode をネイティブに扱う能力を持っていました。
しかし、Perl 5.8.0 の最初のRCリリースは、重大な Unicode の仕事です。
メンテナンスリリースの5.6.1は、最初のUnicode実装の多くの問題を修正しました。
ですが、たとえば、5.6.1で、Unicode での正規表現はまだ働きません。

B<Starting from Perl 5.8.0, the use of C<use utf8> is no longer
necessary.> In earlier releases the C<utf8> pragma was used to declare
that operations in the current block or file would be Unicode-aware.
This model was found to be wrong, or at least clumsy: the "Unicodeness"
is now carried with the data, instead of being attached to the
operations.  Only one case remains where an explicit C<use utf8> is
needed: if your Perl script itself is encoded in UTF-8, you can use
UTF-8 in your identifier names, and in string and regular expression
literals, by saying C<use utf8>.  This is not the default because
scripts with legacy 8-bit data in them would break.  See L<utf8>.

B<Perl5.8.0 から、C<use utf8>の使用は、もはや必要ではありません>。
初期のリリースでは、C<utf8>プラグマは、現在のブロックやファイルの操作が、
Unicodeであると明示するのを宣言するために使われました。
このモデルは間違いが見つけられるか、少なくとも、不格好です:
操作に添付するかわりに、"Unicodeness"は、今や、データに持ち込まれています。
唯一残されている、明示的にC<use utf8>をする必要がある場所は:
Perl スクリプト自身が UTF-8でエンコードされていれば、
識別子の名前、キャラクタの中と、正規表現のリテラルに、UTF-8 を使うことができます。
これは、デフォルトではありません。なぜなら、レガシーの8-bitデータのスクリプトが
壊れるからです。L<utf8>を見て下さい。

=head2 PerlのUnicode モデル

Perl supports both pre-5.6 strings of eight-bit native bytes, and
strings of Unicode characters.  The principle is that Perl tries to
keep its data as eight-bit bytes for as long as possible, but as soon
as Unicodeness cannot be avoided, the data is transparently upgraded
to Unicode.

8ビットネイティブのバイト列のPerl 5.6未満の文字列と、
Unicode キャラクタの文字列の両方をサポートします。
方針は、Perlは、可能な限り長く、8ビットバイト列として、データを保とうとします。
ですが、Unicodeness が避けられなくなるとすぐに、
データはUnicode にアップグレードされます。

Internally, Perl currently uses either whatever the native eight-bit
character set of the platform (for example Latin-1) is, defaulting to
UTF-8, to encode Unicode strings. Specifically, if all code points in
the string are C<0xFF> or less, Perl uses the native eight-bit
character set.  Otherwise, it uses UTF-8.

内部的には、Perlは、プラットフォームの8ビットキャラクタセット(例えば、Latin-1)は、
デフォルトはUTF-8ですが、Unicode 文字列ににエンコードします。
特に、文字列中の、全てのコードポイントは、C<0xFF>以下であれば、
Perlは、ネイティブの8ビットのキャラクタセットを使います。そうでなければ、UTF-8を使います。

A user of Perl does not normally need to know nor care how Perl
happens to encode its internal strings, but it becomes relevant when
outputting Unicode strings to a stream without a PerlIO layer -- one with
the "default" encoding.  In such a case, the raw bytes used internally
(the native character set or UTF-8, as appropriate for each string)
will be used, and a "Wide character" warning will be issued if those
strings contain a character beyond 0x00FF.

Perlのユーザは普通は、Perlがその内部文字列をたまたま、どのようにエンコード
するかを、知る必要も、気にする必要もありません。
ですが、Unicode文字列をPerlIOレイヤーなしにストリームに出力しようとすると、
関係するようになります -- one with the "default" encoding。
このようなケースでは、内部的に使われている生のバイト列
(それぞれの文字列の必要に応じて、ネイティブのキャラクタセットか、UTF-8)が使われます。
それらの文字列に、0x00FFを超えるキャラクタがあれば、"Wide character" の警告が出されます。

For example,

たとえば、

      perl -e 'print "\x{DF}\n", "\x{0100}\x{DF}\n"'              

produces a fairly useless mixture of native bytes and UTF-8, as well
as a warning:

ネイティブのバイト列とUTF-8の、まったく役に立たない混合もまた、
同様に警告を出します:

     Wide character in print at ...

To output UTF-8, use the C<:utf8> output layer.  Prepending

UTF-8を出力するために、use C<:utf8>アウトプットレイヤーを使います。 Prepending

      binmode(STDOUT, ":utf8");

to this sample program ensures that the output is completely UTF-8,
and removes the program's warning.

このサンプルプログラムが、出力が完全にUTF-8であることを保証し、
プログラムの警告を削除します。

You can enable automatic UTF-8-ification of your standard file
handles, default C<open()> layer, and C<@ARGV> by using either
the C<-C> command line switch or the C<PERL_UNICODE> environment
variable, see L<perlrun> for the documentation of the C<-C> switch.

C<-C>コマンドラインスイッチか、C<PERL_UNICODE>環境変数のどちらか一方を使うことで、
標準ファイルハンドルと、デフォルトのC<open()>レイヤーと、C<@ARGV>のUTF-8-ificationを
自動的に有効に出来ます。L<perlrun>のC<-C>スイッチのドキュメントを見て下さい。

Note that this means that Perl expects other software to work, too:
if Perl has been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another command is not UTF-8, Perl will complain
about the malformed UTF-8.

このことは、Perlが他のソフトウェアの動きを予測することを意味するのに気をつけて下さい:
PerlがSTDINがUTF-8であるべきと信じるように主導されていて、
他のコマンドからくるSTDINがUTF-8でなければ、
Perlは、奇形のUTF-8であると文句を言います。

All features that combine Unicode and I/O also require using the new
PerlIO feature.  Almost all Perl 5.8 platforms do use PerlIO, though:
you can see whether yours is by running "perl -V" and looking for
C<useperlio=define>.

Unicode と、I/O の結合の特徴もまた、新しいPerlIOの特徴を使うことを必要とします。
ほとんど全てのPerl5.8プラットフォームは、PerlIOを使います。ですが:
"perl -V"を動かして、C<useperlio=define>を見れば、 PerlIOを使っているかどうか、
わかります。

=head2 Unicode と EBCDIC

Perl 5.8.0 also supports Unicode on EBCDIC platforms.  There,
Unicode support is somewhat more complex to implement since
additional conversions are needed at every step.  Some problems
remain, see L<perlebcdic> for details.

Perl 5.8.0 は、EBCDIC プラットフォームでもまた、Unicode をサポートします。

In any case, the Unicode support on EBCDIC platforms is better than
in the 5.6 series, which didn't work much at all for EBCDIC platform.
On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC
instead of UTF-8.  The difference is that as UTF-8 is "ASCII-safe" in
that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is
"EBCDIC-safe".

=head2 Unicode の作成

To create Unicode characters in literals for code points above C<0xFF>,
use the C<\x{...}> notation in double-quoted strings:

C<0xFF>を超えるコードポイントのリテラルでUnicode キャラクタを作るためには、
C<\x{...}>記法をダブルクォートされた文字列の中で使います。

    my $smiley = "\x{263a}";

Similarly, it can be used in regular expression literals

同様に、正規表現の中でも使えます。

    $smiley =~ /\x{263a}/;

At run-time you can use C<chr()>:

C<chr()>を使って、実行時に:

    my $hebrew_alef = chr(0x05d0);

See L</"Further Resources"> for how to find all these numeric codes.

全てのこれらの数字のコードを見つける方法は、L</"詳しいリソース">を見て下さい。

Naturally, C<ord()> will do the reverse: it turns a character into
a code point.

当然、C<ord()>は、逆を行います。キャラクタをコードポイントに変えます:

Note that C<\x..> (no C<{}> and only two hexadecimal digits), C<\x{...}>,
and C<chr(...)> for arguments less than C<0x100> (decimal 256)
generate an eight-bit character for backward compatibility with older
Perls.  For arguments of C<0x100> or more, Unicode characters are
always produced. If you want to force the production of Unicode
characters regardless of the numeric value, use C<pack("U", ...)>
instead of C<\x..>, C<\x{...}>, or C<chr()>.

C<0x100>(10進の256)未満の引数の、C<\x..> (C<{}>ではなく、
2つの16進数の数字のみです)と、C<\x{...}>と、C<chr(...)>は、古いPerlとの互換性のために、
8ビットの文字列を生成します。<Cx100>かそれ以上の引数では、Unicode キャラクタが、常に生成されます。
何が何でも、数字の値のUnicode キャラクタを、強制的にに生成したければ、
C<\x..>、 C<\x{...}>、 or C<chr()> の代わりに、C<pack("U", ...)>を使って下さい。

You can also use the C<charnames> pragma to invoke characters
by name in double-quoted strings:

ダブルクォートされた文字列内で、名前でキャラクタを呼び出すために、
C<charnames> プラグマを使うこともできます。

    use charnames ':full';
    my $arabic_alef = "\N{ARABIC LETTER ALEF}";

And, as mentioned above, you can also C<pack()> numbers into Unicode
characters:

そして、上述のように、数字をUnicodeキャラクタに、C<pack()>できます。

   my $georgian_an  = pack("U", 0x10a0);

Note that both C<\x{...}> and C<\N{...}> are compile-time string
constants: you cannot use variables in them.  if you want similar
run-time functionality, use C<chr()> and C<charnames::vianame()>.

C<\x{...}>と、C<\N{...}>の両方は、コンパイル時の文字列定数です:
その中に変数を使うことはできません。類似のことを実行時にしたいなら、
c<chr()>と、C<charnames::vianame()>を使ってください。

Also note that if all the code points for pack "U" are below 0x100,
bytes will be generated, just like if you were using C<chr()>.

pack "U" する全てのコードポイントが、0x100 以下なら、
バイト列が生成されます。...C<chr()>を使うならば...

   my $bytes = pack("U*", 0x80, 0xFF);

If you want to force the result to Unicode characters, use the special
C<"U0"> prefix.  It consumes no arguments but forces the result to be
in Unicode characters, instead of bytes.

結果を、Unicode キャラクタに強制したいなら、特別な、C<"U0">接頭辞を使って下さい。
これは、引数を消耗しませんが、バイト列の代わりに、Unicodeキャラクタに結果を強制します。

   my $chars = pack("U0U*", 0x80, 0xFF);

=head2 Unicode を使う

Handling Unicode is for the most part transparent: just use the
strings as usual.  Functions like C<index()>, C<length()>, and
C<substr()> will work on the Unicode characters; regular expressions
will work on the Unicode characters (see L<perlunicode> and L<perlretut>).

Unicode を扱うことは、多くの部分にとって、透明です:
文字列をいつものように使うだけです。
C<index()>、C<length()>、C<substr()>のような関数は
Unicode 文字列で動きます;
正規表現もUnicode文字列で動きます(L<perlunicode>とL<perlretut>を見て下さい)。

Note that Perl considers combining character sequences to be
characters, so for example

Perlは、 combining character sequences をキャラクタと考えていることに注意して下さい。
ですので、例えば

    use charnames ':full';
    print length("\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}"), "\n";

will print 2, not 1.  The only exception is that regular expressions
have C<\X> for matching a combining character sequence.

2をプリントします。1ではありません。唯一の例外は、正規表現に、
combining character sequence にマッチするために、C<\X>がある場合です。

Life is not quite so transparent, however, when working with legacy
encodings, I/O, and certain special cases:



=head2 レガシーエンコーディング

When you combine legacy data and Unicode the legacy data needs
to be upgraded to Unicode.  Normally ISO 8859-1 (or EBCDIC, if
applicable) is assumed.  You can override this assumption by
using the C<encoding> pragma, for example

レガシーデータとUnicodeとを組み合わせる時は、
レガシーデータを、Unicode にアップグレードしなければなりません。
通常、ISO 8859-1 (か、必要ならEBCDIC)が想定されます。
この想定を、C<encoding>プラグマを使ってオーバーライドできます。
たとえば。

    use encoding 'latin2'; # ISO 8859-2

in which case literals (string or regular expressions), C<chr()>,
and C<ord()> in your whole script are assumed to produce Unicode
characters from ISO 8859-2 code points.  Note that the matching for
encoding names is forgiving: instead of C<latin2> you could have
said C<Latin 2>, or C<iso8859-2>, or other variations.  With just

(文字列か正規表現の)リテラルの場合、スクリプト全体の、
C<chr()>と、C<ord()>は、ISO 8859-2コードポイントの
Unicode キャラクタを生成すると想定されます。
エンコーディング名のマッチングが許されているのに注意して下さい:
C<latin2>の代わりに、C<Latin 2> か、C<iso8859-2>か、他のバリエーションを使えます。
ただ単に、

    use encoding;

the environment variable C<PERL_ENCODING> will be consulted.
If that variable isn't set, the encoding pragma will fail.

すると、環境変数C<PERL_ENCODING>が調べられます。
この変数が設定されていなければ、encoding プラグマは失敗します。

The C<Encode> module knows about many encodings and has interfaces
for doing conversions between those encodings:

C<Encode> モジュールは、多くのエンコーディングを知っており、
それらのエンコーディングの間の変換をするインターフェースを持っています。

    use Encode 'from_to';
    from_to($data, "iso-8859-3", "utf-8"); # from legacy to utf-8

=head2 Unicode I/O

Normally, writing out Unicode data

通常、Unicode データを書き出すことは、

    print FH $some_string_with_unicode, "\n";

produces raw bytes that Perl happens to use to internally encode the
Unicode string.  Perl's internal encoding depends on the system as
well as what characters happen to be in the string at the time. If
any of the characters are at code points C<0x100> or above, you will get
a warning.  To ensure that the output is explicitly rendered in the
encoding you desire--and to avoid the warning--open the stream with
the desired encoding. Some examples:

Unicode 文字列を内部的にエンコードするのにたまたまつかわれている、
生のバイト列を生成することです。Perlの内部エンコーディングは、
そのときに、文字列にたまたまあるキャラクタと同じように、
システム依存です。どのキャラクタも、コードポイントがC<0x100>以上なら、
警告がでます。出力が明示的に、望んでいるエンコーディングにレンダリング
されていることを保証し、警告を割けるために、
望んでいるエンコーディングでストリームを open してください。
いくつか例示します:

    open FH, ">:utf8", "file";

    open FH, ">:encoding(ucs2)",      "file";
    open FH, ">:encoding(UTF-8)",     "file";
    open FH, ">:encoding(shift_jis)", "file";

and on already open streams, use C<binmode()>:

すでに開かれているストリームに関しては、C<binmode()>を使います:

    binmode(STDOUT, ":utf8");

    binmode(STDOUT, ":encoding(ucs2)");
    binmode(STDOUT, ":encoding(UTF-8)");
    binmode(STDOUT, ":encoding(shift_jis)");

The matching of encoding names is loose: case does not matter, and
many encodings have several aliases.  Note that the C<:utf8> layer
must always be specified exactly like that; it is I<not> subject to
the loose matching of encoding names.

エンコーディング名のマッチングはルーズです: ケースは重要ではありません。
多くのエンコーディングは、いくつかのエイリアスがあります。
C<:utf8>レイヤーは、常に、きっちりとそのように指定される必要があります。
このことは、エンコーディング名のルーズなマッチングの主題ではI<ありません>。

See L<PerlIO> for the C<:utf8> layer, L<PerlIO::encoding> and
L<Encode::PerlIO> for the C<:encoding()> layer, and
L<Encode::Supported> for many encodings supported by the C<Encode>
module.

C<:utf8>レイヤー関しては、L<PerlIO>を見て下さい。C<:encoding()>に関しては、
L<Encode::PerlIO>を見て下さい。
C<Encode>モジュールでサポートされている、多くのエンコーディングに関しては、
L<Encode::Supported>を見て下さい。

Reading in a file that you know happens to be encoded in one of the
Unicode or legacy encodings does not magically turn the data into
Unicode in Perl's eyes.  To do that, specify the appropriate
layer when opening files

Unicodeかレガシーのエンコーディングどちらかでたまたまエンコードされている
ファイルの読み込んでも、Perlの目で、魔法使いのように、データがUnicodeに変わったりしません。
そうするためには、ファイルを開くときに、適切なレイヤを指定します。

    open(my $fh,'<:utf8', 'anything');
    my $line_of_unicode = <$fh>;

    open(my $fh,'<:encoding(Big5)', 'anything');
    my $line_of_unicode = <$fh>;

The I/O layers can also be specified more flexibly with
the C<open> pragma.  See L<open>, or look at the following example.

I/Oレイヤは、もっと柔軟に、C<open>プラグマでもあた、指定することが出来ます。
L<open>を見るか、次の例を見て下さい。

    use open ':utf8'; # input and output default layer will be UTF-8
    open X, ">file";
    print X chr(0x100), "\n";
    close X;
    open Y, "<file";
    printf "%#x\n", ord(<Y>); # this should print 0x100
    close Y;

With the C<open> pragma you can use the C<:locale> layer

C<open>プラグマで、C<:local> レイヤも使えます。

    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
    # the :locale will probe the locale environment variables like LC_ALL
    use open OUT => ':locale'; # russki parusski
    open(O, ">koi8");
    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
    close O;
    open(I, "<koi8");
    printf "%#x\n", ord(<I>), "\n"; # this should print 0xc1
    close I;

or you can also use the C<':encoding(...)'> layer

また、C<':encoding(...)'>レイヤ使えます。

    open(my $epic,'<:encoding(iso-8859-7)','iliad.greek');
    my $line_of_unicode = <$epic>;

These methods install a transparent filter on the I/O stream that
converts data from the specified encoding when it is read in from the
stream.  The result is always Unicode.

ストリームからファイルが読まれるときに、
特定のエンコーディングから、データを変換するI/Oストリーム上の
トランスペアレントなレイヤです。
その結果は、常に Unicode です。

The L<open> pragma affects all the C<open()> calls after the pragma by
setting default layers.  If you want to affect only certain
streams, use explicit layers directly in the C<open()> call.

L<open> プラグマは、デフォルトのレイヤを設定することで、
プラグマの後の、全てのC<open()>呼び出しに影響します。
あるストリームだけに、影響を限定したいなら、
C<open()>呼び出しで、明示的なレイヤを使って下さい。

You can switch encodings on an already opened stream by using
C<binmode()>; see L<perlfunc/binmode>.

C<binmode()>; を使って、すでに開かれているストリーム
で、エンコーディングを変えることが出来ます。
L<perlfunc/binmode> を見て下さい。

The C<:locale> does not currently (as of Perl 5.8.0) work with
C<open()> and C<binmode()>, only with the C<open> pragma.  The
C<:utf8> and C<:encoding(...)> methods do work with all of C<open()>,
C<binmode()>, and the C<open> pragma.

C<:;pcate> は、現在(Perl 5.8.0 の時点で)、C<open()>と、C<binmode()>では動きません。
C<open> プラグマでのみ動きます。C<:utf8>と、C<:encoding(...)>メソッドは、
全てのC<open()>、C<binmode()>、C<open>プラグマで動きます。

Similarly, you may use these I/O layers on output streams to
automatically convert Unicode to the specified encoding when it is
written to the stream. For example, the following snippet copies the
contents of the file "text.jis" (encoded as ISO-2022-JP, aka JIS) to
the file "text.utf8", encoded as UTF-8:

似たようなものに、ストリームに書き出すときに、
自動的にUnicode を特定のエンコーディングに変換する、
出力ストリームのI/Oレイヤを使うかも知れません。
例えば、次のようなコードの断片は、
(ISO-2022-JP, aka JISとして、エンコードされている)"text.jis"ファイル
の内容を、UTF-8としてエンコードされる"text.utf8"ファイルにコピーします。


    open(my $nihongo, '<:encoding(iso-2022-jp)', 'text.jis');
    open(my $unicode, '>:utf8',                  'text.utf8');
    while (<$nihongo>) { print $unicode $_ }

The naming of encodings, both by the C<open()> and by the C<open>
pragma, is similar to the C<encoding> pragma in that it allows for
flexible names: C<koi8-r> and C<KOI8R> will both be understood.

C<open()>と、C<open>プラグマの両方で使われている、
エンコーディングの名前は、C<encoding>プラグマと同様に。
フレキシブルな名前でかも使えます: C<koi8-r>と、C<KOI8R> は、
両方とも理解されます。

Common encodings recognized by ISO, MIME, IANA, and various other
standardisation organisations are recognised; for a more detailed
list see L<Encode::Supported>.

ISO、MIME、IANA、様々な他の標準化機関はが認識している、
共通のエンコーディングが認識されます: 詳細なリストは、L<Encode::Supported>
を見て下さい。

C<read()> reads characters and returns the number of characters.
C<seek()> and C<tell()> operate on byte counts, as do C<sysread()>
and C<sysseek()>.

C<read()>は、キャラクタを読み、キャラクタの数を返します。
C<seek()>と、C<tell()>は、バイトカウントに関して操作します。
C<sysread>と、C<sysseek()>も同様です。

Notice that because of the default behaviour of not doing any
conversion upon input if there is no default layer,
it is easy to mistakenly write code that keeps on expanding a file
by repeatedly encoding the data:

デフォルトレイヤーがなければ、入力になんの変換もしないのがデフォルトの
振るまいなので、繰り返しデータをエンコーディングすることで、
ファイルを展開し続けるコードを謝って書きやすいです。

    # BAD CODE WARNING
    open F, "file";
    local $/; ## read in the whole file of 8-bit characters
    $t = <F>;
    close F;
    open F, ">:utf8", "file";
    print F $t; ## convert to UTF-8 on output
    close F;

If you run this code twice, the contents of the F<file> will be twice
UTF-8 encoded.  A C<use open ':utf8'> would have avoided the bug, or
explicitly opening also the F<file> for input as UTF-8.

このコードを2回実行すると、F<file>の内容は、UTF-8 に、2回エンコードされます。
C<use open 'utf8'> は、バグを避けるでしょう。
もしくは、UTF-8として入力するために、F<File>を、明示的に開くことです。

B<NOTE>: the C<:utf8> and C<:encoding> features work only if your
Perl has been built with the new PerlIO feature (which is the default
on most systems).

B<注意>: C<:utf8>と、C<:encoding>の機能は、
Perlが、新しいPerlIOの機能で、ビルドされている場合のみ、動きます。
(ほとんどのシステムで、それがデフォルトです)

=head2 テキストとして、Unicode を表示する

Sometimes you might want to display Perl scalars containing Unicode as
simple ASCII (or EBCDIC) text.  The following subroutine converts
its argument so that Unicode characters with code points greater than
255 are displayed as C<\x{...}>, control characters (like C<\n>) are
displayed as C<\x..>, and the rest of the characters as themselves:

Unicodeを含んでいるPerlのスカラを、単純なASCII(か、EBCDIC)のテキストとして、
表示したいかもしれません。下のサブルーチンは、引数を変換して、
255より大きいコードポイントのUnicodeキャラクタを、C<\x{...}>として、
表示し、(C<\n>のような)コントロールキャラクタは、C<\x..>として、
表示します。残りの文字は、そのまま表示します:

   sub nice_string {
       join("",
         map { $_ > 255 ?                  # if wide character...
               sprintf("\\x{%04X}", $_) :  # \x{...}
               chr($_) =~ /[[:cntrl:]]/ ?  # else if control character ...
               sprintf("\\x%02X", $_) :    # \x..
               quotemeta(chr($_))          # else quoted or as themselves
         } unpack("U*", $_[0]));           # unpack Unicode characters
   }

For example,

たとえば、

   nice_string("foo\x{100}bar\n")

returns the string

次のような文字列になります。

   'foo\x{0100}bar\x0A'

which is ready to be printed.

プリントできます。

=head2 特別なケース

=over 4

=item *

Bit Complement Operator ~ And vec()

演算子 ~ と、vec() についてのちょっとした補足

The bit complement operator C<~> may produce surprising results if
used on strings containing characters with ordinal values above
255. In such a case, the results are consistent with the internal
encoding of the characters, but not with much else. So don't do
that. Similarly for C<vec()>: you will be operating on the
internally-encoded bit patterns of the Unicode characters, not on
the code point values, which is very probably not what you want.

演算子C<~>は、255を超える序数の値のキャラクタを含んでいる文字列で、
使われると、驚くべき結果になるでしょう。そのようなケースでは、
その結果はキャラクタの内部的なエンコーディングで一貫性があります。
しかし、他の多くでは違います。ですので、そのようなことはしないでください。
C<vec()>も同様です: コードポイントの値ではなく、内部的にエンコードされた、
Unicode 文字列のビットパターンを操作しているでしょう。
おそらく、それは、望んでいないでしょう。

=item *

Peeking At Perl's Internal Encoding

Perl の内部エンコーディングをのぞき見る。

Normal users of Perl should never care how Perl encodes any particular
Unicode string (because the normal ways to get at the contents of a
string with Unicode--via input and output--should always be via
explicitly-defined I/O layers). But if you must, there are two
ways of looking behind the scenes.

(Unicodeで文字列の内容に達する普通の方法 -- 入出力 -- は、つねに、
明示的に定義されたI/O レイヤを経由すべきです)
Perlがどのように、どんな特別なUnicode文字列をエンコードしているかを、
Perlの普通のユーザは気にするべきではありません。
ですが、必要なら、隠れている裏側を見る2つの方法があります。

One way of peeking inside the internal encoding of Unicode characters
is to use C<unpack("C*", ...> to get the bytes or C<unpack("H*", ...)>
to display the bytes:

Unicodeキャラクタを内部的にエンコーディングする、
内側を覗き見る1つの方法は、C<unpack("C*", ...> を使い、バイトを得るか、
C<unpack("H*", ...)>を使い、バイトを表示することができます:

    # this prints  c4 80  for the UTF-8 bytes 0xc4 0x80
    print join(" ", unpack("H*", pack("U", 0x100))), "\n";

Yet another way would be to use the Devel::Peek module:

別の方法は、Dvel::Peek モジュールを使うことです:

    perl -MDevel::Peek -e 'Dump(chr(0x100))'

That shows the C<UTF8> flag in FLAGS and both the UTF-8 bytes
and Unicode characters in C<PV>.  See also later in this document
the discussion about the C<utf8::is_utf8()> function.

これは、FLAGSのC<UTF8>フラグと、UTF-8バイトと、C<PV>の中の
Unicodeキャラクタの両方を見せます。
このドキュメントの後にある、C<utf8::is_utf8()>機能についての議論も見て下さい。

=back

=head2 Advanced Topics

=over 4

=item *

String Equivalence

文字列の等しさ

The question of string equivalence turns somewhat complicated
in Unicode: what do you mean by "equal"?

文字列の等しさの疑問は、Unicodeでいくぶん複雑になります。
"イコール"で、何を意味していますか？

(Is C<LATIN CAPITAL LETTER A WITH ACUTE> equal to
C<LATIN CAPITAL LETTER A>?)

(IS C<LATIN CAPITAL LETTER A WITH ACCUTE>は、
C<LATIN CAPITAL LETTER A>は、等しいでしょうか？)

The short answer is that by default Perl compares equivalence (C<eq>,
C<ne>) based only on code points of the characters.  In the above
case, the answer is no (because 0x00C1 != 0x0041).  But sometimes, any
CAPITAL LETTER As should be considered equal, or even As of any case.

短く答えれば次のようになります。デフォルトでは、Perlは(C<eq>と、C<ne>で)等しさを
比較しますが、これらは、キャラクタのコードポイントでのみに基づいています。
上のケースでは、答えはいいえです(0x00C1 != 0x0041ですから)。
ですが、どんなCAPITAL LETTER A もどんなケースのAも等しいと考えるべき時もあります。

The long answer is that you need to consider character normalization
and casing issues: see L<Unicode::Normalize>, Unicode Technical
Reports #15 and #21, I<Unicode Normalization Forms> and I<Case
Mappings>, http://www.unicode.org/unicode/reports/tr15/ and 
http://www.unicode.org/unicode/reports/tr21/ 

長く答えるなら、キャラクタ標準化とケースの問題を考える必要があります:
L<Unicode::Normalize>、Unicode テクニカルレポート#15 と #21と、
I<Unicodde Normalization Forms> と、I<Case Mappings>を見て下さい。
http://www.unicode.org/unicode/reports/tr15/ と、
http://www.unicode.org/unicode/reports/tr21/ 

As of Perl 5.8.0, the "Full" case-folding of I<Case
Mappings/SpecialCasing> is implemented.

Perl 5.8 から、I<Case Mappings/SpecialCasing>の、
"Full"ケースフォールディングが実装されています。

=item *

String Collation

People like to see their strings nicely sorted--or as Unicode
parlance goes, collated.  But again, what do you mean by collate?

文字列がうまくソートされているのを好みます--or as Unicode
parlance goes, collated。 ですが、再び、collate で何を意味していますか？

(Does C<LATIN CAPITAL LETTER A WITH ACUTE> come before or after
C<LATIN CAPITAL LETTER A WITH GRAVE>?)

(C<LATIN CAPITAL LETTER A WITH ACUTE> は、C<LATIN CAPITAL LETTER A WITH GRAVE> より、
前でしょうか後でしょうか？)

The short answer is that by default, Perl compares strings (C<lt>,
C<le>, C<cmp>, C<ge>, C<gt>) based only on the code points of the
characters.  In the above case, the answer is "after", since
C<0x00C1> > C<0x00C0>.

短く答えれば次のようになります。Perlは、文字列を、
(C<lt>、C<le>、C<cmp>、C<ge>、C<gt>)で比較しますが、
これらは、キャラクタのコードポイントでのみに基づいています。
上のケースでは、答えは、C<0x00C1> > C<0x00C0>ですので、"後"になります。

The long answer is that "it depends", and a good answer cannot be
given without knowing (at the very least) the language context.
See L<Unicode::Collate>, and I<Unicode Collation Algorithm>
http://www.unicode.org/unicode/reports/tr10/

長く答えるなら、"依存して"います。良い答えは、(とても少なくとも)言語のコンテキストを
知らずには、与えられません。
L<Unicode::Collate>と、I<Unicode Collation Algorithm> を見て下さい。
http://www.unicode.org/unicode/reports/tr10/

=back

=head2 その他

=over 4

=item *

Character Ranges and Classes

Character ranges in regular expression character classes (C</[a-z]/>)
and in the C<tr///> (also known as C<y///>) operator are not magically
Unicode-aware.  What this means that C<[A-Za-z]> will not magically start
to mean "all alphabetic letters"; not that it does mean that even for
8-bit characters, you should be using C</[[:alpha:]]/> in that case.

正規表現のキャラクタークラス(C</[a-z]/>)内と、
C<tf///>(C<y///>としても知られる)演算子内では、
魔法を使ったようには、Unicodeに気付かない。
これが意味することは、C<[A-Za-z]>は、"全てのアルファベット文字"を
魔法を使ったようには意味しはじめません。8ビットのキャラクタで意味します。
このケースでは、C</[[:alpha:]]/>を使うべきです。

For specifying character classes like that in regular expressions,
you can use the various Unicode properties--C<\pL>, or perhaps
C<\p{Alphabetic}>, in this particular case.  You can use Unicode
code points as the end points of character ranges, but there is no
magic associated with specifying a certain range.  For further
information--there are dozens of Unicode character classes--see
L<perlunicode>.

正規表現内のこのような特定のキャラクタクラスに、
様々なUnicodeプロパティ--C<\pL>、または、この特別なケースでは、
たぶん、C<\p{Alphabetic}>を使うことができます。
キャラクタの範囲の終りのポイントとして、
Unicodeのコードポイントを使うことが出来ます。
ですが、ある範囲を特定するのに結びつける何の魔法もありません。
詳しいことは--数ダースのUnicodeキャラクタクラスがあります--
L<perlunicode>を見て下さい。

=item *

String-To-Number Conversions

文字列から数字への変換

Unicode does define several other decimal--and numeric--characters
besides the familiar 0 to 9, such as the Arabic and Indic digits.
Perl does not support string-to-number conversion for digits other
than ASCII 0 to 9 (and ASCII a to f for hexadecimal).

Unicode は、なじみのある、アラビアやインドの数字のような0から9に加えて、
複数の他の10進数--と数字の--キャラクタを、定義します。
Perlは、ASCIIの0から9(と、16進法のASCIIのaからf)以外の数字の、
文字列から数への変換をサポートしません。

=back

=head2 質問と解凍

=over 4

=item *

Will My Old Scripts Break?

古いスクリプトは壊れるでしょうか？

Very probably not.  Unless you are generating Unicode characters
somehow, old behaviour should be preserved.  About the only behaviour
that has changed and which could start generating Unicode is the old
behaviour of C<chr()> where supplying an argument more than 255
produced a character modulo 255.  C<chr(300)>, for example, was equal
to C<chr(45)> or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH
BREVE.

たぶん、壊れません。どうにかして、Unicodeキャラクタを生成していなければ、
古い挙動は、保護されます。変更される、Unicodeを生成し始める唯一の挙動は
古いC<chr()>の挙動です。ここでは、255を法として、キャラクタを生成する
255より上の引数を供給します。C<chr(300)>は、例えば、C<chr(45)>か、
(ASCIIの)"-"と同じでした。現在は、それは、LATIN CAPITAL LETTER I WITH BREVE
と、同じです。

=item *

How Do I Make My Scripts Work With Unicode?

Unicode スクリプトを動かすにはどうすればいいですか？

Very little work should be needed since nothing changes until you
generate Unicode data.  The most important thing is getting input as
Unicode; for that, see the earlier I/O discussion.

Unicodeデータを生成するまで、何も
ほんとうに小さい仕事が必要とされてます。
もっとも重要なものは、Unicodeとして、入力を得ることです;
なので、以前の I/O の議論を見て下さい。

=item *

How Do I Know Whether My String Is In Unicode?

Unicodeの文字列かどうかを知るにはどうしますか？

You shouldn't care.  No, you really shouldn't.  No, really.  If you
have to care--beyond the cases described above--it means that we
didn't get the transparency of Unicode quite right.

気にすることはありません。本当に、気にするべきではありません。本当に。
気にする必要があるなら -- このケースは上で書いています --
本当に正しく、Unicode のトランスペアレント性を得ないことを意味します。

Okay, if you insist:

オーケー、主張するなら:

    print utf8::is_utf8($string) ? 1 : 0, "\n";

But note that this doesn't mean that any of the characters in the
string are necessary UTF-8 encoded, or that any of the characters have
code points greater than 0xFF (255) or even 0x80 (128), or that the
string has any characters at all.  All the C<is_utf8()> does is to
return the value of the internal "utf8ness" flag attached to the
C<$string>.  If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding.  If the flag is on, the bytes in the scalar
are interpreted as the (multi-byte, variable-length) UTF-8 encoded code
points of the characters.  Bytes added to an UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, and
printf/sprintf parameter substitution), the result will be UTF-8 encoded
as if copies of the byte strings were upgraded to UTF-8: for example,

ですが、これは、文字列のキャラクタのすべてが、UTF-8でエンコードされているか、
キャラクタのすべてが、0xFF(255)か、0x80(128)より大きいコードポイントか、
文字列はすべてキャラクタをもつ必要があります。
C<is_utf8()>がすることの全ては、C<$string>につけられている内部の"utf8ness"フラグの
値を返すことです。フラグが無効であれば、スカラ内のバイト列は、
シングルバイトエンコーディングとして、解釈されます。
フラグが有効であれば、スカラ内のバイト列は、(マルチバイト、可変調の) 
UTF-8 でエンコードされたキャラクタのコードポイントとして、解釈されます。
非UTF-8と、UTF-8のスカラがマージされた(ダブルクオートされた語句、
明示的な連結、printf/sprintfパラメタの代用)場合、、この結果は、
バイトストリングのコピーがUTF-8でアップグレードされるように、
UTF-8でエンコードされています。

    $a = "ab\x80c";
    $b = "\x{100}";
    print "$a = $b\n";

the output string will be UTF-8-encoded C<ab\x80c = \x{100}\n>, but
C<$a> will stay byte-encoded.

出力する文字列はUTF-8エンコードされたC<ab\x80c = \x{100}\n>になります。
ですが、C<$a>は、バイトエンコードされます

Sometimes you might really need to know the byte length of a string
instead of the character length. For that use either the
C<Encode::encode_utf8()> function or the C<bytes> pragma and its only
defined function C<length()>:

文字列の長さではなく、文字列のバイト長を知る必要があるかもしれません。
そのためには、C<Encode::encode_utf8()>関数か、C<bytes>プラグマのどちらかを使い、
定義されたC<length()>関数を使うだけです:

    my $unicode = chr(0x100);
    print length($unicode), "\n"; # will print 1
    require Encode;
    print length(Encode::encode_utf8($unicode)), "\n"; # will print 2
    use bytes;
    print length($unicode), "\n"; # will also print 2
                                  # (the 0xC4 0x80 of the UTF-8)

=item *

How Do I Detect Data That's Not Valid In a Particular Encoding?

特別なエンコーディングで、データが、妥当でないことを調べるにはどうしますか？

Use the C<Encode> package to try converting it.
For example,

C<Encode>パッケージを使って、それを変換してみてください。
例えば、

    use Encode 'encode_utf8';
    if (encode_utf8($string_of_bytes_that_I_think_is_utf8)) {
        # valid
    } else {
        # invalid
    }

For UTF-8 only, you can use:

UTF-8だけであれば、次のように出来ます:

    use warnings;
    @chars = unpack("U0U*", $string_of_bytes_that_I_think_is_utf8);

If invalid, a C<Malformed UTF-8 character (byte 0x##) in unpack>
warning is produced. The "U0" means "expect strictly UTF-8 encoded
Unicode".  Without that the C<unpack("U*", ...)> would accept also
data like C<chr(0xFF>), similarly to the C<pack> as we saw earlier.

妥当でなkれば、c<Malformed UTF-8 character (byte 0x## in unpack)>
の警告が出ます。"U0" は、"厳密にUTF-8でエンコードされたUnicodeを期待する" 
ことを意味します。C<unpack("U*", ...)>が、C<chr(0xFF)>のような
データも受け入れることをしなければ、先に見たC<pack>と同様です。

=item *

How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?

バイナリデータを特定のエンコーディングに変換するには、どうしますか？
また、逆はどうしますか？

This probably isn't as useful as you might think.
Normally, you shouldn't need to.

たぶん、思うようには有益ではないでしょう。ふつう、必要とするべきではありません。

In one sense, what you are asking doesn't make much sense: encodings
are for characters, and binary data are not "characters", so converting
"data" into some encoding isn't meaningful unless you know in what
character set and encoding the binary data is in, in which case it's
not just binary data, now is it?

If you have a raw sequence of bytes that you know should be
interpreted via a particular encoding, you can use C<Encode>:

    use Encode 'from_to';
    from_to($data, "iso-8859-1", "utf-8"); # from latin-1 to utf-8

The call to C<from_to()> changes the bytes in C<$data>, but nothing
material about the nature of the string has changed as far as Perl is
concerned.  Both before and after the call, the string C<$data>
contains just a bunch of 8-bit bytes. As far as Perl is concerned,
the encoding of the string remains as "system-native 8-bit bytes".

You might relate this to a fictional 'Translate' module:

   use Translate;
   my $phrase = "Yes";
   Translate::from_to($phrase, 'english', 'deutsch');
   ## phrase now contains "Ja"

The contents of the string changes, but not the nature of the string.
Perl doesn't know any more after the call than before that the
contents of the string indicates the affirmative.

Back to converting data.  If you have (or want) data in your system's
native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.

    $native_string  = pack("C*", unpack("U*", $Unicode_string));
    $Unicode_string = pack("U*", unpack("C*", $native_string));

If you have a sequence of bytes you B<know> is valid UTF-8,
but Perl doesn't know it yet, you can make Perl a believer, too:

    use Encode 'decode_utf8';
    $Unicode = decode_utf8($bytes);

You can convert well-formed UTF-8 to a sequence of bytes, but if
you just want to convert random binary data into UTF-8, you can't.
B<Any random collection of bytes isn't well-formed UTF-8>.  You can
use C<unpack("C*", $string)> for the former, and you can create
well-formed Unicode data by C<pack("U*", 0xff, ...)>.

=item *

How Do I Display Unicode?  How Do I Input Unicode?

Unicode を表示するにはどうしますか？
Unicode を入力するにはどうしますか？

See http://www.alanwood.net/unicode/ and
http://www.cl.cam.ac.uk/~mgk25/unicode.html

http://www.alanwood.net/unicode/ and
http://www.cl.cam.ac.uk/~mgk25/unicode.html を見てください。

=item *

How Does Unicode Work With Traditional Locales?

これまでのロケールで、Unicodeは、どのようにうごきますか？

In Perl, not very well.  Avoid using locales through the C<locale>
pragma.  Use only one or the other.  But see L<perlrun> for the
description of the C<-C> switch and its environment counterpart,
C<$ENV{PERL_UNICODE}> to see how to enable various Unicode features,
for example by using locale settings.

Perlでは、あまりうまくありません。
C<locale>プラグマでロケールを使うことを避けて下さい。
1つのみか、別のものを使ってください。C<-C>スイッチと、
その環境で対応するC<$ENV{PERL_UNICODE}>の説明のために、
L<perlrun>を見て下さい。様々なUnicodeの機能が、
どのように可能になっているのか、たとえば、ロケールの設定によって、が、わかります。

=back

=head2 16進法

The Unicode standard prefers using hexadecimal notation because
that more clearly shows the division of Unicode into blocks of 256 characters.
Hexadecimal is also simply shorter than decimal.  You can use decimal
notation, too, but learning to use hexadecimal just makes life easier
with the Unicode standard.  The C<U+HHHH> notation uses hexadecimal,
for example.

Unicode標準は、16進法を使うのを好みます。それは、
256のキャラクタのブロックにUnicodeを分割しているのが、
他の表記よりわかりやすいからです。
10進法を使うことも出来ますが、16進法を使うことを学べば、
Unicode標準との暮らしが楽になります。C<U+HHHH>表記は、16進法を使います。
たとえば、

The C<0x> prefix means a hexadecimal number, the digits are 0-9 I<and>
a-f (or A-F, case doesn't matter).  Each hexadecimal digit represents
four bits, or half a byte.  C<print 0x..., "\n"> will show a
hexadecimal number in decimal, and C<printf "%x\n", $decimal> will
show a decimal number in hexadecimal.  If you have just the
"hex digits" of a hexadecimal number, you can use the C<hex()> function.

C<0x>の接頭辞は、16進の数字を意味しています。数字は、0-9と、
a-f(か、A-F、大文字小文字は問いません)です。それぞれの、16進の数字は、
4ビット、1/2バイトを表します。C<print 0x..., "\n">は、
10進で、16進の数を見せます。C<printf "%x\n", $decimal>は、
16進で、10進の数をみせます。"hex degits"の16進の数字があるなら、
C<hex()>関数を使うことが出来ます。

    print 0x0009, "\n";    # 9
    print 0x000a, "\n";    # 10
    print 0x000f, "\n";    # 15
    print 0x0010, "\n";    # 16
    print 0x0011, "\n";    # 17
    print 0x0100, "\n";    # 256

    print 0x0041, "\n";    # 65

    printf "%x\n",  65;    # 41
    printf "%#x\n", 65;    # 0x41

    print hex("41"), "\n"; # 65

=head2 詳しいリソース

=over 4

=item *

Unicode Consortium

    http://www.unicode.org/

=item *

Unicode FAQ

    http://www.unicode.org/unicode/faq/

=item *

Unicode Glossary

    http://www.unicode.org/glossary/

=item *

Unicode Useful Resources

    http://www.unicode.org/unicode/onlinedat/resources.html

=item *

Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications

    http://www.alanwood.net/unicode/

=item *

UTF-8 and Unicode FAQ for Unix/Linux

    http://www.cl.cam.ac.uk/~mgk25/unicode.html

=item *

Legacy Character Sets

    http://www.czyborra.com/
    http://www.eki.ee/letter/

=item *

The Unicode support files live within the Perl installation in the
directory

Unicodeサポートのファイルは、Perlをインストールしたディレクトリ内にあります

    $Config{installprivlib}/unicore

in Perl 5.8.0 or newer, and 

Perl 5.8.0 以上では、

    $Config{installprivlib}/unicode

in the Perl 5.6 series.  (The renaming to F<lib/unicore> was done to
avoid naming conflicts with lib/Unicode in case-insensitive filesystems.)
The main Unicode data file is F<UnicodeData.txt> (or F<Unicode.301> in
Perl 5.6.1.)  You can find the C<$Config{installprivlib}> by

Perl 5.6シリーズでは。(ケースインセンシティブなファイルシステムで、
lib/Unicode 名前の衝突を割けるために、F<lib/unicore>にリネームされています)
メインのUnicodeデータファイルは、F<UnicodeData.txt>(か、Perl5.6.1のF<Unicode.301>)
です。次のようにして、C<$Config{installprivlib}>を見つけることができます。

    perl "-V:installprivlib"

You can explore various information from the Unicode data files using
the C<Unicode::UCD> module.

C<Unicode::UCD>モジュールを使って、Unicode データファイルから、
様々な情報を調べることができます。

=back

=head1 古いPerlでのUNICODE

If you cannot upgrade your Perl to 5.8.0 or later, you can still
do some Unicode processing by using the modules C<Unicode::String>,
C<Unicode::Map8>, and C<Unicode::Map>, available from CPAN.
If you have the GNU recode installed, you can also use the
Perl front-end C<Convert::Recode> for character conversions.

Perl 5.8.0以降にアップグレード出来ないくても、まだ、CPANから利用できる、
C<Unicode::String>、C<Unicode::Mmap8>、C<bUnicode::Map>を使って、
Unicode 処理をすることとができます。

The following are fast conversions from ISO 8859-1 (Latin-1) bytes
to UTF-8 bytes and back, the code works even with older Perl 5 versions.

下記のものは、ISO 8859-1 (Latin-1) バイト列から、UTF-8バイト列に、
素早く変換するものです。このコードは、古いPerl 5 でも動きます。

    # ISO 8859-1 to UTF-8
    s/([\x80-\xFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;

    # UTF-8 to ISO 8859-1
    s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)<<6&0xC0|ord($2)&0x3F)/eg;

=head1 SEE ALSO

L<perlunicode>, L<Encode>, L<encoding>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlrun>, L<Unicode::Collate>, L<Unicode::Normalize>,
L<Unicode::UCD>

=head1 謝辞

Thanks to the kind readers of the perl5-porters@perl.org,
perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org
mailing lists for their valuable feedback.

=head1 著者、著作件、ライセンス

Copyright 2001-2002 Jarkko Hietaniemi E<lt>jhi@iki.fiE<gt>

This document may be distributed under the same terms as Perl itself.
