=head1 NAME

utf8 - ソースコード内に、UTF-8(か、UTF-EBCDIC)を有効/無効にするためのプラグマ

=head1 SYNOPSIS

    use utf8;
    no utf8;

    $num_octets = utf8::upgrade($string);
    $success    = utf8::downgrade($string[, FAIL_OK]);

    utf8::encode($string);
    utf8::decode($string);

    $flag = utf8::is_utf8(STRING); # since Perl 5.8.1
    $flag = utf8::valid(STRING);

=head1 DESCRIPTION

The C<use utf8> pragma tells the Perl parser to allow UTF-8 in the
program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based
platforms).  The C<no utf8> pragma tells Perl to switch back to treating
the source text as literal bytes in the current lexical scope.

C<use utf8>プラグマは、Perl パーサーに、現在のレキシカルスコープ内に、
プログラムのテキストに、UTF-8(EBCDICベースのプラットフォームなら、UTF-EBCDIC)
を許すように伝えます。

This pragma is primarily a compatibility device.  Perl versions
earlier than 5.6 allowed arbitrary bytes in source code, whereas
in future we would like to standardize on the UTF-8 encoding for
source text.

このプラグマは、そもそも、互換性のための工夫です。
Perl 5.6未満のバージョンでは、ソースコード中の恣意的なバイト列を許していました。
ですが、将来、ソーステキストに、UTF-8 エンコーディングを標準化したいと思っています。

B<Do not use this pragma for anything else than telling Perl that your
script is written in UTF-8.> The utility functions described below are
useful for their own purposes, but they are not really part of the
"pragmatic" effect.

Perl に script が UTF-8 で書かれているということを教えることの他に、
このプラグマをつかってはいけません。
下に書かれている、utf8のユーティリティ関数は、それ自身の目的で有益です。
それらは、"プラグマ的な"効果の部分ではまったくありません。

Until UTF-8 becomes the default format for source text, either this
pragma or the L</encoding> pragma should be used to recognize UTF-8
in the source.  When UTF-8 becomes the standard source format, this
pragma will effectively become a no-op.  For convenience in what
follows the term I<UTF-X> is used to refer to UTF-8 on ASCII and ISO
Latin based platforms and UTF-EBCDIC on EBCDIC based platforms.

UTG-8 は、ソーステキストにとって、デフォルトのフォーマットになりつつあります。
このプラグマか、L</encoding>プラグマは、効果的に操作できなくなります。
利便のため、I<UTF-X>という語が続けられるものは、
ASCIIとISO Latin ベースのプラットフォームと、EBSDICベースのプラットフォーム
のUTF-EBCDICを参照するものとします。

See also the effects of the C<-C> switch and its cousin, the
C<$ENV{PERL_UNICODE}>, in L<perlrun>.

C<-C>スイッチとそのいとこの、C<$ENV{PERL_UNICODE}>を、L<perlrun>で見て下さい。

Enabling the C<utf8> pragma has the following effect:

C<utf8>プラグマを有効にすると次の効果があります:

=over 4

=item *

Bytes in the source text that have their high-bit set will be treated
as being part of a literal UTF-8 character.  This includes most
literals such as identifier names, string constants, and constant
regular expression patterns.

高ビットのセットのあるソーステキストにあるバイトは、
リテラルのUTF8キャラクタの部分として扱われます。
このことは、ほとんどのリテラル、識別子の名前、
文字列の中身、不定の正規表現のパターンも含みます。

On EBCDIC platforms characters in the Latin 1 character set are
treated as being part of a literal UTF-EBCDIC character.

EBCDICプラットフォームでは、Latin 1 キャラクタセットのキャラクタは、
リテラルの UTF-EBCDICのキャラクタとして扱われます。

=back

Note that if you have bytes with the eighth bit on in your script
(for example embedded Latin-1 in your string literals), C<use utf8>
will be unhappy since the bytes are most probably not well-formed
UTF-8.  If you want to have such bytes and use utf8, you can disable
utf8 until the end the block (or file, if at top level) by C<no utf8;>.

スクリプト内に8bitのバイト列がある(たとえば、文字列リテラルに、Latin-1がある)なら、
C<use utf8>は、不幸をもたらすでしょう。バイト列は、ほとんどの場合、適切なUTF-8ではないからです。
そのようなバイト列がいるなら、ブロック(または、最上部に書けば、ファイル)の終りまで、 
C<no utf8;> で、utf8 を無効にできます。

If you want to automatically upgrade your 8-bit legacy bytes to UTF-8,
use the L</encoding> pragma instead of this pragma.  For example, if
you want to implicitly upgrade your ISO 8859-1 (Latin-1) bytes to UTF-8
as used in e.g. C<chr()> and C<\x{...}>, try this:

自動的に、8bitレガシーのバイト列をUTF-8にアップグレードしたいなら、 
L</encoding> プラグマを、このプラグマの代わりに使ってくだださい。
たとえば、例で使われているように、ISO 8859-1 (Latin-1) のバイト列を
UTF-8に暗にアップグレードしたいなら、C<chr()> と C<\x{...}>を使います。
次のようにします:

    use encoding "latin-1";
    my $c = chr(0xc4);
    my $x = "\x{c5}";

In case you are wondering: yes, C<use encoding 'utf8';> works much
the same as C<use utf8;>.

迷っている場合:こうしてください。
C<use encoding 'utf8';>は、C<use utf8;>と、大差ありません。 


=head2 ユーティリティ関数

The following functions are defined in the C<utf8::> package by the
Perl core.  You do not need to say C<use utf8> to use these and in fact
you should not say that  unless you really want to have UTF-8 source code.

下記の関数は、C<utf8::>パッケージに、Perl core によって、定義されています。
これらの関数を使うのに、C<use utf8>する必要はありません。
実際、本当にUTF-8のソースコードを書こうとしないなら、use utf8 すべきではありません。。

=over 4

=item * $num_octets = utf8::upgrade($string)

Converts (in-place) internal representation of string to Perl's
internal I<UTF-X> form.  Returns the number of octets necessary to
represent the string as I<UTF-X>.  Can be used to make sure that the
UTF-8 flag is on, so that C<\w> or C<lc()> work as expected on strings
containing characters in the range 0x80-0xFF (oon ASCII and
derivatives).  Note that this should not be used to convert a legacy
byte encoding to Unicode: use Encode for that.  Affected by the
encoding pragma.

文字列の内部表現を、Perlの内部的なI<UTF-X>の形式に(適切に)変換します。
I<UTF-X>として、文字列を表現するのに必要な8ビットの数を返します。
UTF-8フラグがオンであることを確認するのに使えます。
ですので、C<\w>か、C<lc()>は、0x80-0xFF(ASCIIとその派生)
のキャラクタを含む文字列で期待されるように動きます。
次のことに注意してください。レガシーのバイトエンコーディングを、
Unicode にする変換に使うべきではありません:
そのためには、Encode を使って下さい。encoding プラグマに影響を受けます。

=item * $success = utf8::downgrade($string[, FAIL_OK])

Converts (in-place) internal representation of string to be un-encoded
bytes.  Returns true on success. On failure dies or, if the value of
FAIL_OK is true, returns false.  Can be used to make sure that the
UTF-8 flag is off, e.g. when you want to make sure that the substr()
or length() function works with the usually faster byte algorithm.
Note that this should not be used to convert Unicode back to a legacy
byte encoding: use Encode for that.  B<Not> affected by the encoding
pragma.

文字列の内部表現を、エンコードされていないバイト列に(適切に)変換します。
成功すると真を返します。失敗すると、死ぬか、FAIL_OKが真であれば、
偽を返します。たとえば、substr() か length()関数が、
普通のより速いバイトアルゴリズムで動くようにしたい場合、
UTF-8フラグがオフであるのを確認するのに使えます。
次のことに注意してください。Unicode をレガシーのバイトエンコーディングに
戻す変換に使うべきではありません: そのためには、Encode を使って下さい。
encodingプラグマによって影響をB<受けません>。

=item * utf8::encode($string)

Converts (in-place) I<$string> from logical characters to octet
sequence representing it in Perl's I<UTF-X> encoding.  Returns
nothing.  Same as Encode::encode_utf8(). Note that this should not be
used to convert a legacy byte encoding to Unicode: use Encode for
that.

論理キャラクタを、8ビットシーケンス表現に、PerlのI<UTF-X>エンコーディングに、
(適切に)変換します。何も返しません。
Encode::encode_utf8()と同じです。
次のことに注意してください。レガシーのバイトエンコーディングを、
Unicode にする変換に使うべきではありません:そのためには、Encode を使って下さい。

=item * utf8::decode($string)

Attempts to convert I<$string> in-place from Perl's I<UTF-X> encoding
into logical characters. Returns nothing.  Same as Encode::decode_utf8().
Note that this should not be used to convert Unicode back to a legacy
byte encoding: use Encode for that.

I<$string>を、PerlのI<UTF-X>エンコーディングから論理キャラクタに、
適切に、変換しようとします。何も返しません。
Encode::decode_utf8()と同じです。
次のことに注意してください。Unicode をレガシーのバイトエンコーディングに
戻す変換に使うべきではありません: そのためには、Encode を使って下さい。

=item * $flag = utf8::is_utf8(STRING)

(Since Perl 5.8.1)  Test whether STRING is in UTF-8.  Functionally
the same as Encode::is_utf8().

(Perl 5.8.1から) STRINGが、UTF-8かどうかをテストします。
機能的には、Encode::is_utf8() と同じです。

=item * $flag = utf8::valid(STRING)

[INTERNAL] Test whether STRING is in a consistent state regarding
UTF-8.  Will return true is well-formed UTF-8 and has the UTF-8 flag
on B<or> if string is held as bytes (both these states are 'consistent').
Main reason for this routine is to allow Perl's testsuite to check
that operations have left strings in a consistent state.  You most
probably want to use utf8::is_utf8() instead.

=back

C<utf8::encode> is like C<utf8::upgrade>, but the UTF8 flag is
cleared.  See L<perlunicode> for more on the UTF8 flag and the C API
functions C<sv_utf8_upgrade>, C<sv_utf8_downgrade>, C<sv_utf8_encode>,
and C<sv_utf8_decode>, which are wrapped by the Perl functions
C<utf8::upgrade>, C<utf8::downgrade>, C<utf8::encode> and
C<utf8::decode>.  Note that in the Perl 5.8.0 and 5.8.1 implementation
the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode,
utf8::upgrade, and utf8::downgrade are always available, without a
C<require utf8> statement-- this may change in future releases.

C<utf8::encode> は、C<utf8::upgrade> に似ています、
ですが、UTF8 フラグが削除されます。
UTF8フラグの詳細は、L<perlunicode> を見て下さい。
そして、C API 関数 C<sv_utf8_upgrade>、C<sv_utf8_downgrade>、
C<sv_utf8_encode>、C<sv_utf8_decode>は、
Perl関数の、C<utf8::upgrade>、C<utf8::downgrade>、C<utf8::encode>、
C<utf8::decode> でラッピングされています。
Perl 5.8.0 と、5.8.1 の実装で、utf8::is_utf8、utf8::valid、
utf8::encode、utf8::decode、utf8::upgrade、utf8::downgradeは、
常に、C<require utf8>せずに、利用可能になっています。
-- これは、将来のリリースで変わるかもしれません。

=head1 BUGS

One can have Unicode in identifier names, but not in package/class or
subroutine names.  While some limited functionality towards this does
exist as of Perl 5.8.0, that is more accidental than designed; use of
Unicode for the said purposes is unsupported.

One reason of this unfinishedness is its (currently) inherent
unportability: since both package names and subroutine names may need
to be mapped to file and directory names, the Unicode capability of
the filesystem becomes important-- and there unfortunately aren't
portable answers.

=head1 SEE ALSO

L<perluniintro>, L<encoding>, L<perlrun>, L<bytes>, L<perlunicode>

