=head1 NAME

=begin original

perlfaq6 - Regular Expressions ($Revision$)

=end original

perlfaq6 - 正規表現 ($Revision$)

=head1 DESCRIPTION

=begin original

This section is surprisingly small because the rest of the FAQ is
littered with answers involving regular expressions.  For example,
decoding a URL and checking whether something is a number are handled
with regular expressions, but those answers are found elsewhere in
this document (in L<perlfaq9>: "How do I decode or create those %-encodings
on the web" and L<perlfaq4>: "How do I determine whether a scalar is
a number/whole/integer/float", to be precise).

=end original

この章は驚くほど小さくなっています。なぜならFAQの残りの部分は
正規表現を伴った回答と一緒にあちこちに散在しているからです。
たとえばURLをデコードするとかあるものが数値かどうか確認することは
正規表現を使って処理されますが、この回答はこの資料のあらゆる所で
見つけることができます(正確には L<perlfaq9>: "How do I decode or create those %-encodings 
+on the web" と L<perfaq4>: "How do I determine whether a scalar is
+a number/whole/integer/float")。

=head2 How can I hope to use regular expressions without creating illegible and unmaintainable code?
X<regex, legibility> X<regexp, legibility>
X<regular expression, legibility> X</x>

(判読し難い、保守できないようなものにすることなく正規表現を使うには?)

=begin original

Three techniques can make regular expressions maintainable and
understandable.

=end original

正規表現を保守可能なものにし、理解できるようにするための
三つの技法があります。

=over 4

=item Comments Outside the Regex

(正規表現の外側にコメントを付ける)

=begin original

Describe what you're doing and how you're doing it, using normal Perl
comments.

=end original

通常のPerlのコメントを使って、
あなたが何を、どのようにしているかを説明します。

	# turn the line into the first word, a colon, and the
	# number of characters on the rest of the line
	s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;

=item Comments Inside the Regex

(正規表現の内側にコメントを付ける)

=begin original

The C</x> modifier causes whitespace to be ignored in a regex pattern
(except in a character class), and also allows you to use normal
comments there, too.  As you can imagine, whitespace and comments help
a lot.

=end original

<CODE>/x</CODE> 修飾子は、正規表現中にある空白を無視するようにし、
(キャラクタクラスの中にあるものを除く)、通常のコメントが使えるように
します。あなたの想像できるように、空白とコメントは非常に助けに
なります。

=begin original

C</x> lets you turn this:

=end original

C</x>によって

	s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;

=begin original

into this:

=end original

この正規表現を以下の様に記述できます:

	s{ <                    # opening angle bracket
		(?:                 # Non-backreffing grouping paren
			[^>'"] *        # 0 or more things that are neither > nor ' nor "
				|           #    or else
			".*?"           # a section between double quotes (stingy match)
				|           #    or else
			'.*?'           # a section between single quotes (stingy match)
		) +                 #   all occurring one or more times
		>                   # closing angle bracket
	}{}gsx;                 # replace with nothing, i.e. delete

=begin original

It's still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.

=end original

これでもまだ散文(prose)程には明確にはなっていませんが、
パターンの各部分の意味を説明するには非常に便利なものです。

=item Different Delimiters

(異なった区切り)

=begin original

While we normally think of patterns as being delimited with C</>
characters, they can be delimited by almost any character.  L<perlre>
describes this.  For example, the C<s///> above uses braces as
delimiters.  Selecting another delimiter can avoid quoting the
delimiter within the pattern:

=end original

私たちは通常、C</>で区切られたものをパターンであると考えています
が、パターンはほとんどすべてのキャラクタを使って区切ることが可能
です。L<perlre>はこれを説明しています。たとえば、先に挙げたC<s///>
では、区切りとしてカーリーブレースを使っています。スラッシュ以外
の区切りを選択することによって、パターンの中に存在する区切り記号
と同じものをクォートする手間を省くことができます。

	s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
	s#/usr/local#/usr/share#g;		# better

=back

=head2 I'm having trouble matching over more than one line.  What's wrong?
X<regex, multiline> X<regexp, multiline> X<regular expression, multiline>

(二行以上に対するマッチングでトラブルがありました。何が悪いのでしょう?)

=begin original

Either you don't have more than one line in the string you're looking
at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).

=end original

マッチングの対象となっている文字列が実際には二行以上になっていないか、
パターンで正しい修飾子 (modifier)を使っていないかのいずれかでしょう
(多分)。

=begin original

There are many ways to get multiline data into a string.  If you want
it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or C<undef> for the whole file) to
allow you to read more than one line at a time.

=end original

複数行のデータを一つの文字列にする方法はたくさんあります。
これを、入力を読み込んでいる間自動で行なわせたいというのであれば、
一度に二行以上読ませるために $/を(パラグラフ単位で読み込みたいなら ''を、
ファイル全体を読み込みたいなら C<undef>を)設定したくなるでしょう。

=begin original

Read L<perlre> to help you decide which of C</s> and C</m> (or both)
you might want to use: C</s> allows dot to include newline, and C</m>
allows caret and dollar to match next to a newline, not just at the
end of the string.  You do need to make sure that you've actually
got a multiline string in there.

=end original

あなたが使いたいのは C</s>かC</m>のいずれなのか(あるいはこれら両方なのか)を
決めるのを助けるために、L<perlre>を読んでください:
C</s>はドットが改行を含むようにしますし、C</m>はキャレットとドル記号が
文字列の両端だけでなく改行の前後でマッチするようにします。
そして、複数行に渡る文字列を取得するようにさせる必要があります。

=begin original

For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones).  For this example, we don't need
C</s> because we aren't using dot in a regular expression that we want
to cross line boundaries.  Neither do we need C</m> because we aren't
wanting caret or dollar to match at any point inside the record next
to newlines.  But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.

=end original

たとえば、以下に挙げるプログラムは重複した単語を、たとえそれが行を
またがっていても(ただしパラグラフはまたがっていない)探し出すものです。
この例では、C</s>の必要はありません。なぜなら、この行をまたがらせたい正規表現で
ドットを使っていないからです。
C</m>を使う必要もありません。
それは、キャレットやドル記号をレコードの中にある改行の前後でマッチさせることは
望んでいないからです。
しかし、$/をデフォルト以外のものに設定することは避けられませんし、
そうしなければ複数行レコードを読み込むことはできないのです。

	$/ = '';  		# read in more whole paragraph, not just one line
	while ( <> ) {
		while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
			print "Duplicate $1 at paragraph $.\n";
		}
	}

=begin original

Here's code that finds sentences that begin with "From " (which would
be mangled by many mailers):

=end original

以下の例は、“From ”で始まるセンテンス(多くのメイラーによって
変形されるであろうもの)を検索するものです。

	$/ = '';  		# read in more whole paragraph, not just one line
	while ( <> ) {
		while ( /^From /gm ) { # /m makes ^ match next to \n
		print "leading from in paragraph $.\n";
		}
	}

=begin original

Here's code that finds everything between START and END in a paragraph:

=end original

次の例は、パラグラフ中のSTARTとENDに挟まれた部分を検索するものです:

	undef $/;  		# read in whole file, not just one line or paragraph
	while ( <> ) {
		while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
		    print "$1\n";
		}
	}

=head2 How can I pull out lines between two patterns that are themselves on different lines?
X<..>

(異なる行にある二つのパターンに挟まれている行を取り出すのはどうやればできますか?)

=begin original

You can use Perl's somewhat exotic C<..> operator (documented in
L<perlop>):

=end original

Perlの C<..>演算子を使えます(L<perlop>に説明があります)。

	perl -ne 'print if /START/ .. /END/' file1 file2 ...

=begin original

If you wanted text and not lines, you would use

=end original

行ではなく、テキストが必要なら次のようにします

	perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...

=begin original

But if you want nested occurrences of C<START> through C<END>, you'll
run up against the problem described in the question in this section
on matching balanced text.

=end original

しかし、C<START>とC<END>が現れるのを入れ子にさせたいというのであれば、
このセクションにある質問で説明されている問題に直面することになります。

=begin original

Here's another example of using C<..>:

=end original

C<..>を使った別の例です:

	while (<>) {
		$in_header =   1  .. /^$/;
		$in_body   = /^$/ .. eof;
	# now choose between them
	} continue {
		$. = 0 if eof;	# fix $.
	}

=head2 I put a regular expression into $/ but it didn't work. What's wrong?
X<$/, regexes in> X<$INPUT_RECORD_SEPARATOR, regexes in>
X<$RS, regexes in>

=begin original

$/ has to be a string.  You can use these examples if you really need to 
do this.

=end original

$/ は文字列でなければなりません。
もし本当にそうする必要があるなら、以下の例が使えます。

=begin original

If you have File::Stream, this is easy.

=end original

もし File::Stream があれば、簡単です。

	use File::Stream;

	my $stream = File::Stream->new(
		$filehandle,
		separator => qr/\s*,\s*/,
		);

	print "$_\n" while <$stream>;

=begin original

If you don't have File::Stream, you have to do a little more work.

=end original

File::Stream がなければ、もう少し作業が必要です。

=begin original

You can use the four argument form of sysread to continually add to
a buffer.  After you add to the buffer, you check if you have a
complete line (using your regular expression).

=end original

You can use the four argument form of sysread to continually add to
a buffer.  After you add to the buffer, you check if you have a
complete line (using your regular expression).
(TBT)

	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		while( s/^((?s).*?)your_pattern/ ) {
			my $record = $1;
			# do stuff here.
		}
	}

=begin original

You can do the same thing with foreach and a match using the
c flag and the \G anchor, if you do not mind your entire file
being in memory at the end.

=end original

You can do the same thing with foreach and a match using the
c flag and the \G anchor, if you do not mind your entire file
being in memory at the end.
(TBT)

	local $_ = "";
	while( sysread FH, $_, 8192, length ) {
		foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
			# do stuff here.
		}
	substr( $_, 0, pos ) = "" if pos;
	}


=head2 How do I substitute case insensitively on the LHS while preserving case on the RHS?
X<replace, case preserving> X<substitute, case preserving>
X<substitution, case preserving> X<s, case preserving>

(演算子の左辺では大小文字を無視して、演算子の右辺では元の大小文字を保存しておくような
置換をするには?)

=begin original

Here's a lovely Perlish solution by Larry Rosler.  It exploits
properties of bitwise xor on ASCII strings.

=end original

以下に Larry Rosler によるとっても Perl ぽい解法があります。
これは ASCII 文字列に対するビット xor の動作を悪用します。

	$_= "this is a TEsT case";

	$old = 'test';
	$new = 'success';

	s{(\Q$old\E)}
	{ uc $new | (uc $1 ^ $1) .
		(uc(substr $1, -1) ^ substr $1, -1) x
		(length($new) - length $1)
	}egi;

	print;

=begin original

And here it is as a subroutine, modeled after the above:

=end original

以下はサブルーチンにしたものです。上記と同じ手法です:

	sub preserve_case($$) {
		my ($old, $new) = @_;
		my $mask = uc $old ^ $old;

		uc $new | $mask .
			substr($mask, -1) x (length($new) - length($old))
    }

	$a = "this is a TEsT case";
	$a =~ s/(test)/preserve_case($1, "success")/egi;
	print "$a\n";

=begin original

This prints:

=end original

これは以下のように表示します:

	this is a SUcCESS case

=begin original

As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:

=end original

As an alternative, to keep the case of the replacement word if it is
longer than the original, you can use this code, by Jeff Pinyan:
(TBT)

	sub preserve_case {
		my ($from, $to) = @_;
		my ($lf, $lt) = map length, @_;

		if ($lt < $lf) { $from = substr $from, 0, $lt }
		else { $from .= substr $to, $lf }

		return uc $to | ($from ^ uc $from);
		}

=begin original

This changes the sentence to "this is a SUcCess case."

=end original

これは文章を "this is a SUcCess case." に変更します。

=begin original

Just to show that C programmers can write C in any programming language,
if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.

=end original

もしもっと C っぽい解決法が好みなら、
以下に挙げるスクリプトは、大小文字の違いを保ったまま、
文字毎に置換を行ないます。
(そしてこれは Perl っぽい解法より 240% 遅いです。)
置換対象の文字列より
も多くのキャラクターが置換後の文字列にあるのであれば、最後のキャラクターの
大小文字の種別が置換後の文字列の残りの部分のキャラクターに対して使われます。

	# Original by Nathan Torkington, massaged by Jeffrey Friedl
	#
	sub preserve_case($$)
	{
		my ($old, $new) = @_;
		my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
		my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
		my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

		for ($i = 0; $i < $len; $i++) {
			if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
				$state = 0;
			} elsif (lc $c eq $c) {
				substr($new, $i, 1) = lc(substr($new, $i, 1));
				$state = 1;
			} else {
				substr($new, $i, 1) = uc(substr($new, $i, 1));
				$state = 2;
			}
		}
		# finish up with any remaining new (for when new is longer than old)
		if ($newlen > $oldlen) {
			if ($state == 1) {
				substr($new, $oldlen) = lc(substr($new, $oldlen));
			} elsif ($state == 2) {
				substr($new, $oldlen) = uc(substr($new, $oldlen));
			}
		}
		return $new;
	}

=head2 How can I make C<\w> match national character sets?
X<\w>

(C<\w> がnational characterにマッチするように
するにはどうすれば良いですか?)

=begin original

Put C<use locale;> in your script.  The \w character class is taken
from the current locale.

=end original

C<use locale;> をスクリプトに書いてください。
\w 文字クラスが現在のロケールから取られるようになります。

=begin original

See L<perllocale> for details.

=end original

詳しくは L<perllocale> を参照してください。

=head2 How can I match a locale-smart version of C</[a-zA-Z]/>?
X<alpha>

(C</[a-zA-Z]/>の locale-smart なバージョンでマッチさせるには?)

=begin original

You can use the POSIX character class syntax C</[[:alpha:]]/>
documented in L<perlre>.

=end original

L<perlre> で記述されている、POSIX 文字クラス文法 C</[[:alpha:]]/> が
使えます。

=begin original

No matter which locale you are in, the alphabetic characters are
the characters in \w without the digits and the underscore.
As a regex, that looks like C</[^\W\d_]/>.  Its complement,
the non-alphabetics, is then everything in \W along with
the digits and the underscore, or C</[\W\d_]/>.

=end original

No matter which locale you are in, the alphabetic characters are
the characters in \w without the digits and the underscore.
As a regex, that looks like C</[^\W\d_]/>.  Its complement,
the non-alphabetics, is then everything in \W along with
the digits and the underscore, or C</[\W\d_]/>.
(TBT)

=head2 How can I quote a variable to use in a regex?
X<regex, escaping> X<regexp, escaping> X<regular expression, escaping>

(正規表現の中で使う変数をクォートするには?)

=begin original

The Perl parser will expand $variable and @variable references in
regular expressions unless the delimiter is a single quote.  Remember,
too, that the right-hand side of a C<s///> substitution is considered
a double-quoted string (see L<perlop> for more details).  Remember
also that any regex special characters will be acted on unless you
precede the substitution with \Q.  Here's an example:

=end original

Perlの構文解析器(parser)は、区切りがシングルクォーテーションでない限り、
正規表現の中にある $variableや@variableといったものを展開します。
C<s///> による置換の右側にあるものはダブルクォーテーションで
括られた文字列とみなされるということを忘れないでください。
また、すべての正規表現演算子はその前に \Qを置いておかないと、
正規表現演算子として振る舞うということも忘れないでください。
以下に例を挙げます。

	$string = "Placido P. Octopus";
	$regex  = "P.";

	$string =~ s/$regex/Polyp/;
	# $string is now "Polypacido P. Octopus"

=begin original

Because C<.> is special in regular expressions, and can match any
single character, the regex C<P.> here has matched the <Pl> in the
original string.

=end original

Because C<.> is special in regular expressions, and can match any
single character, the regex C<P.> here has matched the <Pl> in the
original string.
(TBT)

=begin original

To escape the special meaning of C<.>, we use C<\Q>:

=end original

C<.> の特殊な意味をエスケープするには、C<\Q> を使います:

	$string = "Placido P. Octopus";
	$regex  = "P.";

	$string =~ s/\Q$regex/Polyp/;
	# $string is now "Placido Polyp Octopus"

=begin original

The use of C<\Q> causes the <.> in the regex to be treated as a
regular character, so that C<P.> matches a C<P> followed by a dot.

=end original

The use of C<\Q> causes the <.> in the regex to be treated as a
regular character, so that C<P.> matches a C<P> followed by a dot.
(TBT)

=head2 What is C</o> really for?
X</o, regular expressions> X<compile, regular expressions>

(C</o>は実際なんのためのものなのですか?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The C</o> option for regular expressions (documented in L<perlop> and
L<perlreref>) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.

=end original

The C</o> option for regular expressions (documented in L<perlop> and
L<perlreref>) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.
(TBT)

=begin original

Since the match operator C<m//>, the substitution operator C<s///>,
and the regular expression quoting operator C<qr//> are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to "How can I quote a variable to use in a regex?" for more
details.

=end original

Since the match operator C<m//>, the substitution operator C<s///>,
and the regular expression quoting operator C<qr//> are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to "How can I quote a variable to use in a regex?" for more
details.
(TBT)

=begin original

This example takes a regular expression from the argument list and
prints the lines of input that match it:

=end original

This example takes a regular expression from the argument list and
prints the lines of input that match it:
(TBT)

	my $pattern = shift @ARGV;
	
	while( <> ) {
		print if m/$pattern/;
		}

=begin original

Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if C<$pattern> had not changed. The C</o>
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:

=end original

Versions of Perl prior to 5.6 would recompile the regular expression
for each iteration, even if C<$pattern> had not changed. The C</o>
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:
(TBT)

	my $pattern = shift @ARGV;
	
	while( <> ) {
		print if m/$pattern/o; # useful for Perl < 5.6
		}

=begin original

In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the C</o>
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the C</o>.

=end original

In versions 5.6 and later, Perl won't recompile the regular expression
if the variable hasn't changed, so you probably don't need the C</o>
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the C</o>.
(TBT)

=begin original

You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The C<use re
'debug'> pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see C<re> reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see C<re> report that for the first iteration.

=end original

You can watch Perl's regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The C<use re
'debug'> pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see C<re> reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see C<re> report that for the first iteration.
(TBT)

	use re 'debug';
	
	$regex = 'Perl';
	foreach ( qw(Perl Java Ruby Python) ) {
		print STDERR "-" x 73, "\n";
		print STDERR "Trying $_...\n";
		print STDERR "\t$_ is good!\n" if m/$regex/;
		}

=head2 How do I use a regular expression to strip C style comments from a file?

(ファイルから、C形式のコメントを剥ぎ取る(strip)するには
どのように正規表現を使えば良いのでしょうか?)

=begin original

While this actually can be done, it's much harder than you'd think.
For example, this one-liner

=end original

実際これは可能なのですが、あなたが考えているよりも非常に難しいものです。
たとえば次の一行野郎 (one-liner)はほとんどの場合にうまく行きますが、
すべての場合ではありません。

	perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

=begin original

will work in many but not all cases.  You see, it's too simple-minded for
certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings.  For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.

=end original

そう、これはCのプログラムを簡単に考えすぎているのです。
特に、クォートされた文字列にコメントが出現するということを考慮していません。
このため、Jeffrey Friedl が作成し,
後に Fred Curtis によって修正された次の例のようなことが必要になります。

	$/ = undef;
	$_ = <>;
	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;
	print;

=begin original

This could, of course, be more legibly written with the C</x> modifier, adding
whitespace and comments.  Here it is expanded, courtesy of Fred Curtis.

=end original

もちろんこれは、C</x>修飾子を使って空白やコメントを付加することで、
より読みやすくすることが可能です。
以下は Fred Curtis の提供による拡張版です。

    s{
       /\*         ##  Start of /* ... */ comment
       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
       (
         [^/*][^*]*\*+
       )*          ##  0-or-more things which don't start with /
                   ##    but do end with '*'
       /           ##  End of /* ... */ comment

     |         ##     OR  various things which aren't comments:

       (
         "           ##  Start of " ... " string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^"\\]        ##  Non "\
         )*
         "           ##  End of " ... " string

       |         ##     OR

         '           ##  Start of ' ... ' string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^'\\]        ##  Non '\
         )*
         '           ##  End of ' ... ' string

       |         ##     OR

         .           ##  Anything other char
         [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
       )
     }{defined $2 ? $2 : ""}gxse;

=begin original

A slight modification also removes C++ comments, as long as they are not
spread over multiple lines using a continuation character):

=end original

A slight modification also removes C++ comments, as long as they are not
spread over multiple lines using a continuation character):
(TBT)

	s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#defined $2 ? $2 : ""#gse;

=head2 Can I use Perl regular expressions to match balanced text?
X<regex, matching balanced test> X<regexp, matching balanced test>
X<regular expression, matching balanced test>

(Perlの正規表現をテキストのバランスが取れているかを
検査するために使えますか?)

=begin original

Historically, Perl regular expressions were not capable of matching
balanced text.  As of more recent versions of perl including 5.6.1
experimental features have been added that make it possible to do this.
Look at the documentation for the (??{ }) construct in recent perlre manual
pages to see an example of matching balanced parentheses.  Be sure to take
special notice of the  warnings present in the manual before making use
of this feature.

=end original

Historically, Perl regular expressions were not capable of matching
balanced text.  As of more recent versions of perl including 5.6.1
experimental features have been added that make it possible to do this.
Look at the documentation for the (??{ }) construct in recent perlre manual
pages to see an example of matching balanced parentheses.  Be sure to take
special notice of the  warnings present in the manual before making use
of this feature.
(TBT)

=begin original

CPAN contains many modules that can be useful for matching text
depending on the context.  Damian Conway provides some useful
patterns in Regexp::Common.  The module Text::Balanced provides a
general solution to this problem.

=end original

CPAN contains many modules that can be useful for matching text
depending on the context.  Damian Conway provides some useful
patterns in Regexp::Common.  The module Text::Balanced provides a
general solution to this problem.
(TBT)

=begin original

One of the common applications of balanced text matching is working
with XML and HTML.  There are many modules available that support
these needs.  Two examples are HTML::Parser and XML::Parser. There
are many others.

=end original

One of the common applications of balanced text matching is working
with XML and HTML.  There are many modules available that support
these needs.  Two examples are HTML::Parser and XML::Parser. There
are many others.
(TBT)

=begin original

An elaborate subroutine (for 7-bit ASCII only) to pull out balanced
and possibly nested single chars, like C<`> and C<'>, C<{> and C<}>,
or C<(> and C<)> can be found in
http://www.cpan.org/authors/id/TOMC/scripts/pull_quotes.gz .

=end original

ネストする可能性のある C<`> と C<'>, C<{> と C<}>, C<(> と C<)> のような
単一キャラクタのバランスを検査するための精巧なサブルーチンが、
http://www.cpan.org/authors/id/TOMC/scripts/pull_quotes.gz
にあります(7-bit ASCII専用)。

=begin original

The C::Scan module from CPAN also contains such subs for internal use,
but they are undocumented.

=end original

CPANにある C::Scan モジュールもこのようなサブルーチンを内部的に
使っているのですが、ドキュメントには載っていません。

=head2 What does it mean that regexes are greedy?  How can I get around it?
X<greedy> X<greediness>

(正規表現が欲張り(greedy)であるとはどういうことですか?)

=begin original

Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (C<?>, C<*>, C<+>,
C<{}>) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed.  To get non-greedy
versions of the same quantifiers, use (C<??>, C<*?>, C<+?>, C<{}?>).

=end original

ほとんどの人が、欲張り正規表現(greedy regexps)は可能な限りマッチすると
考えています。
技術的には、量指定子(C<?>, C<*>, C<+>, C<{}>) はパターン全体よりも貪欲です。
Perlは local greedであることを好み、
全体の要求を即座に満足させます。同じ量指定子のnon-greedyバージョンを得るには、
C<??>, C<*?>, C<+?>, C<{}?>を使います。

=begin original

An example:

=end original

例:

	$s1 = $s2 = "I am very very cold";
	$s1 =~ s/ve.*y //;      # I am cold
	$s2 =~ s/ve.*?y //;     # I am very cold

=begin original

Notice how the second substitution stopped matching as soon as it
encountered "y ".  The C<*?> quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, like you would if you were
playing hot potato.

=end original

二番目の置換が、“y ”を見つけてすぐにマッチングを中断していることに
注目してください。量指定子 C<*?>は正規表現エンジンに対して、
あなたが熱いジャガイモを扱っているときのように、可能な限り早く
マッチするものを見つけて制御を次の行に渡すように効果的に指示します。

=head2 How do I process each word on each line?
X<word>

(各行の、各単語毎に処理をするにはどうすれば良いですか?)

=begin original

Use the split function:

=end original

split関数を使います:

	while (<>) {
		foreach $word ( split ) {
			# do something with $word here
		}
	}

=begin original

Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.

=end original

これは実際には英語でいうところの語ではないことに注意してください。
これは、単なる連続した空白でないキャラクターの塊です。

=begin original

To work with only alphanumeric sequences (including underscores), you
might consider

=end original

アルファベットもしくは数字の並びのみを対象とするには以下のようにしてできます。

	while (<>) {
		foreach $word (m/(\w+)/g) {
			# do something with $word here
		}
	}

=head2 How can I print out a word-frequency or line-frequency summary?

(語の出現頻度や行の出現頻度のまとめをどうやれば出力できますか?)

=begin original

To do this, you have to parse out each word in the input stream.  We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:

=end original

これを行うためには、入力ストリームにある単語のそれぞれについて解析する
必要があります。
私たちはここで、一つ前の質問と同様に、非空白キャラクターの塊を語とするのではなく
アルファベット、ハイフン、アポストロフィ、の塊を語とします:

	while (<>) {
		while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
			$seen{$1}++;
		}
	}

	while ( ($word, $count) = each %seen ) {
		print "$count $word\n";
		}

=begin original

If you wanted to do the same thing for lines, you wouldn't need a
regular expression:

=end original

同じことを行に対して行いたいのであれば、正規表現は必要ないでしょう。

	while (<>) {
		$seen{$_}++;
		}

	while ( ($line, $count) = each %seen ) {
		print "$count $line";
	}

=begin original

If you want these output in a sorted order, see L<perlfaq4>: "How do I
sort a hash (optionally by value instead of key)?".

=end original

ソートされた順序で出力したいのなら、L<perlfaq4>: "How do I
sort a hash (optionally by value instead of key)?" を参照してください。

=head2 How can I do approximate matching?
X<match, approximate> X<matching, approximate>

(曖昧なマッチング (approximate matching)はどうやればできますか?)

=begin original

See the module String::Approx available from CPAN.

=end original

CPANで入手できる String::Approx モジュールを参照してください。

=head2 How do I efficiently match many regular expressions at once?
X<regex, efficiency> X<regexp, efficiency>
X<regular expression, efficiency>

(たくさんの正規表現を一度に効率良くマッチングするには?)

=begin original

( contributed by brian d foy )

=end original

(brian d foy によって寄贈されました)

=begin original

Avoid asking Perl to compile a regular expression every time
you want to match it.  In this example, perl must recompile
the regular expression for every iteration of the foreach()
loop since it has no way to know what $pattern will be.

=end original

Avoid asking Perl to compile a regular expression every time
you want to match it.  In this example, perl must recompile
the regular expression for every iteration of the foreach()
loop since it has no way to know what $pattern will be.
(TBT)

	@patterns = qw( foo bar baz );

	LINE: while( <DATA> )
		{
		foreach $pattern ( @patterns )
			{
			if( /\b$pattern\b/i )
				{
				print;
				next LINE;
				}
			}
		}

=begin original

The qr// operator showed up in perl 5.005.  It compiles a
regular expression, but doesn't apply it.  When you use the
pre-compiled version of the regex, perl does less work. In
this example, I inserted a map() to turn each pattern into
its pre-compiled form.  The rest of the script is the same,
but faster.

=end original

The qr// operator showed up in perl 5.005.  It compiles a
regular expression, but doesn't apply it.  When you use the
pre-compiled version of the regex, perl does less work. In
this example, I inserted a map() to turn each pattern into
its pre-compiled form.  The rest of the script is the same,
but faster.
(TBT)

	@patterns = map { qr/\b$_\b/i } qw( foo bar baz );

	LINE: while( <> )
		{
		foreach $pattern ( @patterns )
			{
			print if /$pattern/i;
			next LINE;
			}
		}

=begin original

In some cases, you may be able to make several patterns into
a single regular expression.  Beware of situations that require
backtracking though.

=end original

In some cases, you may be able to make several patterns into
a single regular expression.  Beware of situations that require
backtracking though.
(TBT)

	$regex = join '|', qw( foo bar baz );

	LINE: while( <> )
		{
		print if /\b(?:$regex)\b/i;
		}

=begin original

For more details on regular expression efficiency, see Mastering
Regular Expressions by Jeffrey Freidl.  He explains how regular
expressions engine work and why some patterns are surprisingly
inefficient.  Once you understand how perl applies regular
expressions, you can tune them for individual situations.

=end original

For more details on regular expression efficiency, see Mastering
Regular Expressions by Jeffrey Freidl.  He explains how regular
expressions engine work and why some patterns are surprisingly
inefficient.  Once you understand how perl applies regular
expressions, you can tune them for individual situations.
(TBT)

=head2 Why don't word-boundary searches with C<\b> work for me?
X<\b>

(なぜC<\b>を使った語境界の検索がうまく行かないのでしょうか?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Ensure that you know what \b really does: it's the boundary between a
word character, \w, and something that isn't a word character. That
thing that isn't a word character might be \W, but it can also be the
start or end of the string.

=end original

Ensure that you know what \b really does: it's the boundary between a
word character, \w, and something that isn't a word character. That
thing that isn't a word character might be \W, but it can also be the
start or end of the string.
(TBT)

=begin original

It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.

=end original

It's not (not!) the boundary between whitespace and non-whitespace,
and it's not the stuff between words we use to create sentences.
(TBT)

=begin original

In regex speak, a word boundary (\b) is a "zero width assertion",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.

=end original

In regex speak, a word boundary (\b) is a "zero width assertion",
meaning that it doesn't represent a character in the string, but a
condition at a certain position.
(TBT)

=begin original

For the regular expression, /\bPerl\b/, there has to be a word
boundary before the "P" and after the "l".  As long as something other
than a word character precedes the "P" and succeeds the "l", the
pattern will match. These strings match /\bPerl\b/.

=end original

For the regular expression, /\bPerl\b/, there has to be a word
boundary before the "P" and after the "l".  As long as something other
than a word character precedes the "P" and succeeds the "l", the
pattern will match. These strings match /\bPerl\b/.
(TBT)

	"Perl"    # no word char before P or after l
	"Perl "   # same as previous (space is not a word char)
	"'Perl'"  # the ' char is not a word char
	"Perl's"  # no word char before P, non-word char after "l"

=begin original

These strings do not match /\bPerl\b/.

=end original

これらの文字列は /\bPerl\b/ にマッチしません。

	"Perl_"   # _ is a word char!
	"Perler"  # no word char before P, but one after l

=begin original

You don't have to use \b to match words though.  You can look for
non-word characters surrounded by word characters.  These strings
match the pattern /\b'\b/.

=end original

You don't have to use \b to match words though.  You can look for
non-word characters surrounded by word characters.  These strings
match the pattern /\b'\b/.
(TBT)

	"don't"   # the ' char is surrounded by "n" and "t"
	"qep'a'"  # the ' char is surrounded by "p" and "a"

=begin original

These strings do not match /\b'\b/.

=end original

これらの文字列は /\b'\b/ にマッチしません。

	"foo'"    # there is no word char after non-word '

=begin original

You can also use the complement of \b, \B, to specify that there
should not be a word boundary.

=end original

You can also use the complement of \b, \B, to specify that there
should not be a word boundary.
(TBT)

=begin original

In the pattern /\Bam\B/, there must be a word character before the "a"
and after the "m". These patterns match /\Bam\B/:

=end original

In the pattern /\Bam\B/, there must be a word character before the "a"
and after the "m". These patterns match /\Bam\B/:
(TBT)

	"llama"   # "am" surrounded by word chars
	"Samuel"  # same

=begin original

These strings do not match /\Bam\B/

=end original

これらの文字列は /\Bam\B/ にマッチしません。

	"Sam"      # no word boundary before "a", but one after "m"
	"I am Sam" # "am" surrounded by non-word chars


=head2 Why does using $&, $`, or $' slow my program down?
X<$MATCH> X<$&> X<$POSTMATCH> X<$'> X<$PREMATCH> X<$`>

=begin original

(contributed by Anno Siegel)

=end original

(brian d foy によって寄贈されました)

=begin original

Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer "expensive" the way the other two are.

=end original

プログラムのどこかでそういった変数が使われているのを見つけてしまうと、
Perlはすべてのパターンマッチに対してそれに対処することを
やらなければなりません。
That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often.
可能であれば $&や$'、$`を使わないようにすべきなのですが、
それができないのであれば、
一度これらの変数を使ってしまったら好きなように使いましょう。
なぜなら、罰金はすでに払ってしまったのですから。
アルゴリズムの中にはこういった変数を使うことが適切であるものが
あるということに注意してください。
リリース5.005では、$&はもはや“高価な”ものではありません。
(TBT)

=begin original

Since Perl 5.6.1 the special variables @- and @+ can functionally replace
$`, $& and $'.  These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.

=end original

Perl 5.6.1 から、特殊変数 @- と @+ で $`, $&, $' の機能を
置き換えられるようになりました。
These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information,
過度の文字列コピーのリスクはありません。
(TBT)

=head2 What good is C<\G> in a regular expression?
X<\G>

(正規表現の中でC<\G> を使うと何が良いのですか?)

=begin original

You use the C<\G> anchor to start the next match on the same
string where the last match left off.  The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so C<\G> is similar to the
beginning of string anchor, C<^>.  The C<\G> anchor is typically
used with the C<g> flag.  It uses the value of C<pos()>
as the position to start the next match.  As the match
operator makes successive matches, it updates C<pos()> with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own C<pos()> value.

=end original

You use the C<\G> anchor to start the next match on the same
string where the last match left off.  The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so C<\G> is similar to the
beginning of string anchor, C<^>.  The C<\G> anchor is typically
used with the C<g> flag.  It uses the value of C<pos()>
as the position to start the next match.  As the match
operator makes successive matches, it updates C<pos()> with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own C<pos()> value.
(TBT)

=begin original

Suppose you want to match all of consecutive pairs of digits
in a string like "1122a44" and stop matching when you
encounter non-digits.  You want to match C<11> and C<22> but
the letter <a> shows up between C<22> and C<44> and you want
to stop at C<a>. Simply matching pairs of digits skips over
the C<a> and still matches C<44>.

=end original

Suppose you want to match all of consecutive pairs of digits
in a string like "1122a44" and stop matching when you
encounter non-digits.  You want to match C<11> and C<22> but
the letter <a> shows up between C<22> and C<44> and you want
to stop at C<a>. Simply matching pairs of digits skips over
the C<a> and still matches C<44>.
(TBT)

	$_ = "1122a44";
	my @pairs = m/(\d\d)/g;   # qw( 11 22 44 )

=begin original

If you use the C<\G> anchor, you force the match after C<22> to
start with the C<a>.  The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.

=end original

If you use the C<\G> anchor, you force the match after C<22> to
start with the C<a>.  The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.
(TBT)

	$_ = "1122a44";
	my @pairs = m/\G(\d\d)/g; # qw( 11 22 )

=begin original

You can also use the C<\G> anchor in scalar context. You
still need the C<g> flag.

=end original

スカラコンテキストにも C<\G> アンカーが使えます。
C<g> フラグはまだ必要です。

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

=begin original

After the match fails at the letter C<a>, perl resets C<pos()>
and the next match on the same string starts at the beginning.

=end original

After the match fails at the letter C<a>, perl resets C<pos()>
and the next match on the same string starts at the beginning.
(TBT)

	$_ = "1122a44";
	while( m/\G(\d\d)/g )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "11"

=begin original

You can disable C<pos()> resets on fail with the C<c> flag, documented
in L<perlop> and L<perlreref>. Subsequent matches start where the last
successful match ended (the value of C<pos()>) even if a match on the
same string has failed in the meantime. In this case, the match after
the C<while()> loop starts at the C<a> (where the last match stopped),
and since it does not use any anchor it can skip over the C<a> to find
C<44>.

=end original

You can disable C<pos()> resets on fail with the C<c> flag, documented
in L<perlop> and L<perlreref>. Subsequent matches start where the last
successful match ended (the value of C<pos()>) even if a match on the
same string has failed in the meantime. In this case, the match after
the C<while()> loop starts at the C<a> (where the last match stopped),
and since it does not use any anchor it can skip over the C<a> to find
C<44>.
(TBT)

	$_ = "1122a44";
	while( m/\G(\d\d)/gc )
		{
		print "Found $1\n";
		}

	print "Found $1 after while" if m/(\d\d)/g; # finds "44"

=begin original

Typically you use the C<\G> anchor with the C<c> flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.

=end original

Typically you use the C<\G> anchor with the C<c> flag
when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.
(TBT)

	while (<>) {
		chomp;
		PARSER: {
			m/ \G( \d+\b    )/gcx   && do { print "number: $1\n";  redo; };
			m/ \G( \w+      )/gcx   && do { print "word:   $1\n";  redo; };
			m/ \G( \s+      )/gcx   && do { print "space:  $1\n";  redo; };
			m/ \G( [^\w\d]+ )/gcx   && do { print "other:  $1\n";  redo; };
		}
	}

=begin original

For each line, the C<PARSER> loop first tries to match a series
of digits followed by a word boundary.  This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since C<m/ \G( \d+\b
)/gcx> uses the C<c> flag, if the string does not match that
regular expression, perl does not reset pos() and the next
match starts at the same position to try a different
pattern.

=end original

For each line, the C<PARSER> loop first tries to match a series
of digits followed by a word boundary.  This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since C<m/ \G( \d+\b
)/gcx> uses the C<c> flag, if the string does not match that
regular expression, perl does not reset pos() and the next
match starts at the same position to try a different
pattern.
(TBT)

=head2 Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?
X<DFA> X<NFA> X<POSIX>

(Perlの正規表現ルーチンはDFAですかNFAですか?
また、それはPOSIXに従ってますか?)

=begin original

While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the egrep(1) program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing.  And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases.  (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.)  See the book "Mastering Regular Expressions"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
L<perlfaq2>).

=end original

Perlの正規表現はegrep(1)のDFA (deterministic finite automata, 
決定性有限オートマトン)と似たものではあるのですが、
実際のところはバックトラックや後方参照 (backreferencing)のために
NFAとして実装されています。
そして、Perlの正規表現は POSIX形式のものでもありません。
なぜなら、それはすべてのケースにおいて最悪の振る舞いを行うからです
(一部の人は、それが遅さをもたらすにもかからわず、一貫性をもたらすという点を
好んでいるようです)。
上記のことなどに関しての詳細はJeffrery Friedlによる O'Reillyから出版されている 
"Mastering Regular Expressions" という本を参照してください。

=head2 What's wrong with using grep in a void context?
X<grep>

(無効コンテキストで grep を使うことのどこが間違っているのでしょうか?)

=begin original

The problem is that grep builds a return list, regardless of the context.
This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.

=end original

問題は、grep はそのコンテキストには関係なくリストを返すことです。
これはつまり、Perlにあなたが無視してしまうための戻り値のリストを
作らせるということです。
プログラミング言語を扱う方法はなく、あなたは鈍感な無法者です!

=begin original

In perls older than 5.8.1, map suffers from this problem as well.
But since 5.8.1, this has been fixed, and map is context aware - in void
context, no lists are constructed.

=end original

5.8.1 より前の perl では、map も同じ問題の影響を受けていました。
しかし 5.8.1 から、これは修正され、map はコンテキストを
認識するようになりました - 無効コンテキストではリストは作られません。

=head2 How can I match strings with multibyte characters?
X<regex, and multibyte characters> X<regexp, and multibyte characters>
X<regular expression, and multibyte characters> X<martian> X<encoding, Martian>

=begin original

Starting from Perl 5.6 Perl has had some level of multibyte character
support.  Perl 5.8 or later is recommended.  Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module.  See L<perluniintro>, L<perlunicode>,
and L<Encode>.

=end original

Starting from Perl 5.6 Perl has had some level of multibyte character
support.  Perl 5.8 or later is recommended.  Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module.  See L<perluniintro>, L<perlunicode>,
and L<Encode>.
(TBT)

=begin original

If you are stuck with older Perls, you can do Unicode with the
C<Unicode::String> module, and character conversions using the
C<Unicode::Map8> and C<Unicode::Map> modules.  If you are using
Japanese encodings, you might try using the jperl 5.005_03.

=end original

If you are stuck with older Perls, you can do Unicode with the
C<Unicode::String> module, and character conversions using the
C<Unicode::Map8> and C<Unicode::Map> modules.  If you are using
Japanese encodings, you might try using the jperl 5.005_03.
(TBT)

=begin original

Finally, the following set of approaches was offered by Jeffrey
Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.

=end original

以下に、The Perl Journalの
第五号でこの問題についてより詳しい記事を書いたJeffery Friedlにより
提案されたアプローチの幾つかを挙げます。

=begin original

Let's suppose you have some weird Martian encoding where pairs of
ASCII uppercase letters encode single Martian letters (i.e. the two
bytes "CV" make a single Martian letter, as do the two bytes "SG",
"VS", "XX", etc.). Other bytes represent single characters, just like
ASCII.

=end original

さて、ここでASCIIの大文字二文字で火星語の符号化をしていると仮定しましょう
(たとえば、 "CV", "SG", "VS", "XX"などといった二バイトの並びが
火星語の一文字を表わすということです)。

=begin original

So, the string of Martian "I am CVSGXX!" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.

=end original

ですから、火星語の符号化をしている 12バイトの "I am CVSGXX!" 文字列は、
'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!' という九文字で構成されます。

=begin original

Now, say you want to search for the single character C</GX/>. Perl
doesn't know about Martian, so it'll find the two bytes "GX" in the "I
am CVSGXX!"  string, even though that character isn't there: it just
looks like it is because "SG" is next to "XX", but there's no real
"GX".  This is a big problem.

=end original

ここで、C</GX/>という一文字検索をしたいと考えてみましょう。
Perlは火星語については何も知りませんから、"I am CVSGXX!" という文字列にある
"GX"二バイトを見つけ出してしまうでしょうが、これは文字として
そこにあるものではありません。
つまり、"SG"に続けて"XX"があるのでそう見えるだけであって、
本当に"GX"があるわけではないのです。これは大きな問題です。

=begin original

Here are a few ways, all painful, to deal with it:

=end original

この問題に対処する方法が、うんざりするようなものですが、幾つかあります:

	# Make sure adjacent "martian" bytes are no longer adjacent.
	$martian =~ s/([A-Z][A-Z])/ $1 /g;

	print "found GX!\n" if $martian =~ /GX/;

=begin original

Or like this:

=end original

あるいは:

	@chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
	# above is conceptually similar to:     @chars = $text =~ m/(.)/g;
	#
	foreach $char (@chars) {
	print "found GX!\n", last if $char eq 'GX';
	}

=begin original

Or like this:

=end original

あるいは:

	while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
		print "found GX!\n", last if $1 eq 'GX';
		}

=begin original

Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.

=end original

Here's another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind assertion.
(TBT)

	print "found GX!\n" if	$martian =~ m/
		(?<![A-Z])
		(?:[A-Z][A-Z])*?
		GX
		/x;

=begin original

This succeeds if the "martian" character GX is in the string, and fails
otherwise.  If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A-Z]) with (?:^|[^A-Z]).

=end original

This succeeds if the "martian" character GX is in the string, and fails
otherwise.  If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A-Z]) with (?:^|[^A-Z]).
(TBT)

=begin original

It does have the drawback of putting the wrong thing in $-[0] and $+[0],
but this usually can be worked around.

=end original

It does have the drawback of putting the wrong thing in $-[0] and $+[0],
but this usually can be worked around.
(TBT)

=head2 How do I match a regular expression that's in a variable?
X<regex, in variable> X<eval> X<regex> X<quotemeta> X<\Q, regex>
X<\E, regex>, X<qr//>

(変数に入っている正規表現でマッチングを行うには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.

=end original

We don't have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can put the
pattern in a variable for later use.
(TBT)

=begin original

The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in C<$regex>.
Once you have the pattern in C<$regex>, you use that variable in the
match operator.

=end original

The match operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in C<$regex>.
Once you have the pattern in C<$regex>, you use that variable in the
match operator.
(TBT)

	chomp( my $regex = <STDIN> );

	if( $string =~ m/$regex/ ) { ... }

=begin original

Any regular expression special characters in C<$regex> are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.

=end original

Any regular expression special characters in C<$regex> are still
special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.
(TBT)

	my $regex = "Unmatched ( paren";

	"Two parens to bind them all" =~ m/$regex/;

=begin original

When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:

=end original

When Perl compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:
(TBT)

	Unmatched ( in regex; marked by <-- HERE in m/Unmatched ( <-- HERE  paren/ at script line 3.

=begin original

You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with C<quotemeta> before you use the string.

=end original

You can get around this in several ways depending on our situation.
First, if you don't want any of the characters in the string to be
special, you can escape them with C<quotemeta> before you use the string.
(TBT)

	chomp( my $regex = <STDIN> );
	$regex = quotemeta( $regex );

	if( $string =~ m/$regex/ ) { ... }

=begin original

You can also do this directly in the match operator using the C<\Q>
and C<\E> sequences. The C<\Q> tells Perl where to start escaping
special characters, and the C<\E> tells it where to stop (see L<perlop>
for more details).

=end original

You can also do this directly in the match operator using the C<\Q>
and C<\E> sequences. The C<\Q> tells Perl where to start escaping
special characters, and the C<\E> tells it where to stop (see L<perlop>
for more details).
(TBT)

	chomp( my $regex = <STDIN> );

	if( $string =~ m/\Q$regex\E/ ) { ... }

=begin original

Alternately, you can use C<qr//>, the regular expression quote operator (see
L<perlop> for more details).  It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.

=end original

Alternately, you can use C<qr//>, the regular expression quote operator (see
L<perlop> for more details).  It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.
(TBT)

	chomp( my $input = <STDIN> );

	my $regex = qr/$input/is;

	$string =~ m/$regex/  # same as m/$input/is;

=begin original

You might also want to trap any errors by wrapping an C<eval> block
around the whole thing.

=end original

You might also want to trap any errors by wrapping an C<eval> block
around the whole thing.
(TBT)

	chomp( my $input = <STDIN> );

	eval {
		if( $string =~ m/\Q$input\E/ ) { ... }
		};
	warn $@ if $@;

=begin original

Or...

=end original

または...

	my $regex = eval { qr/$input/is };
	if( defined $regex ) {
		$string =~ m/$regex/;
		}
	else {
		warn $@;
		}

=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
