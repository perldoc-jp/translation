
=encoding euc-jp

=head1 NAME

=begin original

perlretut - Perl regular expressions tutorial

=end original

perlretut - Perl の正規表現のチュートリアル

=head1 DESCRIPTION

=begin original

This page provides a basic tutorial on understanding, creating and
using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions L<perlre>.  Regular expressions
are an integral part of the C<m//>, C<s///>, C<qr//> and C<split>
operators and so this tutorial also overlaps with
L<perlop/"Regexp Quote-Like Operators"> and L<perlfunc/split>.

=end original

このページではPerlの正規表現を理解し、作成し、使用するための基本的な
チュートリアルを提供します。
詳細は正規表現のリファレンスページである L<perlre> にあります。
正規表現は演算子 C<m//>、C<s///>、C<qr//>、C<split> の一部分であり、
本チュートリアルでは L<perlop/"Regexp Quote-Like Operators"> や
L<perlfunc/split> と重複する部分があります。

=begin original

Perl is widely renowned for excellence in text processing, and regular
expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.

=end original

Perl はテキスト処理のための優れた道具であると広く知られていて、
正規表現はこの名声の大きな部分です。
Perl の正規表現は他の大部分の言語で知られていない効率性や融通性を
明らかにします。
正規表現の基本的な部分をマスターすることによってさえ驚くほど簡単に
テキストを操作することができるようになるでしょう。

=begin original

What is a regular expression?  A regular expression is simply a string
that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., C<ls *.txt>
or C<dir *.*>.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.

=end original

正規表現とは何でしょうか? 正規表現とはパターンを表す単純な文字列です。
パターンは今日広く使われています。
たとえば、ウェブページを見つけ出すために検索エンジンにタイプしたり、
ディレクトリの中のファイルをリストアップするために C<ls *.txt> とか
C<dir *.*> としたりします。
Perlでは、パターンは正規表現によって記述され、文字列を探しだしたり、
文字列の望みの部分を取り出したり、検索と置換の操作をするために使われます。

=begin original

Regular expressions have the undeserved reputation of being abstract
and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding C<if> conditionals and C<while>
loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.

=end original

正規表現には抽象的で理解するのが難しいという不適切な悪名があります。
正規表現は条件とループのような単純なコンセプトを使って構成されていて、
Perl 自身の C<if> であるとかC<while> のようなそれと対応するものに比べて
難しいことはありません。
事実、正規表現を学ぶにあたっての主な挑戦はこれらのコンセプトを
表現するために簡潔な記述を使おうとすることなのです。

=begin original

This tutorial flattens the learning curve by discussing regular
expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting edge innovations in 5.6.0.

=end original

本チュートリアルでは表記に関して一度に一つずつ、そして例を多く挙げて正規表現のコンセプトを論じることによって、学習曲線を平坦化します。
本チュートリアルの最初の部分は基本的な正規表現のコンセプトのための単純な単語検索から始まります。
最初の部分をマスターすれば、必要とすることの98%を解決するのに必要なツールを得ることになるでしょう。
本チュートリアルの二番目の部分はより強力なツールのために十分なものです。
そこではより高度な正規表現演算子について論じ、5.6.0で導入された最新の機能を紹介します。

=begin original

A note: to save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.

=end original

'regular expression' はしばしば regexp とか regex と略されます。
regexp は regex よりも自然な略称ですが発音するのが難しいです。
Perl の pod ドキュメントでは regexp と regex が混在しています。
Perl では、略するやり方は一つではないのです。
このチュートリアルでは regexp を使うことにします。

=head1 Part 1: The basics

(基本)

=head2 Simple word matching

(単純な単語マッチング)

=begin original

The simplest regexp is simply a word, or more generally, a string of
characters.  A regexp consisting of a word matches any string that
contains that word:

=end original

最も単純な正規表現は単なる単語、より一般的には文字の並びです。
正規表現は単語を構成する任意の文字列にマッチする単語からなります:

    "Hello World" =~ /World/;  # matches

=begin original

What is this Perl statement all about? C<"Hello World"> is a simple
double quoted string.  C<World> is the regular expression and the
C<//> enclosing C</World/> tells Perl to search a string for a match.
The operator C<=~> associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, C<World> matches the second word in
C<"Hello World">, so the expression is true.  Expressions like this
are useful in conditionals:

=end original

このPerlの文が行っていることは何でしょう?
C<"Hello World"> は単純な、ダブルクォートで囲まれた文字列です。
C<World> は正規表現であり、 C<//> で囲まれたC</World/> は
Perl に対してマッチのために文字列を検索することを指示します。
C<=~> という演算子は正規表現にマッチする文字列に結び付けられ、
正規表現がマッチすれば真の値を生成し、マッチしなければ偽となります。
この例では、C<World> は C<"Hello World"> の二番目の単語にマッチするので、
式は真となります。
このような式は条件文に使うにも便利です:

    if ("Hello World" =~ /World/) {
        print "It matches\n";
    }
    else {
        print "It doesn't match\n";
    }

=begin original

There are useful variations on this theme.  The sense of the match can
be reversed by using the C<!~> operator:

=end original

便利なバリエーションもあります。
マッチの成否の意味を反転する演算子 C<!~> があります:

    if ("Hello World" !~ /World/) {
        print "It doesn't match\n";
    }
    else {
        print "It matches\n";
    }

=begin original

The literal string in the regexp can be replaced by a variable:

=end original

正規表現中のリテラル文字列は変数に置き換えることもができます:

    $greeting = "World";
    if ("Hello World" =~ /$greeting/) {
        print "It matches\n";
    }
    else {
        print "It doesn't match\n";
    }

=begin original

If you're matching against the special default variable C<$_>, the
C<$_ =~> part can be omitted:

=end original

特殊デフォルト変数 C<$_> に対してマッチングを行う場合、C<$_ =~> の
部分は省略することができます:

    $_ = "Hello World";
    if (/World/) {
        print "It matches\n";
    }
    else {
        print "It doesn't match\n";
    }

=begin original

And finally, the C<//> default delimiters for a match can be changed
to arbitrary delimiters by putting an C<'m'> out front:

=end original

最後に、マッチのための C<//> のデフォルトデリミタは C'm'> を
前置することにより任意のものにすることができます:

=begin original

    "Hello World" =~ m!World!;   # matches, delimited by '!'
    "Hello World" =~ m{World};   # matches, note the matching '{}'
    "/usr/bin/perl" =~ m"/perl"; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char

=end original

    "Hello World" =~ m!World!;   # マッチする。デリミタは '!'
    "Hello World" =~ m{World};   # マッチする。組になっている'{}' に注意
    "/usr/bin/perl" =~ m"/perl"; # 'usr/bin'の後にマッチする
                                 # '/' は普通の文字になっている

=begin original

C</World/>, C<m!World!>, and C<m{World}> all represent the
same thing.  When, e.g., the quote (C<">) is used as a delimiter, the forward
slash C<'/'> becomes an ordinary character and can be used in this regexp
without trouble.

=end original

C</World/>,  C<m!World!>, C<m{World}> はすべて同じものを表しています。
例えば C<"> をデリミタとして使ったとき、スラッシュ C<'/'> は
通常の文字となり、トラブルなしに正規表現中で使うことができます。

=begin original

Let's consider how different regexps would match C<"Hello World">:

=end original

異なる正規表現がどのように C<"Hello World"> にマッチするか考えてみましょう:

    "Hello World" =~ /world/;  # doesn't match
    "Hello World" =~ /o W/;    # matches
    "Hello World" =~ /oW/;     # doesn't match
    "Hello World" =~ /World /; # doesn't match

=begin original

The first regexp C<world> doesn't match because regexps are
case-sensitive.  The second regexp matches because the substring
S<C<'o W'>> occurs in the string S<C<"Hello World">>.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp C<'oW'> doesn't match.  The fourth regexp
C<'World '> doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string I<exactly> in order for the
statement to be true.

=end original

最初の正規表現 C<world> はマッチしません。
なぜなら、正規表現は大文字と小文字を区別するからです。
二番目の正規表現は S<C<"Hello World">> という文字列の中に S<C<'o W'>> と
いう部分があるのでマッチします。
スペース ' 'は正規表現の中で他の文字と同じように扱われ、この場合
マッチするのに必要なものです。
スペースがないことが三番目の正規表現 C<'oW'> がマッチしない理由です。
四番目の正規表現は正規表現の末尾にスペースがついているのに、文字列の末尾には
スペースがないのでマッチしません。
このレッスンでは正規表現は、文が真となるためには I<その通り> に文字列の
一部としてマッチしなければならないことを示しました。

=begin original

If a regexp matches in more than one place in the string, Perl will
always match at the earliest possible point in the string:

=end original

正規表現が文字列の二箇所以上にマッチするならば、Perlは常に文字列の中で
最初に現れるものをマッチしようとします:

=begin original

    "Hello World" =~ /o/;       # matches 'o' in 'Hello'
    "That hat is red" =~ /hat/; # matches 'hat' in 'That'

=end original

    "Hello World" =~ /o/;       # 'Hello'の'o'にマッチ
    "That hat is red" =~ /hat/; # 'That'の中の'hat'にマッチ

=begin original

With respect to character matching, there are a few more points you
need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called I<metacharacters>, are reserved
for use in regexp notation.  The metacharacters are

=end original

文字マッチングに対する関心と共に、知っておくべき幾つかのポイントがあります。
まず始めに、すべての文字がマッチにおいて'あるがまま'(as is) に使われるのではないということです。
I<メタ文字> と呼ばれる幾つかの文字が正規表現の記述に使うために予約されています。
メタ文字には以下のものがあります

    {}[]()^$.|*+?\

=begin original

The significance of each of these will be explained
in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:

=end original

これらの文字のそれぞれの重要性は本チュートリアルの残りの部分で説明されますが、
今のところは、メタ文字はバックスラッシュを前置することによって
マッチさせることができることを知っておくことが重要です:

=begin original

    "2+2=4" =~ /2+2/;    # doesn't match, + is a metacharacter
    "2+2=4" =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    "The interval is [0,1)." =~ /[0,1)./     # is a syntax error!
    "The interval is [0,1)." =~ /\[0,1\)\./  # matches
    "#!/usr/bin/perl" =~ /#!\/usr\/bin\/perl/;  # matches

=end original

    "2+2=4" =~ /2+2/;    # マッチしない。+ はメタ文字
    "2+2=4" =~ /2\+2/;   # マッチする。\+ 普通の + のように扱われる
    "The interval is [0,1)." =~ /[0,1)./     # これはシンタックスエラー!
    "The interval is [0,1)." =~ /\[0,1\)\./  # マッチする
    "#!/usr/bin/perl" =~ /#!\/usr\/bin\/perl/;  # マッチする

=begin original

In the last regexp, the forward slash C<'/'> is also backslashed,
because it is used to delimit the regexp.  This can lead to LTS
(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.

=end original

最後の正規表現では、スラッシュ C<'/'>もまたバックスラッシュが
つけられています。
なぜなら、それが正規表現のデリミタとして使われているからです。
これは LTS(leaning toothpick syndrome つまようじ大好き症候群?)を
招きがちですが、読みやすくするためにデリミタを変更することが
しばしばあります。

=begin original

    "#!/usr/bin/perl" =~ m!#\!/usr/bin/perl!;  # easier to read

=end original

    "#!/usr/bin/perl" =~ m!#\!/usr/bin/perl!;  # より読みやすい

=begin original

The backslash character C<'\'> is a metacharacter itself and needs to
be backslashed:

=end original

バックスラッシュ文字 C<'\'> はそれ自身がメタ文字であり、
バックスラッシュをつける必要があります:

=begin original

    'C:\WIN32' =~ /C:\\WIN/;   # matches

=end original

    'C:\WIN32' =~ /C:\\WIN/;   # マッチする

=begin original

In addition to the metacharacters, there are some ASCII characters
which don't have printable character equivalents and are instead
represented by I<escape sequences>.  Common examples are C<\t> for a
tab, C<\n> for a newline, C<\r> for a carriage return and C<\a> for a
bell.  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., C<\033>, or hexadecimal escape
sequence, e.g., C<\x1B> may be a more natural representation for your
bytes.  Here are some examples of escapes:

=end original

メタ文字に加え、印字することのできない文字であって
I<エスケープシーケンス> によって表現されるいくつかの ASCII 文字があります。
一般的な例では、タブを表す C<\t>、改行を表す C<\n>、復帰を表す C<\r>、
ベルを表す C<\a> があります。
文字列を任意のバイト列としてみなすのなら、C<\033>のような
8 進エスケープシーケンスや C<\x1B> のような 16 進エスケープシーケンスは
バイト列のより自然な表現となります。
以下にあげるのはエスケープの例です:

=begin original

    "1000\t2000" =~ m(0\t2)   # matches
    "1000\n2000" =~ /0\n20/   # matches
    "1000\t2000" =~ /\000\t2/ # doesn't match, "0" ne "\000"
    "cat"        =~ /\143\x61\x74/ # matches, but a weird way to spell cat

=end original

    "1000\t2000" =~ m(0\t2)   # マッチする
    "1000\n2000" =~ /0\n20/   # マッチする
    "1000\t2000" =~ /\000\t2/ # マッチしない。
"0" は "\000" ではない
    "cat"        =~ /\143\x61\x74/ # matches, but a weird way to spell cat

=begin original

If you've been around Perl a while, all this talk of escape sequences
may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:

=end original

あなたがすでにPerlを少なからず知っているのなら、エスケープシーケンスに付いて述べた以上のことはすでになじみ深いものかもしれません。
同じようなエスケープシーケンスはダブルクォートで囲まれた文字列で使われていて、事実Perlにおける正規表現はほとんどの場合においてダブルクォートで囲まれた文字列のように扱われます。
このことは正規表現の中で変数を使うことができるということを意味します。
ダブルクォートで囲まれた文字列のように、正規表現中の変数の値はマッチのために正規表現が評価されるより前に置き換えが行われます。
ですから:

    $foo = 'house';
    'housecat' =~ /$foo/;      # matches
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches

=begin original

So far, so good.  With the knowledge above you can already perform
searches with just about any literal string regexp you can dream up.
Here is a I<very simple> emulation of the Unix grep program:

=end original

これまでの知識をもとに任意のリテラル文字列正規表現に関して
検索を行うことができます。
次の例は Unix の grep プログラムの I<非常に単純な> 模倣です。

    % cat > simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (<>) {
        print if /$regexp/;
    }
    ^D

    % chmod +x simple_grep

    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards

=begin original

This program is easy to understand.  C<#!/usr/bin/perl> is the standard
way to invoke a perl program from the shell.
S<C<$regexp = shift;>> saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  S<C<< while (<>) >>> loops over all the lines in
all the files.  For each line, S<C<print if /$regexp/;>> prints the
line if the regexp matches the line.  In this line, both C<print> and
C</$regexp/> use the default variable C<$_> implicitly.

=end original

このプログラムを理解するのは簡単です。
C<#!/usr/bin/perl> はシェルから perl プログラムを起動する標準的な方法です。
S<C<$regexp = shift;>> は最初のコマンドライン引数を正規表現として
使うために保存します。
そして残りのコマンドライン引数はファイルとして扱うために
そのままにしておきます。
S<C< while (<>) >> ループはすべてのファイルのすべての行に対して
実行されます。
各行において、S<C<print if /$regexp/;>> はその行が正規表現に
マッチしていれば行の内容を出力します。
この行で、C<print> と C</$regexp/> は暗黙にデフォルト変数 C<$_> を使用します。

=begin original

With all of the regexps above, if the regexp matched anywhere in the
string, it was considered a match.  Sometimes, however, we'd like to
specify I<where> in the string the regexp should try to match.  To do
this, we would use the I<anchor> metacharacters C<^> and C<$>.  The
anchor C<^> means match at the beginning of the string and the anchor
C<$> means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:

=end original

これまでの正規表現では、文字列のどこかでマッチすればマッチしたとみなしてきました。
しかし、ときには文字列の I<どこで> 正規表現がマッチするのかを指定したいときがあります。
これを行うためには、I<アンカー> メタ文字である C<^> と C<$> を使います。
アンカー C<^> は文字列の先頭でマッチすることを意味し、アンカー C<$> は
文字列の末尾(あるいは文字列の末尾にある改行の前) でマッチすることを意味します。
以下に例を挙げます:

    "housekeeper" =~ /keeper/;    # matches
    "housekeeper" =~ /^keeper/;   # doesn't match
    "housekeeper" =~ /keeper$/;   # matches
    "housekeeper\n" =~ /keeper$/; # matches

=begin original

The second regexp doesn't match because C<^> constrains C<keeper> to
match only at the beginning of the string, but C<"housekeeper"> has
keeper starting in the middle.  The third regexp does match, since the
C<$> constrains C<keeper> to match only at the end of the string.

=end original

二番目の正規表現はマッチしません。
なぜなら、C<^> は C<keeper> が文字列の先頭にあるときにのみマッチすることを
強制しますが、C<"housekeeper"> はその先頭以外にkeeperを含んでいます。
三番目の正規表現は、 C<$> が C<keeper> が文字列の末尾にあるときにのみ
マッチすることを強制しているのでマッチします。

=begin original

When both C<^> and C<$> are used at the same time, the regexp has to
match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider

=end original

C<^> とC<$> の両方が同時に使われた場合、その正規表現は文字列の先頭と
末尾両方にマッチする必要があります。
つまり、その正規表現は文字列全体にマッチするのです。
以下の例で考えてみましょう

    "keeper" =~ /^keep$/;      # doesn't match
    "keeper" =~ /^keeper$/;    # matches
    ""       =~ /^$/;          # ^$ matches an empty string

=begin original

The first regexp doesn't match because the string has more to it than
C<keep>.  Since the second regexp is exactly the string, it
matches.  Using both C<^> and C<$> in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:

=end original

最初の正規表現はマッチしません。
なぜなら、文字列は C<keep> 以外のものを持っているからです。
二番目の正規表現は正確に同じ文字列なのでマッチします。
C<^> と C<$> を正規表現の中で使うことによって、文字列全体にマッチすることを
強制します。
このため、どの文字列がマッチしどの文字列がマッチしないかを完全に
制御することができます。
bertという名前の仲間を探しているとしましょう:

=begin original

    "dogbert" =~ /bert/;   # matches, but not what you want

=end original

    "dogbert" =~ /bert/;   # マッチする。しかし望んだものではない

=begin original

    "dilbert" =~ /^bert/;  # doesn't match, but ..
    "bertram" =~ /^bert/;  # matches, so still not good enough

=end original

    "dilbert" =~ /^bert/;  # マッチしない。しかし…
    "bertram" =~ /^bert/;  # マッチする。ということはまだ十分ではない

=begin original

    "bertram" =~ /^bert$/; # doesn't match, good
    "dilbert" =~ /^bert$/; # doesn't match, good
    "bert"    =~ /^bert$/; # matches, perfect

=end original

    "bertram" =~ /^bert$/; # マッチしない。よし
    "dilbert" =~ /^bert$/; # マッチしない。よし
    "bert"    =~ /^bert$/; # マッチする。完璧

=begin original

Of course, in the case of a literal string, one could just as easily
use the string comparison S<C<$string eq 'bert'>> and it would be
more efficient.   The  C<^...$> regexp really becomes useful when we
add in the more powerful regexp tools below.

=end original

もちろん、リテラル文字列の場合においては、文字列の比較を
S<C<$string eq 'bert'>> を使って簡単に行うことができ、こちらのほうが
より効率がよいです。
C<^...$> 正規表現は以下に述べるより強力な正規表現ツールにおいて
便利になります。

=head2 Using character classes

(文字クラスを使う)

=begin original

Although one can already do quite a lot with the literal string
regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to not just represent a single character sequence, but a I<whole
class> of them.

=end original

先に述べたリテラル文字列の正規表現を使ってさえ多くのことができますが、
それは正規表現テクノロジーの表面をひっかいた程度に過ぎません。
このセクションと続くセクションでは、ただ一文字の文字を表すのではなく
I<文字のクラス全体> を表す正規表現のコンセプト (とそれに結び付けられた
メタ文字表記)を紹介します。

=begin original

One such concept is that of a I<character class>.  A character class
allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  Character
classes are denoted by brackets C<[...]>, with the set of characters
to be possibly matched inside.  Here are some examples:

=end original

そのようなコンセプトは I<文字クラス> です。
文字クラスは正規表現の特定の場所においてマッチする可能性のある文字の
集合です(単一の文字ではありません)。
文字クラスはブラケット C<[...]> で表現され、マッチする可能性のある文字の
集合はその内側に置かれます。
以下はその例です:

    /cat/;       # matches 'cat'
    /[bcr]at/;   # matches 'bat, 'cat', or 'rat'
    /item[0123456789]/;  # matches 'item0' or ... or 'item9'
    "abc" =~ /[cab]/;    # matches 'a'

=begin original

In the last statement, even though C<'c'> is the first character in
the class, C<'a'> matches because the first character position in the
string is the earliest point at which the regexp can match.

=end original

最後の文において、C<'c'> がクラスの最初の文字であるにもかかわらず
C<'a'> がマッチします。
なぜなら、文字列の最初の文字位置が正規表現がマッチすることのできる
最初の位置にある文字だからです。

    /[yY][eE][sS]/;      # match 'yes' in a case-insensitive way
                         # 'yes', 'Yes', 'YES', etc.

=begin original

This regexp displays a common task: perform a case-insensitive
match.  Perl provides a way of avoiding all those brackets by simply
appending an C<'i'> to the end of the match.  Then C</[yY][eE][sS]/;>
can be rewritten as C</yes/i;>.  The C<'i'> stands for
case-insensitive and is an example of a I<modifier> of the matching
operation.  We will meet other modifiers later in the tutorial.

=end original

この正規表現は一般的な仕事を表しています: 大小文字の違いを無視しての
マッチを行います。
Perl はこのようなブラケットを取り除くやり方を提供しています。
それはマッチの終端に C<'i'> をつけることです。
したがって、C</[yY][eE][sS]/;> は C</yes/i;> と書き換えることができます。
この C<'i'> は大小文字の違いを無視することを意味していて、マッチング操作の
I<修飾子> (modifier)の実例です。
本チュートリアルの先のほうで他の修飾子がでてくることでしょう。

=begin original

We saw in the section above that there were ordinary characters, which
represented themselves, and special characters, which needed a
backslash C<\> to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are C<-]\^$> (and
the pattern delimiter, whatever it is).
C<]> is special because it denotes the end of a character class.  C<$> is
special because it denotes a scalar variable.  C<\> is special because
it is used in escape sequences, just like above.  Here is how the
special characters C<]$\> are handled:

=end original

このセクションの前のほうで、自分自身を表す通常の文字とそれ自身を表すためには
バックスラッシュ C<\> が必要な特殊文字があることを見てきました。
同じことが文字クラスの中でも言えます。
しかし、文字クラスの内側にある通常の文字の集合と特殊文字は、文字クラスの
外側にあるものと異なります。
文字クラスのために特殊な文字は C<-]\^$> です
(and
the pattern delimiter, whatever it is)。
C<]> は文字クラスの終端を表すので特殊です。
C<$> はスカラ変数を表すので特殊です。
C<\> はエスケープシーケンスで使われるので特殊です。
以下は特殊文字 C<]$\> を扱うやり方です:
(TBT)

   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat', 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'

=begin original

The last two are a little tricky.  In C<[\$x]>, the backslash protects
the dollar sign, so the character class has two members C<$> and C<x>.
In C<[\\$x]>, the backslash is protected, so C<$x> is treated as a
variable and substituted in double quote fashion.

=end original

最後の二つはちょっとトリッキーです。
C<[\$x]> の中ではバックスラッシュはドル記号をプロテクトしているので、
文字クラスは C<$> とC<x> という二つのメンバーを持ちます。
C<[\\$x]> ではバックラッシュがプロテクトされているので、C<$x> は変数として
扱われ、ダブルクォート規則にのっとり置換が行われます。

=begin original

The special character C<'-'> acts as a range operator within character
classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy C<[0123456789]> and C<[abc...xyz]>
become the svelte C<[0-9]> and C<[a-z]>.  Some examples are

=end original

特殊文字 C<'-'> は文字クラスの中で範囲演算子として振舞います。
このため、連続した範囲の文字を一つの範囲として記述することができます。
範囲を使うことによって、C<[0123456789]> や C<[abc...xyz]> のような
見づらいものはすっきりとした C<[0-9]> であるとか C<[a-z]> のように
書き換えられます。
幾つか例を挙げましょう

    /item[0-9]/;  # matches 'item0' or ... or 'item9'
    /[0-9bx-z]aa/;  # matches '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0-9a-fA-F]/;  # matches a hexadecimal digit
    /[0-9a-zA-Z_]/; # matches a "word" character,
                    # like those in a Perl variable name

=begin original

If C<'-'> is the first or last character in a character class, it is
treated as an ordinary character; C<[-ab]>, C<[ab-]> and C<[a\-b]> are
all equivalent.

=end original

C<'-'> が文字クラスの中の最初か最後の文字であった場合、通常の文字として
扱われます。
C<[-ab]>, C<[ab-]>, C<[a\-b]> はすべて等価です。

=begin original

The special character C<^> in the first position of a character class
denotes a I<negated character class>, which matches any character but
those in the brackets.  Both C<[...]> and C<[^...]> must match a
character, or the match fails.  Then

=end original

文字クラスの先頭の位置にある特殊文字 C<^> は 文字クラスの反転を表し、
ブラケットの中にない文字にマッチします。
C<[...]> と C<[^...]> の両方とも、一つの文字にマッチせねばならず、
そうでないばあいにはマッチは失敗します。
ですから

    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary

=begin original

Now, even C<[0-9]> can be a bother to write multiple times, so in the
interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, these character classes match more
than just a few characters in the ISO 8859-1 range.

=end original

ここで、C<[0-9]> でさえ何回も書くには面倒です。
ですから、キーストロークの数を抑えて、かつ正規表現をより読みやすくするために
Perl は一般的な文字クラスの略記法を持っています, as shown below.
Since the introduction of Unicode, these character classes match more
than just a few characters in the ISO 8859-1 range.
(TBT)

=over 4

=item *

=begin original

\d matches a digit, not just [0-9] but also digits from non-roman scripts

=end original

\d matches a digit, not just [0-9] but also digits from non-roman scripts
(TBT)

=item *

=begin original

\s matches a whitespace character, the set [\ \t\r\n\f] and others

=end original

\s は空白文字にマッチングして、[\ \t\r\n\f]やその他
(TBT)

=item *

=begin original

\w matches a word character (alphanumeric or _), not just [0-9a-zA-Z_]
but also digits and characters from non-roman scripts

=end original

\w は単語を構成する文字(alphanumeric と _)で [0-9a-zA-Z_] を表します 
but also digits and characters from non-roman scripts
(TBT)

=item *

=begin original

\D is a negated \d; it represents any other character than a digit, or [^\d]

=end original


\D は \d の否定形です。
数字or [^\d] 以外の文字を表します

=item *

=begin original

\S is a negated \s; it represents any non-whitespace character [^\s]

=end original


\S は \s の否定形です。
非空白文字[^\s]を表します

=item *

=begin original

\W is a negated \w; it represents any non-word character [^\w]

=end original


\Wは\wの否定形です。
単語を構成しない文字[^\w]を表します

=item *

=begin original

The period '.' matches any character but "\n" (unless the modifier C<//s> is
in effect, as explained below).

=end original


ピリオド '.' は``\n''以外の任意の文字にマッチします
(unless the modifier C<//s> is
in effect, as explained below).
(TBT)

=back

=begin original

The C<\d\s\w\D\S\W> abbreviations can be used both inside and outside
of character classes.  Here are some in use:

=end original

C<\d\s\w\D\S\W> の省略記法は文字クラスの内側でも外側でも使うことができます。
以下はその例です:

    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'

=begin original

Because a period is a metacharacter, it needs to be escaped to match
as an ordinary period. Because, for example, C<\d> and C<\w> are sets
of characters, it is incorrect to think of C<[^\d\w]> as C<[\D\W]>; in
fact C<[^\d\w]> is the same as C<[^\w]>, which is the same as
C<[\W]>. Think DeMorgan's laws.

=end original

ピリオドはメタ文字なので、ピリオドそのものにマッチさせるにはエスケープする
必要があります。
C<\d> や C<\w> は文字の集合なので C<[^\d\w]> を C<[\D\W]> とみなすのは
間違いです。
事実、C<[^\d\w]> は C<[^\w]> と同じであり、これは C<[\W]> と等価です。
ド・モルガンの法則を考えてみてください。

=begin original

An anchor useful in basic regexps is the I<word anchor>
C<\b>.  This matches a boundary between a word character and a non-word
character C<\w\W> or C<\W\w>:

=end original

基本的な正規表現で便利なアンカーに I<語アンカー> (word anchor)の
C<\b> があります。
これは単語を構成する文字と単語を構成しない文字の間 C<\w\W> や C<\W\w> の
境界にマッチします:

    $x = "Housecat catenates house and cat";
    $x =~ /cat/;    # matches cat in 'housecat'
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string

=begin original

Note in the last example, the end of the string is considered a word
boundary.

=end original

最後の例に注意してください。
文字列の終端は単語境界として認識されています。

=begin original

You might wonder why C<'.'> matches everything but C<"\n"> - why not
every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string C<"\n"> represents one line, we would like to think
of it as empty.  Then

=end original

C<'.'> がC<"\n"> 以外の任意の文字にマッチすることに疑問を感じるかも
しれません - なぜすべての文字ではないのでしょうか?
その答えはマッチングがしばしば行に対して行われ、改行文字を
無視したいからです。
たとえば、文字列 C<"\n"> が一行を表していたとして、それを空の行として
みなしたいでしょう。
ですから

    ""   =~ /^$/;    # matches
    "\n" =~ /^$/;    # matches, $ anchors before "\n"

    ""   =~ /./;      # doesn't match; it needs a char
    ""   =~ /^.$/;    # doesn't match; it needs a char
    "\n" =~ /^.$/;    # doesn't match; it needs a char other than "\n"
    "a"  =~ /^.$/;    # matches
    "a\n"  =~ /^.$/;  # matches, $ anchors before "\n"

=begin original

This behavior is convenient, because we usually want to ignore
newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want C<^>
and C<$> to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the C<//s> and C<//m> modifiers.  C<//s> and C<//m> stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the C<'.'> character class is defined, and 2) where the anchors C<^>
and C<$> are able to match.  Here are the four possible combinations:

=end original

通常はある行において文字を数えたりマッチングしたりするときには改行を
無視したいので、この動作は便利です。
しかし、ときとして改行を保存したいときがあります。
C<^> や C<$> を文字列の先頭や末尾ではなく行の先頭や末尾に対するアンカーと
したいときがあるでしょう。
Perl は C<//s> 修飾子や C<//m> 修飾子を使うことによって改行を無視したり
考慮したりすることを選択することを許しています。
C<//s> と C<//m> はそれぞれ単一行(single line)と複数行(multi-line)を意味し、
文字列を連続した文字としてみなすか行の集合としてみなすかを決定します。
これら二つの修飾子は正規表現がどのように解釈されるかに関して二つの影響を
及ぼします: 1) C<'.'> 文字クラスがどのように定義されるか
2) アンカー C<^> と C<$> がどこにマッチできるかです。
四つの可能な組み合わせがあります:

=over 4

=item *

=begin original

no modifiers (//): Default behavior.  C<'.'> matches any character
except C<"\n">.  C<^> matches only at the beginning of the string and
C<$> matches only at the end or before a newline at the end.

=end original

修飾子なし (//): デフォルトの動作です。
C<'.'> は C<"\n"> 以外の任意の文字にマッチします。
C<^> は文字列の先頭にのみマッチし、C<$> は文字列の末尾もしくは終端にある
改行の直前にのみマッチします。

=item *

=begin original

s modifier (//s): Treat string as a single long line.  C<'.'> matches
any character, even C<"\n">.  C<^> matches only at the beginning of
the string and C<$> matches only at the end or before a newline at the
end.

=end original

s 修飾子 (//s): 文字列を一つの長い行としてみなします。
C<'.'> は C<"\n"> も含めた任意の文字にマッチします。
C<^> は文字列の先頭にのみマッチし、C<$> は文字列の末尾もしくは終端にある改行の
直前にのみマッチします。

=item *

=begin original

m modifier (//m): Treat string as a set of multiple lines.  C<'.'>
matches any character except C<"\n">.  C<^> and C<$> are able to match
at the start or end of I<any> line within the string.

=end original

m 修飾子 (//m): 文字列を複数行の集合としてみなします。
C<'.'> は C<"\n"> を除く任意の文字にマッチします。
C<^> と C<$> はそれぞれ文字列中の任意の行の先頭と末尾にマッチします。

=item *

=begin original

both s and m modifiers (//sm): Treat string as a single long line, but
detect multiple lines.  C<'.'> matches any character, even
C<"\n">.  C<^> and C<$>, however, are able to match at the start or end
of I<any> line within the string.

=end original

s 修飾子と m 修飾子の両方 (//sm): 文字列を単一の長い行としてみなしますが、
複数行を検出します。
C<'.'> は C<"\n"> を含めた任意の文字にマッチします。
しかし、C<^> と C<$> はそれぞれ文字列中の任意の行の先頭と末尾にマッチすることが
可能です。

=back

=begin original

Here are examples of C<//s> and C<//m> in action:

=end original

以下はアクション中の C<//s> と C<//m> の例です:

    $x = "There once was a girl\nWho programmed in Perl\n";

    $x =~ /^Who/;   # doesn't match, "Who" not at start of string
    $x =~ /^Who/s;  # doesn't match, "Who" not at start of string
    $x =~ /^Who/m;  # matches, "Who" at start of second line
    $x =~ /^Who/sm; # matches, "Who" at start of second line

    $x =~ /girl.Who/;   # doesn't match, "." doesn't match "\n"
    $x =~ /girl.Who/s;  # matches, "." matches "\n"
    $x =~ /girl.Who/m;  # doesn't match, "." doesn't match "\n"
    $x =~ /girl.Who/sm; # matches, "." matches "\n"

=begin original

Most of the time, the default behavior is what is wanted, but C<//s> and
C<//m> are occasionally very useful.  If C<//m> is being used, the start
of the string can still be matched with C<\A> and the end of the string
can still be matched with the anchors C<\Z> (matches both the end and
the newline before, like C<$>), and C<\z> (matches only the end):

=end original

ほとんどの場合、デフォルトの動作が望んでいるものですが、C<//s> や C<//m> は
とても便利なものです。
もし C<//m> を使っているのなら、文字列の先頭は C<\A> で
マッチさせることができ、文字列の末尾はアンカー C<\Z> (C<$> と同じように、
末尾と末尾にある改行の直前にマッチします) や C<\z> (末尾にのみマッチ)で
マッチさせることができます:

    $x =~ /^Who/m;   # matches, "Who" at start of second line
    $x =~ /\AWho/m;  # doesn't match, "Who" is not at start of string

    $x =~ /girl$/m;  # matches, "girl" at end of first line
    $x =~ /girl\Z/m; # doesn't match, "girl" is not at end of string

    $x =~ /Perl\Z/m; # matches, "Perl" is at newline before end
    $x =~ /Perl\z/m; # doesn't match, "Perl" is not at end of string

=begin original

We now know how to create choices among classes of characters in a
regexp.  What about choices among words or character strings? Such
choices are described in the next section.

=end original

正規表現中で文字クラスをどのように選択するかを学びました。
単語や文字並びに関する選択は? その選択は次のセクションで述べます。

=head2 Matching this or that

=begin original

Sometimes we would like our regexp to be able to match different
possible words or character strings.  This is accomplished by using
the I<alternation> metacharacter C<|>.  To match C<dog> or C<cat>, we
form the regexp C<dog|cat>.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, C<dog>.  If C<dog> doesn't match, Perl will then try the
next alternative, C<cat>.  If C<cat> doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:

=end original

正規表現を異なる単語や文字並びにマッチさせたいと考えることがあるでしょう。
これは I<選択> メタ文字 C<|> によって行うことができます。
C<dog> または C<cat> にマッチさせるには、正規表現を C<dog|cat> のようにします。
以前述べた通り、Perlは文字列の可能な限り最も早い位置でマッチを行おうとします。
それぞれの文字位置で、Perlはまずはじめに最初の選択である C<dog> に
マッチさせることを試みます。
もし C<dog> がマッチしなければ、Perl は次の選択肢である C<cat> を試します。
C<cat> もまたマッチしなければ、マッチは失敗してPerlは文字列の次の位置に
移動します。
幾つか例を挙げましょう:

    "cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
    "cats and dogs" =~ /dog|cat|bird/;  # matches "cat"

=begin original

Even though C<dog> is the first alternative in the second regexp,
C<cat> is able to match earlier in the string.

=end original

二番目の正規表現において最初の選択肢が C<dog> であるにもかかわらず、
C<cat> が文字列で最初に現れるマッチ対象です。

    "cats"          =~ /c|ca|cat|cats/; # matches "c"
    "cats"          =~ /cats|cat|ca|c/; # matches "cats"

=begin original

Here, all the alternatives match at the first string position, so the
first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.

=end original

ここではすべての選択肢が最初の位置でマッチするので、最初の選択肢がマッチ対象となります。
もし一部の選択肢が他の選択肢を縮めたものであるならば、マッチのチャンスを与えるために最も長いものを最初に置きます。

    "cab" =~ /a|b|c/ # matches "c"
                     # /a|b|c/ == /[abc]/

=begin original

The last example points out that character classes are like
alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.

=end original

この最後の例は文字クラスが文字の選択に似ていることを表しています。
与えられた文字位置で、正規表現のマッチングを成功させるための最初の選択肢はマッチする一つとなります。

=head2 Grouping things and hierarchical matching

=begin original

Alternation allows a regexp to choose among alternatives, but by
itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp C<housecat|housekeeper> fits the bill, but is
inefficient because we had to type C<house> twice.  It would be nice to
have parts of the regexp be constant, like C<house>, and some
parts have alternatives, like C<cat|keeper>.

=end original

選択は正規表現が選択肢の中から選び出すことを許しますが、それ自身は
満足できるものではありません。
その理由は、各選択肢は正規表現全体でなければならないのに、正規表現の
一部だけを選択したいときがあるからです。
たとえば、housecats か housekeepers を検索したいとしましょう。
C<housecat|housekeeper> という正規表現はそれができます。
しかし、C<house> を二回タイプしなければならないので効率がよくありません。
正規表現の一部分を C<house> のように定数にできて、そして一部が
C<cat|keeper> のように選択肢を持つようにできればよいのです。

=begin original

The I<grouping> metacharacters C<()> solve this problem.  Grouping
allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the C<housecat|housekeeper> by forming the regexp as
C<house(cat|keeper)>.  The regexp C<house(cat|keeper)> means match
C<house> followed by either C<cat> or C<keeper>.  Some more examples
are

=end original

I<グループ化> メタ文字 C<()> はこの問題を解決します。
グループ化は正規表現の一部分を一つのユニットとして扱うことを許します。
ある正規表現の一部はカッコによって囲まれることでグループ化されます。
したがって、C<housecat|housekeeper> は正規表現を C<house(cat|keeper)> と
することによって解決することができます。
正規表現 C<house(cat|keeper)> は、C<cat> か C<keeper> が後続する
C<house> にマッチすることを意味します。
幾つか例を挙げましょう

    /(a|b)b/;    # matches 'ab' or 'bb'
    /(ac|b)b/;   # matches 'acb' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere
    /(a|[bc])d/; # matches 'ad', 'bd', or 'cd'

    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.

    /(19|20|)\d\d/;  # match years 19xx, 20xx, or the Y2K problem, xx
    "20" =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match

=begin original

Alternations behave the same way in groups as out of them: at a given
string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
C<"20"> matches the second alternative, but there is nothing left over
to match the next two digits C<\d\d>.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
C<"20"> is two digits.

=end original

選択はグループの中でもその外側と同じように振舞います: 文字列の与えられた
場所で、正規表現がマッチする最も左にある選択肢が選ばれます。
ですから、最後の例では最初の文字列位置で二番目の選択肢 C<"20"> に
マッチしますが、残りの二つの数字 C<\d\d> にマッチするものが残っていません。
このため、Perlは次の選択肢へと移り、C<"20"> が二つの数字なので空の選択肢で
うまくいきます。

=begin original

The process of trying one alternative, seeing if it matches, and
moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
I<backtracking>.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp

=end original

ある選択肢を試しマッチすればそれを選び、失敗した場合には次の選択肢へ移る
while going back in the string
from where the previous alternative was tried,
という手順は I<バックトラッキング> (backtracking)と呼ばれます。
 'バックトラッキング'という単語は正規表現のマッチングが森の中の散歩に
似ていることからきています。
正規表現のマッチングが成功することは目的地にたどり着くことです。
多くのtrailheadsがあり、文字列の各位置のひとつで左から右へと順序だてて
一つ一つ試します。
それぞれのtrailheadsからは多くの通り道があり、どれかはあなたが目指す場所で
ほかのどれかは行き止まりになっています。
歩いていて行き止まりにあたったら、あなたはもときた道を後戻り(backtrack)して
別の道を試してみなければなりません。
目的地に着いたなら、即座に止まって他の未知は忘れてしまいます。
あなたは粘り強いので、すべてのtrailheadsからすべての通り道を試してそれでも
目的地に着かなければ、失敗を宣言します。
具体的に、Perlが正規表現のマッチを試しているときに行っていることをステップを
追って説明しましょう
(TBT)

"abcde" =~ /(abd|abc)(df|d|de)/;

=over 4

=item 0

=begin original

Start with the first letter in the string 'a'.

=end original


文字列の最初の文字'a'から始めます。

=item 1

=begin original

Try the first alternative in the first group 'abd'.

=end original


最初のグループの中の最初の選択肢'abd'を試します。

=item 2

=begin original

Match 'a' followed by 'b'. So far so good.

=end original

'a' とそれに続く 'b' にマッチします。
よさそうです。

=item 3

=begin original

'd' in the regexp doesn't match 'c' in the string - a dead
end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.

=end original

正規表現中の 'd' は文字列中の 'c' にマッチしません - 行き止まりです。
このため、二文字後戻りして最初のグループの二番目の選択肢である
'abc' を取り出します。

=item 4

=begin original

Match 'a' followed by 'b' followed by 'c'.  We are on a roll
and have satisfied the first group. Set $1 to 'abc'.

=end original

'a'、'b'、'c'と続けてマッチします。
ここで最初のグループが満足されました。
$1 に 'abc' をセットします。

=item 5

=begin original

Move on to the second group and pick the first alternative
'df'.

=end original

二番目のグループへ移動して、最初の選択肢である 'df' を取り出します。

=item 6

=begin original

Match the 'd'.

=end original

'd' にマッチします。

=item 7

=begin original

'f' in the regexp doesn't match 'e' in the string, so a dead
end.  Backtrack one character and pick the second alternative in the
second group 'd'.

=end original

正規表現中の 'f' は文字列中の 'e' にマッチしません。
行き止まりです。
一文字後戻りして二番目のグループの二番目の選択肢'd'を取り出します。

=item 8

=begin original

'd' matches. The second grouping is satisfied, so set $2 to
'd'.

=end original


      'd'にマッチします。
二番目のグループは満足されたので、$2 に 'd' をセットします。

=item 9

=begin original

We are at the end of the regexp, so we are done! We have
matched 'abcd' out of the string "abcde".

=end original

正規表現の終端に達しました。
これで終わりです!
文字列 "abcde" に対して 'abcd' がマッチしました。

=back

=begin original

There are a couple of things to note about this analysis.  First, the
third alternative in the second group 'de' also allows a match, but we
stopped before we got to it - at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare S<C<$string =~ /(abd|abc)(df|d|de)/;>> to be false.

=end original

この調査に関して注意すべき点が二、三あります。
第一に、二番目のグループの三番目の選択肢'de'もまたマッチしますが、
そこに行く前に停止しました。
与えられた文字の位置で、最も左のものが優先されるからです。
第二に、文字列の最初の文字が 'a' であったのでマッチすることができました。
もし最初の位置でマッチに成功しなければ、Perl は二番目にある文字'b'へと
移動して同じことを繰り返します。
すべての可能な文字位置で、すべての可能な道筋が尽きたときにのみ Perl は
マッチをあきらめ、
S<C<$string =~ /(abd|abc)(df|d|de)/;>> が失敗したと宣言します。

=begin original

Even with all this work, regexp matching happens remarkably fast.  To
speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.

=end original

これだけのことを行ってさえ、正規表現のマッチは目立って速いものです。
検索速度を向上させるために、Perl は正規表現をコンパクトでしばしば
プロセッサのキャッシュに納まるようなオペコードの並びへと変換します。
そのコードが実行されたとき、これらのオペコードはフルスロットルで
走ることができて非常にすばやく検索します。

=head2 Extracting matches

(マッチしたものを取り出す)

=begin original

The grouping metacharacters C<()> also serve another completely
different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables C<$1>, C<$2>, etc.  They can be
used just as ordinary variables:

=end original

グループ化メタ文字 C<()> はまた、まったく異なる別の機能を有しています:
マッチした文字列の一部分を展開することができるのです・これは一般的に、
マッチしたものを見つけ出したり、テキスト処理のために非常に
便利なものです。
それぞれのグループ化に対して、マッチした部分が特殊変数 C<$1>, C<$2> などに
格納されます。
これらの変数は通常の変数と同じように使うことができます:

    # extract hours, minutes, seconds
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # match hh:mm:ss format
	$hours = $1;
	$minutes = $2;
	$seconds = $3;
    }

=begin original

Now, we know that in scalar context,
S<C<$time =~ /(\d\d):(\d\d):(\d\d)/>> returns a true or false
value.  In list context, however, it returns the list of matched values
C<($1,$2,$3)>.  So we could write the code more compactly as

=end original

この例ではスカラコンテキストなので、
S<C<$time =~ /(\d\d):(\d\d):(\d\d)/>> は真か偽の値を返します。
リストコンテキストでは、マッチした値のリスト C<($1,$2,$3)> を返します。
ですから、コードをよりコンパクトに

    # extract hours, minutes, seconds
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);

=begin original

If the groupings in a regexp are nested, C<$1> gets the group with the
leftmost opening parenthesis, C<$2> the next opening parenthesis,
etc.  Here is a regexp with nested groups:

=end original

正規表現中のグループ化がネストしていた場合、C<$1> は最も左にある
開きかっこによってグループ化されているものを取り、C<$2> は
次の開きかっこによるものを取り・・・となっていきます。
これがネストしたグループをもつ正規表現です:

    /(ab(cd|ef)((gi)|j))/;
     1  2      34

=begin original

If this regexp matches, C<$1> contains a string starting with
C<'ab'>, C<$2> is either set to C<'cd'> or C<'ef'>, C<$3> equals either
C<'gi'> or C<'j'>, and C<$4> is either set to C<'gi'>, just like C<$3>,
or it remains undefined.

=end original

If this regexp matches, C<$1> contains a string starting with
C<'ab'>, C<$2> is either set to C<'cd'> or C<'ef'>, C<$3> equals either
C<'gi'> or C<'j'>, and C<$4> is either set to C<'gi'>, just like C<$3>,
or it remains undefined.
(TBT)

=begin original

For convenience, Perl sets C<$+> to the string held by the highest numbered
C<$1>, C<$2>,... that got assigned (and, somewhat related, C<$^N> to the
value of the C<$1>, C<$2>,... most-recently assigned; i.e. the C<$1>,
C<$2>,... associated with the rightmost closing parenthesis used in the
match).

=end original

便利のため、Perl は C<$+> に C<$1>, C<$2> などの代入された番号付け変数の
最も数値の大きなものをセットします(そして、C<$^N> には最も最近代入された
C<$1>, C<$2> などの値がセットされます。
つまり、マッチにおいて使われた閉じカッコの中で最も右にあるものに
結び付けられたものです)。


=head2 Backreferences

=begin original

Closely associated with the matching variables C<$1>, C<$2>, ... are
the I<backreferences> C<\1>, C<\2>,...  Backreferences are simply
matching variables that can be used I<inside> a regexp.  This is a
really nice feature -- what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3-letter doubles with a space in between:

=end original

マッチング変数 C<$1>, C<$2> …に密接に結び付けられたものは 後方参照(backreferences) C<\1>, C<\2> …です。
後方参照は正規表現の I<内側> で使うことのできるマッチング変数です。
これは実に良い機能です - 正規表現の中で後でマッチするものがそれ以前に
マッチしていたものに依存させることができます。
'the the'のように繰り返しされた単語をテキストの中から探したいとしましょう。
以下の正規表現はスペースで分けられた三文字の重複単語を見つけ出します:

    /\b(\w\w\w)\s\1\b/;

=begin original

The grouping assigns a value to \1, so that the same 3 letter sequence
is used for both parts.

=end original

グループ化は値を \1 にセットするので、同じ三文字の並びが両方のパーツで
使われます。

=begin original

A similar task is to find words consisting of two identical parts:

=end original

A similar task is to find words consisting of two identical parts:
(TBT)

    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa

=begin original

The regexp has a single grouping which considers 4-letter
combinations, then 3-letter combinations, etc., and uses C<\1> to look for
a repeat.  Although C<$1> and C<\1> represent the same thing, care should be
taken to use matched variables C<$1>, C<$2>,... only I<outside> a regexp
and backreferences C<\1>, C<\2>,... only I<inside> a regexp; not doing
so may lead to surprising and unsatisfactory results.

=end original

この正規表現は四文字の組み合わせ、三文字の組み合わせなどを扱うただ一つの
グループ化を持っています。
そして、C<\1> は繰り返しを探します。
$1と\1が同じものを表現しているにもかかわらず、マッチ変数 C<$1>, C<$2> …は
正規表現の I<外側> のみで用い、後方参照 C<\1>, C<\2> …は正規表現の
I<内側> でのみ使うようにすべきです。
そうしないと驚くような不満足な結果を招くかもしれません。

=head2 Relative backreferences

=begin original

Counting the opening parentheses to get the correct number for a
backreference is errorprone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write C<\g{-1}>, the next but
last is available via C<\g{-2}>, and so on.

=end original

Counting the opening parentheses to get the correct number for a
backreference is errorprone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write C<\g{-1}>, the next but
last is available via C<\g{-2}>, and so on.
(TBT)

=begin original

Another good reason in addition to readability and maintainability
for using relative backreferences  is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:

=end original

Another good reason in addition to readability and maintainability
for using relative backreferences  is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:
(TBT)

    $a99a = '([a-z])(\d)\2\1';   # matches a11a, g22g, x33x, etc.

=begin original

Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:

=end original

Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:
(TBT)

    $line = "code=e99e";
    if ($line =~ /^(\w+)=$a99a$/){   # unexpected behavior!
        print "$1 is valid\n";
    } else {
        print "bad line: '$line'\n";
    }

=begin original

But this doesn't match -- at least not the way one might expect. Only
after inserting the interpolated C<$a99a> and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired -- the subexpression C<(\w+)> has snatched number 1 and
demoted the groups in C<$a99a> by one rank. This can be avoided by
using relative backreferences:

=end original

But this doesn't match -- at least not the way one might expect. Only
after inserting the interpolated C<$a99a> and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired -- the subexpression C<(\w+)> has snatched number 1 and
demoted the groups in C<$a99a> by one rank. This can be avoided by
using relative backreferences:
(TBT)

    $a99a = '([a-z])(\d)\g{-1}\g{-2}';  # safe for being interpolated


=head2 Named backreferences

=begin original

Perl 5.10 also introduced named capture buffers and named backreferences.
To attach a name to a capturing group, you write either
C<< (?<name>...) >> or C<< (?'name'...) >>.  The backreference may
then be written as C<\g{name}>.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture buffer is accessible through the C<%+> hash.

=end original

Perl 5.10 also introduced named capture buffers and named backreferences.
To attach a name to a capturing group, you write either
C<< (?<name>...) >> or C<< (?'name'...) >>.  The backreference may
then be written as C<\g{name}>.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture buffer is accessible through the C<%+> hash.
(TBT)

=begin original

Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the buffers capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:

=end original

Assuming that we have to match calendar dates which may be given in one
of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the buffers capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:
(TBT)

    $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
    $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
    $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
    for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print "day=$+{d} month=$+{m} year=$+{y}\n";
        }
    }

=begin original

If any of the alternatives matches, the hash C<%+> is bound to contain the
three key-value pairs.

=end original

If any of the alternatives matches, the hash C<%+> is bound to contain the
three key-value pairs.
(TBT)

=head2 Alternative capture group numbering

=begin original

Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:

=end original

Yet another capturing group numbering technique (also as from Perl 5.10)
deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:
(TBT)

    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # process hour and minute
    }

=begin original

Processing the results requires an additional if statement to determine
whether C<$1> and C<$2> or C<$3> and C<$4> contain the goodies. It would
be easier if we could use buffer numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct C<(?|...)>,
set around an alternative achieves. Here is an extended version of the
previous pattern:

=end original

Processing the results requires an additional if statement to determine
whether C<$1> and C<$2> or C<$3> and C<$4> contain the goodies. It would
be easier if we could use buffer numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct C<(?|...)>,
set around an alternative achieves. Here is an extended version of the
previous pattern:
(TBT)

    if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
	print "hour=$1 minute=$2 zone=$3\n";
    }

=begin original

Within the alternative numbering group, buffer numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.

=end original

Within the alternative numbering group, buffer numbers start at the same
position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.
(TBT)

=head2 Position information

=begin original

In addition to what was matched, Perl (since 5.6.0) also provides the
positions of what was matched as contents of the C<@-> and C<@+>
arrays. C<$-[0]> is the position of the start of the entire match and
C<$+[0]> is the position of the end. Similarly, C<$-[n]> is the
position of the start of the C<$n> match and C<$+[n]> is the position
of the end. If C<$n> is undefined, so are C<$-[n]> and C<$+[n]>. Then
this code

=end original

マッチしたものに加えて、Perl (5.6.0 以降) ではマッチしたものの位置を
C<@-> と C<@+> という配列の中身によって提供します。
C<$-[0]> はマッチ全体の開始位置で、C<$+[0]> はマッチ全体の終了位置です。
同様に、 C<$-[n]> は C<$n> の開始位置であり C<$+[n]> はその終了位置です。
C<$n> が未定義であった場合には、C<$-[n]> と C<$+[n]> もまた未定義です。

    $x = "Mmm...donut, thought Homer";
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # matches
    foreach $expr (1..$#-) {
        print "Match $expr: '${$expr}' at position ($-[$expr],$+[$expr])\n";
    }

=begin original

prints

=end original

このコードは以下の出力を行います

    Match 1: 'Mmm' at position (0,3)
    Match 2: 'donut' at position (6,11)

=begin original

Even if there are no groupings in a regexp, it is still possible to
find out what exactly matched in a string.  If you use them, Perl
will set C<$`> to the part of the string before the match, will set C<$&>
to the part of the string that matched, and will set C<$'> to the part
of the string after the match.  An example:

=end original

グループ化を正規表現で使っていなかったとしても、文字列の中で実際に
マッチしたものを見つけ出すことが可能です。
正規表現を使ったとき、 Perl は C<$`> に文字列のマッチした部分より前の部分を
セットし、 C<$&> にはマッチした部分をセットし、そして C<$'> には
マッチした部分より後の部分をセットします:

    $x = "the cat caught the mouse";
    $x =~ /cat/;  # $` = 'the ', $& = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $& = 'the', $' = ' cat caught the mouse'

=begin original

In the second match, C<$`> equals C<''> because the regexp matched at the
first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using C<$`> and C<$'>
slows down regexp matching quite a bit, while C<$&> slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for I<all> regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use C<@-> and
C<@+> instead:

=end original

二番目のマッチでは、C<$`> は C<''> となります;
なぜなら、正規表現は文字列の最初の文字位置でマッチして止まっているからで、
二番目の 'the' を決して見ないからなのです; C<$`> や C<$'> を使うことは
正規表現マッチングを目立って遅くさせることに注意することは重要です。
C<$&> も遅くなる原因です。
なぜなら、プログラムの中の正規表現でこれらを使ったならばプログラムの中の
I<すべて> の正規表現に対してこれらが生成されるからです。
ですから、raw パフォーマンスがあなたの作るアプリケーションのゴールで
あるならば、これらを排除すべきです。
もし必要なら、
to extract the corresponding substrings, 代わりに@-と@+を使いましょう:
(TBT)

    $` is the same as substr( $x, 0, $-[0] )
    $& is the same as substr( $x, $-[0], $+[0]-$-[0] )
    $' is the same as substr( $x, $+[0] )

=head2 Non-capturing groupings

(キャプチャしないグループ化)

=begin original

A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture buffer values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by C<(?:regexp)>,
still allow the regexp to be treated as a single unit, but don't establish
a capturing buffer at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:

=end original

A group that is required to bundle a set of alternatives may or may not be
useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture buffer values, inside as well as
outside the regexp.
非キャプチャグループ化は C<(?:regexp)> のように表記され regexp を一つの
ユニットのように扱うことができるようにするが、同時に捕捉バッファを
作成しません。
キャプチャするグループ化とキャプチャしないグループ化の両方が同じ正規表現の
中で共存することができます。
部分文字列の抜き出しをしないので非キャプチャグループ化はキャプチャする
グループ化よりも高速です。
非キャプチャグループ化はマッチ変数を使って抽出する正規表現の部分を
選択するのに便利です:
(TBT)

    # match a number, $1-$4 are set, but we only want $1
    /([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/;

    # match a number faster , only $1 is set
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/;

    # match a number, get $1 = whole number, $2 = exponent
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/;

=begin original

Non-capturing groupings are also useful for removing nuisance
elements gathered from a split operation where parentheses are
required for some reason:

=end original

非キャプチャグループ化はsplit操作において不必要な要素を取り除くためにも使われますwhere parentheses are
required for some reason:
(TBT)

    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','b','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')


=head2 Matching repetitions

(マッチングの繰り返し)

=begin original

The examples in the previous section display an annoying weakness.  We
were only matching 3-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
C<\w\w\w\w|\w\w\w|\w\w|\w>.

=end original

先のセクションの例では、腹立たしい弱点が明らかになりました。
三文字の単語か、四文字以下の文字の塊にだけマッチしていました。
C<\w\w\w\w|\w\w\w|\w\w|\w> のような長たらしい選択を書くことなしに任意の
長さの単語やより一般的には、文字列にマッチさせたいのです。

=begin original

This is exactly the problem the I<quantifier> metacharacters C<?>,
C<*>, C<+>, and C<{}> were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:

=end original

これは、C<?>, C<*>, C<+>, C<{}> といった I<量指定子> (quatifier)
メタ文字が作られる元となった問題です。
これらはマッチさせたいと考えている正規表現の一部分を繰り返すことを
定めます。
量指定子は繰り返しを指定したい文字、文字クラス、またはグループの直後に
置きます。
量指定子には以下のような意味があります:

=over 4

=item *

=begin original

C<a?> means: match 'a' 1 or 0 times

=end original

C<a?> は: 'a' または空文字列にマッチします

=item *

=begin original

C<a*> means: match 'a' 0 or more times, i.e., any number of times

=end original

C<a*> は: 'a' のゼロ回以上の繰り返しにマッチします。

=item *

=begin original

C<a+> means: match 'a' 1 or more times, i.e., at least once

=end original

C<a+> は: 'a' の一回以上の繰り返しにマッチします。

=item *

=begin original

C<a{n,m}> means: match at least C<n> times, but not more than C<m>
times.

=end original

C<a{n,m}> は: C<n> 回以上 C<m> 回以下の繰り返しにマッチします。

=item *

=begin original

C<a{n,}> means: match at least C<n> or more times

=end original

C<a{n,}> は: C<n> 回以上の繰り返しにマッチします。

=item *

=begin original

C<a{n}> means: match exactly C<n> times

=end original

C<a{n}> は: C<n> 回の繰り返しにマッチします。

=back

=begin original

Here are some examples:

=end original

以下に幾つか例を挙げます:

    /[a-z]+\s+\d*/;  # match a lowercase word, at least one space, and
                     # any number of digits
    /(\w+)\s+\1/;    # match doubled words of arbitrary length
    /y(es)?/i;       # matches 'y', 'Y', or a case-insensitive 'yes'
    $year =~ /\d{2,4}/;  # make sure year is at least 2 but not more
                         # than 4 digits
    $year =~ /\d{4}|\d{2}/;    # better match; throw out 3 digit dates
    $year =~ /\d{2}(\d{2})?/;  # same thing written differently. However,
                               # this produces $1 and the other does not.

    % simple_grep '^(\w+)\1$' /usr/dict/words   # isn't this easier?
    beriberi
    booboo
    coco
    mama
    murmur
    papa

=begin original

For all of these quantifiers, Perl will try to match as much of the
string as possible, while still allowing the regexp to succeed.  Thus
with C</a?.../>, Perl will first try to match the regexp with the C<a>
present; if that fails, Perl will try to match the regexp without the
C<a> present.  For the quantifier C<*>, we get the following:

=end original

これらの量指定子のすべてで、Perl は正規表現のマッチが成功するのを許す範囲で
可能な限りの文字列をマッチさせようとします。
したがって、C</a?.../> があったとき、Perl は最初にaがあるものとして
正規表現のマッチを試みます。
もしそれが失敗したら、Perl は C<a> がないものとして正規表現のマッチを
試みます。
量指定子 C<*> に関して、以下のようになります:

    $x = "the cat in the hat";
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'

=begin original

Which is what we might expect, the match finds the only C<cat> in the
string and locks onto it.  Consider, however, this regexp:

=end original

これはおそらく期待したもので、文字列の中の C<cat> だけを見つけ出して
マッチします。
しかし、次の例で考えてみましょう:

    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 characters match)

=begin original

One might initially guess that Perl would find the C<at> in C<cat> and
stop there, but that wouldn't give the longest possible string to the
first quantifier C<.*>.  Instead, the first quantifier C<.*> grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the C<at> sequence with the final C<at>
in the string.  The other important principle illustrated here is that
when there are two or more elements in a regexp, the I<leftmost>
quantifier, if there is one, gets to grab as much the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier C<.*> grabs most of the string, while
the second quantifier C<.*> gets the empty string.   Quantifiers that
grab as much of the string as possible are called I<maximal match> or
I<greedy> quantifiers.

=end original

Perl は C<cat> の C<at> を見つけて、そこでストップするだろうと考える人が
いるかもしれませんが、それでは最初の量指定子.*に可能な限りの長い文字列を
与えてはいません。
その代わりに、最初の量指定子 C<.*> は正規表現がマッチする範囲で可能な限りの
長い文字列をつかみとります。
この例では C<at> が文字列の最後の C<at> になるということを意味します。
ここで明らかになるもう一つの重要な規則は二つ以上の要素が正規表現の中に
あるときには、I<最も左にある> 量指定子が可能な限りの長さの文字列をつかみとり、
正規表現の残りの部分がどうであるかは放っておくというものです。
したがってこの例では、二番目の量指定子 C<.*> は空文字列をつかみます。
可能な限りの文字列をつかみとる量指定子は I<最長マッチ> とか 
I<貪欲> (greedy)であると呼ばれます。

=begin original

When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:

=end original

正規表現が幾つかの異なる道筋で文字列にマッチすることが可能なとき、
正規表現がどのようにマッチするかを予測するために以下の法則を
使うことができます:

=over 4

=item *

=begin original

Principle 0: Taken as a whole, any regexp will be matched at the
earliest possible position in the string.

=end original

法則 0: 全体で、任意の正規表現は文字列中の可能な限り先頭に近い場所で
マッチする。

=item *

=begin original

Principle 1: In an alternation C<a|b|c...>, the leftmost alternative
that allows a match for the whole regexp will be the one used.

=end original

法則 1: 選択 C<a|b|c...> の中で、正規表現全体がマッチする中で最も左の
選択肢が使われる。

=item *

=begin original

Principle 2: The maximal matching quantifiers C<?>, C<*>, C<+> and
C<{n,m}> will in general match as much of the string as possible while
still allowing the whole regexp to match.

=end original

法則 2: 最大マッチング量指定子 C<?>, C<*>, C<+>, C<{n,m}> は
正規表現全体がマッチする中で最も長い文字列にマッチする。

=item *

=begin original

Principle 3: If there are two or more elements in a regexp, the
leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.

=end original

法則 3: 正規表現の中に二つ以上の要素があったならば、貪欲な量指定子が
もしあれば、その中で最も左にあるものが正規表現全体がマッチする条件に
おいて可能な限りの長さでマッチする。
次の貪欲な量指定子があれば、それは残りの中で正規表現全体がマッチする
条件において最も長い文字列にマッチする。
これをすべての正規表現要素が満足されるまで繰り返す。

=back

=begin original

As we have seen above, Principle 0 overrides the others -- the regexp
will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.

=end original

すでに見たように、法則 0 は他のものを上書きしています -- 正規表現は
可能な限り早い地点でマッチしようとし、他の法則はその正規表現が
どのようにその最も早く現れた文字位置でマッチするかを決定しています。

=begin original

Here is an example of these principles in action:

=end original

以下はこれらの法則をアクションの中で示した例です:

    $x = "The programming republic of Perl";
    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'

=begin original

This regexp matches at the earliest string position, C<'T'>.  One
might think that C<e>, being leftmost in the alternation, would be
matched, but C<r> produces the longest string in the first quantifier.

=end original

この正規表現は最も早い文字列位置 C<'T'> でマッチします。
選択の中で最も左にあるeがマッチすると考えた人がいるかもしれませんが、
C<r> が最初の量指定子に関して最長の文字列を生成します。

    $x =~ /(m{1,2})(.*)$/;  # matches,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'

=begin original

Here, The earliest possible match is at the first C<'m'> in
C<programming>. C<m{1,2}> is the first quantifier, so it gets to match
a maximal C<mm>.

=end original

ここで、最も早い可能な位置は C<programming> の中の最初の C<'m'> です。
C<m{1,2}> は最初の量指定子なので、最も長い C<mm> にマッチするのです。

    $x =~ /.*(m{1,2})(.*)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'

=begin original

Here, the regexp matches at the start of the string. The first
quantifier C<.*> grabs as much as possible, leaving just a single
C<'m'> for the second quantifier C<m{1,2}>.

=end original

これは、文字列の先頭で正規表現はマッチします。
最初の量指定子 C<.*> は可能な限りの部分をつかみとり、二番目の量指定子
C<m{1,2}> のためには C<'m'> 一文字しか残しません。

    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'

=begin original

Here, C<.?> eats its maximal one character at the earliest possible
position in the string, C<'a'> in C<programming>, leaving C<m{1,2}>
the opportunity to match both C<m>'s. Finally,

=end original

この例では、C<.?> は文字列の中で可能な限り早い場所での最大一文字、つまり C<programming> の中の C<'a'> をつかみとります。
C<m{1,2}> は両方の C<m> にマッチする機会を与えられます。
最終的に、

    "aXXXb" =~ /(X*)/; # matches with $1 = ''

=begin original

because it can match zero copies of C<'X'> at the beginning of the
string.  If you definitely want to match at least one C<'X'>, use
C<X+>, not C<X*>.

=end original

そしてこうなるわけは、文字列の先頭にある C<'X'> のゼロ回の繰り返しに
マッチすることができるからです。
少なくとも一つの C<'X'> にマッチさせたいのであるなら、C<X*> ではなく
C<X+> を使いましょう。

=begin original

Sometimes greed is not good.  At times, we would like quantifiers to
match a I<minimal> piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the I<minimal match> or
I<non-greedy> quantifiers C<??>, C<*?>, C<+?>, and C<{}?>.  These are
the usual quantifiers with a C<?> appended to them.  They have the
following meanings:

=end original

貪欲であることがよくない場合もあります。
文字列の最大の部分ではなく 最小の部分にマッチする量指定子が欲しいときが
あります。
この目的のために、Larry Wall は I<最小マッチ>(minimal match)もしくは
I<無欲>(non-greedy)な量指定子 C<??>, C<*?>, C<+?>, C<{}?> を作り出しました。
これらは通常の量指定子に C<?> を付け加えたもので、以下のような意味を
持ちます:

=over 4

=item *

=begin original

C<a??> means: match 'a' 0 or 1 times. Try 0 first, then 1.

=end original

C<a??> は: 空か'a'にマッチします。
はじめに空を試し、それから'a'を試します。

=item *

=begin original

C<a*?> means: match 'a' 0 or more times, i.e., any number of times,
but as few times as possible

=end original

C<a*?> は: 'a'のゼロ回以上の繰り返しにマッチします。
任意回の繰り返しができますが、可能な限り少ない回数になります。

=item *

=begin original

C<a+?> means: match 'a' 1 or more times, i.e., at least once, but
as few times as possible

=end original

C<a+?> は: 'a'の一回以上の繰り返しにマッチします。
一回以上の任意回の繰り返しができますが、可能な限り少ない回数になります。

=item *

=begin original

C<a{n,m}?> means: match at least C<n> times, not more than C<m>
times, as few times as possible

=end original

C<a{n,m}?> は: C<n> 回以上 C<m> 回以下の繰り返しにマッチしますが、可能な
限り少ない回数になります。

=item *

=begin original

C<a{n,}?> means: match at least C<n> times, but as few times as
possible

=end original

C<a{n,}?> は: 少なくとも C<n> 回の繰り返しにマッチしますが、可能な限り
少ない回数になります。

=item *

=begin original

C<a{n}?> means: match exactly C<n> times.  Because we match exactly
C<n> times, C<a{n}?> is equivalent to C<a{n}> and is just there for
notational consistency.

=end original

C<a{n}?> は: ちょうど C<n> 回の繰り返しにマッチします。
ちょうど C<n> 回なので、C<a{n}> と等価であり、一貫性のためだけに
存在します。

=back

=begin original

Let's look at the example above, but with minimal quantifiers:

=end original

先の例を最小量指定子を使ったものにしてみましょう:

    $x = "The programming republic of Perl";
    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'

=begin original

The minimal string that will allow both the start of the string C<^>
and the alternation to match is C<Th>, with the alternation C<e|r>
matching C<e>.  The second quantifier C<.*> is free to gobble up the
rest of the string.

=end original

マッチするために文字列の開始位置 C<^> と選択の両方を満足する最小の
文字列は C<Th> で、選択 C<e|r> は C<e> にマッチします。
二番目の量指定子 C<.*> は文字列の残りから自由につかみとることができます。

    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'

=begin original

The first string position that this regexp can match is at the first
C<'m'> in C<programming>. At this position, the minimal C<m{1,2}?>
matches just one C<'m'>.  Although the second quantifier C<.*?> would
prefer to match no characters, it is constrained by the end-of-string
anchor C<$> to match the rest of the string.

=end original

この正規表現がマッチすることのできる文字列の最初の位置は
C<programming> の中の最初の C<'m'> です。
この位置で、最小マッチ C<m{1,2}?> はただ一つの C<'m'> です。
二番目の量指定子 C<.*?> が空にマッチしようとしますがそれは文字列の
終端アンカー C<$> が阻止して、文字列の残りにマッチします。

    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'

=begin original

In this regexp, you might expect the first minimal quantifier C<.*?>
to match the empty string, because it is not constrained by a C<^>
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it I<will> match at the start of the string.  Thus
the first quantifier has to match everything up to the first C<m>.  The
second minimal quantifier matches just one C<m> and the third
quantifier matches the rest of the string.

=end original

この正規表現において、最小量指定子 C<.*?> は空文字列にマッチすると
考えるかもしれませんが、^アンカーが単語の先頭にマッチすることを
強制していません。
法則 0 がここで適用されます。
文字列の先頭で正規表現全体をマッチさせることが可能なので、文字列の先頭で
マッチ I<します>。
したがって、最初の量指定子は最初の C<m> までにマッチします。
二番目の最小量指定子はただ一文字の C<m> にマッチして、三番目の量指定子が
文字列の残りにマッチします。

    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'

=begin original

Just as in the previous regexp, the first quantifier C<.??> can match
earliest at position C<'a'>, so it does.  The second quantifier is
greedy, so it matches C<mm>, and the third matches the rest of the
string.

=end original

先の正規表現と同じようですが、最初の量指定子 C<.??> は最初の C<'a'> の
位置でマッチできるのでそうします。
二番目の量指定子は貪欲なので C<mm> にマッチし、三番目のものが文字列の
残りにマッチします。

=begin original

We can modify principle 3 above to take into account non-greedy
quantifiers:

=end original

先に挙げた法則 3 を、無欲な量指定子を考慮したものにするために修正します:

=over 4

=item *

=begin original

Principle 3: If there are two or more elements in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.

=end original

法則 3: 正規表現の中に二つ以上の要素があったならば、貪欲な量指定子(もしくは
無欲な量指定子)がもしあれば、その中で最も左にあるものが
正規表現全体がマッチする条件において可能な限りの長さでマッチする。
次の貪欲な量指定子(もしくは無欲な量指定子)があれば、それは残りの中で
正規表現全体がマッチする条件において最も長い(最も短い)文字列にマッチする。
これをすべての正規表現要素が満足されるまで繰り返す。

=back

=begin original

Just like alternation, quantifiers are also susceptible to
backtracking.  Here is a step-by-step analysis of the example

=end original

選択と同じように、量指定子もまたバックトラッキングを行う可能性があります。
以下はステップごとに追った例です

    $x = "the cat in the hat";
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)

=over 4

=item 0

=begin original

Start with the first letter in the string 't'.

=end original


      文字列の最初の文字't'で始まる。

=item 1

=begin original

The first quantifier '.*' starts out by matching the whole
string 'the cat in the hat'.

=end original


      最初の量指定子 '.*' は文字列全体'the cat in the hat'にまずはじめにマッチする。

=item 2

=begin original

'a' in the regexp element 'at' doesn't match the end of the
string.  Backtrack one character.

=end original


      正規表現要素'at'の'a'は文字列の末尾にマッチしない。
一文字後戻りする。

=item 3

=begin original

'a' in the regexp element 'at' still doesn't match the last
letter of the string 't', so backtrack one more character.

=end original


      正規表現要素'at'の'a'は文字列の最後の文字't'にマッチしないので、更に一文字後戻りする。

=item 4

=begin original

Now we can match the 'a' and the 't'.

=end original


      ここで'a'と't'にマッチすることができる。

=item 5

=begin original

Move on to the third element '.*'.  Since we are at the end of
the string and '.*' can match 0 times, assign it the empty string.

=end original


      三番目の要素'.*'に移る。
文字列の末尾に位置していて、'.*'は 0回の繰り返しにマッチすることができるので空文字列をアサインする。

=item 6

=begin original

We are done!

=end original


      完了!

=back

=begin original

Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form

=end original

ほとんどの場合、前方への移動と後戻りが起こったときには迅速に行われ、検索は高速です。
しかしながら、中には文字列の長さに応じて指数的に実行時間が延びるような病理学的(pathological)な正規表現もあります。
そのようなものの例は以下のようなものです

    /(a|b+)*/;

=begin original

The problem is the nested indeterminate quantifiers.  There are many
different ways of partitioning a string of length n between the C<+>
and C<*>: one repetition with C<b+> of length n, two repetitions with
the first C<b+> length k and the second with length n-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try I<every> possibility before giving up.  So be
careful with nested C<*>'s, C<{n,m}>'s, and C<+>'s.  The book
I<Mastering Regular Expressions> by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.

=end original

問題は不確定のネストした量指定子があることです。
C<+> と C<*> の間にある長さ n の文字列には複数の異なる分け方が存在します:
一つは長さ n の C<b+> で、二つ目は長さ k の C<b+> と n-k の長さのもの。
繰り返し m は長さ n まで加えられます。
長さの関数として文字列を分割する方法の数は指数的な数になります。
正規表現は幸運なときには処理の早い段階でマッチに成功するかもしれませんが、
マッチしなかった場合には Perl は音を上げるまで I<すべての> 可能性を
試します。
ですから、ネストした C<*>, C<{n,m}>, C<+> には注意してください。
Jeffrey Friedl による I<Mastering Regular Expressions>
(邦訳 「詳説正規表現」) という本はこういった効率の問題についてすばらしい
解説をしています。

=head2 Possessive quantifiers

=begin original

Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern

=end original

Backtracking during the relentless search for a match may be a waste
of time, particularly when the match is bound to fail.  Consider
the simple pattern
(TBT)

    /^\w+\s+\w+$/; # a word, spaces, a word

=begin original

Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as S<C<"abc  ">> or S<C<"abc  def ">>,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking I<all>
of the initial word characters to match the first repetition, that I<all>
spaces must be eaten by the middle part, and the same goes for the second
word.

=end original

Whenever this is applied to a string which doesn't quite meet the
pattern's expectations such as S<C<"abc  ">> or S<C<"abc  def ">>,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking I<all>
of the initial word characters to match the first repetition, that I<all>
spaces must be eaten by the middle part, and the same goes for the second
word.
(TBT)

=begin original

With the introduction of the I<possessive quantifiers> in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a C<+> appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:

=end original

With the introduction of the I<possessive quantifiers> in Perl 5.10, we
have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a C<+> appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:
(TBT)

=over 4

=item *

=begin original

C<a{n,m}+> means: match at least C<n> times, not more than C<m> times,
as many times as possible, and don't give anything up. C<a?+> is short
for C<a{0,1}+>

=end original

C<a{n,m}+> means: match at least C<n> times, not more than C<m> times,
as many times as possible, and don't give anything up. C<a?+> is short
for C<a{0,1}+>
(TBT)

=item *

=begin original

C<a{n,}+> means: match at least C<n> times, but as many times as possible,
and don't give anything up. C<a*+> is short for C<a{0,}+> and C<a++> is
short for C<a{1,}+>.

=end original

C<a{n,}+> means: match at least C<n> times, but as many times as possible,
and don't give anything up. C<a*+> is short for C<a{0,}+> and C<a++> is
short for C<a{1,}+>.
(TBT)

=item *

=begin original

C<a{n}+> means: match exactly C<n> times.  It is just there for
notational consistency.

=end original

C<a{n}+> means: match exactly C<n> times.  It is just there for
notational consistency.
(TBT)

=back

=begin original

These possessive quantifiers represent a special case of a more general
concept, the I<independent subexpression>, see below.

=end original

These possessive quantifiers represent a special case of a more general
concept, the I<independent subexpression>, see below.
(TBT)

=begin original

As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.

=end original

As an example where a possessive quantifier is suitable we consider
matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.
(TBT)

    /"(?:[^"\\]++|\\.)*+"/;

=head2 Building a regexp

(正規表現を組み立てる)

=begin original

At this point, we have all the basic regexp concepts covered, so let's
give a more involved example of a regular expression.  We will build a
regexp that matches numbers.

=end original

ここまでで、すべての基本的な正規表現のコンセプトをカバーしました。
ですから、もっと複雑な正規表現に行ってみましょう。
例として、数値にマッチする正規表現を組み立てます。

=begin original

The first task in building a regexp is to decide what we want to match
and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.

=end original

正規表現を組み立てるにあたっての最初の仕事は何にマッチさせるかと何を
排除するかを決めることです。
今回は、整数と浮動小数点数の両方にマッチさせ、数値でない文字列をすべて
排除します。

=begin original

The next task is to break the problem down into smaller problems that
are easily converted into a regexp.

=end original

次の仕事は問題を、より正規表現に変換しやすい小さいな問題に
分解することです。

=begin original

The simplest case is integers.  These consist of a sequence of digits,
with an optional sign in front.  The digits we can represent with
C<\d+> and the sign can be matched with C<[+-]>.  Thus the integer
regexp is

=end original

もっとも簡単なケースは整数です。
これは数字の並びであり、省略可能な符号が先頭にあります。
数字は C<\d+> で表すことができ、符号は C<[+-]> にマッチさせることが
できます。
したがって、整数にマッチする正規表現は以下のようになります

    /[+-]?\d+/;  # matches integers

=begin original

A floating point number potentially has a sign, an integral part, a
decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, -1e6, and 25.4E-72.  As with integers, the sign out
front is completely optional and can be matched by C<[+-]?>.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with C<\d*\.\d*>, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are

=end original

浮動小数点数は符号と、整数部と、小数点と、小数部と、指数部を持つ可能性が
あります。
これらの一つ以上のパーツが省略可能であり、可能なものをチェックする必要が
あります。
正しい形式の浮動小数点数は123.、0.345、.34、-1e6、25.4E072 といったものを
含みます。
整数と同じように、先頭にある符合は省略可能で C<[+-]?> にマッチします。
もし指数部がないことがわかれば、浮動小数点数は小数点を持たなければならず、
これがない場合にはそれは整数です。
C<\d*\.\d*> というパターンを使うことを思いつくかもしれませんが、これは
数値ではないただ一つの小数点にもマッチしてしまいます。
ですから、指数部のない浮動小数点には以下の三つのケースが存在します

   /[+-]?\d+\./;  # 1., 321., etc.
   /[+-]?\.\d+/;  # .1, .234, etc.
   /[+-]?\d+\.\d+/;  # 1.0, 30.56, etc.

=begin original

These can be combined into a single regexp with a three-way alternation:

=end original

これらは三つの選択を使った単一の正規表現にまとめることができます:

   /[+-]?(\d+\.\d+|\d+\.|\.\d+)/;  # floating point, no exponent

=begin original

In this alternation, it is important to put C<'\d+\.\d+'> before
C<'\d+\.'>.  If C<'\d+\.'> were first, the regexp would happily match that
and ignore the fractional part of the number.

=end original

この選択肢において、C<'\d+\.\d+'が'\d+\.'> より前に置かれていることが
重要です。
もし C<'\d+\.'> が先頭にあったなら、この正規表現は数値の小数部を無視して
マッチしてしまうでしょう。

=begin original

Now consider floating point numbers with exponents.  The key
observation here is that I<both> integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:

=end original

ここで指数部を持つ浮動小数点数を考えてみましょう。
ここでのポイントは指数部の前に整数と小数点を伴った数の I<両方> が
現れることができるということです。
指数部は符号と同じように、小数点を伴うか伴わないかに関係なくマッチし、
仮数部から分離することも可能です。
正規表現の全体の形式がこれで明らかになりました:

    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;

=begin original

The exponent is an C<e> or C<E>, followed by an integer.  So the
exponent regexp is

=end original

指数部は整数が続く C<e> もしくは C<E> です。
ですから指数部の正規表現は以下のようになります

   /[eE][+-]?\d+/;  # exponent

=begin original

Putting all the parts together, we get a regexp that matches numbers:

=end original

すべてのパーツを一つにまとめることによって、数値にマッチする正規表現を
手に入れます:

   /^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/;  # Ta da!

=begin original

Long regexps like this may impress your friends, but can be hard to
decipher.  In complex situations like this, the C<//x> modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form

=end original

このような長い正規表現を友人に説明することがあるかもしれませんが、
解読するのが難しいかもしれません。
このような複雑なものにおいては、C<//x> 修飾子は重要なものです。
この修飾子は正規表現に対してその意味を変えることなく、ほぼ任意の空白を
入れたりコメントを入れたりすることを許します。
これを使うことによって、よりわかりやすい形式に正規表現を「拡張」することが
できます

   /^
      [+-]?         # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

=begin original

If whitespace is mostly irrelevant, how does one include space
characters in an extended regexp? The answer is to backslash it
S<C<'\ '>> or put it in a character class S<C<[ ]>>.  The same thing
goes for pound signs, use C<\#> or C<[#]>.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:

=end original

もし空白が余計なものであれば、拡張された正規表現にスペースを含ませるには
どうすればよいのでしょうか? その答えは S<C<'\ '>> のようにバックスラッシュを
前置するか、S<C<[ ]>> のように文字クラスに押し込めることです。
同じことが '#' にも言えて、こちらも C<\#> か C<[#]> を使います。
たとえば、Perl が符号と仮数部(もしくは整数部) の間に空白を置くことを
許すとすると、以下のように正規表現に加えることができます:

   /^
      [+-]?\ *      # first, match an optional sign *and space*
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

=begin original

In this form, it is easier to see a way to simplify the
alternation.  Alternatives 1, 2, and 4 all start with C<\d+>, so it
could be factored out:

=end original

この形式においては、選択肢を単純にする方法を見つけるのは簡単です。
選択肢 1, 2, 4 はすべて C<\d+> で始まっています。
ですからこれはまとめることができます:

   /^
      [+-]?\ *      # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ([eE][+-]?\d+)?  # finally, optionally match an exponent
   $/x;

=begin original

or written in the compact form,

=end original

あるいはコンパクトな形式で

    /^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;

=begin original

This is our final regexp.  To recap, we built a regexp by

=end original

これが最終形の正規表現です。
ここでは以下のようにして正規表現を組み立てました。

=over 4

=item *

=begin original

specifying the task in detail,

=end original

なすべきことを詳細に確定し、

=item *

=begin original

breaking down the problem into smaller parts,

=end original

問題を小さなパーツに分割し、

=item *

=begin original

translating the small parts into regexps,

=end original

その小さなパーツを正規表現に変換し、

=item *

=begin original

combining the regexps,

=end original

その正規表現を組み合わせ、

=item *

=begin original

and optimizing the final combined regexp.

=end original

組み合わされた最終的な正規表現を最適化する。

=back

=begin original

These are also the typical steps involved in writing a computer
program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.

=end original

これはコンピュータプログラムを書くにあたっての典型的なステップでもあります。
正規表現はパターンを特定する小さなコンピュータ言語で書くプログラムであるので、このことはまさに当てはまります。

=head2 Using regular expressions in Perl

(Perl で正規表現を使う)

=begin original

The last topic of Part 1 briefly covers how regexps are used in Perl
programs.  Where do they fit into Perl syntax?

=end original

Perl 1 の最後のトピックは正規表現がPerlプログラムでどのように
使われているかを説明します。
正規表現は Perl の構文のどこにフィットしているのでしょう?

=begin original

We have already introduced the matching operator in its default
C</regexp/> and arbitrary delimiter C<m!regexp!> forms.  We have used
the binding operator C<=~> and its negation C<!~> to test for string
matches.  Associated with the matching operator, we have discussed the
single line C<//s>, multi-line C<//m>, case-insensitive C<//i> and
extended C<//x> modifiers.  There are a few more things you might
want to know about matching operators.

=end original

すでにデフォルトの C</regexp/> と任意のデリミタを持つ C<m!regexp!> 形式の
マッチング演算子を説明しています。
マッチさせる文字列を指定するために C<=~> 演算子や C<!~> 演算子を
使っています。
マッチング演算子について、単一行修飾子 C<//s>、複数行修飾子 C<//m>、
大小文字の違いを無視する修飾子 C<//i>、拡張修飾子 C<//x> について述べました。
マッチング演算子に関して、知っておきたいであろう二、三の事柄があります。

=head3 Optimizing pattern evaluation

=begin original

We pointed out earlier that variables in regexps are substituted
before the regexp is evaluated:

=end original

正規表現が評価されるよりも前に変数の置換が行われることをすでに説明しました:

    $pattern = 'Seuss';
    while (<>) {
        print if /$pattern/;
    }

=begin original

This will print any lines containing the word C<Seuss>.  It is not as
efficient as it could be, however, because Perl has to re-evaluate
(or compile) C<$pattern> each time through the loop.  If C<$pattern> won't be
changing over the lifetime of the script, we can add the C<//o>
modifier, which directs Perl to only perform variable substitutions
once:

=end original

この例は C<Seuss> という単語を含む行をすべて出力します。
しかしながらこれは効率が良いものではありません。
なぜなら、Perl はループを回るたびごとに C<$pattern> を
再評価(またはコンパイル)しなければならないからです。
もし C<$pattern> がスクリプトの人生において変化しないものであるなら、
Perl に変数の置換をただ一度だけ行うように指示する C<//o> 修飾子を
つけることができます:

    #!/usr/bin/perl
    #    Improved simple_grep
    $regexp = shift;
    while (<>) {
        print if /$regexp/o;  # a good deal faster
    }

=head3 Prohibiting substitution

=begin original

If you change C<$pattern> after the first substitution happens, Perl
will ignore it.  If you don't want any substitutions at all, use the
special delimiter C<m''>:

=end original

もし最初の置換が行われた後で C<$pattern> を変更したとしても、Perl は
それを無視します。
すべての置換を行いたくないというのであれば、特殊なデリミタ
C<m''> を使います:

    @pattern = ('Seuss');
    while (<>) {
        print if m'@pattern';  # matches literal '@pattern', not 'Seuss'
    }

=begin original

Similar to strings, C<m''> acts like apostrophes on a regexp; all other
C<m> delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the I<last successful match> is used instead.  So we have

=end original

文字列と同様、C<m''> は正規表現においてシングルクォートのように
振舞います。
他のすべての C<m> デリミタはダブルクォートのように振舞います。
もし正規表現が空文字列を評価したならば、その正規表現は
I<最後に成功した> マッチにある正規表現が代わりに使われます。

    "dog" =~ /d/;  # 'd' matches
    "dogbert =~ //;  # this matches the 'd' regexp used before


=head3 Global matching

=begin original

The final two modifiers C<//g> and C<//c> concern multiple matches.
The modifier C<//g> stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
`C<//g> jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
C<pos()> function.

=end original

最後の二つの修飾子 C<//g> と C<//c> は複数回マッチに関連するものです。
修飾子 C<//g> はグローバルマッチングを意味し、マッチング演算子に対して
文字列の中で可能な限りの回数マッチすることを許します。
スカラコンテキストでは、ある文字列に対する連続した呼び出しはマッチから
マッチへとジャンプする C<//g> を持ち、その文字列の中での位置を記憶します。
C<pos()> 関数を使ってこの位置を取り出したり設定したりすることができます。

=begin original

The use of C<//g> is shown in the following example.  Suppose we have
a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:

=end original

C<//g> を使った例を以下に挙げます。
ここで、空白によってくぎら得た単語の並びからなる文字列があるとします。
もしいくつの単語があるかがわかっていれば、グループ化を使って単語を
取り出すことができます:

    $x = "cat dog house"; # 3 words
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # matches,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'

=begin original

But what if we had an indeterminate number of words? This is the sort
of task C<//g> was made for.  To extract all words, form the simple
regexp C<(\w+)> and loop over all matches with C</(\w+)/g>:

=end original

しかしもし不定個の単語があるとしたら?
これが C<//g> が作られた理由となった類の仕事です。
すべての単語を取り出すために、単純な C<(\w+)> という正規表現を使い、
C</(\w+)/g> をループで使ってすべてにマッチさせます:

    while ($x =~ /(\w+)/g) {
        print "Word is $1, ends at position ", pos $x, "\n";
    }

=begin original

prints

=end original

これは

    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13

=begin original

A failed match or changing the target string resets the position.  If
you don't want the position reset after failure to match, add the
C<//c>, as in C</regexp/gc>.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.

=end original

マッチに失敗したり、ターゲット文字列を変更するとこの位置はリセットされます。
もしマッチに失敗したときに位置をリセットしたくないのであれば、
C</regexp/gc> のように C<//c> を追加します。
文字列の中のカレント位置はその文字列に結び付けられていて、正規表現にでは
ありません。
このことは異なる文字列は異なる位置を持っていて、それらのそれぞれの位置は
独立にセットしたり読み出したりすることが可能です。

=begin original

In list context, C<//g> returns a list of matched groupings, or if
there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use

=end original

リストコンテキストでは、C<//g> はマッチしたグループのリストを返します。
グループ化の指定がなければ、正規表現全体にマッチするリストを返します。
ですから、単に単語が欲しいのでれば

    @words = ($x =~ /(\w+)/g);  # matches,
                                # $word[0] = 'cat'
                                # $word[1] = 'dog'
                                # $word[2] = 'house'

=begin original

Closely associated with the C<//g> modifier is the C<\G> anchor.  The
C<\G> anchor matches at the point where the previous C<//g> match left
off.  C<\G> allows us to easily do context-sensitive matching:

=end original

C<//g> 修飾子は\Gアンカーに強く結び付けられています。
C<\G> アンカーは直前のマッチで残った部分にマッチします。
C<\G> はコンテキストを考慮したマッチング(context-sensitive matching)を
容易にさせます。

    $metric = 1;  # use metric units
    ...
    $x = <FILE>;  # read in measurement
    $x =~ /^([+-]?\d+)\s*/g;  # get magnitude
    $weight = $1;
    if ($metric) { # error checking
        print "Units error!" unless $x =~ /\Gkg\./g;
    }
    else {
        print "Units error!" unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # continue processing

=begin original

The combination of C<//g> and C<\G> allows us to process the string a
bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the C<\G> anchor is only fully supported when used to anchor
to the start of the pattern.

=end original

C<//g> と C<\G> の組み合わせは一度に文字列を少しだけ処理して、次に
行うことを決定するために任意の Perl のロジックを使うことを可能にします。
現在のところ、C<\G> アンカーはパターンの最初に使われたときのみ
完全にサポートされます。

=begin original

C<\G> is also invaluable in processing fixed length records with
regexps.  Suppose we have a snippet of coding region DNA, encoded as
base pair letters C<ATCGTTGAAT...> and we want to find all the stop
codons C<TGA>.  In a coding region, codons are 3-letter sequences, so
we can think of the DNA snippet as a sequence of 3-letter records.  The
naive regexp

=end original

C<\G> はまた、正規表現を使って固定長のレコードを処理するときに
貴重なものです。
基礎となる組み合わせ文字でエンコードされた C<ATCGTTGAAT...> のような
DNA の符号化部分があるとして、すべてのストップコドン (codon: 3 つの
ヌクレオチドから成る，遺伝情報の単位)を見つけ出したいとしましょう。
符号化部分の中では、コドンは三文字の並びなので DNA の断片を
三文字のレコードの並びとしてみなすことができます。
単純な正規表現である

    # expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"
    $dna = "ATCGTTGAATGCAAATGACATGAC";
    $dna =~ /TGA/;

=begin original

doesn't work; it may match a C<TGA>, but there is no guarantee that
the match is aligned with codon boundaries, e.g., the substring
S<C<GTT GAA>> gives a match.  A better solution is

=end original

はうまくいきません。
これは C<TGA> にマッチはしますが、 S<C<GTT GAA>> のようにコドンの
境界にないものにもマッチしてしまいます。
より良い解決策は以下のようなものです

    while ($dna =~ /(\w\w\w)*?TGA/g) {  # note the minimal *?
        print "Got a TGA stop codon at position ", pos $dna, "\n";
    }

=begin original

which prints

=end original

これは

    Got a TGA stop codon at position 18
    Got a TGA stop codon at position 23

=begin original

Position 18 is good, but position 23 is bogus.  What happened?

=end original

を出力します。
Position 18 は良いですが、23 は変です。
何が起きているのでしょう?

=begin original

The answer is that our regexp works well until we get past the last
real match.  Then the regexp will fail to match a synchronized C<TGA>
and start stepping ahead one character position at a time, not what we
want.  The solution is to use C<\G> to anchor the match to the codon
alignment:

=end original

その答えは、私たちの正規表現が最後に本当にマッチしたところまでは
うまくいっているからです。
それからこの正規表現は C<TGA> の同期に失敗して私たちが望んでいない場所から
マッチのステップを始めてしまうのです。
解決策は、コドンの境界にマッチさせるために C<\G> を
使って印付けをすることです:

    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print "Got a TGA stop codon at position ", pos $dna, "\n";
    }

=begin original

This prints

=end original

これは

    Got a TGA stop codon at position 18

=begin original

which is the correct answer.  This example illustrates that it is
important not only to match what is desired, but to reject what is not
desired.

=end original

を出力し、そして正しい答えです。
この例はマッチしたものにマッチすることだけが重要なのではなく、
望んでいないものを排除することもまたそうなのだということを
明らかにしました。

=head3 Search and replace

(検索と置換)

=begin original

Regular expressions also play a big role in I<search and replace>
operations in Perl.  Search and replace is accomplished with the
C<s///> operator.  The general form is
C<s/regexp/replacement/modifiers>, with everything we know about
regexps and modifiers applying in this case as well.  The
C<replacement> is a Perl double quoted string that replaces in the
string whatever is matched with the C<regexp>.  The operator C<=~> is
also used here to associate a string with C<s///>.  If matching
against C<$_>, the S<C<$_ =~>> can be dropped.  If there is a match,
C<s///> returns the number of substitutions made, otherwise it returns
false.  Here are a few examples:

=end original

正規表現はまた、Perl における検索と置換操作において大きな役割を
果たしています。
検索と置換は C<s///> 演算子に結び付けられています。
一般的な形は C<s/regexp/replacement/modifiers> で、知っているすべての
正規表現と修飾子をここで使うことができます。
C<replacement> は Perlでのダブルクォートで囲まれた文字列で、
C<regexp> にマッチした文字列を置き換えるものです。
C<=~> 演算子もまた C<s///> を伴った文字列に結びつけられるために使われます。
C<$_> に対してマッチングを行う場合には、S<C<$_ =~>> は省略することができます。
マッチに成功した場合には C<s///> は置換が行われた数を返し、失敗した場合には
偽を返します。
幾つか例を挙げましょう:

    $x = "Time to feed the cat!";
    $x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = "'quoted words'";
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains "quoted words"

=begin original

In the last example, the whole string was matched, but only the part
inside the single quotes was grouped.  With the C<s///> operator, the
matched variables C<$1>, C<$2>, etc.  are immediately available for use
in the replacement expression, so we use C<$1> to replace the quoted
string with just what was quoted.  With the global modifier, C<s///g>
will search and replace all occurrences of the regexp in the string:

=end original

最後の例では、文字列全体がマッチしていましたが、シングルクォートに
囲まれた部分だけがグループ化されています。
C<s///> 演算子を使うにあたって、C<$1>, C<$2> といったマッチ変数は
その置換式のなかで即座に使うことができます。
ですから、C<$1> をクォートされていた文字列に置き換えるために使っています。
グローバル修飾子 C<s///g> を使うことで、文字列中のすべての正規表現に
マッチする検索と置換を行います:

    $x = "I batted 4 for 4";
    $x =~ s/4/four/;   # doesn't do it all:
                       # $x contains "I batted four for 4"
    $x = "I batted 4 for 4";
    $x =~ s/4/four/g;  # does it all:
                       # $x contains "I batted four for four"

=begin original

If you prefer 'regex' over 'regexp' in this tutorial, you could use
the following program to replace it:

=end original

このチュートリアルにある 'regexp' を 'regex' にすることを望むのなら、
以下のプログラムを使って置換することができます:

    % cat > simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (<>) {
        s/$regexp/$replacement/go;
        print;
    }
    ^D

    % simple_replace regexp regex perlretut.pod

=begin original

In C<simple_replace> we used the C<s///g> modifier to replace all
occurrences of the regexp on each line and the C<s///o> modifier to
compile the regexp only once.  As with C<simple_grep>, both the
C<print> and the C<s/$regexp/$replacement/go> use C<$_> implicitly.

=end original

C<simple_replace> では各行のすべての正規表現にマッチする部分を
置換するために C<s///g> 修飾子を使い、正規表現をただ一度だけ
コンパイルするようにするために C<s///o> 修飾子を使っています。
C<simple_grep> と同様、C<print> と C<s/$regexp/$replacement/go> で
C<$_> を暗黙に使用しています。

=begin original

A modifier available specifically to search and replace is the
C<s///e> evaluation modifier.  C<s///e> wraps an C<eval{...}> around
the replacement string and the evaluated result is substituted for the
matched substring.  C<s///e> is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:

=end original

検索と置換において使うことのできる修飾子に評価修飾子 C<s///e> があります。
C<s///e> は置換文字列を C<eval{...}> でラップし、その評価結果を
マッチした部分文字列の置換のために使います。
C<s///e> は置換テキストの処理においてちょっとした計算を行う必要が
あるときに便利です。
以下の例はある行の文字の出現頻度を数えます:

    $x = "Bill the cat";
    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char with itself
    print "frequency of '$_' is $chars{$_}\n"
        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);

=begin original

This prints

=end original

これは以下の出力を行います

    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1

=begin original

As with the match C<m//> operator, C<s///> can use other delimiters,
such as C<s!!!> and C<s{}{}>, and even C<s{}//>.  If single quotes are
used C<s'''>, then the regexp and replacement are treated as single
quoted strings and there are no substitutions.  C<s///> in list context
returns the same thing as in scalar context, i.e., the number of
matches.

=end original

C<m//> 演算子と同様に、C<s///> も C<s!!!> や C<s{}{}> 、
果ては C<s{}//> のように異なるデリミタを使うことができます。
C<s'''> のようにシングルクォートが使われた場合、その正規表現と
置換テキストはシングルクォート文字列のように扱われ、変数の置き換えは
行われません。
リストコンテキストでの C<s///> はスカラコンテキストのときと同じように、
マッチした数を返します。

=head3 The split function

(split 関数)

=begin original

The C<split()> function is another place where a regexp is used.
C<split /regexp/, string, limit> separates the C<string> operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The C<limit>, if present, constrains splitting into no more than C<limit>
number of strings.  For example, to split a string into words, use

=end original

C<split()> 関数は、正規表現が使えるもう一つの場所です。
C<split /regexp/, string, limit> は C<string> オペランドを部分文字列の
リストに分割し、そのリストを返します。
The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
C<limit> が与えられた場合には、文字列を C<limit> 個を超える数には分割しません。
たとえば、文字列を単語に分割するには以下のようにします
(TBT)

    $x = "Calvin and Hobbes";
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'

=begin original

If the empty regexp C<//> is used, the regexp always matches and
the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,

=end original

C<//> が使われた場合には、その正規表現は常にマッチし、文字列は個々の文字に
分割されます。
正規表現がグループ化を伴っていた場合には、グループ化されたものも部分文字列に
含まれるようになります。
例を挙げると以下のようになります

    $x = "/usr/bin/perl";
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'

=begin original

Since the first character of $x matched the regexp, C<split> prepended
an empty initial element to the list.

=end original

$x の最初の文字に正規表現がマッチしているので、C<split> はリストの
最初の要素に空要素を置きます。

=begin original

If you have read this far, congratulations! You now have all the basic
tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while...  S<Part 2>
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.

=end original

ここまで読み進めてきたのならおめでとう!
あなたは広範囲のテキスト処理を解決するのに必要な正規表現の基本的な部分を
すべて会得しました。
このチュートリアルを初めて読んでここまできたのなら、ここで立ち止まって
正規表現を使ってみるのも良いでしょう。
S<Part 2> ではより難解な正規表現の側面に言及します。

=head1 Part 2: Power tools

(強力なツール)

=begin original

OK, you know the basics of regexps and you want to know more.  If
matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.

=end original

あなたはすでに正規表現の基本的なことを知っていて、より深く
知ろうとしています。
正規表現のマッチングが森の中を歩くことに類似しているのなら、Part 1 で
述べられたツールは地図でありコンパスであり、いつも使う基本的な道具です。
Part 2 での大部分のツールは照明弾であり、衛星電話です。
ハイキングにはそうそう使うものではありませんが、困り果てたときには
とても貴重なものです。

=begin original

What follows are the more advanced, less used, or sometimes esoteric
capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the new features.

=end original

以下に挙げるものは Perl の正規表現においてより高度で、
あまり使うことのない、時として難解な機能です。
Part 2 では、あなたが基本を良く知っていて新しい機能に集中できることを
仮定しています。

=head2 More on characters, strings, and character classes

(文字、文字列、文字クラスについての追加事項)

=begin original

There are a number of escape sequences and character classes that we
haven't covered yet.

=end original

まだカバーしていない幾つかのエスケープシーケンスや文字クラスがあります。

=begin original

There are several escape sequences that convert characters or strings
between upper and lower case, and they are also available within
patterns.  C<\l> and C<\u> convert the next character to lower or
upper case, respectively:

=end original

文字や文字列の大小文字を変換するエスケープシーケンスがあり、
これらもパターンで使えます。
C<\l> や C<\u> は続く文字をそれぞれ小文字と大文字に変換します:

    $x = "perl";
    $string =~ /\u$x/;  # matches 'Perl' in $string
    $x = "M(rs?|s)\\."; # note the double backslash
    $string =~ /\l$x/;  # matches 'mr.', 'mrs.', and 'ms.',

=begin original

A C<\L> or C<\U> indicates a lasting conversion of case, until
terminated by C<\E> or thrown over by another C<\U> or C<\L>:

=end original

A C<\L> or C<\U> indicates a lasting conversion of case, until
terminated by C<\E> or thrown over by another C<\U> or C<\L>:
(TBT)

    $x = "This word is in lower case:\L SHOUT\E";
    $x =~ /shout/;       # matches
    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
    $x =~ /\Ukeypunch/;  # matches punch card string

=begin original

If there is no C<\E>, case is converted until the end of the
string. The regexps C<\L\u$word> or C<\u\L$word> convert the first
character of C<$word> to uppercase and the rest of the characters to
lowercase.

=end original

C<\E> がない場合には、大小文字の変換は文字列の終端まで行われます。
C<\L\u$word> や C<\u\L$word> は C<$word> の最初の文字を大文字へと変換し、
残りの文字は小文字にします。

=begin original

Control characters can be escaped with C<\c>, so that a control-Z
character would be matched with C<\cZ>.  The escape sequence
C<\Q>...C<\E> quotes, or protects most non-alphabetic characters.   For
instance,

=end original

制御文字は C<\c> を使ってエスケープすることができます。
ですから、 control-Z 文字は C<\cZ> にマッチします。
C<\Q>...C<\E> というエスケープシーケンスは大部分の非アルファベット文字を
クォートまたはプロテクトします。
たとえば

    $x = "\QThat !^*&%~& cat!";
    $x =~ /\Q!^*&%~&\E/;  # check for rough language

=begin original

It does not protect C<$> or C<@>, so that variables can still be
substituted.

=end original

これは C<$> や C<@> をプロテクトしないので、変数の置換は行われます。

=begin original

With the advent of 5.6.0, Perl regexps can handle more than just the
standard ASCII character set.  Perl now supports I<Unicode>, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255

=end original

5.6.0 において、Perl の正規表現は標準の ASCII 文字セットを超えた扱いを
することができるようになりました。
Perl は現在は事実上世界の全ての言語のアルファベットを表現する標準である
Unicode をサポートしています。
Unicode はこれを 2 バイト以上の幅を持つ文字を許すことで実現しています。
Perl の文字列は Unicode 文字列で、255 以上の値(コードポイントまたは
文字番号)を持つ文字を含みます。

=begin original

What does this mean for regexps? Well, regexp users don't need to know
much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than C<chr(255)> are represented using the C<\x{hex}> notation,
because the \0 octal and \x hex (without curly braces) don't go further
than 255.

=end original

このことが正規表現に及ぼす影響は?
そう、正規表現ユーザーは perl での文字列の内部表現を知る必要はありません。
しかし、知っておくべきことがあります。
1) 正規表現においてUnicode文字をどのように表現するか
2) マッチング操作がバイト列ではなく、Unicode 文字列として扱うということです。
1)に対する答えは C<chr(255)> を越える Unicode 文字は C<\x{hex}> 表記を
使って表現されるだろうということです(ここでhexは十六進整数);
because the \0 octal and \x hex (without curly braces) don't go further
than 255.
(TBT)

    /\x{263a}/;  # match a Unicode smiley face :)

=begin original

B<NOTE>: In Perl 5.6.0 it used to be that one needed to say C<use
utf8> to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit C<utf8> pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit C<use utf8> is needed.)

=end original

注意: Perl 5.6.0 では何かしらの Unicode 機構を使うときには C<use utf8> を
宣言する必要がありました。
これは現在ではあてはまりません: ほとんどすべての Unicode 処理においては、
C<utf8> プラグマは必要ありません (これが意味を持つただ一つのケースは、
あなたの Perl スクリプトが Unicode で書かれていて、かつそれが UTF-8 で
エンコーディングされている場合で、このときは陽に
C<use utf8> を指定する必要があります)。

=begin original

Figuring out the hexadecimal sequence of a Unicode character you want
or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the I<named character>> escape
sequence C<\N{name}>.  C<name> is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use

=end original

あなたが必要なUnicode文字を十六進数で表記することや、別の誰かが十六進表記の
Unicode正規表現を解読することは、機械語でプログラミングすることを
楽しむかのようです。
ですから、Unicode文字を指定する別の方法として C<\N{name}> のような
I<名前付き文字> エスケープシーケンスを使うものがあります。
C<name> は Unicode 文字に対する名前であって、Unicode standard で
定義されているものです。
たとえば、水星を表す占星術記号を表したりマッチさせるために以下のようにします

    use charnames ":full"; # use named chars with Unicode full names
    $x = "abc\N{MERCURY}def";
    $x =~ /\N{MERCURY}/;   # matches

=begin original

One can also use short names or restrict names to a certain alphabet:

=end original

アルファベットを特定するために短い名前や制限された名前を使うこともできます:

    use charnames ':full';
    print "\N{GREEK SMALL LETTER SIGMA} is called sigma.\n";

    use charnames ":short";
    print "\N{greek:Sigma} is an upper-case sigma.\n";

    use charnames qw(greek);
    print "\N{sigma} is Greek sigma\n";

=begin original

A list of full names is found in the file NamesList.txt in the
lib/perl5/X.X.X/unicore directory (where X.X.X is the perl
version number as it is installed on your system).

=end original

フルネームのリストは、lib/perl5/X.X.X/unicore ディレクトリの
NamesList.txtにあります。
(where X.X.X is the perl
version number as it is installed on your system).
(TBT)

=begin original

The answer to requirement 2), as of 5.6.0, is that a regexp uses Unicode
characters. Internally, this is encoded to bytes using either UTF-8 or a
native 8 bit encoding, depending on the history of the string, but
conceptually it is a sequence of characters, not bytes. See
L<perlunitut> for a tutorial about that.

=end original

2)の答えは、5.6.0でのように、正規表現はUnicode文字をつかうというものです。
Internally, this is encoded to bytes using either UTF-8 or a
native 8 bit encoding, depending on the history of the string, but
conceptually it is a sequence of characters, not bytes. See
L<perlunitut> for a tutorial about that.
(TBT)

=begin original

Let us now discuss Unicode character classes.  Just as with Unicode
characters, there are named Unicode character classes represented by the
C<\p{name}> escape sequence.  Closely associated is the C<\P{name}>
character class, which is the negation of the C<\p{name}> class.  For
example, to match lower and uppercase characters,

=end original

Unicode文字クラスについて述べましょう。
Unicde文字と同様に、名前付けされたUnicodeの文字クラスがあり、
C<\p{name}> エスケープシーケンスで表されます。
C<\P{name}> は C<\p{name}> の反対の意味を持つ文字クラスです。
たとえば小文字や大文字の文字にマッチさせるには

    use charnames ":full"; # use named chars with Unicode full names
    $x = "BOB";
    $x =~ /^\p{IsUpper}/;   # matches, uppercase char class
    $x =~ /^\P{IsUpper}/;   # doesn't match, char class sans uppercase
    $x =~ /^\p{IsLower}/;   # doesn't match, lowercase char class
    $x =~ /^\P{IsLower}/;   # matches, char class sans lowercase

=begin original

Here is the association between some Perl named classes and the
traditional Unicode classes:

=end original

以下は、Perl での名前つきクラスと伝統的な Unicode クラスの間の関係です:

    Perl class name  Unicode class name or regular expression

    IsAlpha          /^[LM]/
    IsAlnum          /^[LMN]/
    IsASCII          $code <= 127
    IsCntrl          /^C/
    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
    IsDigit          Nd
    IsGraph          /^([LMNPS]|Co)/
    IsLower          Ll
    IsPrint          /^([LMNPS]|Co|Zs)/
    IsPunct          /^P/
    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
    IsUpper          /^L[ut]/
    IsWord           /^[LMN]/ || $code eq "005F"
    IsXDigit         $code =~ /^00(3[0-9]|[46][1-6])$/

=begin original

You can also use the official Unicode class names with the C<\p> and
C<\P>, like C<\p{L}> for Unicode 'letters', or C<\p{Lu}> for uppercase
letters, or C<\P{Nd}> for non-digits.  If a C<name> is just one
letter, the braces can be dropped.  For instance, C<\pM> is the
character class of Unicode 'marks', for example accent marks.
For the full list see L<perlunicode>.

=end original

Unicode の 'letters' である C<f\p{L}> とか大文字である C<\p{Lu}> とか
数字以外の\P{Nd}のように、公式なUncodeクラス名を C<\p> や C<\P> を
使って使用することができます。
C<name> がただ一文字であった場合には、ブレースは省略することができます。
たとえば、C<\pM> は Unicode の 'marks' の文字クラスで、アクセント記号などが
当てはまります。
リスト全部については L<perlunicode> を参照してください。

=begin original

The Unicode has also been separated into various sets of characters
which you can test with C<\p{...}> (in) and C<\P{...}> (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example C<\p{Latin}>, C<\p{Greek}>,
or C<\P{Katakana}>. Other sets are the Unicode blocks, the names
of which begin with "In". One such block is dedicated to mathematical
operators, and its pattern formula is <C\p{InMathematicalOperators>}>.
For the full list see L<perlunicode>.

=end original

Unicode はまた、C<\p{In...}>(含まれる)と C<\P{In...}> (含まれない)で
検査することのできる文字のセットに分けられます。
To test whether a character is (or is not) an element of a script
you would use the script name, 
たとえば、C<\p{Latin}>, C<\p{Greek}>, C<\P{Katakana}> などがあります。
Other sets are the Unicode blocks, the names
of which begin with "In". One such block is dedicated to mathematical
operators, and its pattern formula is <C\p{InMathematicalOperators>}>.
完全なリストは L<perlunicode> を参照してください。
(TBT)

=begin original

C<\X> is an abbreviation for a character class that comprises
the Unicode I<combining character sequences>.  A combining character
sequence is a base character followed by any number of diacritics, i.e.,
signs like accents used to indicate different sounds of a letter. Using
the Unicode full names, e.g., S<C<A + COMBINING RING>> is a combining
character sequence with base character C<A> and combining character
S<C<COMBINING RING>>, which translates in Danish to A with the circle
atop it, as in the word Angstrom.  C<\X> is equivalent to C<\PM\pM*}>,
i.e., a non-mark followed by one or more marks.

=end original

C<\X> は、Unicode の I<combining character sequences>(結合文字並び)を
構成する文字クラスの並びの略記です。
結合文字並びはa base character followed by any number of diacritics, i.e.,
signs like accents used to indicate different sounds of a letter. 
Unicodeのフルネームを使った S<C<A + COMBINING RING>>  は、
C<A> とそれに続く結合文字 S<C<COMBINING RING>> で、これはデンマーク語の
オングストロームという単語の中にある丸が上についたAです。
C<\X> は C<\PM\pM*}> と等価で、一つ以上のマークの続いたマークでないものです。

=begin original

For the full and latest information about Unicode see the latest
Unicode standard, or the Unicode Consortium's website http://www.unicode.org/

=end original

Unicode に関するすべての情報や最新の情報を得るには、Unicode standard の
最新にものを見るか、Unicode コンソーシアムの web サイト
http://www.unicode.org/ を参照してください。

=begin original

As if all those classes weren't enough, Perl also defines POSIX style
character classes.  These have the form C<[:name:]>, with C<name> the
name of the POSIX class.  The POSIX classes are C<alpha>, C<alnum>,
C<ascii>, C<cntrl>, C<digit>, C<graph>, C<lower>, C<print>, C<punct>,
C<space>, C<upper>, and C<xdigit>, and two extensions, C<word> (a Perl
extension to match C<\w>), and C<blank> (a GNU extension).  If C<utf8>
is being used, then these classes are defined the same as their
corresponding Perl Unicode classes: C<[:upper:]> is the same as
C<\p{IsUpper}>, etc.  The POSIX character classes, however, don't
require using C<utf8>.  The C<[:digit:]>, C<[:word:]>, and
C<[:space:]> correspond to the familiar C<\d>, C<\w>, and C<\s>
character classes.  To negate a POSIX class, put a C<^> in front of
the name, so that, e.g., C<[:^digit:]> corresponds to C<\D> and under
C<utf8>, C<\P{IsDigit}>.  The Unicode and POSIX character classes can
be used just like C<\d>, with the exception that POSIX character
classes can only be used inside of a character class:

=end original

これで十分でないかのように、PerlではPOSIX形式の文字クラスも定義しています。
これらは[:name:]という形式で、nameは POSIXのクラスの名前です。
POSIXクラスにはalpha、alnum、ascii、 cntrl、digit、graph、lower、print、punct、space、 upper、xdigitがあり、さらに二つの拡張 word(\wにマッチする Perlの拡張)とblank(GNUによる拡張)があります。
utf8が使われている場合には、これらのクラスはそれぞれを表すperlのUnicodeクラスに等価なものとして定義されます: たとえば[:upper:]は\p{IsUpper}と同じことです。
しかしながら、POSIX文字クラスはutf8を必要とはしません。
 [:digit:], [:word:], [:space:]はそれぞれなじみ深い\d、\w、\sに対応します。
POSIXクラスを否定するには ^を名前の前に置きます。
ですから、[:^digit:] は\Dに対応し、 utf8の元での\P{IsDigit}になります。
Unicodeの文字クラスと POSIXの文字クラスは\dのように使うことができますが、 POSIXの文字クラスは文字クラスの中でだけ使うことができます。

    /\s+[abc[:digit:]xyz]\s*/;  # match a,b,c,x,y,z, or a digit
    /^=item\s[[:digit:]]/;      # match '=item',
                                # followed by a space and a digit
    use charnames ":full";
    /\s+[abc\p{IsDigit}xyz]\s+/;  # match a,b,c,x,y,z, or a digit
    /^=item\s\p{IsDigit}/;        # match '=item',
                                  # followed by a space and a digit

=begin original

Whew! That is all the rest of the characters and character classes.

=end original

これが文字と文字クラスで残っていたことです。

=head2 Compiling and saving regular expressions

(正規表現のコンパイルとセーブ)

=begin original

In Part 1 we discussed the C<//o> modifier, which compiles a regexp
just once.  This suggests that a compiled regexp is some data structure
that can be stored once and used again and again.  The regexp quote
C<qr//> does exactly that: C<qr/string/> compiles the C<string> as a
regexp and transforms the result into a form that can be assigned to a
variable:

=end original

Part 1 において、正規表現をただ一度だけコンパイルする C<//o> 修飾子について
述べました。
これはコンパイルされた正規表現が一度だけ格納されて繰り返し使うことのできる
データ構造にであることを示唆しています。
C<qr//> で表される正規表現クォートは次のようなものです:
C<qr/string/> は C<string> を正規表現としてコンパイルして結果を変数に
代入することのできる形式へと変換します:

    $reg = qr/foo+bar?/;  # reg contains a compiled regexp

=begin original

Then C<$reg> can be used as a regexp:

=end original

C<$reg> は正規表現として使うことができます:

    $x = "fooooba";
    $x =~ $reg;     # matches, just like /foo+bar?/
    $x =~ /$reg/;   # same thing, alternate form

=begin original

C<$reg> can also be interpolated into a larger regexp:

=end original

C<$reg> はより大きな正規表現の中で展開することもできます:

    $x =~ /(abc)?$reg/;  # still matches

=begin original

As with the matching operator, the regexp quote can use different
delimiters, e.g., C<qr!!>, C<qr{}> or C<qr~~>.  Apostrophes
as delimiters (C<qr''>) inhibit any interpolation.

=end original

マッチング演算子を伴ったときのように正規表現クォートは
C<qr!!>, C<qr{}>, C<qr~~> のような異なるデリミタを使うことができます。
シングルクォートを使ったデリミタ (C<qr''>) は変数展開を抑止します。

=begin original

Pre-compiled regexps are useful for creating dynamic matches that
don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a C<grep_step> program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.

=end original

コンパイル済み正規表現は、現れるたびにコンパイルする必要のない動的な
マッチングを生成するのに便利です。
コンパイル済み正規表現を使って
we write a C<grep_step> program
which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.
(TBT)

    % cat > grep_step
    #!/usr/bin/perl
    # grep_step - match <number> regexps, one after the other
    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    @compiled = map qr/$_/, @regexp;
    while ($line = <>) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D

    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;

=begin original

Storing pre-compiled regexps in an array C<@compiled> allows us to
simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.

=end original

コンパイル済み正規表現を配列 C<@compiled> に格納することで、
再コンパイルすることなく正規表現を使うことができ、これにより
速度を犠牲にすることなく融通性を手に入れることができました。

=head2 Composing regular expressions at runtime

=begin original

Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the C<simple_grep> program: a program that matches
multiple patterns:

=end original

Backtracking is more efficient than repeated tries with different regular
expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the C<simple_grep> program: a program that matches
multiple patterns:
(TBT)

    % cat > multi_grep
    #!/usr/bin/perl
    # multi_grep - match any of <number> regexps
    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...

    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    $pattern = join '|', @regexp;

    while ($line = <>) {
        print $line if $line =~ /$pattern/o;
    }
    ^D

    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);

=begin original

Sometimes it is advantageous to construct a pattern from the I<input>
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.

=end original

Sometimes it is advantageous to construct a pattern from the I<input>
that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.
(TBT)

    % cat > keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $command = <> ){
        $command =~ s/^\s+|\s+$//g;  # trim leading and trailing spaces
        if( ( @matches = $kwds =~ /\b$command\w*/g ) == 1 ){
            print "command: '$matches'\n";
        } elsif( @matches == 0 ){
            print "no such command: '$command'\n";
        } else {
            print "not unique: '$command' (could be one of: @matches)\n";
        }
    }
    ^D

    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'

=begin original

Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation S<C<$kwds =~ /\b($command\w*)/g>> does several things at the
same time. It makes sure that the given command begins where a keyword
begins (C<\b>). It tolerates abbreviations due to the added C<\w*>. It
tells us the number of matches (C<scalar @matches>) and all the keywords
that were actually matched.  You could hardly ask for more.

=end original

Rather than trying to match the input against the keywords, we match the
combined set of keywords against the input.  The pattern matching
operation S<C<$kwds =~ /\b($command\w*)/g>> does several things at the
same time. It makes sure that the given command begins where a keyword
begins (C<\b>). It tolerates abbreviations due to the added C<\w*>. It
tells us the number of matches (C<scalar @matches>) and all the keywords
that were actually matched.  You could hardly ask for more.
(TBT)

=head2 Embedding comments and modifiers in a regular expression

(正規表現にコメントや修飾子を埋め込む)

=begin original

Starting with this section, we will be discussing Perl's set of
I<extended patterns>.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs C<??>, C<*?>, C<+?>, C<{n,m}?>, and C<{n,}?>.  The
rest of the extensions below have the form C<(?char...)>, where the
C<char> is a character that determines the type of extension.

=end original

このセクションのはじめで、Perlの I<拡張パターン>(extended patterns)の
セットについて述べると言いました。
以下に述べるのは、伝統的な正規表現構文を拡張して、パターンマッチングに
おいて新しい強力なツールを提供するものです。
すでに、C<??>, C<*?>, C<+?>, C<{n,m}?>, C<{n,}?> といった
最小マッチングの拡張について述べました。
残りの拡張は C<(?char...)> という形式で、C<char> は
拡張の型を指定する文字です。

=begin original

The first extension is an embedded comment C<(?#text)>.  This embeds a
comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is

=end original

最初の拡張はコメント C<(?#text)> です。
これは正規表現に、その意味を変更することなくコメントを埋め込みます。
コメントはテキストの中で閉じカッコ以外の任意のものを持てます。
例を挙げましょう

    /(?# Match an integer:)[+-]?\d+/;

=begin original

This style of commenting has been largely superseded by the raw,
freeform commenting that is allowed with the C<//x> modifier.

=end original

このスタイルのコメントは、C<//x> 修飾子を使ったときの自由形式の
コメントにとって代わられています。

=begin original

The modifiers C<//i>, C<//m>, C<//s>, C<//x> and C<//k> (or any
combination thereof) can also embedded in
a regexp using C<(?i)>, C<(?m)>, C<(?s)>, and C<(?x)>.  For instance,

=end original

C<//i>, C<//m>, C<//s>, C<//x> といった修飾子(あるいはその組み合わせ)は
C<(?i)>, C<(?m)>, C<(?s)>, C<(?x)> を使って正規表現に
埋め込むこともできます。
例を挙げましょう

    /(?i)yes/;  # match 'yes' case insensitively
    /yes/i;     # same thing
    /(?x)(          # freeform version of an integer regexp
             [+-]?  # match an optional sign
             \d+    # match a sequence of digits
         )
    /x;

=begin original

Embedded modifiers can have two important advantages over the usual
modifiers.  Embedded modifiers allow a custom set of modifiers to
I<each> regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:

=end original

埋め込み修飾子は通常の修飾子に比べて二つの利点があります。
埋め込み修飾子は正規表現のパターンの I<それぞれに> 別々の修飾子を
与えることができます。
これは異なる修飾子を持った正規表現の配列にマッチングさせるのに有利です:

    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (<>) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }

=begin original

The second advantage is that embedded modifiers (except C<//k>, which
modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:

=end original

二番目の利点は、埋め込み修飾子(except C<//k>, which
modifies the entire regexp)
はそれが埋め込まれたグループの中にある正規表現にだけ影響するということです。
このため、グループ化を修飾子の影響を局所化するために使うことができます:
(TBT)

    /Answer: ((?i)yes)/;  # matches 'Answer: yes', 'Answer: YES', etc.

=begin original

Embedded modifiers can also turn off any modifiers already present
by using, e.g., C<(?-i)>.  Modifiers can also be combined into
a single expression, e.g., C<(?s-i)> turns on single line mode and
turns off case insensitivity.

=end original

埋め込み修飾子は C<(?-i)> のようにして任意の修飾子を無効にすることもできます。
修飾子は一つの式にまとめることもでき、たとえば C<(?s-i)> は
単一行モードを有効にして大小文字の違いを無視ししないようにします。

=begin original

Embedded modifiers may also be added to a non-capturing grouping.
C<(?i-m:regexp)> is a non-capturing grouping that matches C<regexp>
case insensitively and turns off multi-line mode.

=end original

埋め込みの修飾子は非キャプチャグループ化にも追加できます:
C<(?i-m:regexp)> は C<regexp> に大小文字の違いを無視してマッチし
複数行モードをオフにする非キャプチャグループ化です。

=head2 Looking ahead and looking behind

(先読みと戻り読み)

=begin original

This section concerns the lookahead and lookbehind assertions.  First,
a little background.

=end original

本セクションでは先読み(lookahead)と戻り読み(後読み: lookbehind)の
表明について述べます。
まずはじめにちょっとした背景から。

=begin original

In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match.  For instance, the regexp element
C<[abc}]> eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor C<^> matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor C<\b> matches wherever a character matching C<\w>
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of I<zero-width assertions>.
Zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.

=end original

Perlの正規表現では、ほとんどの正規表現要素はそれにマッチしたときに文字列の
一部を「食い取り」(eat up)します。
たとえば、C<[abc}]> という正規表現要素はそれにマッチしたときに文字列の
文字一つを食い取ります。
そして Perl はマッチの後で文字列の次の位置の文字へと移動します。
しかしながら、マッチしたときに文字を食い取らない(が、文字位置は進める)
要素が存在します。
その例はアンカーとしてすでに登場しています。
C<^> というアンカーは行の先頭にマッチしますが文字を食い取ることはしません。
同様に語境界アンカー C<\b> はたとえば単語を構成する文字で、次が単語を
構成する文字でない場所にマッチしますが、文字を食い取ることはしません。
アンカーは「ゼロ幅の表明」(zero-width assertions) の実例です。
文字を消費しないのでゼロ幅で、文字列のなんらかの属性をテストするので
表明です。
正規表現のマッチングを森の中での歩行にたとえた文脈で言えば、大部分の
正規表現要素は移動を伴うものであるが、アンカーは足を止めて周囲を
確認するようなものです。
局所的な環境をチェックしたなら、進むことができます。
しかし局所的な環境が私たちを満足するものでなければ、私たちは
後戻りしなければなりません。

=begin original

Checking the environment entails either looking ahead on the trail,
looking behind, or both.  C<^> looks behind, to see that there are no
characters before.  C<$> looks ahead, to see that there are no
characters after.  C<\b> looks both ahead and behind, to see if the
characters on either side differ in their "word-ness".

=end original

環境をチェックすることは道の上で先を見通したり、後ろを振り返ったり
することです。
C<^> は後ろを振り返って、文字が存在していないかどうかを確認します。
C<$> は先を見て、更に文字が続いていないかどうかを確認します。
C<\b> は先や後ろを、そこにある文字がそれぞれに対して異なる
単語属性("word-ness")であるかどうかを確認します。

=begin original

The lookahead and lookbehind assertions are generalizations of the
anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by C<(?=regexp)> and the lookbehind
assertion is denoted by C<< (?<=fixed-regexp) >>.  Some examples are

=end original

先読み表明や戻り読み表明はアンカーの考え方を一般化したものです。
先読み表明と戻り読み表明はゼロ幅の表明で、文字が
テストしたいものであることを指定します。
先読み表明は C<(?=regexp)> で表され、戻り読み表明は
C<< (?<=fixed-regexp) >> で表されます。
幾つか例を挙げましょう

    $x = "I catch the housecat 'Tom-cat' with catnip";
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?<=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom-cat'
    $x =~ /(?<=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x

=begin original

Note that the parentheses in C<(?=regexp)> and C<< (?<=regexp) >> are
non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead C<(?=regexp)> can match arbitrary regexps, but
lookbehind C<< (?<=fixed-regexp) >> only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
C<< (?<=(ab|bc)) >> is fine, but C<< (?<=(ab)*) >> is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by C<(?!regexp)> and C<< (?<!fixed-regexp) >> respectively.
They evaluate true if the regexps do I<not> match:

=end original

C<(?=regexp)> と C<< (?<=regexp) >> の中にあるカッコが、これらがゼロ幅の
表明であるためにキャプチャを行わないことに注意してください。
したがって、二番目の正規表現ではキャプチャされた部分文字列は
正規表現全体に対応するものになります。
先読み表明 C<(?=regexp)> には任意の正規表現を使うことができますが、
戻り読み表明 C<< (?<=fixed-regexp) >> は固定長の正規表現、たとえば固定長の
文字並びでのみ使うことができます。
このため、C<< (?<=(ab|bc)) >> は大丈夫ですが C<< (?<=(ab)*) >>は使えません。
先読み表明と戻り読み表明の否定形はそれぞれ C<(?!regexp)> と
C<< (?<!fixed-regexp) >> で表されます。
これらはその正規表現がマッチしなかったときに真となります。

    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?<!\s)foo/;  # matches, there is no \s before 'foo'

=begin original

The C<\C> is unsupported in lookbehind, because the already
treacherous definition of C<\C> would become even more so
when going backwards.

=end original

C<\C> は戻り読みでサポートされていません。
なぜなら、C<\C> の定義がすでに当てにならないもので後ろに戻るときには
より一層当てにならないからです。

=begin original

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using C</\s+/> alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:

=end original

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components.
Using C</\s+/> alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:
(TBT)

    $str = "one two - --6-8";
    @toks = split / \s+              # a run of spaces
                  | (?<=\S) (?=-)    # any non-space followed by '-'
                  | (?<=-)  (?=\S)   # a '-' followed by any non-space
                  /x, $str;          # @toks = qw(one two - - - 6 - 8)


=head2 Using independent subexpressions to prevent backtracking

(バックトラッキングの抑制のために独立部分式を使う)

=begin original

I<Independent subexpressions> are regular expressions, in the
context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by C<< (?>regexp) >>.  We can illustrate their behavior by first
considering an ordinary regexp:

=end original

I<独立部分式> (Independent subexpressions )はより大きな正規表現の中で
独立した機能を持った正規表現です。
つまり、より大きな正規表現がマッチすることには関係なく、望む限りの大きな
文字列もしくは望む限りの小さな文字列にマッチしたものを消費します。
独立部分式は C<< (?>regexp) >> で表されます。
これの振る舞いを通常の正規表現を使って説明しましょう:

    $x = "ab";
    $x =~ /a*ab/;  # matches

=begin original

This obviously matches, but in the process of matching, the
subexpression C<a*> first grabbed the C<a>.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, C<a*>
eventually gave back the C<a> and matched the empty string.  Here, what
C<a*> matched was I<dependent> on what the rest of the regexp matched.

=end original

これは明らかにマッチします。
しかし、マッチングのプロセスにおいて部分式 C<a*> は最初に C<a> を
つかみとります。
それを行うことによって、正規表現全体がマッチすることを許さず、そのために
バックトラッキングが起きて C<a*> は C<a> を戻して空文字列にマッチします。
ここで、C<a*> は正規表現の残りの部分のマッチに依存してマッチしました。

=begin original

Contrast that with an independent subexpression:

=end original

独立部分式を使うと対照的に:

    $x =~ /(?>a*)ab/;  # doesn't match!

=begin original

The independent subexpression C<< (?>a*) >> doesn't care about the rest
of the regexp, so it sees an C<a> and grabs it.  Then the rest of the
regexp C<ab> cannot match.  Because C<< (?>a*) >> is independent, there
is no backtracking and the independent subexpression does not give
up its C<a>.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:

=end original

この独立部分式 C<< (?>a*) >> は正規表現の残りの部分を考慮しません。
そのため、C<a> を見つけたらそれをつかみとります。
そして残りの正規表現 C<ab> はマッチできません。
C<< (?>a*) >> は独立しているので、バックトラッキングは行わず、独立部分式は
C<a> を戻すこともありません。
結果として正規表現全体のマッチングは失敗します。
同様の動作が、完全に独立した正規表現においても発生します:

    $x = "ab";
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available

=begin original

Here C<//g> and C<\G> create a 'tag team' handoff of the string from
one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.

=end original

ここで、C<//g> と C<\G> は「タッグチーム」を結成していて、一つの
正規表現から別の正規表現へと文字列を手渡ししています。
独立部分式を持った正規表現はこれと同じようにマッチし、独立部分式に文字列を
手渡しして、それにマッチした文字列を戻します。

=begin original

The ability of an independent subexpression to prevent backtracking
can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:

=end original

バックトラッキングを阻止するという独立部分式の能力はとても便利です。
2 レベルの深さを持つカッコに囲まれたから出ない文字列にマッチさせることを
考えてみましょう。
それは以下のような正規表現になります:

    $x = "abc(de(fg)h";  # unbalanced parentheses
    $x =~ /\( ( [^()]+ | \([^()]*\) )+ \)/x;

=begin original

The regexp matches an open parenthesis, one or more copies of an
alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative C<[^()]+> matching a substring with no
parentheses and the second alternative C<\([^()]*\)>  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form C<(a+|b)+>.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:

=end original

この正規表現は開きかっこ、選択肢にある一つか二つのコピー、そして
閉じかっこにマッチします。
この選択肢は二分岐で、最初の選択肢は括弧のない部分文字列にマッチする
C<[^()]+> で、二番目の選択肢はかっこによって区切られた部分文字列に
マッチする C<\([^()]*\)> です。
この正規表現の問題点は病理学的なものです: C<(a+|b)+> のように非決定的な
量指定子がネストしています。
Part 1 において、ネストした量指定子はマッチに失敗するときには実行に
指数的な時間を要することについて言及しました。
これを防ぐために、不要なバックトラッキングを抑制することが必要となります。
これは内側の量指定子を独立部分式としてやることで行うことができます:

    $x =~ /\( ( (?>[^()]+) | \([^()]*\) )+ \)/x;

=begin original

Here, C<< (?>[^()]+) >> breaks the degeneracy of string partitioning
by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.

=end original

ここで、C<< (?>[^()]+) >> は可能な限りマッチしたものをつかみとって
保持することによって文字列の分割の退行を邪魔しています。
それからマッチは即座に失敗することになります。

=head2 Conditional expressions

(条件式)

=begin original

A I<conditional expression> is a form of if-then-else statement
that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
C<(?(condition)yes-regexp)> and
C<(?(condition)yes-regexp|no-regexp)>.  C<(?(condition)yes-regexp)> is
like an S<C<'if () {}'>> statement in Perl.  If the C<condition> is true,
the C<yes-regexp> will be matched.  If the C<condition> is false, the
C<yes-regexp> will be skipped and Perl will move onto the next regexp
element.  The second form is like an S<C<'if () {} else {}'>> statement
in Perl.  If the C<condition> is true, the C<yes-regexp> will be
matched, otherwise the C<no-regexp> will be matched.

=end original

I<条件式> (conditional expression )はif-the-elseの形式の文で、何らかの
条件に基づいてどちらのパターンをマッチさせるかを選択できます。
条件式には二つのタイプがあります: C<(?(condition)yes-regexp)> と C<(?(condition)yes-regexp|no-regexp)> です。
C<(?(condition)yes-regexp)> は Perl の S<C<'if () {}'>> 文のようなものです。
もし C<condition> が真であれば、C<yes-regexp> がマッチの対象となります。
C<condition> が偽であった場合、C<yes-regexp> はスキップされて、
Perl は次の正規表現要素へと進みます。
二番目の形式は Perl の S<C<'if () {} else {}'>> 文のようなものです。
C<conditon> が真であれば C<yes-regexp> がマッチの対象となり、偽であれば
C<no-regexp> がマッチの対象となります。

=begin original

The C<condition> can have several forms.  The first form is simply an
integer in parentheses C<(integer)>.  It is true if the corresponding
backreference C<\integer> matched earlier in the regexp.  The same
thing can be done with a name associated with a capture buffer, written
as C<< (<name>) >> or C<< ('name') >>.  The second form is a bare
zero width assertion C<(?...)>, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (C<(R)>) or is being called from some capturing group,
referenced either by number (C<(R1)>, C<(R2)>,...) or by name
(C<(R&name)>).

=end original

C<condition> はいくつかのの形式を取ることができます。
最初の形式は単純な整数をカッコでくくったもの C<(integer)> です。
これは対応する後方参照 C<\integer> が先行する正規表現の部分の中で
マッチしていれば真となります。
The same
thing can be done with a name associated with a capture buffer, written
as C<< (<name>) >> or C<< ('name') >>.
二番目の形式はゼロ幅の表明 C<(?...)> で、先読み、戻り読み、もしくは
コード表明 (code assertion 次のセクションで説明します)のいずれかです。
The third set of forms
provides tests that return true if the expression is executed within
a recursion (C<(R)>) or is being called from some capturing group,
referenced either by number (C<(R1)>, C<(R2)>,...) or by name
(C<(R&name)>).
(TBT)

=begin original

The integer or name form of the C<condition> allows us to choose,
with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form C<"$x$x"> or C<"$x$y$y$x">:

=end original

整数または名前形式の C<condition> はより一層の融通性を伴って
選択することを可能にします。
マッチするかどうかは正規表現の先行する部分がマッチするかどうかに依存します。
以下の例は C<"$x$x"> や C<"$x$y$y$x"> という形式の単語を検索します。

    % simple_grep '^(\w+)(\w+)?(?(2)\2\1|\1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu

=begin original

The lookbehind C<condition> allows, along with backreferences,
an earlier part of the match to influence a later part of the
match.  For instance,

=end original

戻り読みの C<condition> は後方参照といっしょで、マッチの先行する部分が
マッチの後ろの部分に影響を及ぼします。
たとえば

    /[ATGC]+(?(?<=AA)G|C)$/;

=begin original

matches a DNA sequence such that it either ends in C<AAG>, or some
other base pair combination and C<C>.  Note that the form is
C<< (?(?<=AA)G|C) >> and not C<< (?((?<=AA))G|C) >>; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.

=end original

これは C<AAG> で終わるかその他の C<C> とのコンビネーションのペアと
なっている DNA シーケンスにマッチします。
この形式は C<< (?(?<=AA)G|C) >> であって、
C<< (?((?<=AA))G|C) >> でないことに注意してください。
先読み、戻り読み、コードの表明に対しては条件部分を囲むカッコは
必要ありません。

=head2 Defining named patterns

=begin original

Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is C<< (?(DEFINE)(?<name>pattern)...) >>.  An insertion
of a named pattern is written as C<(?&name)>.

=end original

Some regular expressions use identical subpatterns in several places.
Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is C<< (?(DEFINE)(?<name>pattern)...) >>.  An insertion
of a named pattern is written as C<(?&name)>.
(TBT)

=begin original

The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.

=end original

The example below illustrates this feature using the pattern for
floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.
(TBT)

   /^ (?&osg)\ * ( (?&int)(?&dec)? | (?&dec) )
      (?: [eE](?&osg)(?&int) )?
    $
    (?(DEFINE)
      (?<osg>[-+]?)         # optional sign
      (?<int>\d++)          # integer
      (?<dec>\.(?&int))     # decimal fraction
    )/x


=head2 Recursive patterns

=begin original

This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
C<(?group-ref)>, the I<pattern> within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained I<within> the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.

=end original

This feature (introduced in Perl 5.10) significantly extends the
power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
C<(?group-ref)>, the I<pattern> within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained I<within> the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.
(TBT)

=begin original

To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.

=end original

To illustrate this feature, we'll design a pattern that matches if
a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.
(TBT)

    /(?: (\w) (?...Here be a palindrome...) \{-1} | \w? )/x

=begin original

Adding C<\W*> at either end to eliminate was is to be ignored, we already
have the full pattern:

=end original

Adding C<\W*> at either end to eliminate was is to be ignored, we already
have the full pattern:
(TBT)

    my $pp = qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix;
    for $s ( "saippuakauppias", "A man, a plan, a canal: Panama!" ){
        print "'$s' is a palindrome\n" if $s =~ /$pp/;
    }

=begin original

In C<(?...)> both absolute and relative backreferences may be used.
The entire pattern can be reinserted with C<(?R)> or C<(?0)>.
If you prefer to name your buffers, you can use C<(?&name)> to
recurse into that buffer.

=end original

In C<(?...)> both absolute and relative backreferences may be used.
The entire pattern can be reinserted with C<(?R)> or C<(?0)>.
If you prefer to name your buffers, you can use C<(?&name)> to
recurse into that buffer.
(TBT)

=head2 A bit of magic: executing Perl code in a regular expression

(ちょっとした魔法: 正規表現の中で Perl のコードを実行する)

=begin original

Normally, regexps are a part of Perl expressions.
I<Code evaluation> expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted C<(?{code})>, with I<code> a string of Perl
statements.

=end original

通常、正規表現は Perl の式の一部です。
I<コード評価> (code evaluation) 式は任意のPerlのコードを正規表現の
一部として使うことができるようにします。
コード評価式は C<(?{code})> で表され、I<code> は Perl の文である文字列です。

=begin original

Be warned that this feature is considered experimental, and may be
changed without notice.

=end original

Be warned that this feature is considered experimental, and may be
changed without notice.
(TBT)

=begin original

Code expressions are zero-width assertions, and the value they return
depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
C<(?(condition)...)>, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
C<$^R>.  The variable C<$^R> can then be used in code expressions later
in the regexp.  Here are some silly examples:

=end original

コード式はゼロ幅の表明で、その値は環境に依存したものです。
そこには二つの可能性があります: コード式が条件式の中で
C<(?(condition)...)> のように使われるかそうでないかです。
もしコード式が条件式に使われていれば、そのコードは評価された後その結果
(最後の文の結果)が真か偽かを決定するのに使われます。
コード式が条件式として使われていなければ、その表明は常に真であり
その結果は特殊変数 C<$^R> に格納されます。
変数 C<$^R> は正規表現の後の部分のコード式で使うことができます。
以下に単純な例を挙げます:

    $x = "abcdef";
    $x =~ /abc(?{print "Hi Mom!";})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print "Hi Mom!";})def/; # doesn't match,
                                         # no 'Hi Mom!'

=begin original

Pay careful attention to the next example:

=end original

次の例に注目してください:

    $x =~ /abc(?{print "Hi Mom!";})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?

=begin original

At first glance, you'd think that it shouldn't print, because obviously
the C<ddd> isn't going to match the target string. But look at this
example:

=end original

ぱっと見て、出力されないとは思わなかったでしょう。
なぜなら C<ddd> は明らかにターゲット文字列に
マッチするものではないからです。
しかし次の例:

    $x =~ /abc(?{print "Hi Mom!";})[d]dd/; # doesn't match,
                                           # but _does_ print

=begin original

Hmm. What happened here? If you've been following along, you know that
the above pattern should be effectively the same as the last one --
enclosing the d in a character class isn't going to change what it
matches. So why does the first not print while the second one does?

=end original

ふーむ。
何が起きたのでしょう? 先のパターンが効果としては最後のものと同じであることをあなたは知っています -- 文字クラスの中に閉じ込められた d はマッチを変えるものではありません。
では、なぜ最初のパターンは出力されないのに二番目のものは出力されたのでしょう?

=begin original

The answer lies in the optimizations the regex engine makes. In the first
case, all the engine sees are plain old characters (aside from the
C<?{}> construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated than it is. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.

=end original

その答えは正規表現エンジンが行う最適化にあります。
最初のケースでは。
エンジンが見ているものは普通の古い文字(C<?{}> 構造は別として) です。
パターンを実際に実行するよりも前にターゲット文字列が 'ddd' という
文字列を含んでいないことがわかるくらい賢いのです。
しかし二番目のケースでは、それよりも複雑なパターンであると
思わせるようなトリックを使いました。
文字クラスを見て、エンジンはマッチするかどうかは実際にパターンを
実行してみなければならないと判断し、その実行の最中にマッチしないことが
わかるよりも前にある print 文にヒットするのです。

=begin original

To take a closer look at how the engine does optimizations, see the
section L<"Pragmas and debugging"> below.

=end original

エンジンがどのように最適化を行うかについては後にあるセクション
L<"Pragmas and debugging"> を参照してください。

=begin original

More fun with C<?{}>:

=end original

More fun with C<?{}>:

    $x =~ /(?{print "Hi Mom!";})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
                                           # prints '1'

=begin original

The bit of magic mentioned in the section title occurs when the regexp
backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using C<local>, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,

=end original

このセクションのタイトルにある The bit of magic というのは
マッチのために検索処理をしているときのバックトラックが
起きたときのことを言っています。
もしバックトラックがコード式をまたいで発生して、C<local> によって
その中に局所化された変数を使っていた場合、コード式による変数の変更は
巻き戻されます!
したがって、グループの中にある文字の数を数えたい場合には

    $x = "aaaa";
    $count = 0;  # initialize 'a' count
    $c = "bob";  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print "'a' count is $count, \$c variable is '$c'\n";

=begin original

This prints

=end original

のようにすることができ、これは

    'a' count is 2, $c variable is 'bob'

=begin original

If we replace the S<C< (?{local $c = $c + 1;})>> with
S<C< (?{$c = $c + 1;})>>, the variable changes are I<not> undone
during backtracking, and we get

=end original

もし S<C< (?{local $c = $c + 1;})>> を S<C< (?{$c = $c + 1;})>> にすると、
バックトラックによって変数の変更は I<巻き戻されず>、結果は
以下のようになります

    'a' count is 4, $c variable is 'bob'

=begin original

Note that only localized variable changes are undone.  Other side
effects of code expression execution are permanent.  Thus

=end original

局所化された変数の変更だけが巻き戻されるということに注意してください。
コード式の別の副作用は恒久的です。
したがって

    $x = "aaaa";
    $x =~ /(a(?{print "Yow\n";}))*aa/;

=begin original

produces

=end original

これは以下の結果となります

   Yow
   Yow
   Yow
   Yow

=begin original

The result C<$^R> is automatically localized, so that it will behave
properly in the presence of backtracking.

=end original

結果である C<$^R> は自動的に局所化されるので、バックトラックが
行われても適切に振舞います。

=begin original

This example uses a code expression in a conditional to match a
definite article, either 'the' in English or 'der|die|das' in German:

=end original

以下の例は、条件にコード式を使って英語の 'the' か
ドイツ語の 'der|die|das' にマッチさせるものです:

    $lang = 'DE';  # use German
    ...
    $text = "das";
    print "matched\n"
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;

=begin original

Note that the syntax here is C<(?(?{...})yes-regexp|no-regexp)>, not
C<(?((?{...}))yes-regexp|no-regexp)>.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.

=end original

ここでの構文が C<(?((?{...}))yes-regexp|no-regexp)> ではなく C<(?(?{...})yes-regexp|no-regexp)> であることに注意してください。
言い換えれば、コード式の場合には条件を囲む余計なかっこは
いらないということです。

=begin original

If you try to use code expressions with interpolating variables, Perl
may surprise you:

=end original

コード式を変数展開と共に使おうとしたならば、Perl は
あなたを驚かせるかもしれません:

    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compile error!
    /foo${pat}bar/;      # compile error!

    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok

=begin original

If a regexp has (1) code expressions and interpolating variables, or
(2) a variable that interpolates a code expression, Perl treats the
regexp as an error. If the code expression is precompiled into a
variable, however, interpolating is ok. The question is, why is this
an error?

=end original

もし正規表現が (1) コード式と変数展開を持っているか、
(2) コード式に展開される変数を持っていたならば、Perl は
その正規表現をエラーとします。
しかしながら、コード式が変数にプリコンパイルされていた場合には、
変数展開は ok です。
疑問は、これがなぜエラーになるかです。

=begin original

The reason is that variable interpolation and code expressions
together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:

=end original

その理由は、変数展開とコード式を組み合わせることでセキュリティ上の
リスクが発生するからです。
この組み合わせは検索エンジンを記述する多くのプログラマがしばしば
ユーザーからの入力を取り、それをダイレクトに変数に押し込むから
危険なのです。

    $regexp = <>;       # read user-supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp

=begin original

If the C<$regexp> variable contains a code expression, the user could
then execute arbitrary Perl code.  For instance, some joker could
search for S<C<system('rm -rf *');>> to erase your files.  In this
sense, the combination of interpolation and code expressions I<taints>
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking S<C<use re 'eval'>>:

=end original

もし変数 C<$regexp> がコード式を含んでいたら、ユーザーは任意の
Perl コードを実行することが可能となります。
たとえば、一部の不心得者が C<system('rm -rf *');> を検索したら、
あなたのファイルを消すことになります。
このため、変数展開とコード式の組み合わせは正規表現を I<汚染する> ものと
みなされます。
そのためデフォルトでは、同じ正規表現の中で変数展開とコード式の両方を
使うことを許していないのです。
もし悪意あるユーザーを考慮しないのであれば、S<C<use re 'eval'>>を
実行することによってセキュリティチェックをバイパスすることが可能です:

    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ 1 })$bar/;   # compiles ok
    /foo${pat}bar/;      # compiles ok

=begin original

Another form of code expression is the I<pattern code expression>.
The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is

=end original

もう一つのコード式は I<パターンコード式>(pattern code expression ) です。
パターンコード式は通常のコード式に似ていますが、コードの評価結果が
正規表現として扱われ、即座にマッチに使われる点が異なります。
単純な例を挙げましょう

    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'


=begin original

This final example contains both ordinary and pattern code
expressions.  It detects whether a binary string C<1101010010001...> has a
Fibonacci spacing 0,1,1,2,3,5,...  of the C<1>'s:

=end original

最後の例はコード式とパターンコード式の両方を含んだものです。
これは 2 進文字列 C<1101010010001...> に、C<1> の
フィボナッチ空白 0,1,1,2,3,5,... があるかを見つけ出します:

    $x = "1101010010001000001";
    $z0 = ''; $z1 = '0';   # initial conditions
    print "It is a Fibonacci sequence\n"
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
		       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf "Largest sequence matched was %d\n", length($z1)-length($z0);

=begin original

Remember that C<$^N> is set to whatever was matched by the last
completed capture group. This prints

=end original

Remember that C<$^N> is set to whatever was matched by the last
completed capture group. This prints
(TBT)

    It is a Fibonacci sequence
    Largest sequence matched was 5

=begin original

Ha! Try that with your garden variety regexp package...

=end original

Ha! Try that with your garden variety regexp package...
(TBT)

=begin original

Note that the variables C<$z0> and C<$z1> are not substituted when the
regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the code expressions are evaluated when Perl
encounters them during the search for a match.

=end original

C<$z0> と C<$z1> という変数は正規表現がコンパイルされたときには、
コード式の外側で通常の変数が使われたときのような置換は
行われないということに注意してください。
コード式は Perlがマッチのために検索を行っているときに
見つかったときに評価が行われます。

=begin original

The regexp without the C<//x> modifier is

=end original

C<//x> 修飾子がない正規表現は

    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/

=begin original

which shows that spaces are still possible in the code parts. Nevertheless,
when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.

=end original

のようになり、
which shows that spaces are still possible in the code parts. Nevertheless,
コード式と条件式を使ったとき、正規表現の拡張された形式は正規表現を生成して
デバッグする必要があるでしょう。

=head2 Backtracking control verbs

=begin original

Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to L<perlre/"Special Backtracking Control Verbs"> for a
detailed description.

=end original

Perl 5.10 introduced a number of control verbs intended to provide
detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to L<perlre/"Special Backtracking Control Verbs"> for a
detailed description.
(TBT)

=begin original

Below is just one example, illustrating the control verb C<(*FAIL)>,
which may be abbreviated as C<(*F)>. If this is inserted in a regexp
it will cause to fail, just like at some mismatch between the pattern
and the string. Processing of the regexp continues like after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
buffers or produce results, it may be necessary to use this in
combination with embedded code.

=end original

Below is just one example, illustrating the control verb C<(*FAIL)>,
which may be abbreviated as C<(*F)>. If this is inserted in a regexp
it will cause to fail, just like at some mismatch between the pattern
and the string. Processing of the regexp continues like after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
buffers or produce results, it may be necessary to use this in
combination with embedded code.
(TBT)

   %count = ();
   "supercalifragilisticexpialidoceous" =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/oi;
   printf "%3d '%s'\n", $count{$_}, $_ for (sort keys %count);

=begin original

The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like C<$count{'a'}++;> is executed, incrementing
the letter's counter. Then C<(*FAIL)> does what it says, and
the regexp  engine proceeds according to the book: as long as the end of
the string  hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the the entire string has been inspected.
(It's remarkable that an alternative solution using something like

=end original

The pattern begins with a class matching a subset of letters.  Whenever
this matches, a statement like C<$count{'a'}++;> is executed, incrementing
the letter's counter. Then C<(*FAIL)> does what it says, and
the regexp  engine proceeds according to the book: as long as the end of
the string  hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the the entire string has been inspected.
(It's remarkable that an alternative solution using something like
(TBT)

   $count{lc($_)}++ for split('', "supercalifragilisticexpialidoceous");
   printf "%3d '%s'\n", $count2{$_}, $_ for ( qw{ a e i o u } );

=begin original

is considerably slower.)

=end original

is considerably slower.)
(TBT)

=head2 Pragmas and debugging

(プラグマとデバッグ)

=begin original

Speaking of debugging, there are several pragmas available to control
and debug regexps in Perl.  We have already encountered one pragma in
the previous section, S<C<use re 'eval';>>, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are

=end original

デバッグに関して、Perlで正規表現を制御したりデバッグするために幾つかの
プラグマがあります。
前のセクションですでに S<C<use re 'eval';>> という正規表現の中で
変数展開とコード式を共存させることを許可するプラグマが登場しています。
他のプラグマには以下のものがあります

    use re 'taint';
    $tainted = <>;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted

=begin original

The C<taint> pragma causes any substrings from a match with a tainted
variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use C<taint> when you are not extracting safe bits, but are
performing some other processing.  Both C<taint> and C<eval> pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.

=end original

C<taint> プラグマは汚染された変数に対するマッチによる部分文字列を
同様に汚染されたものにするというものです。
これは通常の場合では行われず、正規表現はしばしば汚染された変数から
安全な情報を取り出すのに使われています。
安全な情報を取り出すのではないとき C<taint> を使いますが、他の処理を
行います。
プラグマ C<taint> と C<eval> は両方ともレキシカルスコープで、その
プラグマを囲むブロックの最後までしか影響が及びません。

    use re 'debug';
    /^(.*)$/s;       # output debugging info

    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color

=begin original

The global C<debug> and C<debugcolor> pragmas allow one to get
detailed debugging info about regexp compilation and
execution.  C<debugcolor> is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:

=end original

C<debug> プラグマと C<debugcolor> プラグマは正規表現のコンパイルと
実行に関する詳細なデバッグ情報を提供します。
C<debugcolor> は C<debug> と同じですが、デバッグ情報を色付きで
(termcapのカラーシーケンスを出力することのできる)ターミナルに出力します。
以下は出力の例です:

    % perl -e 'use re "debug"; "abc" =~ /a*b+c/;'
    Compiling REx `a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)
    floating `bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx `a*b+c' against `abc'...
    Found floating substr `bc' at offset 1...
    Guessed: match at offset 0
    Matching REx `a*b+c' against `abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: `a*b+c'

=begin original

If you have gotten this far into the tutorial, you can probably guess
what the different parts of the debugging output tell you.  The first
part

=end original

このチュートリアルを読み進めてきたのであれば、デバッグ出力の異なる部分が
あなたに情報を伝えているのではないかと思うかも知れません。
最初の部分

    Compiling REx `a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT <a>(0)
       4: PLUS(7)
       5:   EXACT <b>(0)
       7: EXACT <c>(9)
       9: END(0)

=begin original

describes the compilation stage.  C<STAR(4)> means that there is a
starred object, in this case C<'a'>, and if it matches, goto line 4,
i.e., C<PLUS(7)>.  The middle lines describe some heuristics and
optimizations performed before a match:

=end original

はコンパイルステージのものです。
C<STAR(4)> は star のついたオブジェクト、この場合は C<'a'> があって、
それがマッチした場合には line 4、つまり C<PLUS(7)> へ
移動することを意味しています。
真中の数行はマッチ前の幾つかの発見的手法(heuristics)と
最適化が行われたことを示しています:

    floating `bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx `a*b+c' against `abc'...
    Found floating substr `bc' at offset 1...
    Guessed: match at offset 0

=begin original

Then the match is executed and the remaining lines describe the
process:

=end original

その後でマッチが実行され、残りの行はそのプロセスを説明しています:

    Matching REx `a*b+c' against `abc'
      Setting an EVAL scope, savestack=3
       0 <> <abc>             |  1:  STAR
                               EXACT <a> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 <a> <bc>             |  4:    PLUS
                               EXACT <b> can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 <ab> <c>             |  7:      EXACT <c>
       3 <abc> <>             |  9:      END
    Match successful!
    Freeing REx: `a*b+c'

=begin original

Each step is of the form S<C<< n <x> <y> >>>, with C<< <x> >> the
part of the string matched and C<< <y> >> the part not yet
matched.  The S<C<< |  1:  STAR >>> says that Perl is at line number 1
n the compilation list above.  See
L<perldebguts/"Debugging regular expressions"> for much more detail.

=end original

各ステップは S<C<< n <x> <y> >>> という形式で、C<< <x> >> は
マッチした文字列の部分で、C<< <y> >> はまだマッチしていない部分です。
S<C<< |  1:  STAR >>> は Perl が先のコンパイルリストの中の行番号 1 の
位置にあることを示しています。
詳細は L<perldebguts/"Debugging regular expressions"> を参照してください。

=begin original

An alternative method of debugging regexps is to embed C<print>
statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:

=end original

これとは別の正規表現のデバッグ手法は正規表現の中に C<print> 文を
埋め込むことです。
以下の例は選択肢の中のバックトラッキングを逐一数えるものです:

    "that this" =~ m@(?{print "Start at position ", pos, "\n";})
                     t(?{print "t1\n";})
                     h(?{print "h1\n";})
                     i(?{print "i1\n";})
                     s(?{print "s1\n";})
                         |
                     t(?{print "t2\n";})
                     h(?{print "h2\n";})
                     a(?{print "a2\n";})
                     t(?{print "t2\n";})
                     (?{print "Done at position ", pos, "\n";})
                    @x;

=begin original

prints

=end original

出力は以下のようになります

    Start at position 0
    t1
    h1
    t2
    h2
    a2
    t2
    Done at position 4

=head1 BUGS

=begin original

Code expressions, conditional expressions, and independent expressions
are I<experimental>.  Don't use them in production code.  Yet.

=end original

コード式、条件式、独立式は I<実験的> なものです。
商用のコードでは使わないようにしましょう。
今のところは。

=head1 SEE ALSO

=begin original

This is just a tutorial.  For the full story on Perl regular
expressions, see the L<perlre> regular expressions reference page.

=end original

本ドキュメントはチュートリアルです。
Perl の正規表現に関する完全な説明は正規表現に関する
リファレンスページである L<perlre> を参照してください。

=begin original

For more information on the matching C<m//> and substitution C<s///>
operators, see L<perlop/"Regexp Quote-Like Operators">.  For
information on the C<split> operation, see L<perlfunc/split>.

=end original

マッチング C<m//> や置換 C<s///> に関するより詳細な情報は
L<perlop/"Regexp Quote-Like Operators"> を参照してください。
C<split> 操作に関する情報は L<perlfunc/split> を参照してください。

=begin original

For an excellent all-around resource on the care and feeding of
regular expressions, see the book I<Mastering Regular Expressions> by
Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).

=end original

正規表現に関するすばらしい情報源として Jeffrey Friedl による書籍
I<Mastering Regular Expressions> があります(O'Reillyから出版。
 ISBN 1556592-257-3)。
日本語版は 「詳説 正規表現」ISBN4-87311-130-7 (第二版のもの)。

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 2000 Mark Kvale
All rights reserved.

This document may be distributed under the same terms as Perl itself.

=head2 Acknowledgments

The inspiration for the stop codon DNA example came from the ZIP
code example in chapter 7 of I<Mastering Regular Expressions>.

The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.

=cut

=begin meta

Created: KIMURA Koichi
Updated: Kentaro Shirakata <argrath@ub32.org> (5.10.0-)

=end meta

