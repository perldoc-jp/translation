=encoding euc-jp

=head1 NAME

=begin original

perlvar - Perl predefined variables

=end original

perlvar - Perl で定義済みの変数

=head1 DESCRIPTION

=head2 Predefined Names

(定義済みの変数)

=begin original

The following names have special meaning to Perl.  Most 
punctuation names have reasonable mnemonics, or analogs in the
shells.  Nevertheless, if you wish to use long variable names,
you need only say

=end original

以下の名前は Perl では特別な意味を持ちます。
記号的な名前の多くは記憶法があるか、シェルでの類推が可能です。
それでも長い名前を使用したい場合には

    use English;

=begin original

at the top of your program.  This will alias all the short names to the
long names in the current package.  Some even have medium names,
generally borrowed from B<awk>.

=end original

とプログラムの最初に書いてください。
これは、すべての短い名前の別名として、
カレントパッケージで長い名前を付けるものです。
B<awk> から持ってきた中間的な名前を持っているものもあります。

=begin original

If you don't mind the performance hit, variables that depend on the
currently selected filehandle may instead be set by calling an
appropriate object method on the IO::Handle object.  (Summary lines
below for this contain the word HANDLE.)  First you must say

=end original

性能を気にしないのなら、現在選択されているファイルハンドルに
依存する変数の場合には、代わりに IO::Handle オブジェクトに
関するオブジェクトメソッドを呼び出して設定することができます。
(以下の要約では HANDLE という語を含んでいます。)
まず最初に必ず、

    use IO::Handle;

=begin original

after which you may use either

=end original

と書き、その後で以下のように書くか、

    method HANDLE EXPR

=begin original

or more safely,

=end original

もしくはより安全に以下のように書きます:

    HANDLE->method(EXPR)

=begin original

Each method returns the old value of the IO::Handle attribute.
The methods each take an optional EXPR, which if supplied specifies the
new value for the IO::Handle attribute in question.  If not supplied,
most methods do nothing to the current value--except for
autoflush(), which will assume a 1 for you, just to be different.
Because loading in the IO::Handle class is an expensive operation, you should
learn how to use the regular built-in variables.

=end original

それぞれのメソッドは、IO::Handle 属性の昔の値を返します。
メソッドはそれぞれ EXPR をとることができ、指定した場合には、
問題の IO::Handle 属性の新しい値を指定することになります。
指定しない場合には、多くのメソッドでは現在の値に対して何もしませんが、
autoflush() では 1 を指定されたものとします。
IO::Handle クラスを読み込むのはコストの高い操作なので、
通常の組み込み変数の使い方を覚えるべきです。

=begin original

A few of these variables are considered "read-only".  This means that if
you try to assign to this variable, either directly or indirectly through
a reference, you'll raise a run-time exception.

=end original

これらの変数の中には "read-only" として扱われるものもあります。
つまり、そういった変数に対して、直接にしろ、リファレンスを
介して間接にしろ、代入を行なおうとした場合には、実行時に
例外処理が起動されます。

=begin original

The following list is ordered by scalar variables first, then the
arrays, then the hashes.

=end original

以下のリストはまずスカラ変数、それから配列、ハッシュの順に
並んでいます。

=over 8

=item $ARG

=item $_

=begin original

The default input and pattern-searching space.  The following pairs are
equivalent:

=end original

デフォルトの入力とパターン検索のスペース。
以下の 2つは同値です:

    while (<>) {...}	# equivalent only in while!
    while (defined($_ = <>)) {...}

    /^Subject:/
    $_ =~ /^Subject:/

    tr/a-z/A-Z/
    $_ =~ tr/a-z/A-Z/

    chomp
    chomp($_)

=begin original

Here are the places where Perl will assume $_ even if you
don't use it:

=end original

Perl が(あなたが使いたくなくても) $_ を仮定する場合がいくつかあります。

=over 3

=item *

=begin original

Various unary functions, including functions like ord() and int(), as well
as the all file tests (C<-f>, C<-d>) except for C<-t>, which defaults to
STDIN.

=end original

様々な単項関数。ord() や int()、また C<-t> 以外の全ての
ファイルテスト (C<-f>, C<-d>)など。C<-t> のデフォルトは STDIN です。

=item *

=begin original

Various list functions like print() and unlink().

=end original

print() や unlink() などの様々なリスト関数。

=item *

=begin original

The pattern matching operations C<m//>, C<s///>, and C<tr///> when used
without an C<=~> operator.

=end original

C<=~> 演算子なしで用いられたパターンマッチ演算 C<m//>, C<s///>, C<tr///>。

=item *

=begin original

The default iterator variable in a C<foreach> loop if no other
variable is supplied.

=end original

C<foreach> ループでの他の変数が補われなかった場合のデフォルトの
繰り返し変数。

=item *

=begin original

The implicit iterator variable in the grep() and map() functions.

=end original

grep() 関数と map() 関数の暗黙の繰り返し変数。

=item *

=begin original

The default place to put an input record when a C<< <FH> >>
operation's result is tested by itself as the sole criterion of a C<while>
test.  Outside a C<while> test, this will not happen.

=end original

C<< <FH> >> が単独で C<while> テストでテストされた場合の
結果を入れるデフォルトの場所。
C<while> テスト以外ではこれは起こりません。

=back

=begin original

(Mnemonic: underline is understood in certain operations.)

=end original

(記憶法: 下線はある操作を覚えるためのもの。)

=back

=over 8

=item $<I<digits>>

=begin original

Contains the subpattern from the corresponding set of capturing
parentheses from the last pattern match, not counting patterns
matched in nested blocks that have been exited already.  (Mnemonic:
like \digits.)  These variables are all read-only and dynamically
scoped to the current BLOCK.

=end original

最後のパターンマッチで対応する括弧のサブパターンにマッチした
文字列が入っているが、既に抜けてしまったブロックでの
パターンマッチは勘定に入れない。
(記憶法: \(数字) のようなもの。)
これらの変数はすべて read-onlyで、現在の BLOCK に動的なスコープを持ちます。

=item $MATCH

=item $&

=begin original

The string matched by the last successful pattern match (not counting
any matches hidden within a BLOCK or eval() enclosed by the current
BLOCK).  (Mnemonic: like & in some editors.)  This variable is read-only
and dynamically scoped to the current BLOCK.

=end original

最後に成功したパターンマッチでマッチした文字列 (現在の
BLOCK で囲まれた BLOCK や eval() で隠れている部分でのマッチは
勘定に入れない)。
(記憶法: あるエディタの & ようなもの。) 
この変数は read-only で、現在の BLOCK に動的なスコープを持ちます。

=begin original

The use of this variable anywhere in a program imposes a considerable
performance penalty on all regular expression matches.  See L<BUGS>.

=end original

この変数をプログラムのどこかで使うと、プログラム中の全ての正規表現
マッチングにおいてかなりの性能低下を引き起こします。
L<BUGS> を参照して下さい。

=item $PREMATCH

=item $`

=begin original

The string preceding whatever was matched by the last successful
pattern match (not counting any matches hidden within a BLOCK or eval
enclosed by the current BLOCK).  (Mnemonic: C<`> often precedes a quoted
string.)  This variable is read-only.

=end original

最後の成功したパターンマッチ (現在のBLOCK で囲まれた
BLOCK や eval() に隠れている部分でのマッチは勘定に入れない) で
マッチした部分の前の文字列。
(記憶法: C<`> は多くの場合クォートされた文字列の前にある。)
この変数は read-only です。

=begin original

The use of this variable anywhere in a program imposes a considerable
performance penalty on all regular expression matches.  See L<BUGS>.

=end original

この変数をプログラムのどこかで使うと、プログラム中の全ての正規表現
マッチングにおいてかなりの性能低下を引き起こします。
L<BUGS> を参照して下さい。

=item $POSTMATCH

=item $'

=begin original

The string following whatever was matched by the last successful
pattern match (not counting any matches hidden within a BLOCK or eval()
enclosed by the current BLOCK).  (Mnemonic: C<'> often follows a quoted
string.)  Example:

=end original

最後の成功したパターンマッチ (現在のBLOCK で囲まれた
BLOCK や eval() に隠れている部分でのマッチは勘定に入れない) で
マッチした部分に続く文字列。
(記憶法: C<'> は多くの場合クォートされた文字列の後にある。)　例:

    $_ = 'abcdefghi';
    /def/;
    print "$`:$&:$'\n";  	# prints abc:def:ghi

=begin original

This variable is read-only and dynamically scoped to the current BLOCK.

=end original

この変数は read-only で、現在の BLOCK に動的なスコープを持ちます。

=begin original

The use of this variable anywhere in a program imposes a considerable
performance penalty on all regular expression matches.  See L<BUGS>.

=end original

この変数をプログラムのどこかで使うと、プログラム中の全ての正規表現
マッチングにおいてかなりの性能低下を引き起こします。
L<BUGS> を参照して下さい。

=item $LAST_PAREN_MATCH

=item $+

=begin original

The last bracket matched by the last search pattern.  This is useful if
you don't know which one of a set of alternative patterns matched.  For
example:

=end original

最後に検索されたパターンの最後の括弧にマッチした文字列。
これはいくつかの選択肢の中でどれがマッチするのか
わからないような場合に使うと便利です。たとえば:

    /Version: (.*)|Revision: (.*)/ && ($rev = $+);

=begin original

(Mnemonic: be positive and forward looking.)
This variable is read-only and dynamically scoped to the current BLOCK.

=end original

(記憶法: ポジティブで前向き。)
この変数は read-only で、現在の BLOCK に動的なスコープを持ちます。

=item @LAST_MATCH_END

=item @+

=begin original

This array holds the offsets of the ends of the last successful
submatches in the currently active dynamic scope.  C<$+[0]> is
the offset into the string of the end of the entire match.  This
is the same value as what the C<pos> function returns when called
on the variable that was matched against.  The I<n>th element
of this array holds the offset of the I<n>th submatch, so
C<$+[1]> is the offset past where $1 ends, C<$+[2]> the offset
past where $2 ends, and so on.  You can use C<$#+> to determine
how many subgroups were in the last successful match.  See the
examples given for the C<@-> variable.

=end original

この配列は、現在アクティブな動的スコープで最後に成功した
サブマッチの最後へのオフセットを保持します。
C<$+[0]> はマッチ全体の文字列の最後へのオフセットです。
これはマッチした変数に対して C<pos> 関数を呼び出したときの
返り値と同じです。
この配列の I<n> 番目の要素は I<n> 番目のサブマッチのオフセットを
保持していますので、C<$+[1]> は過去の $1 の終わりのオフセット、
C<$+[2]> は $2 のオフセット、という形になります。
C<$#+> は最後に成功したマッチでいくつサブグループがあるかを
決定するのに使えます。
C<@-> 変数の例を参照して下さい。

=item $MULTILINE_MATCHING

=item $*

=begin original

Set to a non-zero integer value to do multi-line matching within a
string, 0 (or undefined) to tell Perl that it can assume that strings
contain a single line, for the purpose of optimizing pattern matches.
Pattern matches on strings containing multiple newlines can produce
confusing results when C<$*> is 0 or undefined. Default is undefined.
(Mnemonic: * matches multiple things.) This variable influences the
interpretation of only C<^> and C<$>. A literal newline can be searched
for even when C<$* == 0>.

=end original

文字列中で複数行マッチを行なうために非ゼロに設定し、
0 (または undef)にすると、Perl が文字列に 1 行しか無いと仮定して、
ある種のパターンマッチに関する最適化を行なうようになります。
複数の改行を含む文字列でのパターンマッチを
C<$*> が 0 または undef のまま行なうと結果は信用の
ないものになります。
デフォルトでは undef になっています。
(記憶法: * は複数のものにマッチします。)
この変数は C<^> と C<$> の解釈にのみ影響します。
リテラルの改行文字は、C<$* == 0> であっても検索することが可能です。

=begin original

Use of C<$*> is deprecated in modern Perl, supplanted by 
the C</s> and C</m> modifiers on pattern matching.

=end original

最近の Perl では "$*" を使わないようにしてください。
パターンマッチの C</s> と C</m> の修飾子に取って代わられています。

=begin original

Assigning a non-numerical value to C<$*> triggers a warning (and makes
C<$*> act if C<$* == 0>), while assigning a numerical value to C<$*>
makes that an implicit C<int> is applied on the value.

=end original

数値でない値を C<$*> に代入すると警告を引き起こします
(そして C<$*> は C<$* == 0> のように振る舞います)。
一方数値を C<$*> に代入すると暗黙に C<int> が値に適用されます。

=item input_line_number HANDLE EXPR

=item $INPUT_LINE_NUMBER

=item $NR

=item $.

=begin original

The current input record number for the last file handle from which
you just read() (or called a C<seek> or C<tell> on).  The value
may be different from the actual physical line number in the file,
depending on what notion of "line" is in effect--see C<$/> on how
to change that.  An explicit close on a filehandle resets the line
number.  Because C<< <> >> never does an explicit close, line
numbers increase across ARGV files (but see examples in L<perlfunc/eof>).
Consider this variable read-only: setting it does not reposition
the seek pointer; you'll have to do that on your own.  Localizing C<$.>
has the effect of also localizing Perl's notion of "the last read
filehandle".  (Mnemonic: many programs use "." to mean the current line
number.)

=end original

最後にread() (または C<seek> または C<tell>)を
行なったファイルハンドルの現在の入力レコード番号。
この値はファイルの実際の物理行番号とは異なるかもしれません。
「行」とは何かによります。
これを変えるには C<$/> を参照して下さい。
明示的にファイルハンドルをクローズした場合に、行番号がリセットされます。
C<< <> >> 構文では明示的にクローズを行ないませんから、ARGV の
ファイルに跨って行番号が数えられることになります (が、
L<perlfunc/eof> の例を参照してください)。
この変数は読み込み専用と考えてください。
値を設置してもシークポインタは移動しません。自力でする必要があります。
C<$.>を local 化すると、Perl の「最後に読んだファイルハンドル」を
local 化する効果があります。
(記憶法: 多くのプログラムで "." が現在行番号を示すように使われています。)

=item input_record_separator HANDLE EXPR

=item $INPUT_RECORD_SEPARATOR

=item $RS

=item $/

=begin original

The input record separator, newline by default.  This 
influences Perl's idea of what a "line" is.  Works like B<awk>'s RS
variable, including treating empty lines as a terminator if set to
the null string.  (An empty line cannot contain any spaces
or tabs.)  You may set it to a multi-character string to match a
multi-character terminator, or to C<undef> to read through the end
of file.  Setting it to C<"\n\n"> means something slightly
different than setting to C<"">, if the file contains consecutive
empty lines.  Setting to C<""> will treat two or more consecutive
empty lines as a single empty line.  Setting to C<"\n\n"> will
blindly assume that the next input character belongs to the next
paragraph, even if it's a newline.  (Mnemonic: / delimits
line boundaries when quoting poetry.)

=end original

入力レコードセパレータで、デフォルトでは改行文字。
これは Perl での「行」とは何か、ということに影響を与えます。
空文字列に設定されると、空行をセパレータとして扱うことを
含めて、B<awk> の変数 RS のように働きます
(空行はスペースやタブを含んでいてはいけません)。
複数文字の区切文字を示すために、文字列を設定することもできます。
また、ファイルの最後まで読み込むために undef を指定することもできます。
この変数に C<"\n\n"> を設定すると、空行が続く場合において、
C<""> を設定した場合とわずかに違う動作をするようになります。
C<""> を設定した場合には、複数の空行も 1 つの空行であるかのように扱います。
C<"\n\n"> を設定した場合には、単純に次の文字が (たとえ改行文字であっても)
次の段落に含まれるものとして扱います。
(記憶法: /は、詩を引用するときに、行の区切りを示します。)

    undef $/;		# enable "slurp" mode
    $_ = <FH>;		# whole file now here
    s/\n[ \t]+/ /g;

=begin original

Remember: the value of C<$/> is a string, not a regex.  B<awk> has to be
better for something. :-)

=end original

注意: C<$/> は文字列であり、正規表現ではありません。
B<awk> は何かもっとうまくやらなくてはいけません。:-)

=begin original

Setting C<$/> to a reference to an integer, scalar containing an integer, or
scalar that's convertible to an integer will attempt to read records
instead of lines, with the maximum record size being the referenced
integer.  So this:

=end original

C<$/> に整数、整数を含むスカラ、整数に変換できるスカラのいずれかへの
リファレンスをセットすると、行を読む代わりにレコードを読もうとします。
この場合、最大レコードサイズはリファレンス先の整数値となります。つまり:

    $/ = \32768; # or \"32768", or \$var_containing_32768
    open(FILE, $myfile);
    $_ = <FILE>;

=begin original

will read a record of no more than 32768 bytes from FILE.  If you're
not reading from a record-oriented file (or your OS doesn't have
record-oriented files), then you'll likely get a full chunk of data
with every read.  If a record is larger than the record size you've
set, you'll get the record back in pieces.

=end original

これは FILE から 32768 バイトを超えないようにレコードを読み込みます。
もしレコード指向のファイルを読み込まない場合
(あるいは OS がレコード指向ファイルを持たない場合)、
読み込み毎にデータのチャンク全部を取り込みます。
もしレコードがセットしたレコードサイズより大きい場合、
レコードの部分を取り込みます。

=begin original

On VMS, record reads are done with the equivalent of C<sysread>,
so it's best not to mix record and non-record reads on the same
file.  (This is unlikely to be a problem, because any file you'd
want to read in record mode is probably unusable in line mode.)
Non-VMS systems do normal I/O, so it's safe to mix record and
non-record reads of a file.

=end original

VMS では、レコード読み込みは C<sysread> と等価に行われますので、
レコード読み込みと非レコード読み込みを同じファイルで混ぜないのが
最善です。(これはあまり問題になりません。なぜなら
レコード読み込みしたいファイルは多分行モードでは使えないものだからです。)
VMS 以外のシステムでは普通の I/O を使いますので、
同じファイルのレコード読み込みと非レコード読み込みを混ぜても安全です。

=begin original

See also L<perlport/"Newlines">.  Also see C<$.>.

=end original

L<perlport/"Newlines"> と C<$.> も参照してください。

=item autoflush HANDLE EXPR

=item $OUTPUT_AUTOFLUSH

=item $|

=begin original

If set to nonzero, forces a flush right away and after every write
or print on the currently selected output channel.  Default is 0
(regardless of whether the channel is really buffered by the
system or not; C<$|> tells you only whether you've asked Perl
explicitly to flush after each write).  STDOUT will
typically be line buffered if output is to the terminal and block
buffered otherwise.  Setting this variable is useful primarily when
you are outputting to a pipe or socket, such as when you are running
a Perl program under B<rsh> and want to see the output as it's
happening.  This has no effect on input buffering.  See L<perlfunc/getc>
for that.  (Mnemonic: when you want your pipes to be piping hot.)

=end original

0 以外に設定されると、
その時点で選択されている出力チャネルを
直ちにその場でフラッシュし、
さらに write や print を行なうごとに、強制的にフラッシュします。
デフォルトでは 0 となっています
(チャンネルが実際にシステムによってバッファリングされているかどうかは
関知しません。C<$|> は Perl が明示的に毎回書き込みの後に
フラッシュするかどうかのみを示します)。
STDOUT は通常では、端末への出力時には行バッファリング、
それ以外ではブロックバッファリングであることに注意してください。
これは、Perl のスクリプトを rsh 配下で実行して、
実行状況を確認したい場合のように、パイプやソケットに出力するときに特に便利でしょう。
これは入力バッファリングには何の影響も与えません。
(記憶法: パイプをホットな状態にしておくために使う。)

=item output_field_separator HANDLE EXPR

=item $OUTPUT_FIELD_SEPARATOR

=item $OFS

=item $,

=begin original

The output field separator for the print operator.  Ordinarily the
print operator simply prints out its arguments without further
adornment.  To get behavior more like B<awk>, set this variable as
you would set B<awk>'s OFS variable to specify what is printed
between fields.  (Mnemonic: what is printed when there is a "," in
your print statement.)

=end original

print 演算子のための出力フィールドセパレータ。
通常 print 演算子は、引数を修飾なしで単純に印字します。
より、B<awk> に近い動作をさせるには、
フィールドの区切りとして印字されるものとして B<awk> の
変数 OFS に設定するものを、この変数に設定します。
(記憶法: print 文で "," を書いた場所に印字されるもの。)

=item output_record_separator HANDLE EXPR

=item $OUTPUT_RECORD_SEPARATOR

=item $ORS

=item $\

=begin original

The output record separator for the print operator.  Ordinarily the
print operator simply prints out its arguments as is, with no
trailing newline or other end-of-record string added.  To get
behavior more like B<awk>, set this variable as you would set
B<awk>'s ORS variable to specify what is printed at the end of the
print.  (Mnemonic: you set C<$\> instead of adding "\n" at the
end of the print.  Also, it's just like C<$/>, but it's what you
get "back" from Perl.)

=end original

print 演算子のための出力レコードセパレータ。
通常print 演算子は、引数を単純に印字し、
改行などレコード終わりの文字列をつけません。
より B<awk> に近い動作をさせるには、
print の最後に印字されるものとして B<awk> の変数 ORS に
設定するものを、この変数に設定します。
(記憶法: print の最後に "\n" を付け加える代わりに C<$\> を設定する。
また、C<$/> に似通っているが、Perl から「バック」されるものです。)

=item $LIST_SEPARATOR

=item $"

=begin original

This is like C<$,> except that it applies to array and slice values
interpolated into a double-quoted string (or similar interpreted
string).  Default is a space.  (Mnemonic: obvious, I think.)

=end original

C<$,> と同様ですが、これは 2 重引用符で括られた文字列
(または、同様に扱われる文字列) 内で配列とスライスの値が展開される
際に適用されます。
デフォルトではスペースになっています。(記憶法: 明らかでしょう。)

=item $SUBSCRIPT_SEPARATOR

=item $SUBSEP

=item $;

=begin original

The subscript separator for multidimensional array emulation.  If you
refer to a hash element as

    $foo{$a,$b,$c}

it really means

    $foo{join($;, $a, $b, $c)}

But don't put

    @foo{$a,$b,$c}	# a slice--note the @

which means

    ($foo{$a},$foo{$b},$foo{$c})

=end original

多次元配列のエミュレートのための添え字の区切文字。
ハッシュの要素を

    $foo{$a,$b,$c}

のようにして参照すると、実際には

    $foo{join($;, $a, $b, $c)}

という意味になります。　しかし、

    @foo{$a,$b,$c}      # スライス -- @ に注意

としてはいけません。これは以下の意味になります。

    ($foo{$a},$foo{$b},$foo{$c})

=begin original

Default is "\034", the same as SUBSEP in B<awk>.  If your
keys contain binary data there might not be any safe value for C<$;>.
(Mnemonic: comma (the syntactic subscript separator) is a
semi-semicolon.  Yeah, I know, it's pretty lame, but C<$,> is already
taken for something more important.)

=end original

デフォルトは "\034" で、C<awk> の SUBSEP と同じです。
使おうとしている key の値がバイナリのデータを含むならば、
C<$;> に設定する安全な値などはないことになります。
(記憶法: コンマ (構文上の添え字区切り文字) は
セミ−セミコロンなのです。
ええ、詭弁だとはわかってますが、C<$,> はもう既にもっと
重要な任務を持ってるんです。)

=begin original

Consider using "real" multidimensional arrays as described
in L<perllol>.

=end original

L<perllol> で記述している「本物の」多次元配列を使うようにしてください。

=item $OFMT

=item $#

=begin original

The output format for printed numbers.  This variable is a half-hearted
attempt to emulate B<awk>'s OFMT variable.  There are times, however,
when B<awk> and Perl have differing notions of what counts as 
numeric.  The initial value is "%.I<n>g", where I<n> is the value
of the macro DBL_DIG from your system's F<float.h>.  This is different from
B<awk>'s default OFMT setting of "%.6g", so you need to set C<$#>
explicitly to get B<awk>'s value.  (Mnemonic: # is the number sign.)

=end original

数字を印字する際の出力フォーマット。
この変数は、不十分ではありますが、B<awk> の変数 OFMT を
エミュレートしようとするものです。
しかしながら、B<awk> と Perl は異なる記法で数値を表わしています。
また、初期値は"%.I<n>g" で、ここで I<n> はシステムの F<float.h> で
定義されているマクロ DBL_DIG の値です。
これはB<awk> のOFMT のデフォルト値である "%.6g" と異なっていますので、
awk での値を得るには、明示的に C<$#> を設定する必要があります。
(記憶法: # は数値記号です。)

=begin original

Use of C<$#> is deprecated.

=end original

C<$#> は古いものなので使わないようにしてください。

=item format_page_number HANDLE EXPR

=item $FORMAT_PAGE_NUMBER

=item $%

=begin original

The current page number of the currently selected output channel.
Used with formats.
(Mnemonic: % is page number in B<nroff>.)

=end original

その時点で選択されている出力チャネルの、その時点でのページ番号。
フォーマットで用いられます。
(記憶法: % は、B<nroff> でのページ番号です。)

=item format_lines_per_page HANDLE EXPR

=item $FORMAT_LINES_PER_PAGE

=item $=

=begin original

The current page length (printable lines) of the currently selected
output channel.  Default is 60.  
Used with formats.
(Mnemonic: = has horizontal lines.)

=end original

その時点で選択されている出力チャネルの、その時点での
ページ長 (印字可能行数)。デフォルトは 60 です。
フォーマットで用いられます。
(記憶法: = には複数の水平線 (行) が含まれます。)

=item format_lines_left HANDLE EXPR

=item $FORMAT_LINES_LEFT

=item $-

=begin original

The number of lines left on the page of the currently selected output
channel.  
Used with formats.
(Mnemonic: lines_on_page - lines_printed.)

=end original

その時点で選択されている出力チャネルの、ページに残っている行数。
フォーマットで用いられます。
(記憶法: "ページ行数" - "印字済み行数")

=item @LAST_MATCH_START

=item @-

=begin original

$-[0] is the offset of the start of the last successful match.
C<$-[>I<n>C<]> is the offset of the start of the substring matched by
I<n>-th subpattern, or undef if the subpattern did not match.

=end original

$-[0] は最後に成功したマッチの先頭のオフセットです。
C<$-[>I<n>C<]> は I<n> 番目のサブパターンにマッチした部分文字列の
先頭のオフセットです。サブパターンがマッチしなかった場合は undef です。

=begin original

Thus after a match against $_, $& coincides with C<substr $_, $-[0],
$+[0] - $-[0]>.  Similarly, C<$>I<n> coincides with C<substr $_, $-[>I<n>C<],
$+[>I<n>C<] - $-[>I<n>C<]> if C<$-[>I<n>C<]> is defined, and $+ coincides with
C<substr $_, $-[$#-], $+[$#-]>.  One can use C<$#-> to find the last
matched subgroup in the last successful match.  Contrast with
C<$#+>, the number of subgroups in the regular expression.  Compare
with C<@+>.

=end original

従って $_ のマッチの後、$& は C<substr $_, $-[0], $+[0] - $-[0]> と
一致します。同様に、C<$>I<n> は、C<$-[>I<n>C<]> が定義されていれば
C<substr $_, $-[>I<n>C<], $+[>I<n>C<] - $-[>I<n>C<]> と一致し、
$+ は C<substr $_, $-[$#-], $+[$#-]> と一致します。
C<$#-> は直前に成功したマッチで最後のマッチしたサブグループを
探すのに使えます。
正規表現でのサブグループの数である C<$#+> と対照的です。
C<@+> と比較してください。

=begin original

This array holds the offsets of the beginnings of the last
successful submatches in the currently active dynamic scope.
C<$-[0]> is the offset into the string of the beginning of the
entire match.  The I<n>th element of this array holds the offset
of the I<n>th submatch, so C<$+[1]> is the offset where $1
begins, C<$+[2]> the offset where $2 begins, and so on.
You can use C<$#-> to determine how many subgroups were in the
last successful match.  Compare with the C<@+> variable.

=end original

この配列は現在アクティブな動的スコープ内で最後に成功した
サブマッチの先頭位置のオフセットを保持します。
C<$-[0]> はマッチ全体の先頭の文字列へのオフセットです。
この配列の I<n> 番目の要素は I<n> 番目のサブマッチへの
オフセットを保持しますので、C<$+[1]> は $1 の先頭への
オフセット、C<$+[2]> は $2 の先頭へのオフセット、などとなります。
C<$#-> を、最後に成功したマッチでいくつのサブグループがあるのかを
決定するのに使えます。
C<@+> 変数と比較してください。

=begin original

After a match against some variable $var:

=end original

ある変数 $var でマッチした後、以下のようになります。

=over 5

=begin original

=item C<$`> is the same as C<substr($var, 0, $-[0])>

=item C<$&> is the same as C<substr($var, $-[0], $+[0] - $-[0])>

=item C<$'> is the same as C<substr($var, $+[0])>

=item C<$1> is the same as C<substr($var, $-[1], $+[1] - $-[1])>  

=item C<$2> is the same as C<substr($var, $-[2], $+[2] - $-[2])>

=item C<$3> is the same as C<substr $var, $-[3], $+[3] - $-[3])>

=end original

=item C<$`> は C<substr($var, 0, $-[0])> と同じです。

=item C<$&> は C<substr($var, $-[0], $+[0] - $-[0])> と同じです。

=item C<$'> は C<substr($var, $+[0])> と同じです。

=item C<$1> は C<substr($var, $-[1], $+[1] - $-[1])> と同じです。

=item C<$2> は C<substr($var, $-[2], $+[2] - $-[2])> と同じです。

=item C<$3> は C<substr $var, $-[3], $+[3] - $-[3])> と同じです。


=back

=item format_name HANDLE EXPR

=item $FORMAT_NAME

=item $~

=begin original

The name of the current report format for the currently selected output
channel.  Default is the name of the filehandle.  (Mnemonic: brother to
C<$^>.)

=end original

その時点で選択されている出力チャネルの、その時点でのフォーマット名。
デフォルトでは、ファイルハンドルと同名です。
(記憶法: C<$^> の兄弟。)

=item format_top_name HANDLE EXPR

=item $FORMAT_TOP_NAME

=item $^

=begin original

The name of the current top-of-page format for the currently selected
output channel.  Default is the name of the filehandle with _TOP
appended.  (Mnemonic: points to top of page.)

=end original

その時点で選択されている出力チャネルの、その時点での
ページ先頭フォーマット名。
デフォルトでは、ファイルハンドル名に _TOP を続けたもの。
(記憶法: ページの先頭へのポインタ。)

=item format_line_break_characters HANDLE EXPR

=item $FORMAT_LINE_BREAK_CHARACTERS

=item $:

=begin original

The current set of characters after which a string may be broken to
fill continuation fields (starting with ^) in a format.  Default is
S<" \n-">, to break on whitespace or hyphens.  (Mnemonic: a "colon" in
poetry is a part of a line.)

=end original

フォーマットの充填継続フィールド (^ で始まるもの) への
文字列で行分割を許す文字集合。
デフォルトは S<" \n-"> で空白か改行の後で行分割が可能となっています。
(記憶法: 詩では「コロン」は、行の一部。)

=item format_formfeed HANDLE EXPR

=item $FORMAT_FORMFEED

=item $^L

=begin original

What formats output as a form feed.  Default is \f.

=end original

フォーマット出力で、改ページのために出力されるもの。
デフォルトは \f。

=item $ACCUMULATOR

=item $^A

=begin original

The current value of the write() accumulator for format() lines.  A format
contains formline() calls that put their result into C<$^A>.  After
calling its format, write() prints out the contents of C<$^A> and empties.
So you never really see the contents of C<$^A> unless you call
formline() yourself and then look at it.  See L<perlform> and
L<perlfunc/formline()>.

=end original

format() 行のための、その時点での write() アキュムレータの値。
format には、C<$^A> に結果を残す、formline() 呼び出しが含まれます。
自分のフォーマットを呼び出した後で、
write() は C<$^A> の内容を出力してから消去します。
したがって、自分で formline() を呼び出すのでなければ、
C<$^A> の値が見えることはありません。
L<perlform> と L<perlfunc/formline()> を参照してください。

=item $CHILD_ERROR

=item $?

=begin original

The status returned by the last pipe close, backtick (C<``>) command,
successful call to wait() or waitpid(), or from the system()
operator.  This is just the 16-bit status word returned by the
wait() system call (or else is made up to look like it).  Thus, the
exit value of the subprocess is really (C<<< $? >> 8 >>>), and
C<$? & 127> gives which signal, if any, the process died from, and
C<$? & 128> reports whether there was a core dump.  (Mnemonic:
similar to B<sh> and B<ksh>.)

=end original

最後に close したパイプ、バッククォート (C<``>) コマンド、
成功した wait() または waitpid() 呼び出し、system() 演算子が返したステータス。
このステータスワードは wait() システムコールが返した
16 ビットのステータス(またはそのように見えるもの)です。
従ってサブプロセスの exit 値は、実際には (C<<< $? >> 8 >>>)
で、C<$? & 127> は、もしあれば、そのプロセスを止めたシグナルで、
C<$? & 128> はコアダンプがあるかどうかを示します。
(記憶法: B<sh> や B<ksh> と同様。)

=begin original

Additionally, if the C<h_errno> variable is supported in C, its value
is returned via $? if any C<gethost*()> function fails.

=end original

さらに、C で C<h_errno> 変数に対応している場合は、
C<gethost*()> が失敗したときに $? を通して返されます。

=begin original

If you have installed a signal handler for C<SIGCHLD>, the
value of C<$?> will usually be wrong outside that handler.

=end original

C<SIGCHLD> のシグナルハンドラを設定した場合、
C<$?> の値は通常ハンドラの外側では正しくない値となります。

=begin original

Inside an C<END> subroutine C<$?> contains the value that is going to be
given to C<exit()>.  You can modify C<$?> in an C<END> subroutine to
change the exit status of your program.  For example:

=end original


    END {
	$? = 1 if $? == 255;  # die would make it 255
    } 

=begin original

Under VMS, the pragma C<use vmsish 'status'> makes C<$?> reflect the
actual VMS exit status, instead of the default emulation of POSIX
status.

=end original

VMS では、C<use vmsish 'status'> を指定すると、
C<$?> はPOSIX ステータスをエミュレートしたものではなく、
実際の VMS 終了ステータスを反映します。

=begin original

Also see L<Error Indicators>.

=end original

L<Error Indicators> も参照して下さい。

=item $OS_ERROR

=item $ERRNO

=item $!

=begin original

If used numerically, yields the current value of the C C<errno>
variable, with all the usual caveats.  (This means that you shouldn't
depend on the value of C<$!> to be anything in particular unless
you've gotten a specific error return indicating a system error.)
If used an a string, yields the corresponding system error string.
You can assign a number to C<$!> to set I<errno> if, for instance,
you want C<"$!"> to return the string for error I<n>, or you want
to set the exit value for the die() operator.  (Mnemonic: What just
went bang?)

=end original

数値として使われると、その時点の C の C<errno> 変数の値が
(通常の注意事項と共に) 得られます。
(これは、システムエラーを示す特定のエラーが得られた場合でもなければ、
C<$!> の値が、特に何かを示すものであると、頼ってはならないということです。)
文字列として使われると、対応するシステムエラーのメッセージ文字列が得られます。
たとえば、C<$!> にエラーの文字列を返して欲しいならば、あるいは、
die() 演算子の exit 値を設定するために、I<errno> を設定するため 
C<$!> へ代入を行なうことが可能です。
(記憶法: 何が bang(!) したか。)

=begin original

Also see L<Error Indicators>.

=end original

L<Error Indicators> も参照して下さい。

=item $EXTENDED_OS_ERROR

=item $^E

=begin original

Error information specific to the current operating system.  At
the moment, this differs from C<$!> under only VMS, OS/2, and Win32
(and for MacPerl).  On all other platforms, C<$^E> is always just
the same as C<$!>.

=end original

現在のオペレーティングシステムに特化したエラー情報です。
現在のところ、VMS, OS/2, Win32 (と MacPerl) のみで
C<$!> と異なる値をもちます。
その他のプラットフォームでは、C<$^E> はいつも C<$!> と同じです。

=begin original

Under VMS, C<$^E> provides the VMS status value from the last
system error.  This is more specific information about the last
system error than that provided by C<$!>.  This is particularly
important when C<$!> is set to B<EVMSERR>.

=end original

VMS では、C<$^E> は最後のシステムエラーの VMS ステータス値です。
これは、最後のシステムエラーについて C<$!> で提供されるものより
具体的な情報を示します。
これは特に C<$!> が B<EVMSERR> にセットされた場合に重要です。

=begin original

Under OS/2, C<$^E> is set to the error code of the last call to
OS/2 API either via CRT, or directly from perl.

=end original

OS/2 では、C<$^E> は CRT 経由、または Perl から直接呼び出された
最後の OS/2 API のエラーコードがセットされます。

=begin original

Under Win32, C<$^E> always returns the last error information
reported by the Win32 call C<GetLastError()> which describes
the last error from within the Win32 API.  Most Win32-specific
code will report errors via C<$^E>.  ANSI C and Unix-like calls
set C<errno> and so most portable Perl code will report errors
via C<$!>. 

=end original

Win32 では、C<$^E> は Win32 API での最後のエラーの内容を返す
C<GetLastError()> Win32 呼び出しで報告される最新のエラー情報を
返します。
ほとんどの Win32 固有のコードはエラーを C<$^E> 経由で返します。
ANSI C と Unix 風の呼び出しは C<errno> をセットするので、
ほとんどの移植性のある Perl コードは C<$!> 経由で
エラーを報告します。

=begin original

Caveats mentioned in the description of C<$!> generally apply to
C<$^E>, also.  (Mnemonic: Extra error explanation.)

=end original

C<$!> の説明で触れた問題点は一般的に C<$^E> にも適用されます。
(記憶法: 追加の(Extra)エラーの説明。)

=begin original

Also see L<Error Indicators>.

=end original

L<Error Indicators> も参照して下さい。

=item $EVAL_ERROR

=item $@

=begin original

The Perl syntax error message from the last eval() operator.  If null, the
last eval() parsed and executed correctly (although the operations you
invoked may have failed in the normal fashion).  (Mnemonic: Where was
the syntax error "at"?)

=end original

最後の eval() 操作子による Perl の構文エラーメッセージです。
空文字列であれば、最後の eval() が正常に
解析され、実行されたことになります (が、実行した演算子が、
通常の意味で失敗しているかもしれません)。
(記憶法: どこで ("at" where) 構文エラーが起ったか。)

=begin original

Warning messages are not collected in this variable.  You can,
however, set up a routine to process warnings by setting C<$SIG{__WARN__}>
as described below.

=end original

警告メッセージはこの変数に入りません。
しかし、後述する C<$SIG{__WARN__}> にセットすることで
警告を処理するルーチンを設定できます。

=begin original

Also see L<Error Indicators>.

=end original

L<Error Indicators> も参照して下さい。

=item $PROCESS_ID

=item $PID

=item $$

=begin original

The process number of the Perl running this script.  You should
consider this variable read-only, although it will be altered
across fork() calls.  (Mnemonic: same as shells.)

=end original

スクリプトを実行している Perl のプロセス番号です。
この変数は read-only と考えるべきですが、
fork() 呼び出しによって値は変わります。
(記憶法: シェルと同じ。)

=item $REAL_USER_ID

=item $UID

=item $<

=begin original

The real uid of this process.  (Mnemonic: it's the uid you came I<from>,
if you're running setuid.)

=end original

本プロセスの実 uid を示します。
(記憶法: setuid で実行中であれば、そこ「から」来た uid です。)

=item $EFFECTIVE_USER_ID

=item $EUID

=item $>

=begin original

The effective uid of this process.  Example:

=end original

本プロセスの実効 uid を示します、　例:

    $< = $>;		# set real to effective uid
    ($<,$>) = ($>,$<);	# swap real and effective uid

=begin original

(Mnemonic: it's the uid you went I<to>, if you're running setuid.)
C<< $< >> and C<< $> >> can be swapped only on machines
supporting setreuid().

=end original

(記憶法: setuid で実行中であれば、そこ「へ」行く uidです。)
C<< $< >> と C<< $> >> の交換は、setreuid() をサポートしている
マシンでのみ可能です。

=item $REAL_GROUP_ID

=item $GID

=item $(

=begin original

The real gid of this process.  If you are on a machine that supports
membership in multiple groups simultaneously, gives a space separated
list of groups you are in.  The first number is the one returned by
getgid(), and the subsequent ones by getgroups(), one of which may be
the same as the first number.

=end original

本プロセスの実 gid を示します。　同時に複数のグループに
所属できるマシンでは、所属するグループをスペースで
区切ったリストが得られます。
最初の数値は、getgid() で返されるものです。
その後に getgroups() が返す値が続き、その中の 1 つは、
最初の値と同じかもしれません。

=begin original

However, a value assigned to C<$(> must be a single number used to
set the real gid.  So the value given by C<$(> should I<not> be assigned
back to C<$(> without being forced numeric, such as by adding zero.

=end original

しかし、C<$(> に代入された値は実際の gid に設定された値の
一つでなければなりません。
従って、 C<$(> で与えられた値はゼロを足すことによって
数値化することなく C<$(> に書き戻すべきではありません。

=begin original

(Mnemonic: parentheses are used to I<group> things.  The real gid is the
group you I<left>, if you're running setgid.)

=end original

(記憶法: 括弧は、I<グループ化>に使われます。
setgid で実行中であれば、実 gid は I<left> した、
つまり離れたグループです。)

=item $EFFECTIVE_GROUP_ID

=item $EGID

=item $)

=begin original

The effective gid of this process.  If you are on a machine that
supports membership in multiple groups simultaneously, gives a space
separated list of groups you are in.  The first number is the one
returned by getegid(), and the subsequent ones by getgroups(), one of
which may be the same as the first number.

=end original

本プロセスの実効 gid を示します。
同時に複数のグループに所属できるマシンでは、
所属するグループをスペースで区切ったリストが得られます。
最初の数値は、getegid() で返されるものです。
その後に getgroups()が返す値が続き、その中の 1 つは、
最初の値と同じかもしれません。

=begin original

Similarly, a value assigned to C<$)> must also be a space-separated
list of numbers.  The first number sets the effective gid, and
the rest (if any) are passed to setgroups().  To get the effect of an
empty list for setgroups(), just repeat the new effective gid; that is,
to force an effective gid of 5 and an effectively empty setgroups()
list, say C< $) = "5 5" >.

=end original

同様に、C<$)> へ代入する値はスペースで区切られた数値の
リストでなければなりません。
最初の数値は実効 gid を設定し、残りの数値は(もしあれば) setgroups() に
渡されます。
setgroups() に空リストを渡したい場合は、単に新しい実効 gid を
繰り返してください。
つまり、実効 gid を 5 にして、setgroups() に空リストを渡したい場合は、
C< $) = "5 5" > としてください。

=begin original

(Mnemonic: parentheses are used to I<group> things.  The effective gid
is the group that's I<right> for you, if you're running setgid.)

=end original

(記憶法: 括弧は、I<グループ化>に使われます。
setgid で実行中であれば、実効 gid は right な、つまり正しいグループです。)

=begin original

C<< $< >>, C<< $> >>, C<$(> and C<$)> can be set only on
machines that support the corresponding I<set[re][ug]id()> routine.  C<$(>
and C<$)> can be swapped only on machines supporting setregid().

=end original

C<< $< >>, C<< $> >>, C<$(>, C<$)> は、実行するマシンで、
対応する I<set[re][ug]id()> ルーティンがサポートされているときにのみ
設定可能です。
C<$(> と C<$)> の交換は、
setregid() がサポートされているマシンでのみ可能です。

=item $PROGRAM_NAME

=item $0

=begin original

Contains the name of the program being executed.  On some operating
systems assigning to C<$0> modifies the argument area that the B<ps>
program sees.  This is more useful as a way of indicating the current
program state than it is for hiding the program you're running.
(Mnemonic: same as B<sh> and B<ksh>.)

=end original

実行されているプログラムの名前を示します。
C<$0> に代入を行なうことで B<ps>) プログラムが覗く、
引数エリアを修正できるシステムもあります。
実行しているプログラムを隠すよりは、
実行中のプログラムの状態を表示するときに、使うとよいでしょう。
(記憶法: B<sh> や B<ksh> と同じ。)

=begin original

Note for BSD users: setting C<$0> does not completely remove "perl"
from the ps(1) output.  For example, setting C<$0> to C<"foobar"> will
result in C<"perl: foobar (perl)">.  This is an operating system
feature.

=end original

BSD ユーザーへの注意: C<$0> に値をセットしても、ps(1) の出力から
完全に "perl" の文字列は取り除かれません。
例えば、C<$0> に C<"foobar"> と設定すると、C<"perl: foobar (perl)"> という
結果になります。これはオペレーティングシステムの機能です。

=item $[

=begin original

The index of the first element in an array, and of the first character
in a substring.  Default is 0, but you could theoretically set it
to 1 to make Perl behave more like B<awk> (or Fortran) when
subscripting and when evaluating the index() and substr() functions.
(Mnemonic: [ begins subscripts.)

=end original

配列の最初の要素や、文字列の最初の文字のインデックスを
示します。
デフォルトは 0 ですが、理論的には、index() 関数や
substr() 関数を評価するときに、Perl の動作をより B<awk>
(や Fortran) に近づけるため、1 に設定することもできます。
(記憶法: [ は添え字付けの始め。)

=begin original

As of release 5 of Perl, assignment to C<$[> is treated as a compiler
directive, and cannot influence the behavior of any other file.
Its use is highly discouraged.

=end original

Perl 5 からは C<$[> への代入は、コンパイラへのディレクティブとして扱われ、
他のファイルの動作に影響を与えることがなくなりました。
この変数はできるだけ使わないようにしてください。

=item $]

=begin original

The version + patchlevel / 1000 of the Perl interpreter.  This variable
can be used to determine whether the Perl interpreter executing a
script is in the right range of versions.  (Mnemonic: Is this version
of perl in the right bracket?)  Example:

=end original

Perl インタプリタの version + patchlevel / 1000 が返されます。
スクリプトの最初で、そのスクリプトを実行しているインタプリタのバージョンが
適切な範囲内にあるかを調べる、といったことができます。
(記憶法: Perl のバージョンは、正しい範囲 (right
bracket) にあるか。)　例:

    warn "No checksumming!\n" if $] < 3.019;

=begin original

See also the documentation of C<use VERSION> and C<require VERSION>
for a convenient way to fail if the running Perl interpreter is too old.

=end original

実行する Perl インタプリタが古すぎる場合に終了する便利な方法に
ついては C<use VERSION> と C<require VERSION> のドキュメントも
参照して下さい。

=begin original

The use of this variable is deprecated.  The floating point representation
can sometimes lead to inaccurate numeric comparisons.  See C<$^V> for a
more modern representation of the Perl version that allows accurate string
comparisons.

=end original

この変数は使わないようにしてください。
浮動小数点表現は数値比較が不正確に成ることがあります。
文字列比較が使える新しい Perl バージョンの表現方法である C<$^V> を
参照して下さい。

=item $COMPILING

=item $^C

=begin original

The current value of the flag associated with the B<-c> switch.
Mainly of use with B<-MO=...> to allow code to alter its behavior
when being compiled, such as for example to AUTOLOAD at compile
time rather than normal, deferred loading.  See L<perlcc>.  Setting
C<$^C = 1> is similar to calling C<B::minus_c>.

=end original

B<-c> スイッチに関連付けられた現在の値です。
主に B<-MO=...> と共に用いられ、例えば AUTOLOAD を通常の遅延ロードでは
なくコンパイル時に実行するといった、コンパイル時の振る舞いを
変えるために用います。L<perlcc> を参照して下さい。
C<$^C = 1> に設定することは C<B::minus_c> を呼び出すのと似ています。

=item $DEBUGGING

=item $^D

=begin original

The current value of the debugging flags.  (Mnemonic: value of B<-D>
switch.)

=end original

デバッグフラグの現在の値を示します。
(記憶法: B<-D> スイッチの値。)

=item $SYSTEM_FD_MAX

=item $^F

=begin original

The maximum system file descriptor, ordinarily 2.  System file
descriptors are passed to exec()ed processes, while higher file
descriptors are not.  Also, during an open(), system file descriptors are
preserved even if the open() fails.  (Ordinary file descriptors are
closed before the open() is attempted.)  The close-on-exec
status of a file descriptor will be decided according to the value of
C<$^F> when the corresponding file, pipe, or socket was opened, not the
time of the exec().

=end original

システムが使用するファイル記述子の最大値を示し、
通常は 2 です。
システムファイル記述子は、exec() されたプロセスに渡されますが、
それ以降のファイル記述子は渡されません。
また、open() の実行中は、システムファイル記述子は、
たとえ open() が失敗しても、保存されます。
(通常のファイル記述子は、open() が実行される前にクローズされます。)
ファイル記述子の close-on-exec のステータスは、exec() 時ではなく、
対応するファイル、パイプソケットの open 時の C<$^F> の値によって
決められます。

=item $^H

=begin original

WARNING: This variable is strictly for internal use only.  Its availability,
behavior, and contents are subject to change without notice.

=end original

警告: この変数は厳密に内部使用に限定されます。
その可用性、挙動、内容は告知なく変更される可能性があります。

=begin original

This variable contains compile-time hints for the Perl interpreter.  At the
end of compilation of a BLOCK the value of this variable is restored to the
value when the interpreter started to compile the BLOCK.

=end original

この変数には Perl インタプリタのコンパイル時のヒントが入ります。
BLOCK のコンパイル終了時に、この変数の値は
インタプリタが BLOCK のコンパイルを開始した時の値に戻されます。

=begin original

When perl begins to parse any block construct that provides a lexical scope
(e.g., eval body, required file, subroutine body, loop body, or conditional
block), the existing value of $^H is saved, but its value is left unchanged.
When the compilation of the block is completed, it regains the saved value.
Between the points where its value is saved and restored, code that
executes within BEGIN blocks is free to change the value of $^H.

=end original

Perl がレキシカルスコープを持つブロック構造(eval の中身、required された
ファイル、サブルーチンの中身、loop の中身、条件付きブロック)の
パーズを開始するとき、現在の $^H の値は保存されますが、
値は変更されません。
ブロックのコンパイルが終わると、保存された値が戻されます。
値の保存と回復の間の地点で、
BEGIN ブロックの中で実行されるコードは自由に
$^H の値を変更できます。

=begin original

This behavior provides the semantic of lexical scoping, and is used in,
for instance, the C<use strict> pragma.

=end original

この振る舞いはレキシカルスコープを持ち、その中で使えます。
例としては C<use strict> があります。

=begin original

The contents should be an integer; different bits of it are used for
different pragmatic flags.  Here's an example:

=end original

内容は整数であるべきです。
ビット毎に異なるプラグマフラグとして使われます。以下は例です:

    sub add_100 { $^H |= 0x100 }

    sub foo {
	BEGIN { add_100() }
	bar->baz($boon);
    }

=begin original

Consider what happens during execution of the BEGIN block.  At this point
the BEGIN block has already been compiled, but the body of foo() is still
being compiled.  The new value of $^H will therefore be visible only while
the body of foo() is being compiled.

=end original

BEGIN ブロックの実行中に起こることを考えてみます。
この時点で BEGIN ブロックは既にコンパイルされていますが、
foo() の中身はまだコンパイル中です。
従って $^H の新しい値は foo() の中身がコンパイル中にのみ
見ることが出来ます。

=begin original

Substitution of the above BEGIN block with:

=end original

上記の BEGIN ブロックを以下のように変更すると:

    BEGIN { require strict; strict->import('vars') }

=begin original

demonstrates how C<use strict 'vars'> is implemented.  Here's a conditional
version of the same lexical pragma:

=end original

どのように C<use strict 'vars'> が実装されているかがわかります。
以下は同じレキシカルプラグマの条件付き版です:

    BEGIN { require strict; strict->import('vars') if $condition }

=item %^H

=begin original

WARNING: This variable is strictly for internal use only.  Its availability,
behavior, and contents are subject to change without notice.

=end original

警告: この変数は厳密に内部使用に限定されます。
その可用性、挙動、内容は告知なく変更される可能性があります。

=begin original

The %^H hash provides the same scoping semantic as $^H.  This makes it
useful for implementation of lexically scoped pragmas.

=end original

%^H ハッシュは $^H と同じスコープを持ちます。
これはレキシカルスコープを持つプラグマを実装するのに便利です。

=item $INPLACE_EDIT

=item $^I

=begin original

The current value of the inplace-edit extension.  Use C<undef> to disable
inplace editing.  (Mnemonic: value of B<-i> switch.)

=end original

置き換え編集の拡張子の値を示します。
置き換え編集を禁止するためには、C<undef> を設定します。
(記憶法: B<-i> スイッチの値。)

=item $^M

=begin original

By default, running out of memory is an untrappable, fatal error.
However, if suitably built, Perl can use the contents of C<$^M>
as an emergency memory pool after die()ing.  Suppose that your Perl
were compiled with -DPERL_EMERGENCY_SBRK and used Perl's malloc.
Then

=end original

デフォルトでは、メモリ不足はトラップできない致命的エラーとなります。
しかし、もし適切に構築されていれば、Perl は C<$^M> の中身を
die() した後の緊急用メモリとして使えます。
Perl が -DPERL_EMERGENCY_SBRK 付きでコンパイルされ、
Perl の malloc を使うと仮定します。そして、

    $^M = 'a' x (1 << 16);

=begin original

would allocate a 64K buffer for use in an emergency.  See the
F<INSTALL> file in the Perl distribution for information on how to
enable this option.  To discourage casual use of this advanced
feature, there is no L<English|English> long name for this variable.

=end original

とすると緊急用の 64K のバッファを割り当てます。
このオプションを有効にする方法ｎついての情報は
Perl 配布パッケージに含まれている F<INSTALL> ファイルを参照して下さい。
この拡張機能を気軽に使えないようにするために、
この変数には L<English|English> の長い名前はありません。

=item $OSNAME

=item $^O

=begin original

The name of the operating system under which this copy of Perl was
built, as determined during the configuration process.  The value
is identical to C<$Config{'osname'}>.  See also L<Config> and the 
B<-V> command-line switch documented in L<perlrun>.

=end original

この Perl が構築されたオペレーティングシステムの名前です。
これは設定プロセス中に決定されます。
この値は C<$Config{'osname'}> と同じです。
L<Config> と、L<perlrun> でドキュメント化されている
B<-V> コマンドラインスイッチも参照して下さい。

=item $PERLDB

=item $^P

=begin original

The internal variable for debugging support.  The meanings of the
various bits are subject to change, but currently indicate:

=end original

デバッグ機能のための内部変数です。
それぞれのビットの意味は変わるかもしれませんが、
現在のところは以下の通りです:

=over 6

=item 0x01

=begin original

Debug subroutine enter/exit.

=end original

サブルーチンの出入りをデバッグします。

=item 0x02

=begin original

Line-by-line debugging.

=end original

行毎にデバッグします。

=item 0x04

=begin original

Switch off optimizations.

=end original

最適化を行いません。

=item 0x08

=begin original

Preserve more data for future interactive inspections.

=end original

将来の対話的な検査のためにより多くのデータを保存します。

=item 0x10

=begin original

Keep info about source lines on which a subroutine is defined.

=end original

サブルーチンが定義されたソース行に関する情報を保持します。

=item 0x20

=begin original

Start with single-step on.

=end original

シングルステップ実行で開始します。

=item 0x40

=begin original

Use subroutine address instead of name when reporting.

=end original

報告時にサブルーチン名でなくサブルーチンのアドレスを使います。

=item 0x80

=begin original

Report C<goto &subroutine> as well.

=end original

C<goto &subroutine> も同様に報告します。

=item 0x100

=begin original

Provide informative "file" names for evals based on the place they were compiled.

=end original

eval に対して、コンパイルされた位置を元にした「ファイル」名を提供します。

=item 0x200

=begin original

Provide informative names to anonymous subroutines based on the place they
were compiled.

=end original

無名サブルーチンに対して、
コンパイルされた位置を基にした参考名を提供します。

=back

=begin original

Some bits may be relevant at compile-time only, some at
run-time only.  This is a new mechanism and the details may change.

=end original

コンパイル時にのみ有効なビットもあり、実行時にのみ有効なビットもあります。
これは新しいメカニズムであり、詳細は変わるかもしれません。

=item $LAST_REGEXP_CODE_RESULT

=item $^R

=begin original

The result of evaluation of the last successful C<(?{ code })>
regular expression assertion (see L<perlre>).  May be written to.

=end original

最後に成功した C<(?{ code })> 正規表現アサートの評価の結果です
(L<perlre> を参照して下さい)。おそらくもっと書き足します。

=item $EXCEPTIONS_BEING_CAUGHT

=item $^S

=begin original

Current state of the interpreter.  Undefined if parsing of the current
module/eval is not finished (may happen in $SIG{__DIE__} and
$SIG{__WARN__} handlers).  True if inside an eval(), otherwise false.

=end original

現在のインタプリタの状態を示します。
現在のモジュール/eval のパーズが終了していない場合は
未定義です(これは $SIG{__DIE__} と $SIG{__WARN__} のハンドラで
起こり得ます)。
eval() の内部では真、それ以外では偽となります。

=item $BASETIME

=item $^T

=begin original

The time at which the program began running, in seconds since the
epoch (beginning of 1970).  The values returned by the B<-M>, B<-A>,
and B<-C> filetests are based on this value.

=end original

プログラムを実行開始した時刻を、紀元 (1970年の始め) からの秒数で示したものです。
ファイルテスト B<-M>、B<-A>、B<-C> で返される値は、この値に基づいています。

=item $PERL_VERSION

=item $^V

=begin original

The revision, version, and subversion of the Perl interpreter, represented
as a string composed of characters with those ordinals.  Thus in Perl v5.6.0
it equals C<chr(5) . chr(6) . chr(0)> and will return true for
C<$^V eq v5.6.0>.  Note that the characters in this string value can
potentially be in Unicode range.

=end original

Perl インタプリタの revision, version, subversion を
それぞれの序数の文字からなる文字列で表現します。
つまり Perl v5.6.0 では C<chr(5) . chr(6) . chr(0)> となり、
C<$^V eq v5.6.0> は真を返します。
この文字列の文字は Unicode の範囲に入るかもしれないことに注意してください。

=begin original

This can be used to determine whether the Perl interpreter executing a
script is in the right range of versions.  (Mnemonic: use ^V for Version
Control.)  Example:

=end original

これはスクリプトを実行している Perl インタプリタのバージョンが
正しい範囲に入っているかを調べるのに使えます。(記憶法:
^V をバージョンコントロールに使います。) 例:

    warn "No \"our\" declarations!\n" if $^V and $^V lt v5.6.0;

=begin original

See the documentation of C<use VERSION> and C<require VERSION>
for a convenient way to fail if the running Perl interpreter is too old.

=end original

実行する Perl インタプリタが古すぎる場合に終了する便利な方法に
ついては C<use VERSION> と C<require VERSION> のドキュメントを
参照して下さい。

=begin original

See also C<$]> for an older representation of the Perl version.

=end original

Perl バージョンの古い表現については C<$]> も参照して下さい。

=item $WARNING

=item $^W

=begin original

The current value of the warning switch, initially true if B<-w>
was used, false otherwise, but directly modifiable.  (Mnemonic:
related to the B<-w> switch.)  See also L<warnings>.

=end original

警告スイッチの値で、B<-w> スイッチが使われると内部的に真となり、
そうでない場合は直接変更可能です。
(記憶法: B<-w> スイッチに関係します。)
L<warnings> も参照して下さい。

=item ${^WARNING_BITS}

=begin original

The current set of warning checks enabled by the C<use warnings> pragma.
See the documentation of C<warnings> for more details.

=end original

C<use warnings> プラグマで有効にされた、現在の警告チェックの集合です。
詳細については C<warnings> のドキュメントを参照して下さい。

=item ${^WIDE_SYSTEM_CALLS}

=begin original

Global flag that enables system calls made by Perl to use wide character
APIs native to the system, if available.  This is currently only implemented
on the Windows platform.

=end original

Perl によるシステムコールで、システムにネイティブなワイド文字 API を
(もし使えるなら)使うようにするグローバルフラグです。
これは現在 Windows プラットフォームでのみ実装されています。

=begin original

This can also be enabled from the command line using the C<-C> switch.

=end original

これはコマンドラインで C<-C> スイッチを使うことでも有効になります。

=begin original

The initial value is typically C<0> for compatibility with Perl versions
earlier than 5.6, but may be automatically set to C<1> by Perl if the system
provides a user-settable default (e.g., C<$ENV{LC_CTYPE}>).

=end original

初期値は典型的には C<0> で、これは Perl バージョン 5.6 以前との
互換性のためです。
しかし、システムがユーザー定義可能なデフォルト(C<$ENV{LC_CTYPE}> など)を
提供している場合は、Perl によって自動的に C<1> にセットされることもあります。

=begin original

The C<bytes> pragma always overrides the effect of this flag in the current
lexical scope.  See L<bytes>.

=end original

C<bytes> プラグマは常に現在のレキシカルスコープでの
このフラグの効果を上書きします。L<bytes> を参照して下さい。

=item $EXECUTABLE_NAME

=item $^X

=begin original

The name that the Perl binary itself was executed as, from C's C<argv[0]>.
This may not be a full pathname, nor even necessarily in your path.

=end original

Perl バイナリ自身が実行された時の名前を C の argv[0] から持ってきたものです。
フルパスではないかもしれませんし、検索パスにないかもしれません。

=item $ARGV

=begin original

contains the name of the current file when reading from <>.

=end original

<> から読込みを行なっているとき、その時点のファイル名を示します。

=item @ARGV

=begin original

The array @ARGV contains the command-line arguments intended for
the script.  C<$#ARGV> is generally the number of arguments minus
one, because C<$ARGV[0]> is the first argument, I<not> the program's
command name itself.  See C<$0> for the command name.

=end original

配列 @ARGV は、コマンドラインからスクリプトに渡す引数が入れられます。
C<$ARGV[0]> がI<プログラムのコマンド名自身ではなく>、
最初の引数ですから、C<$#ARGV> は一般には、引数の個数 - 1 となります。
コマンド名については、C<$0> を参照してください。

=item @INC

=begin original

The array @INC contains the list of places that the C<do EXPR>,
C<require>, or C<use> constructs look for their library files.  It
initially consists of the arguments to any B<-I> command-line
switches, followed by the default Perl library, probably
F</usr/local/lib/perl>, followed by ".", to represent the current
directory.  If you need to modify this at runtime, you should use
the C<use lib> pragma to get the machine-dependent library properly
loaded also:

=end original

配列 @INC には、do EXPR、require、use によってライブラリファイルを
探すときに評価する場所のリストが納められています。
初期状態では、コマンドラインスイッチ B<-I> の引数と
デフォルトの Perl ライブラリディレクトリ (おそらく
F</usr/local/lib/perl5>) とカレントディレクトリを表わす
"." を順につなげたものです。
実行時にこれを変更する必要がある場合は、
マシン依存のライブラリを正しく読み込むために C<use lib> も使うべきです:

    use lib '/mypath/libdir/';
    use SomeMod;

=item @_

=begin original

Within a subroutine the array @_ contains the parameters passed to that
subroutine.  See L<perlsub>.

=end original

サブルーチンの内部では、配列 @_ はサブルーチンに渡されたパラメータです。
L<perlsub> を参照して下さい。

=item %INC

=begin original

The hash %INC contains entries for each filename included via the
C<do>, C<require>, or C<use> operators.  The key is the filename
you specified (with module names converted to pathnames), and the
value is the location of the file found.  The C<require>
operator uses this hash to determine whether a particular file has
already been included.

=end original

ハッシュ %INC は、C<do>, C<require>, C<use>演算子によって
インクルードされた、個々のファイル名をエントリとして持っています。
key は指定したファイル名(モジュール名はパス名に変換されます)で、
value は見つかった場所となっています。
C<require> 演算子は、指定されたファイル名が既に
インクルードされているかを、このハッシュを使って調べます。

=item %ENV

=item $ENV{expr}

=begin original

The hash %ENV contains your current environment.  Setting a
value in C<ENV> changes the environment for any child processes
you subsequently fork() off.

=end original

ハッシュ %ENV には、その時点の環境変数が設定されています。
C<ENV> に値を設定することで、
以後に fork() した子プロセスの環境変数を変更します。

=item %SIG

=item $SIG{expr}

=begin original

The hash %SIG contains signal handlers for signals.  For example:

=end original

ハッシュ %SIG にはシグナルのためのシグナルハンドラが含まれています。例:

    sub handler {	# 1st argument is signal name
	my($sig) = @_;
	print "Caught a SIG$sig--shutting down\n";
	close(LOG);
	exit(0);
    }

    $SIG{'INT'}  = \&handler;
    $SIG{'QUIT'} = \&handler;
    ...
    $SIG{'INT'}  = 'DEFAULT';	# restore default action
    $SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT

=begin original

Using a value of C<'IGNORE'> usually has the effect of ignoring the
signal, except for the C<CHLD> signal.  See L<perlipc> for more about
this special case.

=end original

C<'IGNORE'> という値は通常はシグナルの効果を無視するために使いますが、
C<CHLD> シグナルは例外です。
この特別な場合に関する詳細は L<perlipc> を参照して下さい。

=begin original

Here are some other examples:

    $SIG{"PIPE"} = "Plumber";   # assumes main::Plumber (not recommended)
    $SIG{"PIPE"} = \&Plumber;   # just fine; assume current Plumber
    $SIG{"PIPE"} = *Plumber;    # somewhat esoteric
    $SIG{"PIPE"} = Plumber();   # oops, what did Plumber() return??

=end original

以下にその他の例を示します:

    $SIG{"PIPE"} = "Plumber";   # main::Plumber を仮定します(非推奨)
    $SIG{"PIPE"} = \&Plumber;   # 問題なし; カレントの Plumber を仮定します
    $SIG{"PIPE"} = *Plumber;    # 少々難解
    $SIG{"PIPE"} = Plumber();   # げげ、Plumber() は何を返すの??

=begin original

Be sure not to use a bareword as the name of a signal handler,
lest you inadvertently call it. 

=end original

裸の単語をシグナルハンドラの名前として使わないようにしてください。
不注意で呼び出すのを避けるためです。

=begin original

If your system has the sigaction() function then signal handlers are
installed using it.  This means you get reliable signal handling.  If
your system has the SA_RESTART flag it is used when signals handlers are
installed.  This means that system calls for which restarting is supported
continue rather than returning when a signal arrives.  If you want your
system calls to be interrupted by signal delivery then do something like
this:

=end original

システムに sigaction() 関数がある場合は、
シグナルハンドラはこの関数を使って設定されます。
これにより、信頼性のあるシグナルハンドリングが可能になります。
システムに SA_RESTART フラグがある場合は、
シグナルハンドラはこれを使います。
これによりこれにより再開に対応しているシステムコールは
シグナルが到着したときに返らずに再開します。
シグナルが届いたときにシステムコールを中断したい場合は
以下のようにしてください:

    use POSIX ':signal_h';

    my $alarm = 0;
    sigaction SIGALRM, new POSIX::SigAction sub { $alarm = 1 }
    	or die "Error setting SIGALRM handler: $!\n";

=begin original

See L<POSIX>.

=end original

L<POSIX> を参照して下さい。

=begin original

Certain internal hooks can be also set using the %SIG hash.  The
routine indicated by C<$SIG{__WARN__}> is called when a warning message is
about to be printed.  The warning message is passed as the first
argument.  The presence of a __WARN__ hook causes the ordinary printing
of warnings to STDERR to be suppressed.  You can use this to save warnings
in a variable, or turn warnings into fatal errors, like this:

=end original

ある種の内部フックも %SIG ハッシュを使ってセットされます。
警告メッセージを表示しようとするときに C<$SIG{__WARN__}> で
示されたルーチンが呼び出されます。
警告メッセージは最初の引数として渡されます。
__WARN__ フックがあると、通常の STDERR への警告の出力は行われません。
これを使って、警告メッセージを変数にいれたり、
あるいは以下のようにして警告を致命的エラーに変えたり出来ます:

    local $SIG{__WARN__} = sub { die $_[0] };
    eval $proggie;

=begin original

The routine indicated by C<$SIG{__DIE__}> is called when a fatal exception
is about to be thrown.  The error message is passed as the first
argument.  When a __DIE__ hook routine returns, the exception
processing continues as it would have in the absence of the hook,
unless the hook routine itself exits via a C<goto>, a loop exit, or a die().
The C<__DIE__> handler is explicitly disabled during the call, so that you
can die from a C<__DIE__> handler.  Similarly for C<__WARN__>.

=end original

C<$SIG{__DIE__}> で示されるルーチンは
致命的な例外がまさに投げられようとするときに呼び出されます。
エラーメッセージは最初の引数として渡されます。
__DIE__ フックから戻ると、
例外処理はフックがなかったかのように再開されますが、
フックルーチン自体が C<goto>、ループ終了、die() によって
終了した場合を除きます。
C<__DIE__> ハンドラは呼び出し中は明示的に無効になりますので、
C<__DIE__> ハンドラから die できます。
C<__WARN__> も同様です。

=begin original

Due to an implementation glitch, the C<$SIG{__DIE__}> hook is called
even inside an eval().  Do not use this to rewrite a pending exception
in C<$@>, or as a bizarre substitute for overriding CORE::GLOBAL::die().
This strange action at a distance may be fixed in a future release
so that C<$SIG{__DIE__}> is only called if your program is about
to exit, as was the original intent.  Any other use is deprecated.

=end original

実装上の不具合により、C<$SIG{__DIE__}> は eval() の中でも
呼び出されます。これを、C<$@> の待っている例外を書き換えたり、
CORE::GLOBAL::die() を上書きするのに使わないでください。
この奇妙な行動は将来のリリースで修正される予定なので、
C<$SIG{__DIE__}> は当初の目的通り、
プログラムが終了するときにのみ呼び出されるようになります。
その他の用途は非推奨です。

=begin original

C<__DIE__>/C<__WARN__> handlers are very special in one respect:
they may be called to report (probable) errors found by the parser.
In such a case the parser may be in inconsistent state, so any
attempt to evaluate Perl code from such a handler will probably
result in a segfault.  This means that warnings or errors that
result from parsing Perl should be used with extreme caution, like
this:

=end original

C<__DIE__> と C<__WARN__> のハンドラは一つの点で非常に特別です。
パーザによってエラー(であろうもの)を報告するために呼び出されることがある
ことです。
このような場合、パーザは不安定な状態になっているかもしれないので、
ハンドラから Perl コードを評価しようとするとセグメンテーションフォールトが
発生するかもしれません。
Perl のパーズ中の警告やエラーは、以下のように非常に注意して扱うべきです。

    require Carp if defined $^S;
    Carp::confess("Something wrong") if defined &Carp::confess;
    die "Something wrong, but could not load Carp to give backtrace...
         To see backtrace try starting Perl with -MCarp switch";

=begin original

Here the first line will load Carp I<unless> it is the parser who
called the handler.  The second line will print backtrace and die if
Carp was available.  The third line will be executed only if Carp was
not available.

=end original

一行目は、I<パーザがハンドラを呼び出したのでなければ>
Carp を読み込みます。
二行目は、Carp が使えるならバックとレースを表示して die します。
三行目は Carp が使えないときにのみ実行されます。

=begin original

See L<perlfunc/die>, L<perlfunc/warn>, L<perlfunc/eval>, and
L<warnings> for additional information.

=end original

追加の情報については L<perlfunc/die>, L<perlfunc/warn>, L<perlfunc/eval>,
L<warnings> を参照して下さい。

=back

=head2 Error Indicators

(エラー指示子)

=begin original

The variables C<$@>, C<$!>, C<$^E>, and C<$?> contain information
about different types of error conditions that may appear during
execution of a Perl program.  The variables are shown ordered by
the "distance" between the subsystem which reported the error and
the Perl process.  They correspond to errors detected by the Perl
interpreter, C library, operating system, or an external program,
respectively.

=end original

変数 C<$@>, C<$!>, C<$^E>, C<$?> は Perl プログラムの実行中に
発生した、異なる種類のエラー情報を保持します。
変数はエラーを報告した副システムと Perl プロセスとの「距離」
の順番に並んでいます。
これらはそれぞれ、Perl インタプリタ、C ライブラリ、
オペレーティングシステム、外部プログラムによって検出された
エラーに対応しています。

=begin original

To illustrate the differences between these variables, consider the 
following Perl expression, which uses a single-quoted string:

=end original

これらの変数の違いを示すために、
以下のようなシングルクォートを用いた Perl 式を考えます:

    eval q{
	open PIPE, "/cdrom/install |";
	@res = <PIPE>;
	close PIPE or die "bad pipe: $?, $!";
    };

=begin original

After execution of this statement all 4 variables may have been set.  

=end original

この文を実行した後、4 つの変数全てがセットされる可能性があります。

=begin original

C<$@> is set if the string to be C<eval>-ed did not compile (this
may happen if C<open> or C<close> were imported with bad prototypes),
or if Perl code executed during evaluation die()d .  In these cases
the value of $@ is the compile error, or the argument to C<die>
(which will interpolate C<$!> and C<$?>!).  (See also L<Fatal>,
though.)

=end original

C<$@> は C<eval> された文字列がコンパイルされなかったとき
(これは C<open> か C<close> が正しくない
プロトタイプでインポートされたときに起こり得ます)、
または評価中に実行している Perl コードが die() したときにセットされます。
これらの場合には $@ の値はコンパイルエラー、または
C<die> への引数(これには C<$!> と C<$?> が差し挟まれます!)です。
(しかし、L<Fatal> も参照して下さい。)

=begin original

When the eval() expression above is executed, open(), C<< <PIPE> >>,
and C<close> are translated to calls in the C run-time library and
thence to the operating system kernel.  C<$!> is set to the C library's
C<errno> if one of these calls fails. 

=end original

上記の eval() 式が実行された後、
open(), C<< <PIPE> >>, C<close> は C ランタイムライブラリの呼び出しに
変換され、それからオペレーティングシステムコールに変換されます。
C<$!> はこれらの呼び出しのどれかが失敗したとき、
C ライブラリの C<errno> の値がセットされます。

=begin original

Under a few operating systems, C<$^E> may contain a more verbose
error indicator, such as in this case, "CDROM tray not closed."
Systems that do not support extended error messages leave C<$^E>
the same as C<$!>.

=end original

いくつかのオペレーティングシステムでは、
C<$^E> により詳細なエラー指示子が入っているかもしれません。
今回の場合で言えば、"CDROM tray not closed." などです。
追加のエラーメッセージに対応していないシステムでは、
C<$^E> は C<$!> と同じ値です。

=begin original

Finally, C<$?> may be set to non-0 value if the external program
F</cdrom/install> fails.  The upper eight bits reflect specific
error conditions encountered by the program (the program's exit()
value).   The lower eight bits reflect mode of failure, like signal
death and core dump information  See wait(2) for details.  In
contrast to C<$!> and C<$^E>, which are set only if error condition
is detected, the variable C<$?> is set on each C<wait> or pipe
C<close>, overwriting the old value.  This is more like C<$@>, which
on every eval() is always set on failure and cleared on success.

=end original

最後に、C<$?> は外部プログラム F</cdrom/install> が失敗したときに
非 0 にセットされるかもしれません。
上位の 8 ビットはプログラムが遭遇した特定のエラー状況
(プログラムの exit() の値)を反映します。
下位の 8 ビットは、シグナルの死亡やコアダンプ情報と言った失敗のモードを反映します。
詳細については wait(2) を参照して下さい。
C<$!> と C<$^E> はエラー状況が検出されたときにのみ設定されますが、
変数 C<$?> は C<wait> やパイプの C<close> の度に、前の値を上書きします。
これは、C<$@> が eval() の実行毎に、エラーならセットされ、
成功ならクリアされるという動作と似ています。

=begin original

For more details, see the individual descriptions at C<$@>, C<$!>, C<$^E>,
and C<$?>.

=end original

より詳細については、C<$@>, C<$!>, C<$^E>, C<$?> それぞれの説明を
参照して下さい。

=head2 Technical Note on the Syntax of Variable Names

(変数名の文法に関するテクニカルノート)

=begin original

Variable names in Perl can have several formats.  Usually, they
must begin with a letter or underscore, in which case they can be
arbitrarily long (up to an internal limit of 251 characters) and
may contain letters, digits, underscores, or the special sequence
C<::> or C<'>.  In this case, the part before the last C<::> or
C<'> is taken to be a I<package qualifier>; see L<perlmod>.

=end original

Perl の変数名は様々な形があります。
通常、変数名は英文字か下線で始まらなければならず、
任意の長さ(内部制限の 251 文字まで)を取ることができ、
英文字、数字、下線、特別な文字列である C<::> と C<'> を含むことができます。
この場合、最後の C<::> または C<'> の前は
I<パッケージ限定子> として扱われます。
L<perlmod> を参照して下さい。

=begin original

Perl variable names may also be a sequence of digits or a single
punctuation or control character.  These names are all reserved for
special uses by Perl; for example, the all-digits names are used
to hold data captured by backreferences after a regular expression
match.  Perl has a special syntax for the single-control-character
names: It understands C<^X> (caret C<X>) to mean the control-C<X>
character.  For example, the notation C<$^W> (dollar-sign caret
C<W>) is the scalar variable whose name is the single character
control-C<W>.  This is better than typing a literal control-C<W>
into your program.

=end original

Perl の変数は、数字の列または一文字の句読点かコントロール文字の
場合もあります。
これらの名前は全て Perl によって特別な用途のために予約されています。
例えば、全て数字の名前は正規表現マッチの後の後方参照のデータを
保持するために用いられます。
Perl には一文字のコントロール文字の名前のための特別な文法があります。
C<^X>(キャレット C<X>)は control-C<X> キャラクタを意味します。
例えば、C<$^W>(ドル記号 キャレット C<W>)は control-C<W> 一文字の
名前をもつスカラ変数です。
これはプログラム中にリテラルな control-C<W> をタイプするより
良いです。

=begin original

Finally, new in Perl 5.6, Perl variable names may be alphanumeric
strings that begin with control characters (or better yet, a caret).
These variables must be written in the form C<${^Foo}>; the braces
are not optional.  C<${^Foo}> denotes the scalar variable whose
name is a control-C<F> followed by two C<o>'s.  These variables are
reserved for future special uses by Perl, except for the ones that
begin with C<^_> (control-underscore or caret-underscore).  No
control-character name that begins with C<^_> will acquire a special
meaning in any future version of Perl; such names may therefore be
used safely in programs.  C<$^_> itself, however, I<is> reserved.

=end original

最後に、Perl 5.6 の新機能として、コントロール文字(もっと言えばキャレット)で
始まる、英数字からなる文字列の変数名も使えます。
これらの変数は C<${^Foo}> の形で書かれなければなりません。
括弧は必須です。
C<${^Foo}> はコントロール-C<F> の後に二つ C<o> が続く名前を持つ
スカラ変数です。
これらの変数は Perl によって特別な用途のために予約されていますが、
C<^_> (コントロール-下線またはキャレット-下線)で始まるものは例外です。
C<^_> で始まるコントロール文字名は Perl の将来のバージョンで
特別な意味を持つことはありません。
従ってこれらの名前はプログラム中で安全に使用できます。
但し、C<$^_> そのものは I<予約されます>。

=begin original

Perl identifiers that begin with digits, control characters, or
punctuation characters are exempt from the effects of the C<package>
declaration and are always forced to be in package C<main>.  A few
other names are also exempt:

=end original

数字、コントロール文字、句読点で始まる Perl の識別子は
C<package> 宣言の効果から逃れて、常に C<main> パッケージにあるものとして
扱われます。さらに以下のものも逃れます:

	ENV		STDIN
	INC		STDOUT
	ARGV		STDERR
	ARGVOUT
	SIG

=begin original

In particular, the new special C<${^_XYZ}> variables are always taken
to be in package C<main>, regardless of any C<package> declarations
presently in scope.

=end original

特に、新しい特別な C<${^_XYZ}> 変数はスコープ内の C<package> 宣言に関わらず
常に C<main> パッケージとして扱われます。

=head1 BUGS

(バグ)

=begin original

Due to an unfortunate accident of Perl's implementation, C<use
English> imposes a considerable performance penalty on all regular
expression matches in a program, regardless of whether they occur
in the scope of C<use English>.  For that reason, saying C<use
English> in libraries is strongly discouraged.  See the
Devel::SawAmpersand module documentation from CPAN
(http://www.perl.com/CPAN/modules/by-module/Devel/)
for more information.

=end original

Perl の実装における不幸な事故により、
C<use English> はプログラム中の全ての正規表現マッチングにおいて
かなりの性能低下を引き起こします。
これは C<use English> のスコープ内かどうかに関わりません。
この理由により、ライブラリで C<use English> を使うのは
できるだけ避けてください。
さらなる情報については CPAN の Devel::SawAmpersand モジュール
(http://www.perl.com/CPAN/modules/by-module/Devel/) の
ドキュメントを参照して下さい。

=begin original

Having to even think about the C<$^S> variable in your exception
handlers is simply wrong.  C<$SIG{__DIE__}> as currently implemented
invites grievous and difficult to track down errors.  Avoid it
and use an C<END{}> or CORE::GLOBAL::die override instead.

=end original

例外ハンドラの中で C<$^S> を使おうなどとは考えてもいけません。
現在の実装の C<$SIG{__DIE__}> は面倒を引き寄せ、エラーの追跡を困難にします。
これの代わりに C<END{}> を使うか、CORE::GLOBAL::die をオーバーライドしてください。
