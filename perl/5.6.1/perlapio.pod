=head1 NAME

perlapio - perlの入出力抽象インターフェース

=head1 SYNOPSIS

    PerlIO *PerlIO_stdin(void);
    PerlIO *PerlIO_stdout(void);
    PerlIO *PerlIO_stderr(void);

    PerlIO *PerlIO_open(const char *,const char *);
    int     PerlIO_close(PerlIO *);

    int     PerlIO_stdoutf(const char *,...)
    int     PerlIO_puts(PerlIO *,const char *);
    int     PerlIO_putc(PerlIO *,int);
    int     PerlIO_write(PerlIO *,const void *,size_t);
    int     PerlIO_printf(PerlIO *, const char *,...);
    int     PerlIO_vprintf(PerlIO *, const char *, va_list);
    int     PerlIO_flush(PerlIO *);

    int     PerlIO_eof(PerlIO *);
    int     PerlIO_error(PerlIO *);
    void    PerlIO_clearerr(PerlIO *);

    int     PerlIO_getc(PerlIO *);
    int     PerlIO_ungetc(PerlIO *,int);
    int     PerlIO_read(PerlIO *,void *,size_t);

    int     PerlIO_fileno(PerlIO *);
    PerlIO *PerlIO_fdopen(int, const char *);
    PerlIO *PerlIO_importFILE(FILE *, int flags);
    FILE   *PerlIO_exportFILE(PerlIO *, int flags);
    FILE   *PerlIO_findFILE(PerlIO *);
    void    PerlIO_releaseFILE(PerlIO *,FILE *);

    void    PerlIO_setlinebuf(PerlIO *);

    long    PerlIO_tell(PerlIO *);
    int     PerlIO_seek(PerlIO *,off_t,int);
    int     PerlIO_getpos(PerlIO *,Fpos_t *)
    int     PerlIO_setpos(PerlIO *,Fpos_t *)
    void    PerlIO_rewind(PerlIO *);

    int     PerlIO_has_base(PerlIO *);
    int     PerlIO_has_cntptr(PerlIO *);
    int     PerlIO_fast_gets(PerlIO *);
    int     PerlIO_canset_cnt(PerlIO *);

    char   *PerlIO_get_ptr(PerlIO *);
    int     PerlIO_get_cnt(PerlIO *);
    void    PerlIO_set_cnt(PerlIO *,int);
    void    PerlIO_set_ptrcnt(PerlIO *,char *,int);
    char   *PerlIO_get_base(PerlIO *);
    int     PerlIO_get_bufsiz(PerlIO *);

=head1 DESCRIPTION

Perlのソースコードでは、ANSI CのI<stdio.h>にある関数ではなく
上記の関数を使うべきであり、I<perlio.h>がConfigureの実行時に選択した
I/O機構へC<#define>します。

これらの関数はI<stdio.h>にあるものがモデルになっていますが、
それに渡すパラメーターは“ちょっとばかし整頓”されています。

=over 4

=item B<PerlIO *>

これはFILE *と似たものではありますが、FILE *と異なるのはこれが
不透明なものであるように扱うべきだということです
(これが何かに対するポインターであると仮定するのが安全でしょう)。

=item B<PerlIO_stdin()>, B<PerlIO_stdout()>, B<PerlIO_stderr()>

C<stdin>, C<stdout>, C<stderr>の代わりに使ってください。
これらは変数でなく“関数呼び出し”のように記述されていますが、
これは使用するプラットフォームにおいてロードモジュールに対するデータの
エクスポートができなかったり、あるいは異なる“スレッド”が異なる値を
持つ可能性があるといったときに、これらをB<関数呼び出しにする>のが
簡単になるからです。

=item B<PerlIO_open(path, mode)>, B<PerlIO_fdopen(fd,mode)>

対応する fopen()/fdopen() と同じ引数を取ります。

=item B<PerlIO_printf(f,fmt,...)>, B<PerlIO_vprintf(f,fmt,a)>

fprintf()/vfprintf と等価です。

=item B<PerlIO_stdoutf(fmt,...)>

これはprintf()と等価です。printfはこの関数に対する#definedとなっていますから、
(現時点では)Perlのソースコード中でC<printf(fmt,...)>とすることは合法です。

=item B<PerlIO_read(f,buf,count)>, B<PerlIO_write(f,buf,count)>

fread() および fwrite()に対応します。これらの引数がそれとは異なり、
“count”は一つだけしかなくて“file”が先頭であるということに
注意してください。

=item B<PerlIO_close(f)>

=item B<PerlIO_puts(s,f)>, B<PerlIO_putc(c,f)>

fputs() および fputc()に対応します。最初の引数に“file”が来るということに
注意してください。

=item B<PerlIO_ungetc(c,f)>

ungetc()に対応します。最初の引数に“file”が来るということに注意してください。

=item B<PerlIO_getc(f)>

getc()に対応します。

=item B<PerlIO_eof(f)>

feof()に対応します。

=item B<PerlIO_error(f)>

ferror()に対応します。

=item B<PerlIO_fileno(f)>

fileno()に対応します。一部のプラットフォームにおいては、“fileno”の
意味するところがUNIXとは違うということに注意してください。

=item B<PerlIO_clearerr(f)>

clearerr()に対応し、“ストリーム”の`eof'や`error'といったフラグを
クリアします。

=item B<PerlIO_flush(f)>

fflush()に対応します。

=item B<PerlIO_tell(f)>

ftell()に対応します。

=item B<PerlIO_seek(f,o,w)>

fseek()に対応します。

=item B<PerlIO_getpos(f,p)>, B<PerlIO_setpos(f,p)>

それぞれftgetpos()とfsetpos()に対応します。
プラットフォームが stdio 呼び出しを持っていない場合にはこれらの関数は
PerlIO_tell()、PerlIO_seek()によって実装されます。

=item B<PerlIO_rewind(f)>

rewind()に対応します。一部の状況においてはこれはPerlIO_seek()によって
再定義されている可能性があるので注意してください。

=item B<PerlIO_tmpfile()>

tmpfile()に対応し、クローズ時に自動的に削除される無名 PerlIOを返します。

=back

=head2 Co-existence with stdio

(stdioとの共存)

PerlIOとstdioとの共存をサポートするためのアウトラインがあります。
PerlIOがstdioを使って実装されているのであれば、問題はありません。
しかし、perlioが sfioのの上に実装されているのであればstdio呼び出しを
使おうとするライブラリコードに渡すことができるFILE *を作成する機構が
なければなりません。

=over 4

=item B<PerlIO_importFILE(f,flags)>

FILE *からPerlIO *を得るのに使います。検討されている インターフェースの
引数を追加することができます。

=item B<PerlIO_exportFILE(f,flags)>

PerlIO *を取り、ANSI CのI<stdio.h>のルーチンに渡して使われる
‘ネイティブ’な FILE * 構造体を返します。

‘export’された FILE *は記録され、それ以後のオリジナルの 
PerlIO *に対するPerlIO操作に影響を及ぼす可能性があります。

=item B<PerlIO_findFILE(f)>

直前の`export'されたFILE *を(もしあれば)返します。インターフェースが
完全に定義されるまではこれはプレースホルダーです。

=item B<PerlIO_releaseFILE(p,f)>

PerlIO_releaseFILE は、PerlIOにすべてのFILE *の使用が完了したことを知らせます。
完了したものは‘export’された FILE *のリストから削除されます。
そして、それに結び付けられている PerlIO * は元々の振る舞いに戻ります。

=item B<PerlIO_setlinebuf(f)>

これはsetlinebuf()に対応します。これを使うことは現時点では避けてください。
(Perl coreは“dumping”が$| の自動フラッシュに関係していないB<ときにのみ>
これを使います)。

=back

上述した ユーザーAPIに加えて、perlが、PerlIOの内部で扱うことが
できるようにする“implementation”インターフェースがあります。
以下に挙げる呼び出しは、それぞれConfigureで定義されるFILE_xxxマクロに
対応しています。
このセクションでは、perlプログラムの振る舞いや PerlIO のマッピングの
詳細についてのみ注目します。

=over 4

=item B<PerlIO_has_cntptr(f)>

“バッファ”中のカレントポジションへのポインターとバッファにある
バイト数を返すことのできる実装です。

=item B<PerlIO_get_ptr(f)>

バッファ中にある次の読み出し可能バイトへのポインターを返します。

=item B<PerlIO_get_cnt(f)>

バッファ中の読み出すことのできるバイト数を返します。

=item B<PerlIO_canset_cnt(f)>

バッファにあるバイト数を調整することのできる
実装です。

=item B<PerlIO_fast_gets(f)>

<FILE>機構を取り扱うためのperlのfast codeを許すのに要求される
インターフェースのすべてを実装しています。

  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \
                        PerlIO_canset_cnt(f) && \
                        `Can set pointer into buffer'

=item B<PerlIO_set_ptrcnt(f,p,c)>

ポインターをバッファにセットし、バッファにあるバイト数はそのままです。
以前のC<PerlIO_get_ptr> と C<PerlIO_get_cnt>の呼び出しから
推測される範囲内のポインターをセットすることのみに使うべきでしょう。

=item B<PerlIO_set_cnt(f,c)>

不明瞭 - バッファにあるバイト数をセットします。使うのはお薦めできません。
現在これは、doio.cでのみ count < -1 を 強制的に-1にするために使われています。
おそらくPerlIO_set_emptyやそれに類するものがあるべきでしょう。
この呼び出しは、“count”がポインターと“limit”から導き出される場合には
実際にはなにもしません。

=item B<PerlIO_has_base(f)>

バッファを持っていて、バッファ全体へのポインターやその大きさを
返すことができる実装です。
B<-T>/B<-B>テストのためにperlによって使われます。
そのほかのものは非常にはっきりしない形で使われます…

=item B<PerlIO_get_base(f)>

バッファのB<開始位置>を返します。

=item B<PerlIO_get_bufsiz(f)>

バッファのB<トータルサイズ>を返します。

=back
