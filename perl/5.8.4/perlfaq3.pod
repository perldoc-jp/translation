=encoding euc-jp

=head1 NAME

=begin original

perlfaq3 - Programming Tools ($Revision$, $Date$)

=end original

perlfaq3 - プログラミングツール ($Revision$, $Date$)

=head1 DESCRIPTION

=begin original

This section of the FAQ answers questions related to programmer tools
and programming support.

=end original

FAQのこのセクションでは、プログラマーツールやプログラミングサポートに
関する質問に回答しています。

=head2 How do I do (anything)?

(○○をするにはどうすればいいの?)

=begin original

Have you looked at CPAN (see L<perlfaq2>)?  The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate manpages?  Here's a brief index:

=end original

CPAN(L<perlfaq2>を参照して下さい)はもう見ましたか? 
あなたの問題を解決してくれるような
モジュールを誰かがすでに作っているのを見つけられるかもしれません。
適切なマニュアルページは見ましたか?
簡単なインデックスを挙げておきます:

=begin original

	Basics	        perldata, perlvar, perlsyn, perlop, perlsub
	Execution	perlrun, perldebug
	Functions	perlfunc
	Objects		perlref, perlmod, perlobj, perltie
	Data Structures	perlref, perllol, perldsc
	Modules		perlmod, perlmodlib, perlsub
	Regexes		perlre, perlfunc, perlop, perllocale
	Moving to perl5	perltrap, perl
	Linking w/C	perlxstut, perlxs, perlcall, perlguts, perlembed
	Various 	http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz
			(not a man-page but still useful, a collection
			 of various essays on Perl techniques)

=end original

	基礎		perldata, perlvar, perlsyn, perlop, perlsub
	実行		perlrun, perldebug
	関数		perlfunc
	オブジェクト	perlref, perlmod, perlobj, perltie
	データ構造	perlref, perllol, perldsc
	モジュール	perlmod, perlmodlib, perlsub
	正規表現	perlre, perlfunc, perlop, perllocale
	perl5への移行	perltrap, perl
	Cとのリンク	perlxstut, perlxs, perlcall, perlguts, perlembed
	その他  	http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz
			(man-page ではありませんが有用な、Perl のテクニックに
			関するコラム集です)

=begin original

A crude table of contents for the Perl manpage set is found in L<perltoc>.

=end original

無加工の Perl のマニュアルページセットの目次の一覧がL<perltoc>にあります。

=head2 How can I use Perl interactively?

(どうすれば対話的にPerlを使えますか?)

=begin original

The typical approach uses the Perl debugger, described in the
perldebug(1) manpage, on an ``empty'' program, like this:

=end original

典型的なやり方は、perldebug(1)マニュアルページにあるような Perl
デバッガを以下の例のように“空の”プログラムに対して使うことです:

    perl -de 42

=begin original

Now just type in any legal Perl code, and it will be immediately
evaluated.  You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.

=end original

これで、正しい Perl コードをタイプするだけで即座にそれが評価されます。
同様に、シンボルテーブルの検査やスタックのバックトレースを得ること、
変数の値の確認、ブレークポイントの設定、そしてシンボリックデバッガで
行える典型的な操作が可能です。

=head2 Is there a Perl shell?

(Perlシェルはありますか?)

=begin original

The psh (Perl sh) is currently at version 1.8. The Perl Shell is a
shell that combines the interactive nature of a Unix shell with the
power of Perl. The goal is a full featured shell that behaves as
expected for normal shell activity and uses Perl syntax and
functionality for control-flow statements and other things.
You can get psh at http://www.focusresearch.com/gregor/psh/ .

=end original

psh(Perl sh) は現在バージョン 1.8 です。
Perl Shell は Unix シェルの対話性と Perl の力を融合したものです。
目標は通常のシェルのような機能および、フロー制御やその他のことに
Perl の文法と機能を使う完全な機能を持ったシェルです。
psh は http://www.focusresearch.com/gregor/psh/ で入手できます。

=begin original

Zoidberg is a similar project and provides a shell written in perl,
configured in perl and operated in perl. It is intended as a login shell
and development environment. It can be found at http://zoidberg.sf.net/
or your local CPAN mirror.

=end original

Zoidberg は似たようなプロジェクトで perl で書かれたシェルを提供します。
これは perl で設定され、perl で動作します。これはログインシェルと
開発環境を意図しています。http://zoidberg.sf.net/ またはお近くの
CPAN ミラーにあります。

=begin original

The Shell.pm module (distributed with Perl) makes Perl try commands
which aren't part of the Perl language as shell commands.  perlsh
from the source distribution is simplistic and uninteresting, but
may still be what you want.

=end original

(Perl と一緒に配布されている)Shell.pm モジュールは、
Perl が Perl 言語の一部ではないコマンドをシェルコマンドのように
試してみるようにさせます。ソース配布と一緒にある perlsh は単純で、
おもしろみに書けるものかもしれませんが、あなたの要求には十分かもしれません。

=head2 How do I find which modules are installed on my system?

(自分のシステムに入っているモジュールを知るにはどうしたらいいの?)

=begin original

You can use the ExtUtils::Installed module to show all
installed distributions, although it can take awhile to do
its magic.  The standard library which comes with Perl just
shows up as "Perl" (although you can get those with
Module::CoreList).

=end original

ExtUtils::Installed モジュールを使うことで全てのインストールされた
ディストリビューションを知ることが出来ますが、この魔法を使うには
少し時間がかかります。Perl と共に入る標準ライブラリは
単に "Perl" として表示されます(しかしこれらのリストは
Module::CoreList で得ることが出来ます)。

	use ExtUtils::Installed;

	my $inst    = ExtUtils::Installed->new();
	my @modules = $inst->modules();

=begin original

If you want a list of all of the Perl module filenames, you
can use File::Find::Rule.

=end original

全ての Perl モジュールファイル名の一覧を知りたいなら、
File::Find::Rule が利用できます。

	use File::Find::Rule;

	my @files = File::Find::Rule->file()->name( '*.pm' )->in( @INC );

=begin original

If you do not have that module, you can do the same thing
with File::Find which is part of the standard library.

=end original

このモジュールがない場合、標準ライブラリの一部である
File::Find を使って同じことが出来ます。

    use File::Find;
    my @files;

    find sub { push @files, $File::Find::name if -f _ && /\.pm$/ },
         @INC;

	print join "\n", @files;

=begin original

If you simply need to quickly check to see if a module is
available, you can check for its documentation.  If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases).

=end original

単にあるモジュールが使えるかどうかを知りたいだけなら、
ドキュメントをチェックするという方法があります。
もしそのモジュールに関するドキュメントが読めるなら、
そのモジュールはきっとインストールされています。
ドキュメントが読めない場合、(まれに)モジュールにドキュメントが
ないという可能性もあります。

	prompt% perldoc Module::Name

=begin original

You can also try to include the module in a one-liner to see if
perl finds it.

=end original

一行野郎でモジュールを読み込めるか試すという手もあります。

	perl -MModule::Name -e1

=head2 How do I debug my Perl programs?

(私のPerlプログラムをどうやってデバッグするの?)

=begin original

Have you tried C<use warnings> or used C<-w>?  They enable warnings
to detect dubious practices.

=end original

C<use warning> や C<-w>は使いましたか? これらは怪しいところを警告してくれます。

=begin original

Have you tried C<use strict>?  It prevents you from using symbolic
references, makes you predeclare any subroutines that you call as bare
words, and (probably most importantly) forces you to predeclare your
variables with C<my>, C<our>, or C<use vars>.

=end original

C<use strict>を試しましたか? これはシンボリックリファレンスを
使えないようにし、あなたが bareword を使ってサブルーチン呼び出しの前に
宣言を行うようにします。
さらに(これが一番重要なことですが)C<my>, C<our>, C<use vars>を使って
宣言するように強制します。

=begin original

Did you check the return values of each and every system call?  The operating
system (and thus Perl) tells you whether they worked, and if not
why.

=end original

各システムコールの戻り値をチェックしましたか? オペレーティングシステム
(そして Perl)はその呼び出しが成功したかを、
そしてそれがなぜなのかをあなたに返しています。

  open(FH, "> /etc/cantwrite")
    or die "Couldn't write to /etc/cantwrite: $!\n";

=begin original

Did you read L<perltrap>?  It's full of gotchas for old and new Perl
programmers and even has sections for those of you who are upgrading
from languages like I<awk> and I<C>.

=end original

L<perltrap>を読みましたか? そこには古参の Perl プログラマーと
新参の Perl プログラマーに対する「そうか!」がたくさんあります
さらにI<awk>、I<C>のような別の言語から移ってきた人のための
セクションもあります。

=begin original

Have you tried the Perl debugger, described in L<perldebug>?  You can
step through your program and see what it's doing and thus work out
why what it's doing isn't what it should be doing.

=end original

L<perldebug>で説明されているPerlデバッガを試しましたか?
それによりあなたのプログラムをステップ毎に実行することができ、
あなたの思うように働かなかったのがなぜなのかを
調べることができます。

=head2 How do I profile my Perl programs?

(わたしのPerlプログラムのプロファイルはどうやってとるのでしょう?)

=begin original

You should get the Devel::DProf module from the standard distribution
(or separately on CPAN) and also use Benchmark.pm from the standard
distribution.  The Benchmark module lets you time specific portions of
your code, while Devel::DProf gives detailed breakdowns of where your
code spends its time.

=end original

標準配付キットにある(CPAN にも分離して置いてあります)
Devel::DProf モジュールを入手して、標準配布キットにある
Benchmark.pm も使ってみるべきでしょう。
ベンチマークは、あなたのプログラムの特定の部分の所要時間を取るのに対して、
Devel::DProf はあなたのプログラムのどこがどのくらい時間を
消費しているのかの詳細を報告します。

=begin original

Here's a sample use of Benchmark:

=end original

以下は Benchmark の使い方の例です:

  use Benchmark;

  @junk = `cat /etc/motd`;
  $count = 10_000;

  timethese($count, {
            'map' => sub { my @a = @junk;
			   map { s/a/b/ } @a;
			   return @a },
            'for' => sub { my @a = @junk;
			   for (@a) { s/a/b/ };
			   return @a },
           });

=begin original

This is what it prints (on one machine--your results will be dependent
on your hardware, operating system, and the load on your machine):

=end original

これは以下のような出力を行います
(あるマシン上の例。ハードウェア、オペレーティングシステム、その時点での
マシンの使用状況によって結果は変わります):

  Benchmark: timing 10000 iterations of for, map...
         for:  4 secs ( 3.97 usr  0.01 sys =  3.98 cpu)
         map:  6 secs ( 4.97 usr  0.00 sys =  4.97 cpu)

=begin original

Be aware that a good benchmark is very hard to write.  It only tests the
data you give it and proves little about the differing complexities
of contrasting algorithms.

=end original

良いベンチマークを書くのは非常に大変だということに注意してください。
ベンチマークはあなたが与えたデータのみをテストし、複雑なアルゴリズムが
使われたときの複雑さとは異なっているものなのです。

=head2 How do I cross-reference my Perl programs?

(私のPerlプログラムのクロスリファレンスをとるには?)

=begin original

The B::Xref module can be used to generate cross-reference reports
for Perl programs.

=end original

B::Xref モジュールが Perl プログラムに対する
クロスリファレンスの報告を生成するのに使えます。

    perl -MO=Xref[,OPTIONS] scriptname.plx

=head2 Is there a pretty-printer (formatter) for Perl?

(Perl用のプリティプリンター(フォーマッター)はどこにあるの?)

=begin original

Perltidy is a Perl script which indents and reformats Perl scripts
to make them easier to read by trying to follow the rules of the
L<perlstyle>. If you write Perl scripts, or spend much time reading
them, you will probably find it useful.  It is available at
http://perltidy.sourceforge.net

=end original

Perltidy は Perl スクリプトを L<perlstyle> のルールに従って
読みやすくしようとする Perl スクリプトです。
Perl スクリプトを書いたとき、あるいは多くの時間を Perl スクリプトを
読むのに費やすとき、多分これが有用です。
http://perltidy.sourceforge.net で入手できます。

=begin original

Of course, if you simply follow the guidelines in L<perlstyle>,
you shouldn't need to reformat.  The habit of formatting your code
as you write it will help prevent bugs.  Your editor can and should
help you with this.  The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance.  Tom Christiansen and many other VI users  swear by
the following settings in vi and its clones:

=end original

もちろん、あなたが L<perlstyle>に従っているのであれば、
リフォーマットする必要はないでしょう。自分のプログラムの書式を
統一しておく習慣はバグ対策になります。
あなたの使っているエディターはソースのフォーマッティングを
助けてくれるかもしれません。
emacs の perl モードやより新しい cperl モードは、
コードのほとんど(が、全部ではありません)に対して驚くほどたくさんの手助けを
提供してくれるでしょうし、そしてそれよりも非力なプログラム可能な
エディターでさえも明らかな手助けを提供してくれるかもしれません。
Tom Christiansen とその他の多くの vi 使いは vi (とそのクローン)で
以下のような設定を使っています:

    set ai sw=4
    map! ^O {^M}^[O^T

=begin original

Put that in your F<.exrc> file (replacing the caret characters
with control characters) and away you go.  In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting--
as it were.  A more complete example, with comments, can be found at
http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz

=end original

これをあなたのF<.exrc>というファイル(キャレットはコントロールキャラクターで
置き換えます)に書き込めば OK です。挿入モードでは^Tはインデントを行い、
^Dはアンインデントを、^Oは blockdent をします。
コメント付きの、より完全な例は
http://www.perl.com/CPAN-local/authors/id/TOMC/scripts/toms.exrc.gz
にあります。

=begin original

The a2ps http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gz does
lots of things related to generating nicely printed output of
documents, as does enscript at http://people.ssh.fi/mtr/genscript/ .

=end original

http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gzにある a2ps は
奇麗なドキュメントを出力するということに関して多くのことを行います。
enscript http://people.ssh.fi/mtr/genscript/ も同様です。

=head2 Is there a ctags for Perl?

(Perl 用の ctags はありますか?)

=begin original

Recent versions of ctags do much more than older versions did.
EXUBERANT CTAGS is available from http://ctags.sourceforge.net/
and does a good job of making tags files for perl code.

=end original

最近のバージョンの ctags は昔のバージョンよりはるかに多くのことが出来ます。
EXUBERANT CTAGS は http://ctags.sourceforge.net/ から取得可能で、
perl のコードに対するタグファイル作成に関していい仕事をしています。

=begin original

There is also a simple one at
http://www.cpan.org/authors/id/TOMC/scripts/ptags.gz which may do
the trick.  It can be easy to hack this into what you want.

=end original

また、単純なものが
http://www.cpan.org/authors/id/TOMC/scripts/ptags.gz
にあります。これは簡単に自分の好みにハック出来ます。

=head2 Is there an IDE or Windows Perl Editor?

(Perlの統合開発環境とかWindows Perl Editorはありますか?)

=begin original

Perl programs are just plain text, so any editor will do.

=end original

Perl プログラムは単なるテキストなので、どんなエディタでも作成できます。

=begin original

If you're on Unix, you already have an IDE--Unix itself.  The UNIX
philosophy is the philosophy of several small tools that each do one
thing and do it well.  It's like a carpenter's toolbox.

=end original

あなたが Unix を使っているなら、あなたはすでに統合開発環境を
手にしています--それは Unix 自身です。
Unix の哲学は、一つのことをうまくこなせる小さなツールを複数
組み合わせることです。
これは大工の道具箱に似ています。

=begin original

If you want an IDE, check the following:

=end original

統合開発環境がほしいなら、以下をチェックしてください。

=over 4

=item Komodo

=begin original

ActiveState's cross-platform (as of April 2001 Windows and Linux),
multi-language IDE has Perl support, including a regular expression
debugger and remote debugging
( http://www.ActiveState.com/Products/Komodo/index.html ).  (Visual
Perl, a Visual Studio.NET plug-in is currently (early 2001) in beta
( http://www.ActiveState.com/Products/VisualPerl/index.html )).

=end original

ActiveState のクロスプラットフォーム(2001 年 4 月現在 Windows と Linux)
多言語 IDE は、
正規表現デバッガ、リモートデバッグを含む Perl サポートがあります
( http://www.ActiveState.com/Products/Komodo/index.html )。
(Visual Perl, Visual Studio.NET プラグインは(2001年初頭)現在
ベータ版です( http://www.ActiveState.com/Products/VisualPerl/index.html ))。

=item The Object System

=begin original

( http://www.castlelink.co.uk/object_system/ ) is a Perl web
applications development IDE, apparently for any platform
that runs Perl.

=end original

( http://www.castlelink.co.uk/object_system/ ) は Perl web アプリケーション
開発 IDE で、Perl が動作するあらゆるプラットフォーム用です。

=item Open Perl IDE

=begin original

( http://open-perl-ide.sourceforge.net/ )
Open Perl IDE is an integrated development environment for writing
and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.

=end original

( http://open-perl-ide.sourceforge.net/ )
Open Perl IDE は Windows 95/98/NT/2000 で動作する ActiveState の
ActivePerl で Perl スクリプトを書いたりデバッグしたりするための
統合開発環境です。

=item PerlBuilder

=begin original

( http://www.solutionsoft.com/perl.htm ) is an integrated development
environment for Windows that supports Perl development.

=end original

( http://www.solutionsoft.com/perl.htm ) は Windows 用統合開発環境で、
Perl の開発にも対応しています。

=item visiPerl+

=begin original

( http://helpconsulting.net/visiperl/ )
From Help Consulting, for Windows.

=end original

( http://helpconsulting.net/visiperl/ )
Help Consulting 製で、Windows 用です。

=item OptiPerl

=begin original

( http://www.optiperl.com/ ) is a Windows IDE with simulated CGI
environment, including debugger and syntax highlighting editor.

=end original

( http://www.optiperl.com/ ) は擬似 CGI 環境を持つ Windows 用 IDE で、
デバッガと文法によって色付けされるエディタを含みます。

=back

=begin original

For editors: if you're on Unix you probably have vi or a vi clone already,
and possibly an emacs too, so you may not need to download anything.
In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the
best available Perl editing mode in any editor.

=end original

エディタ使いへ: あなたが Unix を使っているなら、おそらく vi か vi クローンが
すでにあるはずで、emacs もあるかもしれません。
それで、あなたは何もダウンロードする必要はないかもしれません。
あらゆるバージョンの emacs で使える cperl-mode (M-x cperl-mode) は
おそらくエディタでの Perl 編集モードの中で最高のものでしょう。

=begin original

If you are using Windows, you can use any editor that lets
you work with plain text, such as NotePad or WordPad.  Word
processors, such as Microsoft Word or WordPerfect, typically
do not work since they insert all sorts of behind-the-scenes
information, although some allow you to save files as "Text
Only". You can also download text editors designed
specifically for programming, such as Textpad
( http://www.textpad.com/ ) and UltraEdit
( http://www.ultraedit.com/ ), among others.

=end original

Windows を使っているのなら、NotePad や WordPad といった
プレーンテキストを扱えるエディタを使うことが出来ます。
Microsoft Word や WordPerfect といったワードプロセッサは
一般的には使えません。なぜなら色々な「裏方の」情報を追加するからです。
ただし、"Text Only"としてファイルをセーブできるものもあります。
また、Textpad ( http://www.textpad.com/ ) や UltraEdit
( http://www.ultraedit.com/ ) といったプログラミングに特化した
テキストエディタをダウンロードすることもできます。

=begin original

If you are using MacOS, the same concerns apply.  MacPerl
(for Classic environments) comes with a simple editor.
Popular external editors are BBEdit ( http://www.bbedit.com/ )
or Alpha ( http://www.kelehers.org/alpha/ ). MacOS X users can
use Unix editors as well.

=end original

MacOS を使っているなら、同様の考え方が適用されます。
(Classic 環境用の)MacPerl にはシンプルなエディタが付いています。
有名な外部エディタとしては BBEdit ( http://www.bbedit.com/ ) や
Alpha ( http://www.kelehers.org/alpha/ ) があります。
MacOS X ユーザーは Unix エディタも使えます。

=over 4

=item GNU Emacs

http://www.gnu.org/software/emacs/windows/ntemacs.html

=item MicroEMACS

http://www.microemacs.de/

=item XEmacs

http://www.xemacs.org/Download/index.html

=item Jed

http://space.mit.edu/~davis/jed/

=back

=begin original

or a vi clone such as

=end original

あるいは以下のような vi クローンもあります。

=over 4

=item Elvis

ftp://ftp.cs.pdx.edu/pub/elvis/ http://www.fh-wedel.de/elvis/

=item Vile

http://dickey.his.com/vile/vile.html

=item Vim

http://www.vim.org/

=back

=begin original

For vi lovers in general, Windows or elsewhere:

=end original

一般的な、Windows やその他の vi 愛好者のために:

	http://www.thomer.com/thomer/vi/vi.html

=begin original

nvi ( http://www.bostic.com/vi/ , available from CPAN in src/misc/) is
yet another vi clone, unfortunately not available for Windows, but in
UNIX platforms you might be interested in trying it out, firstly because
strictly speaking it is not a vi clone, it is the real vi, or the new
incarnation of it, and secondly because you can embed Perl inside it
to use Perl as the scripting language.  nvi is not alone in this,
though: at least also vim and vile offer an embedded Perl.

=end original

nvi (http://www.bostic.com/vi/ , CPAN の src/misc/ にもあります)は
vi クローンの一つで、残念ながら Windows では動作しませんが、
UNIX プラットフォームを使っているなら試してみるべきです。
第一の理由としては、厳密には vi クローンではないものの、
実際は vi、あるいは vi の子孫であるからです。
第二の理由としては、Perl を内蔵していて、Perl をスクリプト言語として
使えるからです。しかし、nvi はこれらの機能をもつ唯一のものではありません。
少なくとも vim と vile も内蔵 Perl を提供しています。

=begin original

The following are Win32 multilanguage editor/IDESs that support Perl:

=end original

以下は Perl をサポートしている Win32 多言語エディタ/IDE です。

=over 4

=item Codewright

http://www.starbase.com/

=item MultiEdit

http://www.MultiEdit.com/

=item SlickEdit

http://www.slickedit.com/

=back

=begin original

There is also a toyedit Text widget based editor written in Perl
that is distributed with the Tk module on CPAN.  The ptkdb
( http://world.std.com/~aep/ptkdb/ ) is a Perl/tk based debugger that
acts as a development environment of sorts.  Perl Composer
( http://perlcomposer.sourceforge.net/ ) is an IDE for Perl/Tk
GUI creation.

=end original

CPAN で Tk モジュールと共に配布されている、Perl で書かれた
toyedit Textウィジェットベースのエディタがあります。
ptkdb( http://world.std.com/~aep/ptkdb/ ) は 開発環境として振舞う
Perl/tk ベースのデバッガです。Perl Composer
( http://perlcomposer.sourceforge.net/vperl.html )は
Perl/Tk GUI を使った IDE です。

=begin original

In addition to an editor/IDE you might be interested in a more
powerful shell environment for Win32.  Your options include

=end original

エディタ/統合開発環境に加えて、Win32 環境でのより強力な
シェル環境に興味があるかもしれません。
選択肢としては以下のものがあります:

=over 4

=item Bash

=begin original

from the Cygwin package ( http://sources.redhat.com/cygwin/ )

=end original

Cygwin パッケージ ( http://sources.redhat.com/cygwin/ ) から。

=item Ksh

=begin original

from the MKS Toolkit ( http://www.mks.com/ ), or the Bourne shell of
the U/WIN environment ( http://www.research.att.com/sw/tools/uwin/ )

=end original

MKS ツールキット ( http://www.mks.com/ )か、
U/WIN 環境 ( http://www.research.att.com/sw/tools/uwin/ ) の
Bourne shell から。

=item Tcsh

=begin original

ftp://ftp.astron.com/pub/tcsh/ , see also
http://www.primate.wisc.edu/software/csh-tcsh-book/

=end original

ftp://ftp.astron.com/pub/tcsh/　。
http://www.primate.wisc.edu/software/csh-tcsh-book/ も参照してください。

=item Zsh

=begin original

ftp://ftp.blarg.net/users/amol/zsh/ , see also http://www.zsh.org/

=end original

ftp://ftp.blarg.net/users/amol/zsh/ 。
http://www.zsh.org/ も参照してください。

=back

=begin original

MKS and U/WIN are commercial (U/WIN is free for educational and
research purposes), Cygwin is covered by the GNU Public License (but
that shouldn't matter for Perl use).  The Cygwin, MKS, and U/WIN all
contain (in addition to the shells) a comprehensive set of standard
UNIX toolkit utilities.

=end original

MKS とU/WIN は商用(U/WIN は教育・研究目的には無料)で、
Cygwin は GNU Public License で配布されています
(しかしこれは Perl の使用には関係ないはずです)。
Cygwin, MSK, U/WIN は全て(シェルに加えて)広範囲な標準 UNIX ツールキットを
含んでいます。

=begin original

If you're transferring text files between Unix and Windows using FTP
be sure to transfer them in ASCII mode so the ends of lines are
appropriately converted.

=end original

Unix と Windows の間でテキストファイルを FTP で転送する場合、
改行コードを適切に変更するために ASCII モードにしてください。

=begin original

On Mac OS the MacPerl Application comes with a simple 32k text editor
that behaves like a rudimentary IDE.  In contrast to the MacPerl Application
the MPW Perl tool can make use of the MPW Shell itself as an editor (with
no 32k limit).

=end original

Mac OS では MacPerl Application は基本的な IDE のように振舞う
シンプルな 32k テキストエディタがついています。
MacPerl Application と対照的に、MPW Perl tool は MPW Shell 自身を
(32k の制限なしに)エディタとして使えます。

=over 4

=item BBEdit and BBEdit Lite

=begin original

are text editors for Mac OS that have a Perl sensitivity mode
( http://web.barebones.com/ ).

=end original

これは Mac OS で動作するテキストエディタで、
Perl 用のモードがあります( http://web.barebones.com/ )。

=item Alpha

=begin original

is an editor, written and extensible in Tcl, that nonetheless has
built in support for several popular markup and programming languages
including Perl and HTML ( http://alpha.olm.net/ ).

=end original

これはエディタで、Tcl で書かれており、拡張可能です。
それでもいくつかの有名なマークアップ言語とプログラミング言語
( Perl と HTML を含みます)への対応を内蔵しています(http://alpha.olm.net/)。

=back

=begin original

Pepper and Pe are programming language sensitive text editors for Mac
OS X and BeOS respectively ( http://www.hekkelman.com/ ).

=end original

Pepper と Pe はそれぞれ Mac OS X と BeOS 用のプログラミング言語向け
テキストエディタです( http://www.hekkelman.com/ )。

=head2 Where can I get Perl macros for vi?

(vi用のPerlマクロはどこで手に入れられますか?)

=begin original

For a complete version of Tom Christiansen's vi configuration file,
see http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz ,
the standard benchmark file for vi emulators.  The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter--see http://www.cpan.org/src/misc/ .

=end original

viエミュレーターの標準ベンチマークファイルである Tom Christiansen の
vi コンフィグレーションファイルの完全なものは
http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz
を見てください。これはBerkeleyの外にあるviのカレントバージョンである
nvi で最もよく実行されます。nvi は組み込みのPerlインタプリタを
つけてビルドすることもできます。
http://www.cpan.org/src/misc/
を参照してください。

=head2 Where can I get perl-mode for emacs?

(emacs の perl-mode はどこで入手できますか?)

=begin original

Since Emacs version 19 patchlevel 22 or so, there have been both a
perl-mode.el and support for the Perl debugger built in.  These should
come with the standard Emacs 19 distribution.

=end original

Emacs のバージョン 19 パッチレベル 22 から、perl-mode.el と組み込みの Perl
デバッガをサポートしています。
これらは標準の Emacs19 配布セットと一緒にあるはずです。

=begin original

In the Perl source directory, you'll find a directory called "emacs",
which contains a cperl-mode that color-codes keywords, provides
context-sensitive help, and other nifty things.

=end original

Perlのソースディレクトリには、“emacs”というディレクトリがあって、
そこにはキーワードをカラー表示したり、コンテキスト依存な
ヘルプなどのご機嫌なことを提供する cperl-mode があります。

=begin original

Note that the perl-mode of emacs will have fits with C<"main'foo">
(single quote), and mess up the indentation and highlighting.  You
are probably using C<"main::foo"> in new Perl code anyway, so this
shouldn't be an issue.

=end original

emacsのperl-modeはC<“main'foo”>(シングルクォート)スタイルを扱うもので、
インデントやハイライトをおかしくしてしまうことに注意してください。
いずれにしろ、C<“main::foo”>を使うべきでしょう。

=head2 How can I use curses with Perl?

(Perl で curses を使うには?)

=begin original

The Curses module from CPAN provides a dynamically loadable object
module interface to a curses library.  A small demo can be found at the
directory http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz ;
this program repeats a command and updates the screen as needed, rendering
B<rep ps axu> similar to B<top>.

=end original

CPANにあるCursesモジュールは、cursesライブラリに対する動的に
ロード可能なオブジェクトモジュールインターフェースを提供します。
ちょっとしたデモが
http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz
にあります。このプログラムはコマンドを繰り返し、必要に応じて
画面を更新し、B<top>と同じくB<rep ps axu>をレンダリングします。

=head2 How can I use X or Tk with Perl?

(どうすればPerlとXやTkを使えますか?)

=begin original

Tk is a completely Perl-based, object-oriented interface to the Tk toolkit
that doesn't force you to use Tcl just to get at Tk.  Sx is an interface
to the Athena Widget set.  Both are available from CPAN.  See the
directory http://www.cpan.org/modules/by-category/08_User_Interfaces/

=end original

Tkは完全にPerlベースで、Tkを使うためにTclの使用が強制されないような、
Tkツールキットに対するオブジェクト指向インターフェースです。
SxはAthena ウィジェットセットに対するインターフェースです。
これらの両方ともCPANから入手できます。
http://www.cpan.org/modules/by-category/08_User_Interfaces/
を参照してください。

=begin original

Invaluable for Perl/Tk programming are the Perl/Tk FAQ at
http://w4.lns.cornell.edu/%7Epvhp/ptk/ptkTOC.html , the Perl/Tk Reference
Guide available at
http://www.cpan.org/authors/Stephen_O_Lidie/ , and the
online manpages at
http://www-users.cs.umn.edu/%7Eamundson/perl/perltk/toc.html .

=end original

Perl/Tkに関する貴重な情報として、
Perl/Tkに関するFAQが
http://w4.lns.cornell.edu/%7Epvhp/ptk/ptkTOC.html にあります。
また、
http://www.cpan.org/authors/Stephen_O_Lidie/
にはPerl/Tkのリファレンスが、
http://www-users.cs.umn.edu/%7Eamundson/perl/perltk/toc.html
にはマニュアルページがあります。

=head2 How can I generate simple menus without using CGI or Tk?

(どうやれば CGIやTkを使わずに単純なメニューを生成できますか?)

=begin original

The http://www.cpan.org/authors/id/SKUNZ/perlmenu.v4.0.tar.gz
module, which is curses-based, can help with this.

=end original

cursesベースの
http://www.cpan.org/authors/id/SKUNZ/perlmenu.v4.0.tar.gz
このモジュールが助けになるかもしれません。

=head2 How can I make my Perl program run faster?

(どうすれば私のPerlプログラムをもっと速くできますか?)

=begin original

The best way to do this is to come up with a better algorithm.  This
can often make a dramatic difference.  Jon Bentley's book
I<Programming Pearls> (that's not a misspelling!)  has some good tips
on optimization, too.  Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware.  You will probably want to
read the answer to the earlier question ``How do I profile my Perl
programs?'' if you haven't done so already.

=end original

その最善の方法とは、よりよいアルゴリズムを使うということです。
ラクダ本の第八章にはあなたが感心をよせるかもしれない幾つかの効率的な
tips があります。
Jon Bentleyの著作“Programming Pearls”(ミススペルではありません!)
(邦訳「珠玉のプログラミング」)にも最適化に関するいくつかの Tips があります。
ベンチマークとプロファイルによって、
あなたのプログラムのどこに手を入れて最適化するのが正しいのかを
はっきりさせ、ちまちまと高速化を行うのではなくより良いアルゴリズムを
探す手掛かりになります。そして、どうしようもなくなったときには
いつ新しいハードウェアを買うかということを知る手掛かりともなります。

=begin original

A different approach is to autoload seldom-used Perl code.  See the
AutoSplit and AutoLoader modules in the standard distribution for
that.  Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler.  Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the PDL module
from CPAN).

=end original

別のアプローチには、時々使う Perl コードを
オートローディングするというものがあります。
このために標準配布キットにある AutoSplitモジュールと
AutoLoader モジュールを参照してください。
あるいは、ボトルネックとなっているところを特定し、
その部分を C で書くことを考えるかもしれません。
ちょうど C で書かれたプログラムのボトルネックをアセンブラで書くのと同じことです。
C で書き直すという意味では、
クリティカルセクションを持ったモジュールを
C で書き直すというのも同様です(例えば、CPANにある
PDLモジュールがそうです)。

=begin original

If you're currently linking your perl executable to a shared
I<libc.so>, you can often gain a 10-25% performance benefit by
rebuilding it to link with a static libc.a instead.  This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it.  See the F<INSTALL> file in the source distribution
for more information.

=end original

もしあなたが今、perlの実行ファイルと共有ライブラリC<libc.so>を
リンクしているのであれば、スタティックにlibc.aとリンクしてperlを
再ビルドすることによって、10パーセントから25パーセント性能を
向上させることがほとんどの場合可能です。
これはperlの実行ファイルを大きなものにしてしまいますが、
あなたのPerlプログラム(とプログラマー)はスタティックリンクされたことを
感謝するでしょう。
より詳しい情報は、ソース配布にあるF<INSTALL>というファイルを参照してください。

=begin original

The undump program was an ancient attempt to speed up Perl program by
storing the already-compiled form to disk.  This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.

=end original

undump プログラムは、コンパイル済みの形式でディスクに格納することで
Perlプログラムを高速化するのに古くは使われていました。
これはほんの一部のアーキテクチャーでのみ働くものであって、
最早価値ある選択肢ではなく、かつ、よい解決策ではありません。

=head2 How can I make my Perl program take less memory?

(どうすれば私のPerlプログラムのメモリ消費量を少なくできますか?)

=begin original

When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem.  Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more.  While
there's still a lot to be done, recent releases have been addressing
these issues.  For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.

=end original

時間と空間とを天秤に掛けたとき、Perlはほとんど常にメモリーに関する
問題を放棄します。PerlにおけるスカラーはCの文字列よりもメモリーを消費し、
配列も同様です。ハッシュは更にメモリを使います。
まだ行うことは残ってはいるものの、最近のリリースではこの問題に対処しています。
たとえば5.004にあるように、重複したハッシュキーは全てのハッシュで共有されます。
このため、(そのハッシュキーの格納のための)再割り付けの必要はありません。

=begin original

In some cases, using substr() or vec() to simulate arrays can be
highly beneficial.  For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125-byte bit vector--a considerable memory savings.  The standard
Tie::SubstrHash module can also help for certain types of data
structure.  If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.

=end original

substr()やvec()を使って配列をシミュレートすることで大幅に効率を
上げられることがあるでしょう。
たとえば千個のブール値を持った配列は、
少なくとも二万バイトの空間を必要とします。
しかし、これを125バイトのビットベクターに置き換えることができます--
これで劇的にメモリを節約できます。
標準のTie::SubstrHashモジュールもデータ構造の幾つかの型に対する助けを
してくれるでしょう。あなたがデータ構造のスペシャリスト
(例えば行列など)モジュールとともに仕事をしようとしているのなら、
Cで実装されたモジュールはPerlで実装された等価なモジュールよりも
少ないメモリしか使わないでしょう。

=begin original

Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc.  Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the F<INSTALL> file in the source
distribution.  You can find out whether you are using perl's malloc by
typing C<perl -V:usemymalloc>.

=end original

試してみるべきもう一つの事柄は、あなたの使っているPerlがシステムの
mallocを使っているのかPerl組み込みのmallocを使っているのかを知ることです。
いずれを使っているにしろ、別のものを使うようにしてみてそれによる差を確かめます。
mallocに関する情報はソース配布にあるF<INSTALL>というファイルにあります。
C<perl -V:usemymalloc>とタイプすればperlが使っている
mallocがどちらであるかを知ることができます。

=begin original

Of course, the best way to save memory is to not do anything to waste
it in the first place. Good programming practices can go a long way
toward this:

=end original

もちろん、メモリを節約する一番の方法はまず無駄なことをしないことです。
よいプログラミングプラクティスは以下のようなものを通じて得られています。

=over 4

=item * Don't slurp!

=begin original

Don't read an entire file into memory if you can process it line
by line. Or more concretely, use a loop like this:

=end original

ファイルを行単位で処理するときにファイル全体をメモリに読み込んでは
いけません。より具体的には、以下のようなループを使います:

	#
	# Good Idea
	#
	while (<FILE>) {
	   # ...
	}

=begin original

instead of this:

=end original

以下のような方式はよくないです:

	#
	# Bad Idea
	#
	@data = <FILE>;
	foreach (@data) {
	    # ...
	}

=begin original

When the files you're processing are small, it doesn't much matter which
way you do it, but it makes a huge difference when they start getting
larger.

=end original

処理するファイルサイズが小さいなら、どちらの方法をとっても大きな
違いはありません。しかし、ファイルが大きくなるにつれて
その差は大きいものとなります。

=item * Use map and grep selectively

=begin original

Remember that both map and grep expect a LIST argument, so doing this:

=end original

map と grep はどちらも LIST 引数を取るので、以下のようにすると:

        @wanted = grep {/pattern/} <FILE>;

=begin original

will cause the entire file to be slurped. For large files, it's better
to loop:

=end original

ファイル全体を読み込むことになります。大きなファイルでは
以下のようにループしたほうがよいです:

        while (<FILE>) {
                push(@wanted, $_) if /pattern/;
        }

=item * Avoid unnecessary quotes and stringification

=begin original

Don't quote large strings unless absolutely necessary:

=end original

本当に必要でないかぎりは大きな文字列をクォートしてはいけません。

        my $copy = "$large_string";

=begin original

makes 2 copies of $large_string (one for $copy and another for the
quotes), whereas

=end original

このように書くと、$large_string のコピーを二つ($copy とクォートと)
作ります。一方以下のようにすると:

        my $copy = $large_string;

=begin original

only makes one copy.

=end original

コピーは一つしか作られません。

=begin original

Ditto for stringifying large arrays:

=end original

大きな配列の文字列化かでも同じことが言えます:

        {
                local $, = "\n";
                print @big_array;
        }

=begin original

is much more memory-efficient than either

=end original

これは次のものや

        print join "\n", @big_array;

=begin original

or

=end original

次のものよりメモリ効率がよいです:

        {
                local $" = "\n";
                print "@big_array";
        }

=item * Pass by reference

=begin original

Pass arrays and hashes by reference, not by value. For one thing, it's
the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgment, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.

=end original

配列とハッシュは値ではなく、リファレンスで渡します。
これは一つの呼び出し/返り値で複数のリストやハッシュ(やその両方)を
渡す唯一の方法です。
また、これにより内容全てのコピーを作成しなくてすみます。
しかし、これにはいくばくかの判断が必要です。なぜならあらゆる変更が
元のデータに伝播するからです。
もし本当にコピーをいじりたい(修正したい)のなら、
コピーを作るためのメモリを犠牲にする必要があります。

=item * Tie large variables to disk.

=begin original

For "big" data stores (i.e. ones that exceed available memory) consider
using one of the DB modules to store it on disk instead of in RAM. This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.

=end original

「大きな」データストア(利用可能なメモリ量を超えるようなもの)を
扱う時には RAM の代わりにディスクに保存するために DB モジュールの
どれかを使うことを考えてください。
これはアクセス時間の低下を招きますが、おそらくは
大量のスワッピングによって
ハードディスクが激しく動くよりましです。

=back

=head2 Is it safe to return a reference to local or lexical data?

(ローカルやレキシカルなデータへのポインターを返すことは安全ですか?)

=begin original

Yes. Perl's garbage collection system takes care of this so
everything works out right.

=end original

はい。Perl のガベージコレクションシステムは全てがうまくいくように
考慮されています。

    sub makeone {
	my @a = ( 1 .. 10 );
	return \@a;
    }

    for ( 1 .. 10 ) {
        push @many, makeone();
    }

    print $many[4][5], "\n";

    print "@many\n";

=head2 How can I free an array or hash so my program shrinks?

(どうすれば、配列やハッシュを解放して私のプログラムを小さくできますか?)

=begin original

You usually can't. On most operating systems, memory
allocated to a program can never be returned to the system.
That's why long-running programs sometimes re-exec
themselves. Some operating systems (notably, systems that
use mmap(2) for allocating large chunks of memory) can
reclaim memory that is no longer used, but on such systems,
perl must be configured and compiled to use the OS's malloc,
not perl's.

=end original

それは通常できません。ほとんどのシステムでは、プログラムのために
割り付けたメモリーは、決してシステムに返されることはありません。
これは、長期間動作しているプログラムが時々自分自身を
再起動する理由でもあります。
一部のオペレーティングシステム(特に大きなメモリーの塊を
割り付けるときに mmap(2) を使うシステム)では、
最早使われていないメモリーの塊を回収できますが、
そのようなシステムでは、perl を perl 自身ではなく OS の
malloc を使うように設定し、コンパイルしなければなりません。

=begin original

However, judicious use of my() on your variables will help make sure
that they go out of scope so that Perl can free up that space for
use in other parts of your program.  A global variable, of course, never
goes out of scope, so you can't get its space automatically reclaimed,
although undef()ing and/or delete()ing it will achieve the same effect.
In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl, but even this capability
(preallocation of data types) is in the works.

=end original

しかしながら、変数に対して賢明なmy()の使用をすることで、
それらの変数がスコープからはずれたときにPerlがそれらが使っていた領域を
解放してプログラムの他の部分で使えるようにする助けになります。
もちろんグローバル変数は決してスコープから外れることはなく、そのため、
undef()やdeleteを使って同様のことができるにもかかわらず、それらの
空間を自動的に取り戻すようなことはできません。
一般的には、メモリ割り付けと解放はあなたが扱えることではなく、
データ型の先行割り付け(preallocation)がうまくいっていたとしても
Perlがどうやっているかを心配すべきものです。

=head2 How can I make my CGI script more efficient?

(どうやれば私のCGIスクリプトをもっと効率よくできますか?)

=begin original

Beyond the normal measures described to make general Perl programs
faster or smaller, a CGI program has additional issues.  It may be run
several times per second.  Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer.  Compiling into C B<isn't going to help
you> because the process start-up overhead is where the bottleneck is.

=end original

普通のPerlプログラムを速くしたり小さくしたりするための基準とは別に、
CGIプログラムには更に別の基準があります。
CGIプログラムは一秒に数回実行される可能性があります。
実行する度毎にスクリプトの再コンパイルとシステムメモリーを
一メガバイト以上割りつけることが必要となります。これは問題点となり得ます。
CへコンパイルすることはB<助けにはなりません>。
なぜなら、プロセスのスタートアップ時のオーバーヘッドがボトルネックだからです。

=begin original

There are two popular ways to avoid this overhead.  One solution
involves running the Apache HTTP server (available from
http://www.apache.org/ ) with either of the mod_perl or mod_fastcgi
plugin modules.

=end original

このオーバーヘッドを避けるためのポピュラーな手段が二つあります。
解決策の一つはApache HTTPサーバー(http://www.apache.org/ から入手可能)に
mod_perlかmod_fastcgiのいずれかのプラグインモジュールを
取り込ませて実行させるというものです。

=begin original

With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking.  The Apache extension also gives Perl access to
the internal server API, so modules written in Perl can do just about
anything a module written in C can.  For more on mod_perl, see
http://perl.apache.org/

=end original

mod_perlとApache::Registry モジュール(mod_perlと一緒に配布されて
います)と組み合わせることで、httpdは組み込みのPerl
インタプリタと共に実行させるようになります。
これで、あなたのスクリプトは事前にコンパイルされ、
それをfork抜きで同じアドレス空間で実行されるようになります。
Apatche エクステンションはまた、
Perlに内部サーバーAPIをアクセスすることを許可するので、
Perlで記述されたモジュールはCで書かれたモジュールができることはなんでも
できるようになります。
mod_perlに関する詳細は http://perl.apache.org/ を参照してください。

=begin original

With the FCGI module (from CPAN) and the mod_fastcgi
module (available from http://www.fastcgi.com/ ) each of your Perl
programs becomes a permanent CGI daemon process.

=end original

FCGIモジュール(CPANにあります)と
mod_fastcgiモジュール(http://www.fastcgi.comで入手できます)
はあなたのPerlプログラムのそれぞれを永続的 CGI デーモンプロセスにします。

=begin original

Both of these solutions can have far-reaching effects on your system
and on the way you write your CGI programs, so investigate them with
care.

=end original

これらの解決策は両方ともあなたの使うシステムで効果がない可能性があり、
また、あなたが書いたCGIプログラムに依存する方法なので、
注意して検査してください。

=begin original

See http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/ .

=end original

http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/ を
参照してください。

=begin original

A non-free, commercial product, ``The Velocity Engine for Perl'',
(http://www.binevolve.com/ or http://www.binevolve.com/velocigen/ )
might also be worth looking at.  It will allow you to increase the
performance of your Perl programs, running programs up to 25 times
faster than normal CGI Perl when running in persistent Perl mode or 4
to 5 times faster without any modification to your existing CGI
programs. Fully functional evaluation copies are available from the
web site.

=end original

フリーソフトではない、商用の製品の``The Velocity Engine for Perl''
があります(http://www.binevolve.com/ または http://www.binevolve.com/velocigen/)。
これがお望みのものかもしれません。
これはまた、あなたのPerlプログラムの性能を引き上げ、
persistent Perlモードで実行されている
通常のCGI Perlの25倍の早さにすることもありますし、
すでにあるCGIプログラムも何も変更せずに四倍から五倍早いものに
します。機能が全て使える評価版が先のwebサイトで入手可能です。

=head2 How can I hide the source for my Perl program?

(どうやれば私のPerlプログラムのソースを隠せるでしょうか?)

=begin original

Delete it. :-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of ``security''.

=end original

削除しましょう :-) まじめな話、様々な“セキュリティ”レベルを持った
幾つかの解決策があります(ほとんどは満足行くものではないでしょう)。

=begin original

First of all, however, you I<can't> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.

=end original

しかしながら、まず最初に、あなたは読み取り権限(read permission)を
落とすことはできません。
なぜなら、スクリプトのソースコードはコンパイルとインタープリットのために
読み取り可能でなければならない
からです(これはCGIスクリプトのソースコードがweb上で、
読み取り可能であることとは違います--
ファイルシステムに対してアクセスできる人だけが読み取り可能です)。
ですから、権限の設定を少なくとも socially friendly な 0755 の
レベルにしておく必要があります。

=begin original

Some people regard this as a security problem.  If your program does
insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

=end original

中にはこれをセキュリティ上の問題であると考えている人もいます。
あなたのプログラムが安全でないことを行った場合、
そして、人々がそのような安全でないことを暴露する方法を知らないことに
頼っているのなら、安全ではないのです。
誰かが、安全でないことを見つけだすこととソースを見ることなしにそれを
暴露することはしばしば可能となるのです。
セキュリティバグを直すのではなくてそのバグを隠すといった、
知られていないことに頼るセキュリティ(security through obscurity)は
小さなセキュリティの傷です。

=begin original

You can try using encryption via source filters (Starting from Perl
5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it.  You can try using the byte code compiler and interpreter
described below, but the curious might still be able to de-compile it.
You can try using the native-code compiler described below, but
crackers might be able to disassemble it.  These pose varying degrees
of difficulty to people wanting to get at your code, but none can
definitively conceal it (true of every language, not just Perl).

=end original

ソースフィルター(Perl 5.8 からは Filter::Simple と Filter::Util::Call は
標準配布物に含まれています)を使った暗号化を試すこともできます。
しかし、悪意在るプログラマーはそれを復号化できるかもしれません。
あなたはバイトコードコンパイラーとインタプリタを
(上で説明したように)使うことを試せるかもしれませんが、
探りたがりの人はそれを逆コンパイルできるかもしれません。
(上で説明したような)ネイティブコードコンパイラーを試すこともできますが、
クラッカーはそれを逆アセンブルできるかもしれません。
これらの手段は、あなたのプログラムを手に入れようとする人達に様々な困難を
もたらしますが、
誰もそれを決定的に防ぐ障壁にすることはできないのです(Perlのみに
限らず、あらゆる言語で真となります)。

=begin original

It is very easy to recover the source of Perl programs.  You simply
feed the program to the perl interpreter and use the modules in
the B:: hierarchy.  The B::Deparse module should be able to
defeat most attempts to hide source.  Again, this is not
unique to Perl.

=end original

Perl プログラムのソースを取り出すのはとても簡単です。
プログラムを perl インタプリタに渡して B:: 階層のモジュールを
使うだけです。
B::Deparse モジュールはソースを隠そうとするほとんどの試みを
打ち破るはずです。繰り返しますが、これは Perl に限ったことではありません。

=begin original

If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like ``This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah.''  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.

=end original

あなたが、誰かがあなたのプログラムを元になにか利益を
得るのではないかということを考えているのなら、
プログラムの最後の行を制限付きライセンスとすれば、
あなたに法的な安全性 (legal security)をもたらすでしょう。
あなたのソフトウェアをライセンスし、
“This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah.”
(本ソフトウェアは、XYZコーポレイションにより作成された非公開の
独占的ソフトウェアです。あなたがこれにアクセスすることは許されていません、
云々)のような文章で味付けします。もちろん私たちは弁護士ではありませんから、
あなたが確実に自分のライセンスが有効なものになるようにしたいのなら、
弁護士に会っておくべきでしょう。

=head2 How can I compile my Perl program into byte code or C?

(どうやれば私のPerlプログラムをバイトコードやCへコンパイルできますか?)

=begin original

Malcolm Beattie has written a multifunction backend compiler,
available from CPAN, that can do both these things.  It is included
in the perl5.005 release, but is still considered experimental.
This means it's fun to play with if you're a programmer but not
really for people looking for turn-key solutions.

=end original

Malcolm Beattieは多機能バックエンドコンパイラー(multifunction
backend compiler)を作成しました。
これはCPANで入手することができ質問の両方ともを行えます。
このコンパイラーはperl5.005のリリースに
含まれていますが、まだまだ実験段階のもので、
あなたがプログラマーであるなら使って遊ぶこともできますが、
プログラマーでない人々が望んでいるものではありません。

=begin original

Merely compiling into C does not in and of itself guarantee that your
code will run very much faster.  That's because except for lucky cases
where a lot of native type inferencing is possible, the normal Perl
run-time system is still present and so your program will take just as
long to run and be just as big.  Most programs save little more than
compilation time, leaving execution no more than 10-30% faster.  A few
rare programs actually benefit significantly (even running several times
faster), but this takes some tweaking of your code.

=end original

Cコードへの単なる変換はあなたのプログラムをより早く実行するように
するものではありません。なぜならそれは、内部型(native type)の
インタフェースの数多くがが使用可能であるという幸運な場合を除き、
通常のPerlのランタイムシステムはまだ(プログラムの中に)存在していて、
それによってあなたのプログラムはその大きさに応じた分だけ
起動に時間がかかるからなのです。
ほとんどのプログラムはコンパイル時間程の節約しかできず、
実行時間はせいぜいが10から30%程度でしょう。
ほんの一部のプログラムは目に見えるような改善が得られるでしょう
(何倍も早くなることもあります)が
あなたのプログラムを少々ひねくり回すことになります。

=begin original

You'll probably be astonished to learn that the current version of the
compiler generates a compiled form of your script whose executable is
just as big as the original perl executable, and then some.  That's
because as currently written, all programs are prepared for a full
eval() statement.  You can tremendously reduce this cost by building a
shared I<libperl.so> library and linking against that.  See the
F<INSTALL> podfile in the Perl source distribution for details.  If
you link your main perl binary with this, it will make it minuscule.
For example, on one author's system, F</usr/bin/perl> is only 11k in
size!

=end original

コンパイラーのカレントバージョンが、オリジナルのPerlの実行ファイルと
同じくらいの大きさのコンパイル済みスクリプトを生成することを
知ってびっくりするかもしれません。
これは、現在のものでは全てのプログラムが全体がeval()文で囲まれているかのように
扱われているからです。
これは、共有ライブラリ I<libperl.so>を作成してそれを使うようにすることで
劇的に小さくすることができます。
詳しくは、Perlのソース配布キットにある F<INSTALL>というpodfileを
参照してください。
あなたの使っている perl バイナリをこのライブラリとリンクすれば、
perlバイナリを取るに足らないくらい小さくします。
たとえば、ある著者のシステムでは、/usr/bin/perl はたったの11kバイトの
大きさでしかないのです!

=begin original

In general, the compiler will do nothing to make a Perl program smaller,
faster, more portable, or more secure.  In fact, it can make your
situation worse.  The executable will be bigger, your VM system may take
longer to load the whole thing, the binary is fragile and hard to fix,
and compilation never stopped software piracy in the form of crackers,
viruses, or bootleggers.  The real advantage of the compiler is merely
packaging, and once you see the size of what it makes (well, unless
you use a shared I<libperl.so>), you'll probably want a complete
Perl install anyway.

=end original

一般的にいって、コンパイラーはPerlプログラムを小さくもしませんし、
早くもしなければ、移植性を増すこともせず、安全にもしません。
実際、状況がより悪くなることもあります。
実行ファイルは大きくなり、あなたの使うVMシステムは全体をロードするのに
より時間を要すようになりますし、バイナリコードは壊れやすくて
修整しにくいものです。
そして、コンパイルはソフトウェアの不法使用者のクラッキングも、ウィルスも、
密売も防ぐことはできません。
コンパイラーの本当の有利な点は、単にパッケージングということで、
出来上がった実行ファイルの大きさ(まあ、I<libperl.so>共有ライブラリを
使った場合は別ですが)を見てしまえば、Perl全体をインストールしてしまおうと
思うかもしれません。

=head2 How can I compile Perl into Java?

(どうやればPerlをJavaにコンパイルできますか?)

=begin original

You can also integrate Java and Perl with the
Perl Resource Kit from O'Reilly and Associates.  See
http://www.oreilly.com/catalog/prkunix/ .

=end original

オライリーの Perl リソースキットを使って Java と Perl を統合することも出来ます。
http://www.oreilly.com/catalog/prkunix/ を参照してください。

=begin original

Perl 5.6 comes with Java Perl Lingo, or JPL.  JPL, still in
development, allows Perl code to be called from Java.  See jpl/README
in the Perl source tree.

=end original

Perl 5.6 は Java Perl Lingo(JPL) と協調できます。
JPL はまだ開発中ですが、Perl コードを Java から呼び出せます。
Perl ソースツリーの jpl/README を参照してください。

=head2 How can I get C<#!perl> to work on [MS-DOS,NT,...]?

(MS-DOS, NT, etc で '#!perl'が動作するようにするには?)

=begin original

For OS/2 just use

=end original

OS/2では

    extproc perl -S -your_switches

=begin original

as the first line in C<*.cmd> file (C<-S> due to a bug in cmd.exe's
`extproc' handling).  For DOS one should first invent a corresponding
batch file and codify it in C<ALTERNATE_SHEBANG> (see the
F<dosish.h> file in the source distribution for more information).

=end original

C<*.cmd>ファイルの先頭をこのようにするだけです(C<-S>は、
cmd.exeの`extproc'に関するバグのためです)。DOSの場合は、適切なバ
ッチファイルを作ってC<ALTERNATE_SHEBANG> を行うべきでしょう(詳
細は、ソース配布キットにあるF<dosish.h>というファイルを参照してくだ
さい)。

=begin original

The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the C<.pl> extension with the
perl interpreter.  If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself.  In addition to associating C<.pl> with the
interpreter, NT people can use: C<SET PATHEXT=%PATHEXT%;.PL> to let them
run the program C<install-linux.pl> merely by typing C<install-linux>.

=end original

Windows 95やWindows NTで ActiveStateの移植したPerl
を使うのなら、これはC<.pl>という拡張子をperlインタプリタに関連
づけるようにレジストリを変更します。その他の移植になるperl
を使うか、あるいはあなた自身が Windowsに移植されたgcc(cygwinやmingw)を
使って標準ソースからPerlをビルドするというの
であれば自分自身でレジストリを変更する必要があるでしょう。
C<.pl>とインタプリタを関連づけることによって、NTを使っている
人はC<install-linux.pl> を C<install-linux>のように起動することが
可能です。NTではC<SET PATHEXT=%PATHEXT%;.PL>のようにします。

=begin original

Macintosh Perl programs will have the appropriate Creator and
Type, so that double-clicking them will invoke the Perl application.

=end original

Macintosh Perlのプログラムは適切なCreatorとTypeとを持っているで
しょうから、ダブルクリックするだけでPerlアプリケーションが
起動するでしょう。

=begin original

I<IMPORTANT!>: Whatever you do, PLEASE don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server.  This is an EXTREMELY big
security risk.  Take the time to figure out how to do it correctly.

=end original

B<重要!>:あなたが何をするにしても、どうか不満を感じないでください。
そして、あなたのプログラムがwebサーバのために動作するようにさせ
るためにperlインタプリタをcgi-binディレクトリに放り込むよう
なことはしないでください。これはB<非常に>大きなセキュリティ上の
リスクとなります。正しく動作させるための方法を考えるための時間を
取ってください。

=head2 Can I write useful Perl programs on the command line?

(コマンドライン上で便利なperlプログラムを書けますか?)

=begin original

Yes.  Read L<perlrun> for more information.  Some examples follow.
(These assume standard Unix shell quoting rules.)

=end original

できます。詳しくはL<perlrun>を読んでください。幾つかのサンプルを
以下に挙げておきます(ここでは標準のUNIX シェル引用規則に従っていると
仮定します)。

=begin original

    # sum first and last fields
    perl -lane 'print $F[0] + $F[-1]' *

=end original

    # 最初と最後のフィールドを加算する
    perl -lane 'print $F[0] + $F[-1]' *

=begin original

    # identify text files
    perl -le 'for(@ARGV) {print if -f && -T _}' *

=end original

    # テキストファイルを見つけだす
    perl -le 'for(@ARGV) {print if -f && -T _}' *

=begin original

    # remove (most) comments from C program
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

=end original

    # Cプログラムから(大部分の)コメントを取り除く
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

=begin original

    # make file a month younger than today, defeating reaper daemons
    perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

=end original

    # ファイルの修整日付を今日より一月先にして、reaper daemonを打ち負かす
    perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

=begin original

    # find first unused uid
    perl -le '$i++ while getpwuid($i); print $i'

=end original

    # 最初の未使用uidを見つけだす
    perl -le '$i++ while getpwuid($i); print $i'

=begin original

    # display reasonable manpath
    echo $PATH | perl -nl -072 -e '
	s![^/+]*$!man!&&-d&&!$s{$_}++&&push@m,$_;END{print"@m"}'

=end original

    # 適切なmanpathを表示する
    echo $PATH | perl -nl -072 -e '
	s![^/+]*$!man!&&-d&&!$s{$_}++&&push@m,$_;END{print"@m"}'

=begin original

OK, the last one was actually an Obfuscated Perl Contest entry. :-)

=end original

そう、最後のは Obfuscated Perl コンテストにエントリーされてましたね :-)

=head2 Why don't Perl one-liners work on my DOS/Mac/VMS system?

(なぜ私の DOS/Mac/VMSシステムでは一行野郎(one-liners)は動かないのでしょうか?)

=begin original

The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created.  On some systems, you may have to
change single-quotes to double ones, which you must I<NOT> do on Unix
or Plan9 systems.  You might also have to change a single % to a %%.

=end original

この問題は、そういったシステムのコマンドインタプリタが、
一行野郎が作られた環境であるUNIXのシェルの引用規則とは異なるこということです。
一部のシステムでは、シングルクォートをダブルクォートに
変更する必要があるかもしれません(これはUNIXやPlan9といったシステムでは
B<してはいけません>)。
同様に、%を%%に変更する必要もあるかもしれません。

=begin original

For example:

=end original

例を挙げましょう:

    # Unix
    perl -e 'print "Hello world\n"'

    # DOS, etc.
    perl -e "print \"Hello world\n\""

    # Mac
    print "Hello world\n"
     (then Run "Myscript" or Shift-Command-R)

    # MPW
    perl -e 'print "Hello world\n"'


    # VMS
    perl -e "print ""Hello world\n"""

=begin original

The problem is that none of these examples are reliable: they depend on the
command interpreter.  Under Unix, the first two often work. Under DOS,
it's entirely possible that neither works.  If 4DOS was the command shell,
you'd probably have better luck like this:

=end original

問題は、これらの例の中に信頼できるものがないということです:
コマンドインタープリタに依存します。
UNIXでは、最初の二つはほとんどの場合動作するでしょう。
DOSでは、どれも働かないかもしれません。
4DOSをコマンドシェルとしているのなら、以下のようにするのがよいと思います:

  perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

=begin original

Under the Mac, it depends which environment you are using.  The MacPerl
shell, or MPW, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.

=end original

Macでは、あなたが使っている環境に依存します。
MacPerlシェルやMPWは、制御キャラクターのようなMacの非ASCIIキャラクターが
自由に使えるという点を除いて、
UNIXシェルのように数種類の引用規則をサポートします。

=begin original

Using qq(), q(), and qx(), instead of "double quotes", 'single
quotes', and `backticks`, may make one-liners easier to write.

=end original

ダブルクォート(")、シングルクォート(')、バッククォート(`)の
代わりにqq(), q(), qx()をそれぞれ使います。これによって
一行野郎を書くことが簡単になるかもしれません。

=begin original

There is no general solution to all of this.  It is a mess.

=end original

この件全てに関する一般的な解決策はありません。ごちゃごちゃです。

=begin original

[Some of this answer was contributed by Kenneth Albanowski.]

=end original

[この回答の一部はKenneth Albanowskiから寄せられました]

=head2 Where can I learn about CGI or Web programming in Perl?

(わたしがPerlによるCGIやWebプログラミングについて学べる場所は?)

=begin original

For modules, get the CGI or LWP modules from CPAN.  For textbooks,
see the two especially dedicated to web stuff in the question on
books.  For problems and questions related to the web, like ``Why
do I get 500 Errors'' or ``Why doesn't it run from the browser right
when it runs fine on the command line'', see the troubleshooting
guides and references in L<perlfaq9> or in the CGI MetaFAQ:

=end original

モジュールなら、CPANからCGIモジュールやLWPモジュールを入手しましょう。
教科書なら、本にあるweb stuffの特に決定的な二つを参照しましょう。
“Why do I get 500 Errors” (なんで 500 Errors になるの)
“Why doesn't it run from the browser right when it runs fine on the command line”
(なぜコマンドラインからだとちゃんと動くのに、ブラウザーからだと
だめなんでしょうか)のようにwebに関連する問題や疑問は
L<perlfaq9> か CGI MetaFAQ を参照してください:

	http://www.perl.org/CGI_MetaFAQ.html

=head2 Where can I learn about object-oriented Perl programming?

(オブジェクト指向のPerlプログラミングはどこで学べますか?)

=begin original

A good place to start is L<perltoot>, and you can use L<perlobj>,
L<perlboot>, L<perltoot>, L<perltooc>, and L<perlbot> for reference.
(If you are using really old Perl, you may not have all of these,
try http://www.perldoc.com/ , but consider upgrading your perl.)

=end original

始めるにはよい場所は L<perltoot>です。リファレンスとしてL<perlobj>,
L<perlboot>, <perltooc>, <perlbot>が使えます。
(もしあなたが本当に古い Perl を使っているなら、これらの全てが含まれて
いないかもしれません。その場合は http://www.perldoc.com/ を見てください。
但し、perl をアップグレードすることも検討してください。)

=begin original

A good book on OO on Perl is the "Object-Oriented Perl"
by Damian Conway from Manning Publications,
http://www.manning.com/Conway/index.html

=end original

Perl でのオブジェクト指向に関するよい本は Manning Publications が
出版する Damian Conway による "Object-Oriented Perl" です。
http://www.manning.com/Conway/index.html

=head2 Where can I learn about linking C with Perl? [h2xs, xsubpp]

(C と Perl のリンクについてはどこで学べますか? [h2xs, xsubpp])

=begin original

If you want to call C from Perl, start with L<perlxstut>,
moving on to L<perlxs>, L<xsubpp>, and L<perlguts>.  If you want to
call Perl from C, then read L<perlembed>, L<perlcall>, and
L<perlguts>.  Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.

=end original

もしPerlからCを呼び出したいのなら、L<perlxstut>から始めてL<perlxs>, 
L<xsubpp>, L<perlguts>へと進みます。CからPerlを呼び出したいのなら、
L<perlembed>, L<perlcall>, L<perlguts>を読みましょう。
すでにあるエクステンションの作者がどのようにそれを記述し、
どのように彼らの問題を解決したのかを見ることで多くのことが
学べるのだということを忘れないでください。

=head2 I've read perlembed, perlguts, etc., but I can't embed perl in
my C program; what am I doing wrong?

(perlembedやperlgutsなんかを読んだのだけど、
私のCプログラムにperlを組み込めません。
何が悪いのでしょうか?)

=begin original

Download the ExtUtils::Embed kit from CPAN and run `make test'.  If
the tests pass, read the pods again and again and again.  If they
fail, see L<perlbug> and send a bug report with the output of
C<make test TEST_VERBOSE=1> along with C<perl -V>.

=end original

CPANからExtUtils::Embedキットをダウンロードして、`make test'を
実行してください。
もしこのテストに合格したのなら、podを何度も何度もくり返しくり返し
読んでください。
テストに失敗したなら、L<perlbug>を読んで、C<perl -V>の出力と
C<make test TEST_VERBOSE=1>の出力を添付してバグレポートを送ってください。

=head2 When I tried to run my script, I got this message. What does it mean?

(私のスクリプトを実行したとき、こんなメッセージを受け取りました。
これって何を意味しているのでしょうか?)

=begin original

A complete list of Perl's error messages and warnings with explanatory
text can be found in L<perldiag>. You can also use the splain program
(distributed with Perl) to explain the error messages:

=end original

perl のすべてのエラーメッセージ、警告メッセージの説明テキスト付きのリストが
L<perldiag> にあります。
エラーメッセージを説明するために、
splain プログラムを使うこともできます(これは Perl と一緒に配布されています)。

    perl program 2>diag.out
    splain [-v] [-p] diag.out

=begin original

or change your program to explain the messages for you:

=end original

あるいは、メッセージを説明的にするようにプログラムを変更します。

    use diagnostics;

=begin original

or

=end original

あるいはこう

    use diagnostics -verbose;

=head2 What's MakeMaker?

(MakeMakerってなんですか?)

=begin original

This module (part of the standard Perl distribution) is designed to
write a Makefile for an extension module from a Makefile.PL.  For more
information, see L<ExtUtils::MakeMaker>.

=end original

このモジュール(標準Perl配布キットの一部です)はMakefile.PLから
エクステンションモジュール用のMakefileを作成するために
デザインされたものです。
詳しくは L<ExtUtils::MakeMaker> を参照してください。

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples here are in the public
domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit.  A simple comment in the code giving credit to the FAQ would
be courteous but is not required.
