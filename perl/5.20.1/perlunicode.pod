
=encoding euc-jp

=head1 NAME

=begin original

perlunicode - Unicode support in Perl

=end original

perlunicode - Perl における Unicode サポート

=head1 DESCRIPTION

=head2 Important Caveats

(重要な警告)

=begin original

Unicode support is an extensive requirement. While Perl does not
implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.

=end original

Unicode サポートは大規模な要求です。
Perl は標準 Unicode や付随する技術的なレポートを一つ残らず
実装しているわけではありませんが、多くの Unicode 機能を
サポートしています。

=begin original

People who want to learn to use Unicode in Perl, should probably read
the L<Perl Unicode tutorial, perlunitut|perlunitut> and
L<perluniintro>, before reading
this reference document.

=end original

Perl で Unicode を使うことを学びたい人は、多分このリファレンスを読む前に
L<the Perl Unicode tutorial, perlunitut|perlunitut> と L<perluniintro> を
読んだ方がよいでしょう。

=begin original

Also, the use of Unicode may present security issues that aren't obvious.
Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.

=end original

また、Unicode を使うと、明らかではないセキュリティ問題が姿を現すかも
知れません。
L<Unicode Security Considerations|http://www.unicode.org/reports/tr36> を
読んでください。

=over 4

=item Safest if you C<use feature 'unicode_strings'>

(C<use feature 'unicode_strings'> とすれば一番安全)

=begin original

In order to preserve backward compatibility, Perl does not turn
on full internal Unicode support unless the pragma
C<use feature 'unicode_strings'> is specified.  (This is automatically
selected if you use C<use 5.012> or higher.)  Failure to do this can
trigger unexpected surprises.  See L</The "Unicode Bug"> below.

=end original

後方互換性を維持するために、Perl は
C<use feature 'unicode_strings'> プラグマが指定されない限り
完全な内部 Unicode 対応をオンにしません。
(これは C<use 5.012> 以上を使うと自動的に選択されます。)
こうするのに失敗すると予測できない驚きを引き起こすかも知れません。
後述する L</The "Unicode Bug"> を参照してください。

=begin original

This pragma doesn't affect I/O.  Nor does it change the internal
representation of strings, only their interpretation.  There are still
several places where Unicode isn't fully supported, such as in
filenames.

=end original

このプラグマは I/O には影響しません。
また、文字列の内部表現も変更しません; その解釈だけです。
ファイル名のように Unicode に完全に対応していない場所がいくつかあります。

=item Input and Output Layers

(入出力層)

=begin original

Perl knows when a filehandle uses Perl's internal Unicode encodings
(UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with
the C<:encoding(utf8)> layer.  Other encodings can be converted to Perl's
encoding on input or from Perl's encoding on output by use of the
C<:encoding(...)>  layer.  See L<open>.

=end original

Perl は、ファイルハンドルが C<:encoding(utf8)> 層を指定してオープンされると、
ファイルハンドルが Perl の内部 Unicode エンコーディング
(UTF-8, または EBCDIC の時は UTF-EBCDIC) を使うことが分かります。 
その他のエンコーディングは、C<:encoding(...)> 層を使うことで、
入力時の Perl のエンコーディングへの変換や出力時の Perl の
エンコーディングからの変換を行えます。
L<open> を参照してください。

=begin original

To indicate that Perl source itself is in UTF-8, use C<use utf8;>.

=end original

Perl のソース自身が UTF-8 であることを示すには、C<use utf8;> を
使ってください。

=item C<use utf8> still needed to enable UTF-8/UTF-EBCDIC in scripts

=begin original

As a compatibility measure, the C<use utf8> pragma must be explicitly
included to enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identifier names) on
ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based
machines.  B<These are the only times when an explicit C<use utf8>
is needed.>  See L<utf8>.

=end original

互換性のために、ASCII ベースのマシンにおいて Perl スクリプトそれ自身の
中の UTF-8 を(文字列や正規表現リテラル、あるいは変数名で) 認識可能に
するためや、EBCDIC ベースのマシンで UTF-EBCDIC を認識させるために
C<use utf8> プラグマを明示的に含めなければなりません。
B<これらは明示的に C<use utf8> が必要な唯一の場合です。>
L<utf8> を参照してください。

=item C<BOM>-marked scripts and UTF-16 scripts autodetected

=begin original

If a Perl script begins marked with the Unicode C<BOM> (UTF-16LE, UTF16-BE,
or UTF-8), or if the script looks like non-C<BOM>-marked UTF-16 of either
endianness, Perl will correctly read in the script as Unicode.
(C<BOM>less UTF-8 cannot be effectively recognized or differentiated from
ISO 8859-1 or other eight-bit encodings.)

=end original

Unicode C<BOM> (UTF-16LE, UTF16-BE, またはUTF-8)で Perl スクリプトが
始まっていたり、スクリプトが C<BOM> がついていない
UTF-16(BE か LE のいずれか) であった場合、Perl はそのスクリプトを
Unicode であるとして正しく読み込みます。
(C<BOM> がない UTF-8 は、効率的に ISO 8859-1 などの 8 ビットエンコーディングと
区別したり認識することができません。)

=item C<use encoding> needed to upgrade non-Latin-1 byte strings

=begin original

By default, there is a fundamental asymmetry in Perl's Unicode model:
implicit upgrading from byte strings to Unicode strings assumes that
they were encoded in I<ISO 8859-1 (Latin-1)>, but Unicode strings are
downgraded with UTF-8 encoding.  This happens because the first 256
codepoints in Unicode happens to agree with Latin-1.

=end original

デフォルトでは、Perl の Unicode モデルにおける基本的な非対称があります:
バイト文字列から Unicode 文字列への暗黙の昇格はその文字列が
I<ISO 8859-1 (Latin-1)> でエンコードされているものと仮定しますが、
Unicode 文字列からのダウングレードは
UTF-8 エンコーディングへと行われます。
これは Unicode の最初の 256 文字が Latin-1 と共通であるからです。

=begin original

See L</"Byte and Character Semantics"> for more details.

=end original

詳細は L</"Byte and Character Semantics"> を参照してください。

=back

=head2 Byte and Character Semantics

(バイトと文字のセマンティクス)

=begin original

Perl uses logically-wide characters to represent strings internally.

=end original

Perl は論理的なワイド文字を内部的な文字列の表現のために使っています。

=begin original

Starting in Perl 5.14, Perl-level operations work with
characters rather than bytes within the scope of a
C<L<use feature 'unicode_strings'|feature>> (or equivalently
C<use 5.012> or higher).  (This is not true if bytes have been
explicitly requested by C<L<use bytes|bytes>>, nor necessarily true
for interactions with the platform's operating system.)

=end original

Perl 5.14 から、C<L<use feature 'unicode_strings'|feature>> (または等価な
C<use 5.012> 以上) のスコープ内では、
Perl レベルの操作はバイトではなく文字に対して働きます。
(これは C<L<use bytes|bytes>> によってバイトが明示的に要求された
場合には真ではなく、プラットフォームのオペレーティングシステムとの
相互作用に関しては真である必要はありません。)

=begin original

For earlier Perls, and when C<unicode_strings> is not in effect, Perl
provides a fairly safe environment that can handle both types of
semantics in programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to character
semantics.  For operations where this determination cannot be made
without additional information from the user, Perl decides in favor of
compatibility and chooses to use byte semantics.

=end original

より古い Perl や、C<unicode_strings> が有効でないとき、Perl は
プログラムで両方の型の意味論を扱えるかなり安全な環境を提供します。
入力データが文字であると Perl が曖昧さなく決定できる操作については、
Perl は文字セマンティクスに切り替えます。
ユーザーからの付加的な情報抜きに決定することができない操作については
Perl は互換性の観点からバイトセマンティクスを選択します。

=begin original

When C<use locale> (but not C<use locale ':not_characters'>) is in
effect, Perl uses the rules associated with the current locale.
(C<use locale> overrides C<use feature 'unicode_strings'> in the same scope;
while C<use locale ':not_characters'> effectively also selects
C<use feature 'unicode_strings'> in its scope; see L<perllocale>.)
Otherwise, Perl uses the platform's native
byte semantics for characters whose code points are less than 256, and
Unicode rules for those greater than 255.  That means that non-ASCII
characters are undefined except for their
ordinal numbers.  This means that none have case (upper and lower), nor are any
a member of character classes, like C<[:alpha:]> or C<\w>.  (But all do belong
to the C<\W> class or the Perl regular expression extension C<[:^alpha:]>.)

=end original

C<use locale> が有効 (しかし C<use locale ':not_characters'> が有効でない)
の場合、Perl は現在のロケールに関連づけられた規則を使います。
(C<use locale> は同じスコープ内の C<use feature 'unicode_strings'> を
上書きします;
一方 C<use locale ':not_characters'> も事実上そのスコープ内で
C<use feature 'unicode_strings'> を選択します; L<perllocale> を
参照してください。)
さもなければ、Perl は 256 より小さい符号位置の文字に関しては
プラットフォームのネイティブなバイト意味論を使い、
255 より大きい符号位置については Unicode の規則を使います。
つまり 非 ASCII 文字は、その番号以外では未定義です。
つまり、大文字小文字はなく、C<[:alpha:]> や C<\w> のような、
どの文字クラスにも含まれません。
(しかし C<\W> クラスや Perl の正規表現拡張 C<[:^alpha:]> には属します。)

=begin original

This behavior preserves compatibility with earlier versions of Perl,
which allowed byte semantics in Perl operations only if
none of the program's inputs were marked as being a source of Unicode
character data.  Such data may come from filehandles, from calls to
external programs, from information provided by the system (such as C<%ENV>),
or from literals and constants in the source text.

=end original

この動作は Perl の以前のバージョンとの互換性を維持し、プログラムの
入力が Unicode の文字データのソースであるとマークされていない場合にのみ
Perl の操作でバイトセマンティクスを許可します。
そのようなデータは、ファイルハンドル、外部プログラムの呼び出し、
システムから提供される情報(C<%ENV> のような)、ソーステキスト中のリテラルや
定数といったものからくるものです。

=begin original

The C<utf8> pragma is primarily a compatibility device that enables
recognition of UTF-(8|EBCDIC) in literals encountered by the parser.
Note that this pragma is only required while Perl defaults to byte
semantics; when character semantics become the default, this pragma
may become a no-op.  See L<utf8>.

=end original

C<utf8> プラグマは主としてパーサが遭遇するリテラル中の UTF-(8|EBCDIC) の
認識を有効にする互換デバイス(compatibility device)です。
このプラグマは Perl のデフォルトがバイトセマンティクスであるときにのみ
必要であることに注意してください; 文字セマンティクスが
デフォルトである場合には、このプラグマは何もしません。
L<utf8> を参照してください。

=begin original

If strings operating under byte semantics and strings with Unicode
character data are concatenated, the new string will have
character semantics.  This can cause surprises: See L</BUGS>, below.
You can choose to be warned when this happens.  See C<L<encoding::warnings>>.

=end original

バイトセマンティクスの元での文字列の操作で、Unicode 文字データが
連結された文字列であった場合、新たな文字列は文字セマンティックスを
保ちます。
これは驚きを引き起こすかもしれません: 後述する L</BUGS> を
参照してください。
これが起きたときに警告されるようにすることを選択できます。
C<L<encoding::warnings>> を参照してください。

=begin original

Under character semantics, many operations that formerly operated on
bytes now operate on characters. A character in Perl is
logically just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes internally, but
this internal detail is mostly hidden for Perl code.
See L<perluniintro> for more.

=end original

文字セマンティクスの元では、伝統的にバイトに対して働いていた操作の多くが
文字に対して働きます。
Perl における文字は論理的には 0 から 2**31 までの範囲の数値です。
大きな文字は内部的にはより長いシーケンスにエンコードされる可能性が
ありますが、この内部の詳細は Perl プログラムからほとんど隠されています。
詳細は L<perluniintro> を参照してください。

=head2 Effects of Character Semantics

(文字セマンティクスの効果)

=begin original

Character semantics have the following effects:

=end original

文字セマンティクスは以下の効果を持っています:

=over 4

=item *

=begin original

Strings--including hash keys--and regular expression patterns may
contain characters that have an ordinal value larger than 255.

=end original

文字列 -- ハッシュのキーを含め -- と正規表現パターンは序数値として 255 を
超える値を持つ文字を含めることができます。

=begin original

If you use a Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a C<BOM> or C<use utf8>, the latter requires a C<BOM>.)

=end original

プログラムを編集するのに Unicode エディタを使っているのであれば、Unicode の
文字 UTF-8 か UTF-16 のエンコーディングコーディングでリテラル文字列に
含めることができます。
(前者は C<BOM> か C<use utf8> を必要とし、後者は C<BOM> を必要とします。)

=begin original

Unicode characters can also be added to a string by using the C<\N{U+...}>
notation.  The Unicode code for the desired character, in hexadecimal,
should be placed in the braces, after the C<U>. For instance, a smiley face is
C<\N{U+263A}>.

=end original

Unicode の文字は C<\x{...}> 表記を使うことにより文字列に
追加することもできます。
その表現される Unicode コードは、16 進でブレースに囲みます。
たとえば、smiley face は C<\N{U+263A}> です。

=begin original

Alternatively, you can use the C<\x{...}> notation for characters C<0x100> and
above.  For characters below C<0x100> you may get byte semantics instead of
character semantics;  see L</The "Unicode Bug">.  On EBCDIC machines there is
the additional problem that the value for such characters gives the EBCDIC
character rather than the Unicode one, thus it is more portable to use
C<\N{U+...}> instead.

=end original

あるいは、C<0x100> 以上の文字については C<\x{...}> 記法が使えます。
C<0x100> より小さい文字については文字セマンティクスではなく
バイトセマンティクスを使います; L</The "Unicode Bug"> を参照してください。
EBCDIC マシンでは、このような文字の値が Unicode のものではなく
EBCDIC のものになるという追加の問題があります;
従って、代わりに C<\N{U+...}> を使う方が移植性があります。

=begin original

Additionally, you can use the C<\N{...}> notation and put the official
Unicode character name within the braces, such as
C<\N{WHITE SMILING FACE}>.  This automatically loads the L<charnames>
module with the C<:full> and C<:short> options.  If you prefer different
options for this module, you can instead, before the C<\N{...}>,
explicitly load it with your desired options; for example,

=end original

これに加えて、C<\N{...}> 表記を使うことができ、公式な Unicode 文字名を
C<\N{WHITE SMILING FACE}> のようにブレースの中に置くことができます。
これは自動的に C<:full> と C<:short> オプション付きで
L<charnames> で読み込みます。
このモジュールに異なったオプションを指定したい場合は、C<\N{...}> を
使う前に、好みのオプションで明示的にこれを読み込んでください; 例えば:

   use charnames ':loose';

=item *

=begin original

If an appropriate L<encoding> is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl does not currently attempt to canonicalize variable
names.

=end original

適切な L<encoding> が指定されていれば、Perl スクリプトの中の識別子で
表意文字を含めた Unicode の英数字を含めることができます。
Perl は現在、変数名を正規化しようとはしません。

=item *

=begin original

Regular expressions match characters instead of bytes.  C<"."> matches
a character instead of a byte.

=end original

正規表現はバイトではなく文字にマッチします。
C<"."> は一バイトではなく、ひとつの文字にマッチします。

=item *

=begin original

Bracketed character classes in regular expressions match characters instead of
bytes and match against the character properties specified in the
Unicode properties database.  C<\w> can be used to match a Japanese
ideograph, for instance.

=end original

正規表現中の大かっこ文字クラスはバイトではなく文字にマッチし、Unicode の
特性データベースで定義されている文字特性に対してマッチを行います。
たとえば、C<\w> は日本語の表意文字にマッチさせるために使うことができます。

=item *

=begin original

Named Unicode properties, scripts, and block ranges may be used (like bracketed
character classes) by using the C<\p{}> "matches property" construct and
the C<\P{}> negation, "doesn't match property".
See L</"Unicode Character Properties"> for more details.

=end original

名前付き Unicode 特性、用字、ブロック範囲は、
C<\p{}> 「特性にマッチング」構文および否定である C<\P{}>
「特性にマッチングしない」を使って(大かっこ文字クラスのように)使えます。
さらなる詳細については L</"Unicode Character Properties"> を参照してください。

=begin original

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.
See L</"User-Defined Character Properties"> for more details.

=end original

独自の文字特性を定義して、C<\p{}> と C<\P{}> 構文によって
正規表現でそれらを使うことができます。
さらなる詳細については L</"User-Defined Character Properties"> を
参照してください。

=item *

=begin original

The special pattern C<\X> matches a logical character, an "extended grapheme
cluster" in Standardese.  In Unicode what appears to the user to be a single
character, for example an accented C<G>, may in fact be composed of a sequence
of characters, in this case a C<G> followed by an accent character.  C<\X>
will match the entire sequence.

=end original

特殊なパターン C<\X> は論理文字、標準で言うところの
「拡張書記素クラスタ」にマッチングします。
Unicode では、ユーザーには単一の文字、例えばアクセント付きの C<G> に
見えるものが、実際には文字の並び、この場合では C<G> に引き続いて
アクセント文字から構成されるかもしれません。
C<\X> は並び全体にマッチングします。

=item *

=begin original

The C<tr///> operator translates characters instead of bytes.  Note
that the C<tr///CU> functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).

=end original

C<tr///> 演算子はバイトではなく文字で変換します。
C<tr///CU> は削除されたことに注意してください。
同様のことを行うには pack('U0', ...) と pack('C0', ...) を
参照してください。

=item *

=begin original

Case translation operators use the Unicode case translation tables
when character input is provided.  Note that C<uc()>, or C<\U> in
interpolated strings, translates to uppercase, while C<ucfirst>,
or C<\u> in interpolated strings, translates to titlecase in languages
that make the distinction (which is equivalent to uppercase in languages
without the distinction).

=end original

大小文字の変換演算子は Unicode の大小文字変換テーブルを、文字の入力が
あったときに使用します。
C<uc()> や展開文字列中の C<\U> は大文字に変換し、C<ucfirst> や
展開文字列中の C<\u> はその言語で区別されているときに
タイトルケースに変換します (これは、区別がない言語では大文字と等価です)。

=item *

=begin original

Most operators that deal with positions or lengths in a string will
automatically switch to using character positions, including
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sprintf()>, C<write()>, and C<length()>.  An operator that
specifically does not switch is C<vec()>.  Operators that really don't
care include operators that treat strings as a bucket of bits such as
C<sort()>, and operators dealing with filenames.

=end original

文字列の位置や長さを取り扱う演算子の大部分は自動的に文字の位置を
使うように変更されました; これには C<chop()>, C<chomp()>, C<substr()>,
C<pos()>, C<index()>, C<rindex()>, C<sprintf()>, C<write()>, C<length()> が
含まれます。
C<vec()> は変更されていません。
文字列をビットのバケツのように扱う C<sort()>、ファイル名を取り扱う演算子は
文字かどうかを気にしません。

=item *

=begin original

The C<pack()>/C<unpack()> letter C<C> does I<not> change, since it is often
used for byte-oriented formats.  Again, think C<char> in the C language.

=end original

C<pack()>/C<unpack()> の文字 C<C> は I<変更されていません>; なぜなら、
これらはしばしばバイト指向の書式のために使われるからです。
繰り返しますが、C 言語の C<char> を考えてください。

=begin original

There is a new C<U> specifier that converts between Unicode characters
and code points. There is also a C<W> specifier that is the equivalent of
C<chr>/C<ord> and properly handles character values even if they are above 255.

=end original

Unicode の文字と符号位置の間の変換を行う新たな C<U> 指定子があります。
C<chr>/C<ord> と等価で、文字の値が 255 を超えていても適切に扱える
C<W> 指定子もあります。

=item *

=begin original

The C<chr()> and C<ord()> functions work on characters, similar to
C<pack("W")> and C<unpack("W")>, I<not> C<pack("C")> and
C<unpack("C")>.  C<pack("C")> and C<unpack("C")> are methods for
emulating byte-oriented C<chr()> and C<ord()> on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.

=end original

C<chr()> 関数と C<ord()> 関数は C<pack("W")> や C<unpack("W")> のように
文字に対して働き、C<pack("C")> や C<unpack("C")> のようには I<働きません>。
C<pack("C")> と C<unpack("C")> は Unicode 文字列においてバイト指向の
C<chr()> や C<ord()> をエミュレートするためのメソッドです。
これらのメソッドが Unicode 文字列の内部エンコーディングを明らかにするので、
通常はケアする必要はありません。

=item *

=begin original

The bit string operators, C<& | ^ ~>, can operate on character data.
However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use C<~> (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (C<~($x|$y) eq ~$x&~$y> and C<~($x&$y) eq ~$x|~$y>)
will not hold.  The reason for this mathematical I<faux pas> is that
the complement cannot return B<both> the 8-bit (byte-wide) bit
complement B<and> the full character-wide bit complement.

=end original

ビット文字列演算子 C<& | ^ ~> は文字データを操作できます。
しかし、例えば全ての文字の値が 255 以下のときに
ビット文字列演算を使った場合の後方互換性のために、
256 以上の値の文字と 255 以下の値の文字の両方が含まれている文字列に
C<~> (ビット補数) を使うべきではありません。
最も重要なことは、ド・モルガンの法則 (C<~($x|$y) eq ~$x&~$y> と
C<~($x&$y) eq ~$x|~$y>) が成り立たないということです。
この数学的な I<過失> の理由は補数(complement)が 8 ビットのビット補数
B<および> 文字幅のビット補数の B<両方> を返すことができないためです。

=item *

=begin original

There is a CPAN module, C<L<Unicode::Casing>>, which allows you to define
your own mappings to be used in C<lc()>, C<lcfirst()>, C<uc()>,
C<ucfirst()>, and C<fc> (or their double-quoted string inlined
versions such as C<\U>).
(Prior to Perl 5.16, this functionality was partially provided
in the Perl core, but suffered from a number of insurmountable
drawbacks, so the CPAN module was written instead.)

=end original

C<lc()>, C<lcfirst()>, C<uc()>, C<ucfirst()>, C<fc> (および C<\U> のような
ダブルクォート文字列インライン版) で使える独自のマッピングを定義できる
CPAN モジュール C<L<Unicode::Casing>> があります。
(Perl 5.16 以前では、この機能は Perl コアで部分的に提供されていましたが、
多くの克服できない欠点があったため、代わりに CPAN モジュールが書かれました。)

=back

=over 4

=item *

=begin original

And finally, C<scalar reverse()> reverses by character rather than by byte.

=end original

そして最後に、C<scalar reverse()> はバイト単位ではなく文字単位で
反転を行います。

=back

=head2 Unicode Character Properties

(Unicode 文字特性)

=begin original

(The only time that Perl considers a sequence of individual code
points as a single logical character is in the C<\X> construct, already
mentioned above.   Therefore "character" in this discussion means a single
Unicode code point.)

=end original

(Perl が個々の符号位置の並びを単一の論理文字として扱う
唯一のタイミングは、既に前述した C<\X> 構文です。
従って、この議論での「文字」は単一の Unicode 符号位置を意味します。)

=begin original

Very nearly all Unicode character properties are accessible through
regular expressions by using the C<\p{}> "matches property" construct
and the C<\P{}> "doesn't match property" for its negation.

=end original

ほぼ全ての Unicode 文字特性は、
C<\p{}> "matches property" 構文とその否定形の C<\P{}>
"doesn't match property" を使った正規表現を通してアクセス可能です。

=begin original

For instance, C<\p{Uppercase}> matches any single character with the Unicode
C<"Uppercase"> property, while C<\p{L}> matches any character with a
C<General_Category> of C<"L"> (letter) property (see
L</General_Category> below).  Brackets are not
required for single letter property names, so C<\p{L}> is equivalent to C<\pL>.

=end original

たとえば、C<\p{Uppercase}> は Unicode の C<"Uppercase"> 特性を持つ任意の
単一の文字にマッチングし、C<\p{L}> は C<General_Category> C<"L"> (letter)
特性を持つ任意の文字にマッチングします
(後述する L</General_Category> 参照)。
中かっこは一文字の特性名では省略することができるので、C<\p{L}> は
C<\pL> と等価です。

=begin original

More formally, C<\p{Uppercase}> matches any single character whose Unicode
C<Uppercase> property value is C<True>, and C<\P{Uppercase}> matches any character
whose C<Uppercase> property value is C<False>, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively.

=end original

より正式には、C<\p{Uppercase}> は Unicode の C<Uppercase> 特性値 が
C<True> である任意の単一の文字とマッチングし、C<\P{UpperCase}> は
C<UpperCase> 特性値 が C<False> である任意の文字とマッチングします;
そしてこれらはそれぞれ C<\p{Uppercase=True}>, C<\p{Uppercase=False}> と書けます。

=begin original

This formality is needed when properties are not binary; that is, if they can
take on more values than just C<True> and C<False>.  For example, the
C<Bidi_Class> property (see L</"Bidirectional Character Types"> below),
can take on several different
values, such as C<Left>, C<Right>, C<Whitespace>, and others.  To match these, one needs
to specify both the property name (C<Bidi_Class>), AND the value being
matched against
(C<Left>, C<Right>, etc.).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.

=end original

この形式は、特性が 2 値でない場合、つまり、単に C<True> と C<False> より多くの
値を取ることができる場合に必要です。
たとえば、C<Bidi_Class> 特性(L</"Bidirectional Character Types"> を参照)は、
C<Left>, C<Right>, C<Whitespace> などのさまざまな値を取ることができます。
これらにマッチングするには、特性名(C<Bidi_Class>)と、
マッチングする値 (C<Left>, C<Right> など) の両方を指定する必要があります。
これは、前述の例のように、二つの要素を等号
(または、C<\p{Biddi_Class:Left}> のように交換可能なコロン)で
区切ることによって、実行されます。

=begin original

All Unicode-defined character properties may be written in these compound forms
of C<\p{I<property>=I<value>}> or C<\p{I<property>:I<value>}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

=end original

すべての Unicode が定義した文字特性は、C<\p{I<property>=I<value>}> や
C<\p{I<property>:I<value>}> のような複合形式で書けますが、
Perl は特性名および等号やコロンの区切り文字を省略できるように、
単一形式でのみ書ける追加の特性や、全ての 2 値特性と一部の後述する
ものに対する単一形式のショートカットを提供します。

=begin original

Most Unicode character properties have at least two synonyms (or aliases if you
prefer): a short one that is easier to type and a longer one that is more
descriptive and hence easier to understand.  Thus the C<"L"> and
C<"Letter"> properties above are equivalent and can be used
interchangeably.  Likewise, C<"Upper"> is a synonym for C<"Uppercase">,
and we could have written C<\p{Uppercase}> equivalently as C<\p{Upper}>.
Also, there are typically various synonyms for the values the property
can be.   For binary properties, C<"True"> has 3 synonyms: C<"T">,
C<"Yes">, and C<"Y">; and C<"False"> has correspondingly C<"F">,
C<"No">, and C<"N">.  But be careful.  A short form of a value for one
property may not mean the same thing as the same short form for another.
Thus, for the C<L</General_Category>> property, C<"L"> means
C<"Letter">, but for the L<C<Bidi_Class>|/Bidirectional Character Types>
property, C<"L"> means C<"Left">.  A complete list of properties and
synonyms is in L<perluniprops>.

=end original

ほとんどの Unicode 文字特性には、少なくとも二つの同義語
(またはあなたが好むなら別名)があります; 簡単に入力できる短いものと、
より長いけれども説明的で理解しやすいものです。
したがって、前述の C<"L"> および C<"Letter"> 特性は等価であり、
交換可能です。
同様に、C<"Upper"> は C<"Uppercase"> の同義語であり、C<\p{Uppercase}> は
等価に C<\p{Upper}> と書けます。
また、典型的には特性の値に対してさまざまな同義語があります。
2 値特性の場合、C<"True"> には三つの同義語があります:
C<"T">, C<"Yes">, C<"Y">; C<"False"> には C<"F">, C<"No">, C<"N"> が
あります。
しかし注意してください。
ある特性に対する値の短い形式は、他の特性の同じ短い形式と同じものを
意味するとは限りません。
従って、C<L</General_Category>> 特性では C<"L"> は C<"Letter"> を
意味しますが、L<C<Bidi_Class>|/Bidirectional Character Types> 特性では、
C<"L"> は C<"Left"> を意味します。
特性および同義語の完全な一覧は L<perluniprops> にあります。

=begin original

Upper/lower case differences in property names and values are irrelevant;
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators, so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, white space and even
hyphens can usually be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is used is in the middle of numbers, and in the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to non-word characters),
hyphens, and non-interior underscores.

=end original

特性名と値の大文字と小文字の違いは無関係です;
したがって C<\p{Upper}> は C<\p{upper}>, さらには C<\p{UpPeR}> とも同じことを
意味します。
同様に、単語の中のどこにでも下線を追加または削除できるので、
これらは C<\p{U_p_p_e_r}> とも等価です。
また、中かっこや等号、コロンなどの非単語文字に隣接した空白は無視されるので、
C<\p{   Upper  }> and C<\p{ Upper_case : Y }> も等価です。
実際には、通常、空白とハイフンさえどこにでも追加または削除できます。
したがって、C<\p{Upper case=Yes}> ですらも等価です。
これはすべて Unicode で「緩いマッチング」と呼ばれます。
数少ない厳密なマッチングが採用されている場所は数値の中と、下線で始まったり
終わったりする Perl 拡張特性です。
より厳密なマッチングは空白(非単語文字に隣接するものを除く)、ハイフン、
非内部下線を考慮します。

=begin original

You can also use negation in both C<\p{}> and C<\P{}> by introducing a caret
(C<^>) between the first brace and the property name: C<\p{^Tamil}> is
equal to C<\P{Tamil}>.

=end original

C<\p{}> と C<\P{}> の両方で、キャレット(C<^>) を最初のブレースと
特性名の間に置くことによって意味を反転することができます:
C<\p{^Tamil}> は C<\P{Tamil}> と等価です。

=begin original

Almost all properties are immune to case-insensitive matching.  That is,
adding a C</i> regular expression modifier does not change what they
match.  There are two sets that are affected.
The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
And the second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
This set also includes its subsets C<PosixUpper> and C<PosixLower> both
of which under C</i> match C<PosixAlpha>.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case so they are C<Cased>, but aren't considered
letters, so they aren't C<Cased_Letter>s.)

=end original

ほとんど全ての特性は大文字小文字を考慮したマッチングの影響を受けません。
つまり、C</i> 正規表現修飾子を追加することは、
それらがマッチングするものを変えません。
影響を受ける二つの集合があります。
最初の集合は、
C<Uppercase_Letter>,
C<Lowercase_Letter>,
C<Titlecase_Letter>,
C</i> の下で C<Cased_Letter> にマッチングする全てです。
二番目の集合は、
C<Uppercase>,
C<Lowercase>,
C<Titlecase>,
C</i> マッチングの基で C<Cased> にマッチングする全てです。
この集合はまた、C</i> マッチングの基で C<PosixAlpha> にマッチングする
そのサブセット C<PosixUpper> と C<PosixLower> を含みます。
(これらの集合の違いは、ローマ数字のような一部のもので、
大文字と小文字の両方に含まれるので C<Cased> であるけれども、
しかし字と考えられないので、C<Cased_Letter> ではありません。)

=begin original

See L</Beyond Unicode code points> for special considerations when
matching Unicode properties against non-Unicode code points.

=end original

非 Unicode 符号位置に対して Unicode 特性をマッチングしたときの
特殊処理については L</Beyond Unicode code points> を参照してください。

=head3 B<General_Category>

=begin original

Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<http://www.unicode.org/reports/tr44>).

=end original

全ての Unicode 文字は一つの一般カテゴリに割り当てられています;
これは「その文字の最も普通のカテゴライズ」
(L<http://www.unicode.org/reports/tr44> より)です。

=begin original

The compound way of writing these is like C<\p{General_Category=Number}>
(short, C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.

=end original

これらを書く複合的な方法は C<\p{General_Category=Number}>
(短縮形は C<\p{gc:n}>) のようなものです。
Perl は等号またはコロンの区切り文字までの全てを省略できる機能を
提供しています。
従って、代わりに単に C<\pN> と書けます。

=begin original

Here are the short and long forms of the values the C<General Category> property
can have:

=end original

以下は、Unicode の C<一般カテゴリ> 特性が持つことができる値の
短形式と長形式です:

    Short       Long

    L           Letter
    LC, L&      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter

    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark

    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation

    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol

    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator

    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned

=begin original

Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
C<LC> and C<L&> are special: both are aliases for the set consisting of everything matched by C<Ll>, C<Lu>, and C<Lt>.

=end original

単一文字の特性は同じ文字で始まる二文字の任意のサブ特性に含まれる
すべての文字にマッチします。
C<LC> と C<L&> は特別です: 両方とも C<Ll>, C<Lu>, C<Lt> に
マッチングする全てからなる集合への別名です。

=head3 B<Bidirectional Character Types>

(B<双方向文字型>)

=begin original

Because scripts differ in their directionality (Hebrew and Arabic are
written right to left, for example) Unicode supplies a C<Bidi_Class> property.
Some of the values this property can have are:

=end original

用字はその方向性で異なるので (例えばヘブライ語とアラビア語は右から左に
書きます) Unicode は以下の特性を C<Bidi_Class> 特性で提供しています。
この特性が持つことができる値の一部は:

    Value       Meaning

    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals

=begin original

This property is always written in the compound form.
For example, C<\p{Bidi_Class:R}> matches characters that are normally
written right to left.  Unlike the
C<L</General_Category>> property, this
property can have more values added in a future Unicode release.  Those
listed above comprised the complete set for many Unicode releases, but
others were added in Unicode 6.3; you can always find what the
current ones are in in L<perluniprops>.  And
L<http://www.unicode.org/reports/tr9/> describes how to use them.

=end original

この特性は常に複合形式で書かれます。
たとえば、C<\p{Bidi_Class:R}> は通常右から左に書く文字にマッチします。
C<L</General_Category>> 特性とは異なり、
この特性は将来リリースされる Unicode でさらに値が追加されるかもしれません。
これらの上述したものは何回もの Unicode のリリースの間完全な一覧でしたが、
その他の物は Unicode 6.3 で追加されたものです;
現在の内容についてはいつでも L<perluniprops> で確認できます。
これらの使い方については
L<http://www.unicode.org/reports/tr9/> に記述されています。

=head3 B<Scripts>

(B<用字>)

=begin original

The world's languages are written in many different scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

=end original

世界の言語は多くの異なった用字で書かれています。
この文は(訳文を読んでいない限り)ラテン文字で書かれていますが、ロシア語は
キリル文字で書かれています; そしてギリシャ語は、ええと、ギリシャ文字です;
日本語は主にひらがなやカタカナで書かれています。
もっとたくさんあります。

=begin original

The Unicode Script and Script_Extensions properties give what script a
given character is in.  Either property can be specified with the
compound form like
C<\p{Script=Hebrew}> (short: C<\p{sc=hebr}>), or
C<\p{Script_Extensions=Javanese}> (short: C<\p{scx=java}>).
In addition, Perl furnishes shortcuts for all
C<Script> property names.  You can omit everything up through the equals
(or colon), and simply write C<\p{Latin}> or C<\P{Cyrillic}>.
(This is not true for C<Script_Extensions>, which is required to be
written in the compound form.)

=end original

Unicode の Script と Script_Extensions 特性は、指定された文字の中にある
用字を示します
それぞれの用字は C<\p{Script=Hebrew}> (短縮: C<\p{sc=hebr}>)
または
C<\p{Script_Extensions=Javanese}> (short: C<\p{scx=java}>)
のような
複合形式で指定できます。
さらに Perl は、すべてのC<Script> 用字のショートカットを提供します。
等号(またはコロン)までのすべてを省略できます;
そして単に C<\p{Latin}> や C<\P{Cyrillic}> と書けます。
(これは C<Script_Extensions> では正しくありません; これは
複合形式で書かれることを要求します。)

=begin original

The difference between these two properties involves characters that are
used in multiple scripts.  For example the digits '0' through '9' are
used in many parts of the world.  These are placed in a script named
C<Common>.  Other characters are used in just a few scripts.  For
example, the C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> is used in both Japanese
scripts, Katakana and Hiragana, but nowhere else.  The C<Script>
property places all characters that are used in multiple scripts in the
C<Common> script, while the C<Script_Extensions> property places those
that are used in only a few scripts into each of those scripts; while
still using C<Common> for those used in many scripts.  Thus both these
match:

=end original

これら二つの特性の違いは、複数の用字で使われている文字に関係があります。
例えば、数字 '0' から '9' は世界中の大部分で使われています。
これらは C<Common> という名前の用字に置かれています。
その他の文字はほんのいくつかの用字でのみ使われています。
例えば、C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> は日本語の二つの用字
Katakana と Hiragana の両方で使われていますが、その他では使われていません。
C<Script> 特性は、C<Common> 用字にあって、複数のの用字で使われている
全ての文字に与えられています;
一方 C<Script_Extensions> 特性は、それらの用字それぞれのほんのいくつかの
用字でのみ使われているものに与えられます;
一方多くの用字で使われているものについては未だ C<Common> が使われています。
従ってこれらは両方ともマッチングし:

 "0" =~ /\p{sc=Common}/     # Matches
 "0" =~ /\p{scx=Common}/    # Matches

=begin original

and only the first of these match:

=end original

そしてこれらは最初だけがマッチングします:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Common} # No match

=begin original

And only the last two of these match:

=end original

それこれらは最後の二つだけがマッチングします:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Matches

=begin original

C<Script_Extensions> is thus an improved C<Script>, in which there are
fewer characters in the C<Common> script, and correspondingly more in
other scripts.  It is new in Unicode version 6.0, and its data are likely
to change significantly in later releases, as things get sorted out.

=end original

このように C<Script_Extensions> は改良された C<Script> で、
C<Common> 用字にある文字はより少なく、それに応じて他の用字の文字は
より多くなっています。
これは Unicode バージョン 6.0 からの新しいもので、そのデータは
将来のリリースで整理されて大きく変更される可能性が高いです。

=begin original

(Actually, besides C<Common>, the C<Inherited> script, contains
characters that are used in multiple scripts.  These are modifier
characters which modify other characters, and inherit the script value
of the controlling character.  Some of these are used in many scripts,
and so go into C<Inherited> in both C<Script> and C<Script_Extensions>.
Others are used in just a few scripts, so are in C<Inherited> in
C<Script>, but not in C<Script_Extensions>.)

=end original

(実際、C<Common> を除くと、C<Inherited> 用字は複数の用字で使われている
文字を含みます。
他の文字を修正して、制御文字の用字の値を継承する文字のための
修飾文字です。
その一部は多くの用字で使われているので、
C<Script> と C<Script_Extensions> の両方の中に
C<Inherited> が入っています。
その他のものはいくつかの用字でのみ使われているので、
C<Script> の C<Inherited> にはありますが、
C<Script_Extensions> にはありません。)

=begin original

It is worth stressing that there are several different sets of digits in
Unicode that are equivalent to 0-9 and are matchable by C<\d> in a
regular expression.  If they are used in a single language only, they
are in that language's C<Script> and C<Script_Extension>.  If they are
used in more than one script, they will be in C<sc=Common>, but only
if they are used in many scripts should they be in C<scx=Common>.

=end original

Unicode には、0-9 と等価で、正規表現内で C<\d> にマッチングできる数字の
集合がいくつかあることは強調する価値があります。
それらが単一の言語だけで使われた場合、それらはその言語の
C<Script> と C<Script_Extension> です。
これらが複数の用字で使われている場合、
それらは C<sc=Common> の中にありますが、
C<scx=Common> にあるべき多くの用字で使われている場合のみです。

=begin original

A complete list of scripts and their shortcuts is in L<perluniprops>.

=end original

用字とその省略形の完全な一覧は L<perluniprops> にあります。

=head3 B<Use of the C<"Is"> Prefix>

(B<C<"Is"> 接頭辞の使用>)

=begin original

For backward compatibility (with Perl 5.6), all properties mentioned
so far may have C<Is> or C<Is_> prepended to their name, so C<\P{Is_Lu}>, for
example, is equal to C<\P{Lu}>, and C<\p{IsScript:Arabic}> is equal to
C<\p{Arabic}>.

=end original

(Perl 5.6 との)後方互換性のため、すべての特性はその名前の前に C<Is>
または C<Is_> を置くことができます; したがって、C<\P{Is_Lu}> は C<\P{Lu}> と
等価で、C<\p{IsScript:Arabic}> は C<\p{Arabic}> と等価です。

=head3 B<Blocks>

(B<ブロック>)

=begin original

In addition to B<scripts>, Unicode also defines B<blocks> of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the C<"Basic Latin">
block is all characters whose ordinals are between 0 and 127, inclusive; in
other words, the ASCII characters.  The C<"Latin"> script contains some letters
from this as well as several other blocks, like C<"Latin-1 Supplement">,
C<"Latin Extended-A">, etc., but it does not contain all the characters from
those blocks. It does not, for example, contain the digits 0-9, because
those digits are shared across many scripts, and hence are in the
C<Common> script.

=end original

B<用字> に加え、Unicode では文字の B<ブロック> を定義しています。
用字とブロックの違いは、用字のコンセプトが自然言語に
密着したものであるのに対して、ブロックのコンセプトは連続した番号を持つ
Unicode 文字のグループに基づいたより人工的なグループ分けであることです。
たとえば、C<"Basic Latin"> ブロックは番号 0 から 127 までの全ての文字です;
言い換えると ASCII 文字です。
C<"Latin"> 用字は、このブロックの文字と、C<"Latin-1 Supplement">,
C<"Latin Extended-A"> などのその他のいくつかのブロックの文字を含んでいますが、
それらのブロックのすべての文字を含んではいません。
例を挙げると、数字 0-9 は多くの用字を越えて共有されているので、
(Latin 用字は)数字を含まないので、これらは C<Common> 用字にあります。

=begin original

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<http://www.unicode.org/reports/tr24>

=end original

用字とブロックに違いに関する詳細については、
UAX#24 "Unicode Script Property"
L<http://www.unicode.org/reports/tr24> を参照してください。

=begin original

The C<Script> or C<Script_Extensions> properties are likely to be the
ones you want to use when processing
natural language; the C<Block> property may occasionally be useful in working
with the nuts and bolts of Unicode.

=end original

C<Script> や C<Script_Extensions> 特性は自然言語を処理するときにおそらく
使いたいと思うようなものです;
C<Block> 特性は Unicode の基本的な部分で動作させるのに時々有用です。

=begin original

Block names are matched in the compound form, like C<\p{Block: Arrows}> or
C<\p{Blk=Hebrew}>.  Unlike most other properties, only a few block names have a
Unicode-defined short name.  But Perl does provide a (slight) shortcut:  You
can say, for example C<\p{In_Arrows}> or C<\p{In_Hebrew}>.  For backwards
compatibility, the C<In> prefix may be omitted if there is no naming conflict
with a script or any other property, and you can even use an C<Is> prefix
instead in those cases.  But it is not a good idea to do this, for a couple
reasons:

=end original

ブロック名は C<\p{Block: Arrows}> や C<\p{Blk=Hebrew}> のような
復号形式でマッチングします。
その他のほとんどの特性と違って、いくつかのブロック名だけが Unicode が
定義した短い名前を持ちます。
しかし Perl は(多少の)ショートカットを提供します: 例えば C<\p{In_Arrows}> や
C<\p{In_Hebrew}> のように書けます。  
後方互換性のために、C<In> 接頭辞は用字や他の特性と衝突しなければ
省略することも可能ですし、このような場合で C<Is> 接頭辞を使うこともできます。
しかしそうするのはいい考えではありません; いくつかの理由があります:

=over 4

=item 1

=begin original

It is confusing.  There are many naming conflicts, and you may forget some.
For example, C<\p{Hebrew}> means the I<script> Hebrew, and NOT the I<block>
Hebrew.  But would you remember that 6 months from now?

=end original

混乱します。
多くの名前の衝突があり、一部を忘れているかもしれません。
例えば、C<\p{Hebrew}> はヘブライ I<用字> を意味し、
ヘブライ I<ブロック> ではありません。
しかし 6 ヶ月後まで覚えていられますか?

=item 2

=begin original

It is unstable.  A new version of Unicode may preempt the current meaning by
creating a property with the same name.  There was a time in very early Unicode
releases when C<\p{Hebrew}> would have matched the I<block> Hebrew; now it
doesn't.

=end original

不安定です。
新しいバージョンの Unicode は、同じ名前の特性を作ることで現在の意味を
変えることがあります。
とても初期の Unicode リリースでは
C<\p{Hebrew}> がヘブライ I<ブロック> にマッチングしていた時期がありました;
今はマッチングしません。

=back

=begin original

Some people prefer to always use C<\p{Block: foo}> and C<\p{Script: bar}>
instead of the shortcuts, whether for clarity, because they can't remember the
difference between 'In' and 'Is' anyway, or they aren't confident that those who
eventually will read their code will know that difference.

=end original

一部の人々は、明確化のため、および 'In' と 'Is' の違いを覚えていられない、
あるいは最終的にコードを読む人々が違いを知っているか自信がないという理由で、
ショートカットではなく常に C<\p{Block: foo}> や C<\p{Script: bar}> を
使うのを好みます。

=begin original

A complete list of blocks and their shortcuts is in L<perluniprops>.

=end original

ブロックとその省略形の完全な一覧は L<perluniprops> にあります。

=head3 B<Other Properties>

(B<その他の特性>)

=begin original

There are many more properties than the very basic ones described here.
A complete list is in L<perluniprops>.

=end original

ここで記述したとても基本的なものよりもとても多くの特性があります。
完全な一覧は L<perluniprops> です。

=begin original

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  Most of these are just synonyms for the
Unicode ones, but some are genuine extensions, including several that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<http://www.unicode.org/reports/tr18>).

=end original

Unicode は、複合形式ですべての特性を定義するので、
単一形式の特性はすべて Perl 拡張になります。
これらのほとんどは Unicode のものの同義語にすぎませんが、いくつかは
本物の拡張であり、複合形式のものもあります。
そしてこれらのいくつかは実際に Unicode
(L<http://www.unicode.org/reports/tr18>)で推奨されています。

=begin original

This section gives some details on all extensions that aren't just
synonyms for compound-form Unicode properties
(for those properties, you'll have to refer to the
L<Unicode Standard|http://www.unicode.org/reports/tr44>.

=end original

この節では、単に複合形式の Unicode 特性の同義語ではないすべての
拡張機能について詳しく説明します (これらの特性については、
L<Unicode Standard http://www.unicode.org/reports/tr44> を
参照してください)。

=over

=item B<C<\p{All}>>

=begin original

This matches every possible code point.  It is equivalent to C<qr/./s>.
Unlike all the other non-user-defined C<\p{}> property matches, no
warning is ever generated if this is property is matched against a
non-Unicode code point (see L</Beyond Unicode code points> below).

=end original

これは全ての符号位置にマッチングします。
これは C<qr/./s> と等価です。
その他全てのユーザー定義でない C<\p{}> 特性のマッチングと異なり、
この特性はたとえ非 Unicode 符号位置に対してマッチングしても警告は
発生しません (後述する L</Beyond Unicode code points> 参照)。

=item B<C<\p{Alnum}>>

=begin original

This matches any C<\p{Alphabetic}> or C<\p{Decimal_Number}> character.

=end original

これは任意の C<\p{Alphabetic}> または C<\p{Decimal_Number}> 文字に
マッチングします。

=item B<C<\p{Any}>>

=begin original

This matches any of the 1_114_112 Unicode code points.  It is a synonym
for C<\p{Unicode}>.

=end original

これは任意の 1_114_112 Unicode 符号位置にマッチングします。
これは C<\p{Unicode}> の同義語です。

=item B<C<\p{ASCII}>>

=begin original

This matches any of the 128 characters in the US-ASCII character set,
which is a subset of Unicode.

=end original

これは、Unicode のサブセットである、US-ASCII 文字集合の 128 文字に
マッチングします。

=item B<C<\p{Assigned}>>

=begin original

This matches any assigned code point; that is, any code point whose L<general
category|/General_Category> is not C<Unassigned> (or equivalently, not C<Cn>).

=end original

これは任意の割り当てられた符号位置にマッチングします; つまり、
L<general category|/General_Category> が
C<Unassigned> ではない(または同等に C<Cn> ではない) 符号位置です。

=item B<C<\p{Blank}>>

=begin original

This is the same as C<\h> and C<\p{HorizSpace}>:  A character that changes the
spacing horizontally.

=end original

これは C<\h> および C<\p{HorizSpace}> と同じです: スペースを垂直に変更する
文字です。

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (Short: C<\p{Dt=NonCanon}>)

=begin original

Matches a character that has a non-canonical decomposition.

=end original

非正準分解文字にマッチングします。

=begin original

To understand the use of this rarely used I<property=value> combination, it is
necessary to know some basics about decomposition.
Consider a character, say H.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side or the other, etc.  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base H, and a
character for each of the possible marks, and these can be variously combined
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
This is called an "extended grapheme cluster";  Perl furnishes the C<\X>
regular expression construct to match such sequences.

=end original

このめったに使われない I<property=value> の組の使い方を理解するために、
分解に関するいくつかの基本を知る必要があります。
一つの文字、例えば H について考えてみます。
これは文字の回りの様々なマークとして現れることがあって、
鋭アクセント、曲折アクセント、フック、円、矢など、上、下、左、右、などです。
世界中の言語の中では多くの可能性があります。
組み合わせの数は天文学的で、
それぞれの組み合わせを一つの文字にすると、Unicode の数百万の可能な文字を
すぐに使い切ってしまいます。
それで Unicode は異なる手法を取りました:
基本となる H を一つの文字として、
それぞれの可能なマークのそれぞれを一つの文字として、
最後に論理的な文字でこれらを様々に結合できるようにしました。
それで一つの論理文字--単一の文字として現れるもの--は
複数の独立した文字の並びになることがあります。
これは「拡張書記素クラスタ」("extended grapheme cluster")と呼ばれます;
Perl はこのような並びにマッチングする C<\X> 正規表現構文を用意しています。

=begin original

But Unicode's intent is to unify the existing character set standards and
practices, and several pre-existing standards have single characters that
mean the same thing as some of these combinations.  An example is ISO-8859-1,
which has quite a few of these in the Latin-1 range, an example being C<"LATIN
CAPITAL LETTER E WITH ACUTE">.  Because this character was in this pre-existing
standard, Unicode added it to its repertoire.  But this character is considered
by Unicode to be equivalent to the sequence consisting of the character
C<"LATIN CAPITAL LETTER E"> followed by the character C<"COMBINING ACUTE ACCENT">.

=end original

しかし Unicode の意図は既存の文字集合標準と慣習を統一することであり、
既存のいくつかの標準規格には、これらの組み合わせと同じものを意味する
単一文字が含まれています。
例として、ISO-8859-1があります。この例では、Latin-1の範囲が非常に多く、
C<"LATIN CAPITAL LETTER E WITH ACUTE"> と呼ばれる例があります。
この文字は既存の標準に含まれていたため、Unicode はそれをレパートリーに
追加しました。
しかしこの文字は、文字 C<"LATIN CAPITAL LETTER E"> に引き続いて文字
C<"COMBINING ACUTE ACCENT"> からなる並びと等価であると
Unicode によって考えられています。

=begin original

C<"LATIN CAPITAL LETTER E WITH ACUTE"> is called a "pre-composed" character, and
its equivalence with the sequence is called canonical equivalence.  All
pre-composed characters are said to have a decomposition (into the equivalent
sequence), and the decomposition type is also called canonical.

=end original

C<"LATIN CAPITAL LETTER E WITH ACUTE"> は「合成済」(pre-composed) 文字と
呼ばれ、等価な並びは正準等価 (canonical equivalence) と呼ばれます。
全ての合成済文字は(等価な並びに)分解でき、分解の種類もまた正準と呼ばれます。

=begin original

However, many more characters have a different type of decomposition, a
"compatible" or "non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the pre-composed
character.  An example, again in the Latin-1 range, is the C<"SUPERSCRIPT ONE">.
It is somewhat like a regular digit 1, but not exactly; its decomposition
into the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see L<http://www.unicode.org/reports/tr44>), including one
called "compat", which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen.

=end original

しかし、多くの文字は異なる種類の分解を持ち、
「互換」分解あるいは「非正準」分解と呼ばれます。
これらの分解を形成する並びは合成済文字への正準等価ではないと考えられます。
例えば、再び Latin-1 の範囲では C<"SUPERSCRIPT ONE"> です。
これは普通の数字 1 のようなものですが、正確ではありません;
これの数字 1 への分解は
「互換」分解と呼ばれ、特に「スーパー」分解と呼ばれます。
このような互換分解(L<http://www.unicode.org/reports/tr44>を参照)は
いくつかあります; "compat" と呼ばれる、
Unicodeが 選択した分解カテゴリに収まらない、様々な分解を意味するものも
あります。

=begin original

Note that most Unicode characters don't have a decomposition, so their
decomposition type is C<"None">.

=end original

ほとんどの Unicode 文字は分解を持たないので、それらの分解型は C<"None"> です。

=begin original

For your convenience, Perl has added the C<Non_Canonical> decomposition
type to mean any of the several compatibility decompositions.

=end original

便利なように、Perl は任意の様々な互換分解を意味する C<Non_Canonical> 分解型を
追加しています。

=item B<C<\p{Graph}>>

=begin original

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.

=end original

任意の図形文字にマッチングします。
理論的には、これはプリンタがインクを使うことになる文字を意味します。

=item B<C<\p{HorizSpace}>>

=begin original

This is the same as C<\h> and C<\p{Blank}>:  a character that changes the
spacing horizontally.

=end original

これは C<\h> や C<\p{Blank}> と同じです:
スペースを垂直に変更するものです。

=item B<C<\p{In=*}>>

=begin original

This is a synonym for C<\p{Present_In=*}>

=end original

これは C<\p{Present_In=*}> の同義語です。

=item B<C<\p{PerlSpace}>>

=begin original

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>
and starting in Perl v5.18, experimentally, a vertical tab.

=end original

これは C<\s> と同じで、ASCII に制限されます; つまり C<S<[ \f\n\r\t]>>、
および、Perl v5.18 から実験的に垂直タブ、です。

=begin original

Mnemonic: Perl's (original) space

=end original

記憶法: Perl の (元々の) スペース

=item B<C<\p{PerlWord}>>

=begin original

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>

=end original

これは C<\w> と同じで ASCII に制限されます; つまり C<[A-Za-z0-9_]> です。

=begin original

Mnemonic: Perl's (original) word.

=end original

記憶法: Perl の (元々の) 単語。

=item B<C<\p{Posix...}>>

=begin original

There are several of these, which are equivalents using the C<\p{}>
notation for Posix classes and are described in
L<perlrecharclass/POSIX Character Classes>.

=end original

これらのいくつかには Posix クラスのための C<\p{}> 記法を使った
等価物があります; これらは
L<perlrecharclass/POSIX Character Classes> に記述されています。

=item B<C<\p{Present_In: *}>>    (Short: C<\p{In=*}>)

=begin original

This property is used when you need to know in what Unicode version(s) a
character is.

=end original

この特性は、この文字の Unicode バージョンを知る必要があるときに使われます。

=begin original

The "*" above stands for some two digit Unicode version number, such as
C<1.1> or C<4.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.

=end original

前述の "*" は、C<1.1> や C<4.0> のような 2 桁の Unicode バージョン番号です;
あるいは "*" は C<Unassigned> も取ります。
この特性は、最終的な配置がバージョン番号によって指定された Unicode リリースに
設定された符号位置にマッチングします;
C<\p{Present_In: Unassigned}> は、まだ意味が割り当てられていない符号位置に
マッチングします。

=begin original

For example, C<U+0041> C<"LATIN CAPITAL LETTER A"> was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became C<"LATIN SMALL LETTER Y WITH LOOP">, so the only "*" that
would match it are 5.1, 5.2, and later.

=end original

たとえば、C<U+0041> C<"LATIN CAPITAL LETTER A"> は、使用可能な
最初の Unicode リリースである C<1.1> から存在しているので、
この特性はすべての有効な "*" バージョンに対して真です。
一方、C<U+1EFF> は、これが C<"LATIN SMALL LETTER Y WITH LOOP"> になった
バージョン 5.1 まで割り当てられていなかったので、
これにマッチングする "*" は 5.1, 5.2, およびそれ以降です。

=begin original

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.

=end original

Unicodeは、C<Age> 特性を、これから派生したものから提供します。
Age の問題は、(Perl が行う) 厳密な解釈によって、符号位置の
意味が導入された正確なリリースと一致することです。
したがって、C<U+0041> は、1.1 のみにマッチングし、C<U+1eff> は 5.1 とのみ
マッチングします。
これは通常、あなたが望むものではありません。

=begin original

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl C<Present_In> property; just be aware of that.

=end original

Age 特性の非 Perl 実装の中には、Perl の C<Present_In> 特性と
同じ意味を持つように変更しているものがあります; 知っておいてください。

=begin original

Another confusion with both these properties is that the definition is not
that the code point has been I<assigned>, but that the meaning of the code point
has been I<determined>.  This is because 66 code points will always be
unassigned, and so the C<Age> for them is the Unicode version in which the decision
to make them so was made.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character, as also does C<\p{Present_In: 3.1}> and up.

=end original

これらの特性に関するもう一つの混乱は、定義は
この符号位置が I<割り当てられた> ということではなく、
符号位置の意味が I<決定された> ということです。
これは、66 の符号位置が常に割り当てられなくなり、
それらに対する C<Age> はそう決定された Unicode のバージョンだからです。
たとえば、C<U+FDD0> は永続的に文字が割り当てられないことなっていて、
この決定はバージョン 3.1 で行われたので、
したがって C<\p{Age=3.1}> はこの文字にマッチングし、
C<\p{Present_In:3.1}> 以上もマッチングします。

=item B<C<\p{Print}>>

=begin original

This matches any character that is graphical or blank, except controls.

=end original

制御文字を除く、任意の図形文字か空白にマッチングします。

=item B<C<\p{SpacePerl}>>

=begin original

This is the same as C<\s>, including beyond ASCII.

=end original

これは C<\s> は同様で、ASCII の範囲外を含みます。

=begin original

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
which both the Posix standard and Unicode consider white space.)

=end original

記憶法: スペース、Perl によって修正。
(これは、Posix 標準と Unicode の両方が空白と考える垂直タブを含みません。)

=item B<C<\p{Title}>> and  B<C<\p{Titlecase}>>

(B<C<\p{Title}>> と B<C<\p{Titlecase}>>)

=begin original

Under case-sensitive matching, these both match the same code points as
C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>).  The difference
is that under C</i> caseless matching, these match the same as
C<\p{Cased}>, whereas C<\p{gc=lt}> matches C<\p{Cased_Letter>).

=end original

大文字小文字を無視するマッチングの下では、これらの両方は
C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>) として
同じ符号位置にマッチングします。
違いは、C</i> 大文字小文字無視マッチングでは、
これらのマッチングは C<\p{Cased}> と同じで、
C<\p{gc=lt}> は C<\p{Cased_Letter>) にマッチングすると言うことです。

=item B<C<\p{Unicode}>>

=begin original

This matches any of the 1_114_112 Unicode code points.
C<\p{Any}>.

=end original

これは任意の 1_114_112 Unicode 符号位置にマッチングします。
これは C<\p{Any}> の同義語です。

=item B<C<\p{VertSpace}>>

=begin original

This is the same as C<\v>:  A character that changes the spacing vertically.

=end original

これは C<\v> と同じです: 垂直の空白を変更する文字です。

=item B<C<\p{Word}>>

=begin original

This is the same as C<\w>, including over 100_000 characters beyond ASCII.

=end original

これは C<\w> と同じで、ASCII 範囲外の 100_000 を超える文字を含みます。

=item B<C<\p{XPosix...}>>

=begin original

There are several of these, which are the standard Posix classes
extended to the full Unicode range.  They are described in
L<perlrecharclass/POSIX Character Classes>.

=end original

これらのいくつかには、完全な Unicode の範囲に拡張された標準 Posix クラスが
あります; これらは
L<perlrecharclass/POSIX Character Classes> に記述されています。

=back

=head2 User-Defined Character Properties

(ユーザ定義文字特性)

=begin original

You can define your own binary character properties by defining subroutines
whose names begin with C<"In"> or C<"Is">.  (The experimental feature
L<perlre/(?[ ])> provides an alternative which allows more complex
definitions.)  The subroutines can be defined in any
package.  The user-defined properties can be used in the regular expression
C<\p{}> and C<\P{}> constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its package in the
C<\p{}> or C<\P{}> construct.

=end original

あなた自身の 2 値文字特性を、C<"In"> または C<"Is"> で始まる名前の
サブルーチンを定義することによって持つことができます。
(実験的機能 L<perlre/(?[ ])> はより複雑な定義を可能にする選択肢を
提供します。)
そのサブルーチンは任意のパッケージで定義することができます。
ユーザー定義特性は正規表現の C<\p{}> 構造や C<\P{}> 構造で使うことができます;
もしユーザー定義特性をそれがあるパッケージ以外で使いたいのであれば、
パッケージ名を C<\p{}> (もしくは C<\P{}>)のために指定する必要があります。

    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }

=begin original

Note that the effect is compile-time and immutable once defined.
However, the subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and non-zero if caseless matching
is in effect.  The subroutine may return different values depending on
the value of the flag, and one set of values will immutably be in effect
for all case-sensitive matches, and the other set for all case-insensitive
matches.

=end original

この効果はコンパイル時のもので、一度定義してしまったら
変更できないことに注意してください。
しかし、サブルーチンは一つの引数を取ります;
大文字小文字を認識するマッチングが有効の場合は 0 となり、
大文字小文字を無視するマッチングが有効の場合は非 0 となります。
サブルーチンはフラグの値に依存して異なった値を返すことがあり、
ある集合の値は全ての大文字小文字を認識するマッチングで変わらず有効になり、
もう一つの集合は大文字小文字を無視するマッチングで有効になります。

=begin original

Note that if the regular expression is tainted, then Perl will die rather
than calling the subroutine when the name of the subroutine is
determined by the tainted data.

=end original

正規表現が汚染されている場合、Perl はサブルーチンの呼び出し時ではなく、
サブルーチンの名前が汚染されたデータによって決定された時点で
die することに注意してください。

=begin original

The subroutines must return a specially-formatted string, with one
or more newline-separated lines.  Each line must be one of the following:

=end original

サブルーチンは、ひとつ以上の改行で区切られた特定の形式の文字列を
返さなければなりません。
各行は以下のいずれかの形式でなければなりません:

=over 4

=item *

=begin original

A single hexadecimal number denoting a code point to include.

=end original

含まれる符号位置を示す 1 つの 16 進数。

=item *

=begin original

Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denoting a range of code points to include.

=end original

含まれる符号位置の範囲を示す、
水平的空白(スペースもしくはタブ)によって区切られる 2 つの 16 進数。

=item *

=begin original

Something to include, prefixed by C<"+">: a built-in character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

(C<"+"> を前置して) その特性に含めるもの:
(C<"utf8::"> が前置された) 組み込みの文字特性もしくは
(パッケージ名を含めた)完全修飾されたユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to exclude, prefixed by C<"-">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

(C<"-"> を前置して) その特性から除外するもの:
(C<"utf8::"> が前置された) 組み込みの文字特性もしくは
(パッケージ名を含めた)完全修飾されたユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to negate, prefixed C<"!">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

(C<"!"> を前置して)否定を取るもの:
(C<"utf8::"> が前置された) 組み込みの文字特性もしくは
(パッケージ名を含めた)完全修飾されたユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to intersect with, prefixed by C<"&">: an existing character
property (prefixed by C<"utf8::">) or a fully qualified (including package
name) user-defined character property,
for all the characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal code point.

=end original

(C<"&"> を前置して)共通集合を取るもの:
特性にある文字以外の全ての文字のための
(C<"utf8::"> が前置された) 既に存在する文字特性または
(パッケージ名を含めた)完全修飾されたユーザー定義文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=back

=begin original

For example, to define a property that covers both the Japanese
syllabaries (hiragana and katakana), you can define

=end original

例えば、両方の日本語の音節(ひらがなとカタカナ)を対象とする特性を
定義するには、以下のように定義します

    sub InKana {
        return <<END;
    3040\t309F
    30A0\t30FF
    END
    }

=begin original

Imagine that the here-doc end marker is at the beginning of the line.
Now you can use C<\p{InKana}> and C<\P{InKana}>.

=end original

ヒアドキュメントの終端マーカーは行の先頭に置かれることを思い出してください。
これで、C<\p{InKana}> や C<\P{InKana}> を使うことができます。

=begin original

You could also have used the existing block property names:

=end original

すでに存在しているブロック特性名を使うこともできます:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }

=begin original

Suppose you wanted to match only the allocated characters,
not the raw block ranges: in other words, you want to remove
the non-characters:

=end original

生のブロック範囲ではなく、割り当てられた文字のみにマッチさせたいと
考えているとしましょう: 言い換えれば、文字以外のものを
取り除きたいということです:

    sub InKana {
        return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }

=begin original

The negation is useful for defining (surprise!) negated classes.

=end original

否定は否定クラスを定義するのに便利です。

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }

=begin original

This will match all non-Unicode code points, since every one of them is
not in Kana.  You can use intersection to exclude these, if desired, as
this modified example shows:

=end original

これは全ての非 Unicode 符号位置にマッチングします;
これらのどれも Kana ではないからです。
もし必要なら、この修正された例にように、これらを除外するために
共通集合を使えます:

    sub InNotKana {
        return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &utf8::Any
    END
    }

=begin original

C<&utf8::Any> must be the last line in the definition.

=end original

C<&utf8::Any> は定義の最後の行でなければなりません。

=begin original

Intersection is used generally for getting the common characters matched
by two (or more) classes.  It's important to remember not to use C<"&"> for
the first set; that would be intersecting with nothing, resulting in an
empty set.

=end original

共通集合は一般的に二つ(またはそれ以上)のクラスによってマッチングする
共通の文字を得るために使われます。
最初の集合に C<"&"> を使わないことを覚えておくことは重要です;
これは空集合との共通集合を取るので、結果として空集合になります。

=begin original

Unlike non-user-defined C<\p{}> property matches, no warning is ever
generated if these properties are matched against a non-Unicode code
point (see L</Beyond Unicode code points> below).

=end original

ユーザー定義でない C<\p{}> 特性のマッチングと異なり、
この特性はたとえ非 Unicode 符号位置に対してマッチングしても警告は
発生しません (後述する L</Beyond Unicode code points> 参照)。

=head2 User-Defined Case Mappings (for serious hackers only)

(ユーザ定義の大文字・小文字の対応関係(真剣なハッカー専用))

=begin original

B<This feature has been removed as of Perl 5.16.>
The CPAN module C<L<Unicode::Casing>> provides better functionality without
the drawbacks that this feature had.  If you are using a Perl earlier
than 5.16, this feature was most fully documented in the 5.14 version of
this pod:
L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>

=end original

B<この機能は Perl 5.16 で削除されました。>
CPAN モジュール C<L<Unicode::Casing>> はこの機能が持っていた欠点なしに
よりよい機能を提供します。
5.16 より前の Perl を使っている場合、この機能は 5.14 版のこの pod に
もっともよく文書化されています:
L<http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29>

=head2 Character Encodings for Input and Output

(入出力のための文字エンコーディング)

=begin original

See L<Encode>.

=end original

L<Encode> を参照してください。

=head2 Unicode Regular Expression Support Level

(Unicode 正規表現対応レベル)

=begin original

The following list of Unicode supported features for regular expressions describes
all features currently directly supported by core Perl.  The references to "Level N"
and the section numbers refer to the Unicode Technical Standard #18,
"Unicode Regular Expressions", version 13, from August 2008.

=end original

以下に挙げるリストは、現在コア Perl が直接対応している全ての機能を記述する、
正規表現のための Unicode 対応のリストです。
"Level N" に対する参照とセクション番号は
Unicode Technical Standard #18,
"Unicode Regular Expressions", version 13, from August 2008
を参照しています。

=over 4

=item *

Level 1 - Basic Unicode Support

 RL1.1   Hex Notation                     - done          [1]
 RL1.2   Properties                       - done          [2][3]
 RL1.2a  Compatibility Properties         - done          [4]
 RL1.3   Subtraction and Intersection     - experimental  [5]
 RL1.4   Simple Word Boundaries           - done          [6]
 RL1.5   Simple Loose Matches             - done          [7]
 RL1.6   Line Boundaries                  - MISSING       [8][9]
 RL1.7   Supplementary Code Points        - done          [10]

=over 4

=item [1]

C<\x{...}>

=item [2]

C<\p{...}> C<\P{...}>

=item [3]

=begin original

supports not only minimal list, but all Unicode character properties (see Unicode Character Properties above)

=end original

最小限のリストだけでなく、全ての Unicode 文字特性に対応します
(上述の Unicode Character Properties を参照)

=item [4]

C<\d> C<\D> C<\s> C<\S> C<\w> C<\W> C<\X> C<[:I<prop>:]> C<[:^I<prop>:]>

=item [5]

=begin original

The experimental feature in v5.18 C<"(?[...])"> accomplishes this.  See
L<perlre/(?[ ])>.  If you don't want to use an experimental feature,
you can use one of the following:

=end original

v5.18 の実験的機能 C<"(?[...])"> がこれを行います。
L<perlre/(?[ ])> を参照してください。
実験的機能を使いたくない場合次のうちのどれかが使えます:

=over 4

=item * Regular expression look-ahead

=begin original

You can mimic class subtraction using lookahead.
For example, what UTS#18 might write as

=end original

class subtraction を先読みを使って模倣することができます。
たとえば、以下の UTR #18 は

    [{Block=Greek}-[{UNASSIGNED}]]

=begin original

in Perl can be written as:

=end original

以下のように Perl で記述できます:

    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}

=begin original

But in this particular example, you probably really want

=end original

しかし、この特定の例では、あなたが実際に望んでいたのは次のものでしょう

    \p{Greek}

=begin original

which will match assigned characters known to be part of the Greek script.

=end original

これは Greek 用字の一部として知られている assigned character にマッチします。

=item * CPAN module C<L<Unicode::Regex::Set>>

=begin original

It does implement the full UTS#18 grouping, intersection, union, and
removal (subtraction) syntax.

=end original

これは UTR #18 のグルーピング、intersection、union, removal(substraction)
構文を完全に実装しています。

=item * L</"User-Defined Character Properties">

=begin original

C<"+"> for union, C<"-"> for removal (set-difference), C<"&"> for intersection

=end original

結合のためには C<"+">、除去(差集合)のためには C<"-">、
共通集合のためには C<"&"> です

=back

=item [6]

C<\b> C<\B>

=item [7]

=begin original

Note that Perl does Full case-folding in matching (but with bugs), not
Simple: for example C<U+1F88> is equivalent to C<U+1F00 U+03B9>, instead of
just C<U+1F80>.  This difference matters mainly for certain Greek capital
letters with certain modifiers: the Full case-folding decomposes the
letter, while the Simple case-folding would map it to a single
character.

=end original

Perl はマッチングで Simple ではなく Full 大文字小文字畳み込みを
(バグ付きで)行うことに注意してください:
例えば C<U+1F88> は単なる C<U+1F80> ではなく C<U+1F00 U+03B9> と等価です。
この違いは、主にある種の修飾子付きのある種のギリシャ大文字に対して
問題になります: Full 大文字小文字畳み込みは文字を分解しますが、
Simple 大文字小文字畳み込みはそれを単一文字にマッピングします。

=item [8]

=begin original

Should do C<^> and C<$> also on C<U+000B> (C<\v> in C), C<FF> (C<\f>),
C<CR> (C<\r>), C<CRLF> (C<\r\n>), C<NEL> (C<U+0085>), C<LS> (C<U+2028>),
and C<PS> (C<U+2029>); should also affect C<E<lt>E<gt>>, C<$.>, and
script line numbers; should not split lines within C<CRLF> (i.e. there
is no empty line between C<\r> and C<\n>).  For C<CRLF>, try the
C<:crlf> layer (see L<PerlIO>).

=end original

C<U+000B> (C<\v> in C), C<FF> (C<\f>),
C<CR> (C<\r>), C<CRLF> (C<\r\n>), C<NEL> (C<U+0085>), C<LS> (C<U+2028>),
C<PS> (C<U+2029>) で C<^> と C<$> を行います;
C<E<lt>E<gt>>, C<$.>,  スクリプトの行番号にも影響を与えます;
C<CRLF> の中の行を分割しません (つまり C<\r> と C<\n> の間に
空行はありません)。
C<CRLF> については、C<:crlf> 層 (L<PerlIO> 参照) を試してください。

=item [9]

=begin original

Linebreaking conformant with L<UAX#14 "Unicode Line Breaking
Algorithm"|http://www.unicode.org/reports/tr14>
is available through the C<L<Unicode::LineBreak>> module.

=end original

L<UAX#14 "Unicode Line Breaking
Algorithm"|http://www.unicode.org/reports/tr14> の行分割一致は
C<L<Unicode::LineBreak>> モジュールによって可能です。

=item [10]

=begin original

UTF-8/UTF-EBDDIC used in Perl allows not only C<U+10000> to
C<U+10FFFF> but also beyond C<U+10FFFF>

=end original

Perl で使われる UTF-8/UTF-EBDDIC は C<U+10000> から
C<U+10FFFF> だけでなく C<U+10FFFF> を超える値も認めません

=back

=item *

Level 2 - Extended Unicode Support

 RL2.1   Canonical Equivalents           - MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       - MISSING       [12]
 RL2.3   Default Word Boundaries         - MISSING       [14]
 RL2.4   Default Loose Matches           - MISSING       [15]
 RL2.5   Name Properties                 - DONE
 RL2.6   Wildcard Properties             - MISSING

 [10] see UAX#15 "Unicode Normalization Forms"
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X but we don't have a "Grapheme Cluster Mode"
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)

=item *

Level 3 - Tailored Support

 RL3.1   Tailored Punctuation            - MISSING
 RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        - MISSING
 RL3.4   Tailored Loose Matches          - MISSING
 RL3.5   Tailored Ranges                 - MISSING
 RL3.6   Context Matching                - MISSING       [19]
 RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
 RL3.9   Possible Match Sets             - MISSING
 RL3.10  Folded Matching                 - MISSING       [20]
 RL3.11  Submatchers                     - MISSING

 [17] see UAX#10 "Unicode Collation Algorithms"
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?<=x) and (?=x), but look-aheads or look-behinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      "Character Foldings")

=back

=head2 Unicode Encodings

(Unicode のエンコーディング)

=begin original

Unicode characters are assigned to I<code points>, which are abstract
numbers.  To use these numbers, various encodings are needed.

=end original

Unicode 文字は抽象的な数値である I<符号位置> にアサインされています。
これらの数値を使うために、さまざまなエンコーディングが必要となります。

=over 4

=item *

UTF-8

=begin original

UTF-8 is a variable-length (1 to 4 bytes), byte-order independent
encoding. For ASCII (and we really do mean 7-bit ASCII, not another
8-bit encoding), UTF-8 is transparent.

=end original

UTF-8 は可変長(1 から 4 バイト)で、
バイトの並び順に依存しないエンコーディングです。
ASCII(ここでは 7-bit ASCII のことで、他の 8-bit エンコーディングのことでは
ありません)と UTF-8 は透過です。

=begin original

The following table is from Unicode 3.2.

=end original

以下のテーブルは Unicode 3.2 のものです。

 Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte

   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF

=begin original

Note the gaps marked by "*" before several of the byte entries above.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).

=end original

上記で '*' のマークが付いているいくつかのバイトエントリの前の
隙間に注意してください。
これらは、正当な UTF-8 が最短でないエンコードを避けるために
あります: 技術的には UTF-8 エンコードは一つの符号位置を複数の方法で
表すことができますが、これは明示的に禁止されていて、可能な限り最短の
エンコードが常に使われます(そしてそれが Perl のすることです)。

=begin original

Another way to look at it is via bits:

=end original

これを見るもう一つの方法はビット単位で見ることです:

                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte

                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa

=begin original

As you can see, the continuation bytes all begin with C<"10">, and the
leading bits of the start byte tell how many bytes there are in the
encoded character.

=end original

見ての通り、後続バイトはすべて C<"10"> から始まっていて、開始バイトの
先行ビットはエンコードされた文字がどのくらいの長さであるかを示しています。

=begin original

The original UTF-8 specification allowed up to 6 bytes, to allow
encoding of numbers up to C<0x7FFF_FFFF>.  Perl continues to allow those,
and has extended that up to 13 bytes to encode code points up to what
can fit in a 64-bit word.  However, Perl will warn if you output any of
these as being non-portable; and under strict UTF-8 input protocols,
they are forbidden.

=end original

元の UTF-8 仕様は、C<0x7FFF_FFFF> までの数値をエンコードできるように、
6 バイトまで許されていました。
Perl はこれを許し続け、さらに 64 ビットワードに適合する符号位置を
エンコードするために 13 バイトまで拡張しています。
しかし、これらを出力すると、Perl は互換性がないとして警告します;
そして厳密な UTF-8 入力プロトコルでは、これらは禁止されています。

=begin original

The Unicode non-character code points are also disallowed in UTF-8 in
"open interchange".  See L</Non-character code points>.

=end original

Unicode の非文字符号位置はまた、「交換用」UTF-8 では不許可です。
L</Non-character code points> を参照してください。

=item *

UTF-EBCDIC

=begin original

Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.

=end original

UTF-8 と似ていますが、UTF-8 が ASCII-safe であるように EBCDIC-safe です。

=item *

=begin original

UTF-16, UTF-16BE, UTF-16LE, Surrogates, and C<BOM>s (Byte Order Marks)

=end original

UTF-16, UTF-16BE, UTF-16LE, サロゲート, C<BOM> (Byte Order Marks)

=begin original

The followings items are mostly for reference and general Unicode
knowledge, Perl doesn't use these constructs internally.

=end original

以下の項目はほとんど参照および一般的な Unicode 知識のためのもので、
Perl はこれらの構造を内部で使っていません。

=begin original

Like UTF-8, UTF-16 is a variable-width encoding, but where
UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units.
All code points occupy either 2 or 4 bytes in UTF-16: code points
C<U+0000..U+FFFF> are stored in a single 16-bit unit, and code
points C<U+10000..U+10FFFF> in two 16-bit units.  The latter case is
using I<surrogates>, the first 16-bit unit being the I<high
surrogate>, and the second being the I<low surrogate>.

=end original

UTF-8 と同様、UTF-16 は可変長エンコーディングですが、
UTF-8 が 8 ビットの符号ユニットを使っているところ、
UTF-16 は 16 ビットの符号ユニットを使います。
UTF-16 は全ての符号位置が 2 バイトもしくは 4 バイトです:
C<U+0000..U+FFFF> の範囲の Unicode の符号位置はひとつの 16 ビット
ユニットに収められ、C<U+10000..U+10FFFF> の範囲の符号位置は 2 つの
16 ビットユニットに収められます。
後者をサロゲート(surrogates) と呼びます; 最初の 16 ビットユニットは
I<high surrogate> で、二番目は I<low surrogate> となります。

=begin original

Surrogates are code points set aside to encode the C<U+10000..U+10FFFF>
range of Unicode code points in pairs of 16-bit units.  The I<high
surrogates> are the range C<U+D800..U+DBFF> and the I<low surrogates>
are the range C<U+DC00..U+DFFF>.  The surrogate encoding is

=end original

サロゲートは Unicode の符号位置の C<U+10000..U+10FFFF> の範囲を
16 ビットユニットのペアで表現する集合です。
I<high surrogates> は C<U+D800..U+DBFF> の範囲で、I<low surrogates> は
C<U+DC00..U+DFFF> の範囲です。
サロゲートのエンコーディングは

    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;

=begin original

and the decoding is

=end original

であり、デコードは以下のようなものです

    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

=begin original

Because of the 16-bitness, UTF-16 is byte-order dependent.  UTF-16
itself can be used for in-memory computations, but if storage or
transfer is required either UTF-16BE (big-endian) or UTF-16LE
(little-endian) encodings must be chosen.

=end original

16-bitness のため、UTF-16 はバイトの並び順に依存します。
UTF-16 それ自身はメモリ内の計算に使うことができますが、格納や転送の際には
UTF-16BE (ビッグエンディアン)か UTF-16LE (リトルエンディアン)の
いずれかのエンコーディングを選択しなければなりません。

=begin original

This introduces another problem: what if you just know that your data
is UTF-16, but you don't know which endianness?  Byte Order Marks, or
C<BOM>s, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point C<U+FEFF> is the C<BOM>.

=end original

このことは別の問題を引き起こします: あなたのデータが UTF-16 であることだけを
知っていて、そのバイト並び順を知らなかったとしたら?
バイト順マーク (Byte Order Marks)、略して C<BOM> はこれを解決します。
バイト並びのマーカーとしての機能のために Unicode では特殊な文字が
予約されています: 符号位置 C<U+FEFF> の文字が C<BOM> です。

=begin original

The trick is that if you read a C<BOM>, you will know the byte order,
since if it was written on a big-endian platform, you will read the
bytes C<0xFE 0xFF>, but if it was written on a little-endian platform,
you will read the bytes C<0xFF 0xFE>.  (And if the originating platform
was writing in UTF-8, you will read the bytes C<0xEF 0xBB 0xBF>.)

=end original

このトリックは、C<BOM> を読み込んだときにバイト順がわかるということです;
ビッグエンディアンのプラットフォームで書かれたものならなら
C<0xFE 0xFF> を読み出し、リトルエンディガンのプラットフォームで
書かれたものなら C<0xFF 0xFE> を読み出します。
(そしてもし元のプラットフォームで UTF-8 で書かれたものならば
C<0xEF 0xBB 0xBF> というバイト列を読むことになるでしょう。)

=begin original

The way this trick works is that the character with the code point
C<U+FFFE> is not supposed to be in input streams, so the
sequence of bytes C<0xFF 0xFE> is unambiguously "C<BOM>, represented in
little-endian format" and cannot be C<U+FFFE>, represented in big-endian
format".

=end original

このトリックがうまくいくのは符号位置 C<U+FFFE> の文字は
入力ストリームには現れないはずであるということによって、
C<0xFF 0xFE> という並びは紛れなく
「リトルエンディアンフォーマットの C<BOM>」であって
「ビッグエンディアンの C<U+FFFE>」 とはならないのです。

=begin original

Surrogates have no meaning in Unicode outside their use in pairs to
represent other code points.  However, Perl allows them to be
represented individually internally, for example by saying
C<chr(0xD801)>, so that all code points, not just those valid for open
interchange, are
representable.  Unicode does define semantics for them, such as their
C<L</General_Category>> is C<"Cs">.  But because their use is somewhat dangerous,
Perl will warn (using the warning category C<"surrogate">, which is a
sub-category of C<"utf8">) if an attempt is made
to do things like take the lower case of one, or match
case-insensitively, or to output them.  (But don't try this on Perls
before 5.14.)

=end original

サロゲートは、他の符号位置を表すためにペアで使用する以外は、
Unicode では意味を持ちません。
ただし、Perl では、例えば C<chr(0xD801)> と記述することによって、
内部的に個別に表すことができるため、
オープンな交換に妥当な符号位置だけでなく、
すべての符号位置を表すことができます。
Unicode では、C<L</General_Category>> が C<"Cs"> であるなどの、
このための意味論が定義されています。
しかし、これらの使用はやや危険であるため、Perl では、小文字を使用したり、
大文字と小文字を無視してマッチングしたり、出力しようとした場合には、
(C<"utf8"> のサブカテゴリである C<"surrogate"> 警告カテゴリを使って) 警告が
出されます。
(ただし、5.14 より前の Perl でこれを使用しないでください。)

=item *

UTF-32, UTF-32BE, UTF-32LE

=begin original

The UTF-32 family is pretty much like the UTF-16 family, expect that
the units are 32-bit, and therefore the surrogate scheme is not
needed.  UTF-32 is a fixed-width encoding.  The C<BOM> signatures are
C<0x00 0x00 0xFE 0xFF> for BE and C<0xFF 0xFE 0x00 0x00> for LE.

=end original

UTF-32 ファミリーは UTF-16 ファミリーと良く似ていますが、ユニットが
32 ビットで、そのためサロゲート方式の必要がないという点が異なります。
UTF-32 は固定長エンコーディングです。
C<BOM> シグネチャは BE では C<0x00 0x00 0xFE 0xFF> に、
LE では C<0xFF 0xFE 0x00 0x00> になります。

=item *

UCS-2, UCS-4

=begin original

Legacy, fixed-width encodings defined by the ISO 10646 standard.  UCS-2 is a 16-bit
encoding.  Unlike UTF-16, UCS-2 is not extensible beyond C<U+FFFF>,
because it does not use surrogates.  UCS-4 is a 32-bit encoding,
functionally identical to UTF-32 (the difference being that
UCS-4 forbids neither surrogates nor code points larger than C<0x10_FFFF>).

=end original

ISO 10646 標準で定義されている古い固定長のエンコーディングです。
UCS-2 は 16 ビットエンコーディングです。
UTF-16 とは異なり、UCS-2 は C<U+FFFF> を超えた範囲に拡張できません;
これはサロゲートを使わないためです。
UCS-4 は 32 ビットエンコーディングで、機能的には UTF-32 と同じです
(違いは、UCS-4 はサロゲートや C<0x10_FFFF> より大きな符号位置を
禁止していることです)。

=item *

UTF-7

=begin original

A seven-bit safe (non-eight-bit) encoding, which is useful if the
transport or storage is not eight-bit safe.  Defined by RFC 2152.

=end original

7 ビットセーフ(非 8 ビット)エンコーディングで、8 ビットセーフでない
転送や格納に便利です。
RFC 2152 によって定義されています。

=back

=head2 Non-character code points

=begin original

66 code points are set aside in Unicode as "non-character code points".
These all have the C<Unassigned> (C<Cn>) C<L</General_Category>>, and
they never will
be assigned.  These are never supposed to be in legal Unicode input
streams, so that code can use them as sentinels that can be mixed in
with character data, and they always will be distinguishable from that data.
To keep them out of Perl input streams, strict UTF-8 should be
specified, such as by using the layer C<:encoding('UTF-8')>.  The
non-character code points are the 32 between C<U+FDD0> and C<U+FDEF>, and the
34 code points C<U+FFFE>, C<U+FFFF>, C<U+1FFFE>, C<U+1FFFF>, ... C<U+10FFFE>, C<U+10FFFF>.
Some people are under the mistaken impression that these are "illegal",
but that is not true.  An application or cooperating set of applications
can legally use them at will internally; but these code points are
"illegal for open interchange".  Therefore, Perl will not accept these
from input streams unless lax rules are being used, and will warn
(using the warning category C<"nonchar">, which is a sub-category of C<"utf8">) if
an attempt is made to output them.

=end original

66 の符号位置は、Unicode では「非文字符号位置」として確保されています。
これらはすべて C<Unassigned> (C<Cn>) C<L</General_Category>> を 持ち、
割り当てられることはありません。
これらは、妥当な Unicode 入力ストリーム内にあるとは想定されていないので、
コードでは文字データと混ぜられる標識として使用でき、
常にデータと区別できます。
これらを Perl の入力ストリームから締め出すためには、
C<:encoding('UTF-8')> 層を使うなどして、厳密な UTF-8 を指定する
必要があります。
非文字符号位置は、C<U+FDD0> と C<U+FDEF> の間にある 32 の符号位置と、
C<U+FFFE>, C<U+FFFF>, C<U+1FFFE>, C<U+1FFFF>, ... C<U+10FFFE>,
C<U+10FFFF> の 34 の符号位置です。
これらが「不正」であるという誤った印象を受けている人もいますが、
それは事実ではありません。
アプリケーションまたは連携するアプリケーションの集合は、
内部的には正当にこれらを使用できます; しかし、これらの符号位置は
「オープンな交換には不正」です。
したがって、Perl は、緩い規則が使用されていない限り入力ストリームから
これらを受け入れず、これらを出力しようとすると(C<"utf8"> のサブカテゴリである
C<"nonchar"> 警告カテゴリを使って)警告します。

=head2 Beyond Unicode code points

(Unicode 符号位置を越えたもの)

=begin original

The maximum Unicode code point is C<U+10FFFF>, and Unicode only defines
operations on code points up through that.  But Perl works on code
points up to the maximum permissible unsigned number available on the
platform.  However, Perl will not accept these from input streams unless
lax rules are being used, and will warn (using the warning category
C<"non_unicode">, which is a sub-category of C<"utf8">) if any are output.

=end original

Unicode 符号位置の最大値は C<U+10FFFF> で、
Unicode はここまでの符号位置に対する操作のみを定義しています。
しかし、Perl は、プラットフォームで利用可能な符号なしの最大数までの
符号位置で動作します。
しかし、Perl は、緩い規則が使用されていないかぎり、入力ストリームから
これらを受け入れず、それらを出力しようとすると(C<"utf8"> の
サブカテゴリである C<"non_unicode"> 警告カテゴリを使って)警告します。

=begin original

Since Unicode rules are not defined on these code points, if a
Unicode-defined operation is done on them, Perl uses what we believe are
sensible rules, while generally warning, using the C<"non_unicode">
category.  For example, C<uc("\x{11_0000}")> will generate such a
warning, returning the input parameter as its result, since Perl defines
the uppercase of every non-Unicode code point to be the code point
itself.  In fact, all the case changing operations, not just
uppercasing, work this way.

=end original

Unicode の規則はこれらの符号位置に対して定義されていないため、
Unicode が定義した操作がこれらに対して行われた場合、
Perl は私たちがふさわしいと信じる規則を使いますが、一般的には
C<"non_unicode"> カテゴリの警告を行います。
例えば、C<uc("\x{11_0000}")> はこの警告を生成し、入力パラメータを
その結果として返します; Perl はすべての非 Unicode 符号位置の大文字をその
符号位置自身と定義しているからです。
実際の所、大文字化だけでなく、全ての大文字小文字変更操作はこのように
動作します。

=begin original

The situation with matching Unicode properties in regular expressions,
the C<\p{}> and C<\P{}> constructs, against these code points is not as
clear cut, and how these are handled has changed as we've gained
experience.

=end original

正規表現中で C<\p{}> や C<\P{}> 構文による Unicode 特性を
このような符号位置に対してマッチングさせる状況は
はっきりしたものではなく、これらをどのように扱うかは
経験を積むにつれて変更されてきました。

=begin original

One possibility is to treat any match against these code points as
undefined.  But since Perl doesn't have the concept of a match being
undefined, it converts this to failing or C<FALSE>.  This is almost, but
not quite, what Perl did from v5.14 (when use of these code points
became generally reliable) through v5.18.  The difference is that Perl
treated all C<\p{}> matches as failing, but all C<\P{}> matches as
succeeding.

=end original

One possibility is to treat any match against these code points as
undefined.  But since Perl doesn't have the concept of a match being
undefined, it converts this to failing or C<FALSE>.  This is almost, but
not quite, what Perl did from v5.14 (when use of these code points
became generally reliable) through v5.18.  The difference is that Perl
treated all C<\p{}> matches as failing, but all C<\P{}> matches as
succeeding.
(TBT)

=begin original

One problem with this is that it leads to unexpected, and confusting
results in some cases:

=end original

One problem with this is that it leads to unexpected, and confusting
results in some cases:
(TBT)

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Failed on <= v5.18
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Failed! on <= v5.18

=begin original

That is, it treated both matches as undefined, and converted that to
false (raising a warning on each).  The first case is the expected
result, but the second is likely counterintuitive: "How could both be
false when they are complements?"  Another problem was that the
implementation optimized many Unicode property matches down to already
existing simpler, faster operations, which don't raise the warning.  We
chose to not forgo those optimizations, which help the vast majority of
matches, just to generate a warning for the unlikely event that an
above-Unicode code point is being matched against.

=end original

That is, it treated both matches as undefined, and converted that to
false (raising a warning on each).  The first case is the expected
result, but the second is likely counterintuitive: "How could both be
false when they are complements?"  Another problem was that the
implementation optimized many Unicode property matches down to already
existing simpler, faster operations, which don't raise the warning.  We
chose to not forgo those optimizations, which help the vast majority of
matches, just to generate a warning for the unlikely event that an
above-Unicode code point is being matched against.
(TBT)

=begin original

As a result of these problems, starting in v5.20, what Perl does is
to treat non-Unicode code points as just typical unassigned Unicode
characters, and matches accordingly.  (Note: Unicode has atypical
unassigned code points.  For example, it has non-character code points,
and ones that, when they do get assigned, are destined to be written
Right-to-left, as Arabic and Hebrew are.  Perl assumes that no
non-Unicode code point has any atypical properties.)

=end original

As a result of these problems, starting in v5.20, what Perl does is
to treat non-Unicode code points as just typical unassigned Unicode
characters, and matches accordingly.  (Note: Unicode has atypical
unassigned code points.  For example, it has non-character code points,
and ones that, when they do get assigned, are destined to be written
Right-to-left, as Arabic and Hebrew are.  Perl assumes that no
non-Unicode code point has any atypical properties.)
(TBT)

=begin original

Perl, in most cases, will raise a warning when matching an above-Unicode
code point against a Unicode property when the result is C<TRUE> for
C<\p{}>, and C<FALSE> for C<\P{}>.  For example:

=end original

Perl, in most cases, will raise a warning when matching an above-Unicode
code point against a Unicode property when the result is C<TRUE> for
C<\p{}>, and C<FALSE> for C<\P{}>.  For example:
(TBT)

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails, no warning
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Succeeds, with warning

=begin original

In both these examples, the character being matched is non-Unicode, so
Unicode doesn't define how it should match.  It clearly isn't an ASCII
hex digit, so the first example clearly should fail, and so it does,
with no warning.  But it is arguable that the second example should have
an undefined, hence C<FALSE>, result.  So a warning is raised for it.

=end original

In both these examples, the character being matched is non-Unicode, so
Unicode doesn't define how it should match.  It clearly isn't an ASCII
hex digit, so the first example clearly should fail, and so it does,
with no warning.  But it is arguable that the second example should have
an undefined, hence C<FALSE>, result.  So a warning is raised for it.
(TBT)

=begin original

Thus the warning is raised for many fewer cases than in earlier Perls,
and only when what the result is could be arguable.  It turns out that
none of the optimizations made by Perl (or are ever likely to be made)
cause the warning to be skipped, so it solves both problems of Perl's
earlier approach.  The most commonly used property that is affected by
this change is C<\p{Unassigned}> which is a short form for
C<\p{General_Category=Unassigned}>.  Starting in v5.20, all non-Unicode
code points are considered C<Unassigned>.  In earlier releases the
matches failed because the result was considered undefined.

=end original

Thus the warning is raised for many fewer cases than in earlier Perls,
and only when what the result is could be arguable.  It turns out that
none of the optimizations made by Perl (or are ever likely to be made)
cause the warning to be skipped, so it solves both problems of Perl's
earlier approach.  The most commonly used property that is affected by
this change is C<\p{Unassigned}> which is a short form for
C<\p{General_Category=Unassigned}>.  Starting in v5.20, all non-Unicode
code points are considered C<Unassigned>.  In earlier releases the
matches failed because the result was considered undefined.
(TBT)

=begin original

The only place where the warning is not raised when it might ought to
have been is if optimizations cause the whole pattern match to not even
be attempted.  For example, Perl may figure out that for a string to
match a certain regular expression pattern, the string has to contain
the substring C<"foobar">.  Before attempting the match, Perl may look
for that substring, and if not found, immediately fail the match without
actually trying it; so no warning gets generated even if the string
contains an above-Unicode code point.

=end original

The only place where the warning is not raised when it might ought to
have been is if optimizations cause the whole pattern match to not even
be attempted.  For example, Perl may figure out that for a string to
match a certain regular expression pattern, the string has to contain
the substring C<"foobar">.  Before attempting the match, Perl may look
for that substring, and if not found, immediately fail the match without
actually trying it; so no warning gets generated even if the string
contains an above-Unicode code point.
(TBT)

=begin original

This behavior is more "Do what I mean" than in earlier Perls for most
applications.  But it catches fewer issues for code that needs to be
strictly Unicode compliant.  Therefore there is an additional mode of
operation available to accommodate such code.  This mode is enabled if a
regular expression pattern is compiled within the lexical scope where
the C<"non_unicode"> warning class has been made fatal, say by:

=end original

This behavior is more "Do what I mean" than in earlier Perls for most
applications.  But it catches fewer issues for code that needs to be
strictly Unicode compliant.  Therefore there is an additional mode of
operation available to accommodate such code.  This mode is enabled if a
regular expression pattern is compiled within the lexical scope where
the C<"non_unicode"> warning class has been made fatal, say by:
(TBT)

 use warnings FATAL => "non_unicode"

=begin original

(see L<warnings>).  In this mode of operation, Perl will raise the
warning for all matches against a non-Unicode code point (not just the
arguable ones), and it skips the optimizations that might cause the
warning to not be output.  (It currently still won't warn if the match
isn't even attempted, like in the C<"foobar"> example above.)

=end original

(see L<warnings>).  In this mode of operation, Perl will raise the
warning for all matches against a non-Unicode code point (not just the
arguable ones), and it skips the optimizations that might cause the
warning to not be output.  (It currently still won't warn if the match
isn't even attempted, like in the C<"foobar"> example above.)
(TBT)

=begin original

In summary, Perl now normally treats non-Unicode code points as typical
Unicode unassigned code points for regular expression matches, raising a
warning only when it is arguable what the result should be.  However, if
this warning has been made fatal, it isn't skipped.

=end original

In summary, Perl now normally treats non-Unicode code points as typical
Unicode unassigned code points for regular expression matches, raising a
warning only when it is arguable what the result should be.  However, if
this warning has been made fatal, it isn't skipped.
(TBT)

=begin original

There is one exception to all this.  C<\p{All}> looks like a Unicode
property, but it is a Perl extension that is defined to be true for all
possible code points, Unicode or not, so no warning is ever generated
when matching this against a non-Unicode code point.  (Prior to v5.20,
it was an exact synonym for C<\p{Any}>, matching code points C<0>
through C<0x10FFFF>.)

=end original

There is one exception to all this.  C<\p{All}> looks like a Unicode
property, but it is a Perl extension that is defined to be true for all
possible code points, Unicode or not, so no warning is ever generated
when matching this against a non-Unicode code point.  (Prior to v5.20,
it was an exact synonym for C<\p{Any}>, matching code points C<0>
through C<0x10FFFF>.)
(TBT)

=head2 Security Implications of Unicode

(Unicode のセキュリティへの影響)

=begin original

Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.
Also, note the following:

=end original

L<Unicode Security Considerations|http://www.unicode.org/reports/tr36> を
呼んでください。
また、以下のことに注意してください:

=over 4

=item *

=begin original

Malformed UTF-8

=end original

不正な UTF-8

=begin original

Unfortunately, the original specification of UTF-8 leaves some room for
interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of UTF-8 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a UTF-8 connection.  Perl always generates the
shortest length UTF-8, and with warnings on, Perl will warn about
non-shortest length UTF-8 along with other malformations, such as the
surrogates, which are not Unicode code points valid for interchange.

=end original

残念ながら、元の UTF-8 の仕様ではひとつの Unicode 文字の入力から
何バイトのエンコードされた出力として解釈するのかについていくらかの
余地があります。
厳密にいえば、可能な限り最も短い UTF-8 バイト列が生成されるべきです;
なぜなら、そうしないと UTF-8 コネクションの終わりにおいて、入力バッファが
オーバーフローする可能性があるからです。
Perl は常に最も短い長さの UTF-8 を生成し、交換のために有効な Unicode の
符号位置でないサロゲートのような不正な形式の最短でない UTF-8 に関して
警告を発します。

=item *

=begin original

Regular expression pattern matching may surprise you if you're not
accustomed to Unicode.  Starting in Perl 5.14, several pattern
modifiers are available to control this, called the character set
modifiers.  Details are given in L<perlre/Character set modifiers>.

=end original

Unicode に慣れていないなら、正規表現パターンマッチングは
あなたを驚かせるかもしれません。
Perl 5.14 から、これを制御するためのいくつかのパターンマッチング修飾子が
利用可能になりました; これは文字集合修飾子と呼ばれます。
詳細は L<perlre/Character set modifiers> にあります。

=back

=begin original

As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to characters should happen.  Characters shouldn't get
downgraded to bytes, either.  It is possible to accidentally mix bytes
and characters, however (see L<perluniintro>), in which case C<\w> in
regular expressions might start behaving differently (unless the C</a>
modifier is in effect).  Review your code.  Use warnings and the C<strict> pragma.

=end original

すでに述べている通り、Perl は二つの世界のそれぞれに片方の足
(二つのひづめ?) を突っ込んでいます: 古いバイトの世界と新しい文字の世界で、
必要に応じてバイトから文字に昇格します。
もしあなたの古いコードが明示的に Unicode を使っていないのなら、文字への
切り替えが自動的になされることはありません。
文字はバイトにダウングレードされるべきではありません。
偶発的にバイトと文字が混じる可能性がありますが(L<perluniintro> を参照)、
そのような場合 (C</a> 修飾子が有効でない限り)
正規表現中の C<\w> は異なるふるまいをするかもしれません。
あなたのコードをレビューしてください。
warnings と C<strict> プラグマを使ってください。

=head2 Unicode in Perl on EBCDIC

(EBCDIC 上の Perl での Unicode)

=begin original

The way Unicode is handled on EBCDIC platforms is still
experimental.  On such platforms, references to UTF-8 encoding in this
document and elsewhere should be read as meaning the UTF-EBCDIC
specified in Unicode Technical Report 16, unless ASCII vs. EBCDIC issues
are specifically discussed. There is no C<utfebcdic> pragma or
C<":utfebcdic"> layer; rather, C<"utf8"> and C<":utf8"> are reused to mean
the platform's "natural" 8-bit encoding of Unicode. See L<perlebcdic>
for more discussion of the issues.

=end original

EBCDIC プラットフォームでの Unicode の扱い方は未だ実験的です。
このようなプラットフォームでは、この文書やその他での
UTF-8 エンコーディングへの言及は、特に ASCII 対 EBCDIC 問題について
議論されている場合でない限りは、Unicode Technical Report 16 で
定義されている UTF-EBCDIC を意味するものとして読むべきです。
C<utfebcdic> プラグマや C<":utfebcdic"> 層はありません;
代わりに、C<"utf8"> と C<":utf8"> が、そのプラットフォームの「自然な」
Unicode の 8 ビットエンコーディングを意味するように再利用されています。
この問題に関する更なる議論については L<perlebcdic> を参照してください。

=head2 Locales

(ロケール)

=begin original

See L<perllocale/Unicode and UTF-8>

=end original

L<perllocale/Unicode and UTF-8> を参照してください。

=head2 When Unicode Does Not Happen

(Unicode ではない場合)

=begin original

While Perl does have extensive ways to input and output in Unicode,
and a few other "entry points" like the C<@ARGV> array (which can sometimes be
interpreted as UTF-8), there are still many places where Unicode
(in some encoding or another) could be given as arguments or received as
results, or both, but it is not.

=end original

Perl には入出力を Unicode で行うための多数の方法があり、
C<@ARGV> 配列のように (時々 Unicode (UTF-8) として解釈できるような)その他の
「エントリポイント」はほとんどない一方、(何らかのエンコーディングで)
Unicode が引数として与えられたり結果として返されるべきにも関わらず、
そうなっていない場所も未だ多くあります。

=begin original

The following are such interfaces.  Also, see L</The "Unicode Bug">.
For all of these interfaces Perl
currently (as of v5.16.0) simply assumes byte strings both as arguments
and results, or UTF-8 strings if the (problematic) C<encoding> pragma has been used.

=end original

以下に挙げるのはそのようなインターフェースです。
また、L</The "Unicode Bug"> を参照してください。
これらすべてが現在の Perl(v5.16.0) では単純に引数と戻り値の両方が
バイト文字列か、(問題のある) C<encoding> プラグマが使われていれば
UTF-8 文字列であると仮定しています。

=begin original

One reason that Perl does not attempt to resolve the role of Unicode in
these situations is that the answers are highly dependent on the operating
system and the file system(s).  For example, whether filenames can be
in Unicode and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for C<qx> and C<system>: how well will the
"command-line interface" (and which of them?) handle Unicode?

=end original

このような状況において、Perl が Unicode による解決をしないのかの
理由の一つは、答えがオペレーティングシステムや
ファイルシステムに強く依存しているからです。
たとえば、ファイル名が Unicode で記述できてエンコーディングが
合っていたとしてもそれは移植性のあるコンセプトではないのです。
同様なことが C<qx> や C<system> にも言えます:
「コマンドラインインターフェース」は Unicode をどのように
扱うのでしょうか?

=over 4

=item *

C<chdir>, C<chmod>, C<chown>, C<chroot>, C<exec>, C<link>, C<lstat>, C<mkdir>,
C<rename>, C<rmdir>, C<stat>, C<symlink>, C<truncate>, C<unlink>, C<utime>, C<-X>

=item *

C<%ENV>

=item *

=begin original

C<glob> (aka the C<E<lt>*E<gt>>)

=end original

C<glob> (または C<E<lt>*E<gt>>)

=item *

C<open>, C<opendir>, C<sysopen>

=item *

=begin original

C<qx> (aka the backtick operator), C<system>

=end original

C<qx> (または逆クォート演算子), C<system>

=item *

C<readdir>, C<readlink>

=back

=head2 The "Unicode Bug"

(「Unicode バグ」)

=begin original

The term, "Unicode bug" has been applied to an inconsistency
on ASCII platforms with the
Unicode code points in the C<Latin-1 Supplement> block, that
is, between 128 and 255.  Without a locale specified, unlike all other
characters or code points, these characters have very different semantics in
byte semantics versus character semantics, unless
C<use feature 'unicode_strings'> is specified, directly or indirectly.
(It is indirectly specified by a C<use v5.12> or higher.)

=end original

「Unicode バグ」("Unicode bug")という用語は、ASCII プラットフォームで
C<Latin-1 Supplement> ブロック、つまり 128 から 255 にある Unicode 符号位置の
非一貫性に対して使われます。
ロケール指定がない場合、直接または間接に
C<use feature 'unicode_strings'> が指定されていない限り、
その他の文字や符号位置とは異なり、これらの文字は
バイトセマンティクスと文字セマンティクスでとても異なったセマンティクスです。
(C<use v5.12> 以上で間接的に指定されます。)

=begin original

In character semantics these upper-Latin1 characters are interpreted as
Unicode code points, which means
they have the same semantics as Latin-1 (ISO-8859-1).

=end original

文字セマンティクスでは、これらの上位の Latin1 文字は  Unicode 符号位置として
解釈され、Latin-1 (ISO-8859-1) と同じセマンティクスを持ちます。

=begin original

In byte semantics (without C<unicode_strings>), they are considered to
be unassigned characters, meaning that the only semantics they have is
their ordinal numbers, and that they are
not members of various character classes.  None are considered to match C<\w>
for example, but all match C<\W>.

=end original

(C<unicode_strings> なしの) バイトセマンティクスでは、
未定義文字として扱われ、保持している
セマンティクスはその番号だけで、様々な文字クラスのメンバにはならないことを
意味します。
例えばどれも C<\w> にはマッチングしませんが、全て C<\W> にマッチングします。

=begin original

Perl 5.12.0 added C<unicode_strings> to force character semantics on
these code points in some circumstances, which fixed portions of the
bug; Perl 5.14.0 fixed almost all of it; and Perl 5.16.0 fixed the
remainder (so far as we know, anyway).  The lesson here is to enable
C<unicode_strings> to avoid the headaches described below.

=end original

Perl 5.12.0 では、このバグの一部を修正する、
ある種の状況でこれらの符号位置の文字の意味論を強制する
C<unicode_strings> が追加されました;
Perl 5.14.0 ではこれらのほぼ全てを修正しました;
そして Perl 5.16.0 では (分かっている限りの) 残りを修正しました。
ここでの教訓は、後述する頭痛の種を避けるために
C<unicode_strings> を有効にする、ということです。

=begin original

The old, problematic behavior affects these areas:

=end original

この古い、問題のある振る舞いは以下のような領域で影響があります:

=over 4

=item *

=begin original

Changing the case of a scalar, that is, using C<uc()>, C<ucfirst()>, C<lc()>,
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in double-quotish
contexts, such as regular expression substitutions.
Under C<unicode_strings> starting in Perl 5.12.0, character semantics are
generally used.  See L<perlfunc/lc> for details on how this works
in combination with various other pragmas.

=end original

スカラの大文字小文字を変える; つまり、C<uc()>, C<ucfirst()>, C<lc()>,
C<lcfirst()> を使ったり、正規表現置換のようなダブルクォート風
コンテキストの中で C<\L>, C<\U>, C<\u>, C<\l> を使う。
Perl 5.12.0 からの C<unicode_strings> では、一般的に
文字セマンティクスが使われます。
これがさまざまなプラグマと組み合わせて動作する方法の
詳細については、L<perlfunc/lc> を参照してください。

=item *

=begin original

Using caseless (C</i>) regular expression matching.
Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use character semantics
even when executed or compiled into larger
regular expressions outside the scope.

=end original

大文字小文字を無視した (C</i>) 正規表現マッチングを使う。
Perl 5.14.0 から、C<unicode_strings> のスコープ内でコンパイルされた
正規表現は、スコープの外で実行されたり、
より大きな正規表現の中にコンパイルされたりした場合でも、
その振る舞いを保持します。

=item *

=begin original

Matching any of several properties in regular expressions, namely C<\b>,
C<\B>, C<\s>, C<\S>, C<\w>, C<\W>, and all the Posix character classes
I<except> C<[[:ascii:]]>.
Starting in Perl 5.14.0, regular expressions compiled within
the scope of C<unicode_strings> use character semantics
even when executed or compiled into larger
regular expressions outside the scope.

=end original

正規表現中に、C<\b>, C<\B>, C<\s>, C<\S>, C<\w>, C<\W> および、
C<[[:ascii:]]> I<以外の> Posix 文字クラスのような、
いくつかの特性を使う。
Perl 5.14.0 から、C<unicode_strings> のスコープ内でコンパイルされた
正規表現は、スコープの外で実行されたり、
より大きな正規表現の中にコンパイルされたりした場合でも、
その振る舞いを保持します。

=item *

=begin original

In C<quotemeta> or its inline equivalent C<\Q>, no code points above 127
are quoted in UTF-8 encoded strings, but in byte encoded strings, code
points between 128-255 are always quoted.
Starting in Perl 5.16.0, consistent quoting rules are used within the
scope of C<unicode_strings>, as described in L<perlfunc/quotemeta>.

=end original

C<quotemeta> や、インラインの等価物である C<\Q> の中で、
UTF-8 エンコードされた文字列では 128 を超える符号位置の文字は
クォートされないが、
バイトエンコードされた文字列では、128-255 の符号位置は常にクォートされる。
Perl 5.16.0 から、L<perlfunc/quotemeta> で記述されているように、
C<unicode_strings> のスコープの中では、
一貫したクォート規則が使われます。

=back

=begin original

This behavior can lead to unexpected results in which a string's semantics
suddenly change if a code point above 255 is appended to or removed from it,
which changes the string's semantics from byte to character or vice versa.  As
an example, consider the following program and its output:

=end original

これの振る舞いにより、符号位置 255 を超える文字が追加されたり
削除されたりすると、文字列のセマンティックスがバイトから文字へ(または
その逆へ)突然変更されるという予想外の結果を引き起こすことがあります。
例えば、以下のようなプログラムとその出力を考えます:

 $ perl -le'
     no feature 'unicode_strings';
     $s1 = "\xC2";
     $s2 = "\x{2660}";
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1

=begin original

If there's no C<\w> in C<s1> or in C<s2>, why does their concatenation have one?

=end original

C<s1> や C<s2> に C<\w> がなければ、なぜこれらの結合は一つになるのでしょう?

=begin original

This anomaly stems from Perl's attempt to not disturb older programs that
didn't use Unicode, and hence had no semantics for characters outside of the
ASCII range (except in a locale), along with Perl's desire to add Unicode
support seamlessly.  The result wasn't seamless: these characters were
orphaned.

=end original

この異常は、
Unicode を使用していない、つまり (ロケールを除いて) ASCII の範囲外の
文字について意味論を持たない
古いプログラムを妨害しないようにしようPerl の試みと、
Unicode 対応をシームレスに追加しようとする Perl の
願望によるものです。
その結果はシームレスではありません: これらの文字は孤立していました。

=begin original

For Perls earlier than those described above, or when a string is passed
to a function outside the subpragma's scope, a workaround is to always
call L<C<utf8::upgrade($string)>|utf8/Utility functions>,
or to use the standard module L<Encode>.   Also, a scalar that has any characters
whose ordinal is C<0x100> or above, or which were specified using either of the
C<\N{...}> notations, will automatically have character semantics.

=end original

前述したものより古い Perl の場合や、文字列が副プラグマのスコープ外の関数から
渡された場合、常に L<C<utf8::upgrade($string)>|utf8/Utility functions> を
呼び出すか標準モジュール L<Encode> を使うことです。
また、基数が C<0x100> 以上の文字を持つスカラや、
いずれかの C<\N{...}> 記法を使って指定されたものは、
自動的に文字の意味論を持ちます。

=head2 Forcing Unicode in Perl (Or Unforcing Unicode in Perl)

(Unicode を Perl に強制する (あるいは Unicode でないことを Perl に強制する))

=begin original

Sometimes (see L</"When Unicode Does Not Happen"> or L</The "Unicode Bug">)
there are situations where you simply need to force a byte
string into UTF-8, or vice versa.  The low-level calls
L<C<utf8::upgrade($bytestring)>|utf8/Utility functions> and
L<C<utf8::downgrade($utf8string[, FAIL_OK])>|utf8/Utility functions> are
the answers.

=end original

ときとして(L</When Unicode Does Not Happen> を参照)、バイト列を
UTF-8 であるように強制したりその逆を行う場合があるかもしれません。
低レベルの呼び出し 
L<C<utf8::upgrade($bytestring)>|utf8/Utility functions> と
L<C<utf8::downgrade($utf8string[, FAIL_OK])>|utf8/Utility functions> が
その回答です。

=begin original

Note that C<utf8::downgrade()> can fail if the string contains characters
that don't fit into a byte.

=end original

C<utf8::downgrade()> は、バイトに収まらない文字を含む文字列の場合は
失敗することがあることに注意してください。

=begin original

Calling either function on a string that already is in the desired state is a
no-op.

=end original

既に望み通りの状態になっている文字列に対してこれらの関数を呼び出しても、
何も起こりません。

=head2 Using Unicode in XS

(XS で Unicode を使う)

=begin original

If you want to handle Perl Unicode in XS extensions, you may find the
following C APIs useful.  See also L<perlguts/"Unicode Support"> for an
explanation about Unicode at the XS level, and L<perlapi> for the API
details.

=end original

Perl の Unicode を XS 拡張で取り扱いたいと思うのなら、以下に挙げる
API 群が便利かも知れません。
XS レベルでの Unicode に関しての説明は L<perlguts/"Unicode Support"> を、
API の詳細については L<perlapi> を参照してください。

=over 4

=item *

=begin original

C<DO_UTF8(sv)> returns true if the C<UTF8> flag is on and the bytes
pragma is not in effect.  C<SvUTF8(sv)> returns true if the C<UTF8>
flag is on; the C<bytes> pragma is ignored.  The C<UTF8> flag being on
does B<not> mean that there are any characters of code points greater
than 255 (or 127) in the scalar or that there are even any characters
in the scalar.  What the C<UTF8> flag means is that the sequence of
octets in the representation of the scalar is the sequence of UTF-8
encoded code points of the characters of a string.  The C<UTF8> flag
being off means that each octet in this representation encodes a
single character with code point 0..255 within the string.  Perl's
Unicode model is not to use UTF-8 until it is absolutely necessary.

=end original

C<DO_UTF8(sv)> は C<UTF8> フラグがオンでバイトプラグマが効果を
もっていないときに真を返します。
C<SvUTF8(sv)> は C<UTF8> がオンのとき、C<bytes> プラグマの状態には
関係なく真を返します。
C<UTF8> フラグはスカラの中で 255(もしくは127)を超える符号位置の文字が
あるということを I<意味しません>。
C<UTF8> フラグの意味するところは、スカラ中のそのオクテットの並びが
文字列としてUTF-8でエンコードされた符号位置の並びだということです。
C<UTF8> フラグがオフであるということは文字列の中のエンコードされた
文字が 0..255 の範囲でエンコードされたオクテットであることを意味します。
Perl の Unicode モデルは本当に必要となるまで UTF-8 を使用しません。

=item *

=begin original

C<uvchr_to_utf8(buf, chr)> writes a Unicode character code point into
a buffer encoding the code point as UTF-8, and returns a pointer
pointing after the UTF-8 bytes.  It works appropriately on EBCDIC machines.

=end original

C<uvchr_to_utf8(buf, chr)> は Unicode の文字符号位置を UTF-8 で
エンコードされたの符号位置としてバッファに書き込みます;
そして、その UTF-8 バイトの後を指し示すポインタを返します。
これは EBCDIC のマシンでも適切に動作します。

=item *

=begin original

C<utf8_to_uvchr_buf(buf, bufend, lenp)> reads UTF-8 encoded bytes from a
buffer and
returns the Unicode character code point and, optionally, the length of
the UTF-8 byte sequence.  It works appropriately on EBCDIC machines.

=end original

C<utf8_to_uvchr_buf(buf, bufend, lenp)> はバッファから
UTF-8 エンコードされたバイトを読み出し、
Unicode の文字符号位置と、オプションでその
UTF-8 バイトシーケンスの長さを返します。
これは EBCDIC のマシンでも適切に動作します。

=item *

=begin original

C<utf8_length(start, end)> returns the length of the UTF-8 encoded buffer
in characters.  C<sv_len_utf8(sv)> returns the length of the UTF-8 encoded
scalar.

=end original

C<utf8_length(start, end)> は UTF-8 エンコードされたバッファの長さを
文字で返します。
C<sv_len_utf8(sv)> は UTF-8 エンコードされたスカラの長さを返します。

=item *

=begin original

C<sv_utf8_upgrade(sv)> converts the string of the scalar to its UTF-8
encoded form.  C<sv_utf8_downgrade(sv)> does the opposite, if
possible.  C<sv_utf8_encode(sv)> is like sv_utf8_upgrade except that
it does not set the C<UTF8> flag.  C<sv_utf8_decode()> does the
opposite of C<sv_utf8_encode()>.  Note that none of these are to be
used as general-purpose encoding or decoding interfaces: C<use Encode>
for that.  C<sv_utf8_upgrade()> is affected by the encoding pragma
but C<sv_utf8_downgrade()> is not (since the encoding pragma is
designed to be a one-way street).

=end original

C<sv_utf8_upgrade(sv)> はスカラの文字列をその UTF-8 エンコードされた
形式に変換します。
C<sv_utf8_downgrade(sv)> は(可能であれば)その反対の動作をします。
C<sv_utf8_encode(sv)> は C<sv_utf8_upgrade> に似ていますが、
C<UTF8> フラグをセットしない点が異なります。
C<sv_utf8_decode()> は C<sv_utf8_encode()> の逆を行います。
これらの欠如が一般的な目的のエンコーディングやデコーディングの
インターフェースとして使われていることに注意してください:
C<use Encode> がそのためにあります。
C<sv_utf8_upgrade()> はエンコーディングプラグマに影響を受けますが、
C<sv_utf8_downgrade()> はそうではありません(なぜならエンコーディング
プラグマは一方通行にデザインされているからです)。

=item *

=begin original

C<is_utf8_string(buf, len)> returns true if C<len> bytes of the buffer
are valid UTF-8.

=end original

C<is_utf8_string(buf, len)> はバッファの C<len> バイトが正しい
UTF-8 文字であるときに真を返します。

=item *

=begin original

C<is_utf8_char_buf(buf, buf_end)> returns true if the pointer points to
a valid UTF-8 character.

=end original

C<is_utf8_char_buf(buf, buf_end)> はポインタが正しい UTF-8 文字を
指し示しているときに真を返します。

=item *

=begin original

C<UTF8SKIP(buf)> will return the number of bytes in the UTF-8 encoded
character in the buffer.  C<UNISKIP(chr)> will return the number of bytes
required to UTF-8-encode the Unicode character code point.  C<UTF8SKIP()>
is useful for example for iterating over the characters of a UTF-8
encoded buffer; C<UNISKIP()> is useful, for example, in computing
the size required for a UTF-8 encoded buffer.

=end original

C<UTF8SKIP(buf)> はバッファの中にある UTF-8 エンコードされた文字の
バイト数を返します。
C<UNISKIP(chr)> は UTF-8 エンコードする Unicode 文字の符号位置が要求する
バイト数を返します。
C<UTF8SKIP()> は UTF-8 エンコードされたバッファの文字に対して繰り返しを
行うような例に便利です; C<UNISKIP()> はたとえば、UTF-8 エンコードされた
バッファの要求する大きさを計算するのに便利です。

=item *

=begin original

C<utf8_distance(a, b)> will tell the distance in characters between the
two pointers pointing to the same UTF-8 encoded buffer.

=end original

C<utf8_distance(a, b)> は同じ UTF-8 エンコードされたバッファをさす
二つのポインタの間の文字単位の距離を返します。

=item *

=begin original

C<utf8_hop(s, off)> will return a pointer to a UTF-8 encoded buffer
that is C<off> (positive or negative) Unicode characters displaced
from the UTF-8 buffer C<s>.  Be careful not to overstep the buffer:
C<utf8_hop()> will merrily run off the end or the beginning of the
buffer if told to do so.

=end original

C<utf8_hop(s, off)> は、UTF-8 バッファ C<s> から Unicode で C<off> 文字分
(正数でも負数でも) 移動した UTF-8 エンコーディングバッファへの
ポインタを返します。
バッファを超えないように注意してください: C<utf8_hop()> は、そう
指示されれば何も気にせずにバッファの先頭や末尾を踏み越えます。

=item *

=begin original

C<pv_uni_display(dsv, spv, len, pvlim, flags)> and
C<sv_uni_display(dsv, ssv, pvlim, flags)> are useful for debugging the
output of Unicode strings and scalars.  By default they are useful
only for debugging--they display B<all> characters as hexadecimal code
points--but with the flags C<UNI_DISPLAY_ISPRINT>,
C<UNI_DISPLAY_BACKSLASH>, and C<UNI_DISPLAY_QQ> you can make the
output more readable.

=end original

C<pv_uni_display(dsv, spv, len, pvlim, flags)> と
C<sv_uni_display(dsv, ssv, pvlim, flags)> は Unicode の文字列やスカラの
出力をデバッグするのに便利です。
デフォルトではデバッグのみに便利です -- B<すべての> 文字を
16 進の符号位置として表示します -- しかし C<UNI_DISPLAY_ISPRINT>,
C<UNI_DISPLAY_BACKSLASH>, C<UNI_DISPLAY_QQ> というフラグを
与えることによって、出力を読みやすくできます。

=item *

=begin original

C<foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> can be used to
compare two strings case-insensitively in Unicode.  For case-sensitive
comparisons you can just use C<memEQ()> and C<memNE()> as usual, except
if one string is in utf8 and the other isn't.

=end original

C<foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> は Unicode に
おいて大小文字を無視した文字列比較に使うことができます。
大小文字を意識した比較には、
片方の文字列が UTF8 でもう片方がそうではない場合を除いて、
通常どおり C<memEQ()> や C<memNE()> を使うことができます。

=back

=begin original

For more information, see L<perlapi>, and F<utf8.c> and F<utf8.h>
in the Perl source code distribution.

=end original

もっと詳しい情報は、L<perlapi> と、Perl のソースコード配布の
F<utf8.c> と F<utf8.h> を参照してください。

=head2 Hacking Perl to work on earlier Unicode versions (for very serious hackers only)

(以前の Unicode のバージョンで動作させるように Perl をハックする (とても真剣なハッカー専用))

=begin original

Perl by default comes with the latest supported Unicode version built in, but
you can change to use any earlier one.

=end original

Perl はデフォルトでは最新の Unicode バージョンが組み込まれていますが、
より古いものに変更することができます。

=begin original

Download the files in the desired version of Unicode from the Unicode web
site L<http://www.unicode.org>).  These should replace the existing files in
F<lib/unicore> in the Perl source tree.  Follow the instructions in
F<README.perl> in that directory to change some of their names, and then build
perl (see L<INSTALL>).

=end original

Unicode の Web サイト L<http://www.unicode.org> から、目的の Unicode
バージョンのファイルをダウンロードします。
これらのファイルは、Perl ソースツリーの F<lib/unicore> の既存のファイルを
置き換える必要があります。
一部の名前を変えるには、そのディレクトリにある F<README.perl> の指示に従って、
perl をビルドしてください (L<INSTALL> 参照)。

=head1 BUGS

=head2 Interaction with Locales

(ロケールとの相互作用)

=begin original

See L<perllocale/Unicode and UTF-8>

=end original

L<perllocale/Unicode and UTF-8> を参照してください。

=head2 Problems with characters in the Latin-1 Supplement range

(Latin-1 Supplement の範囲の文字の問題)

=begin original

See L</The "Unicode Bug">

=end original

L</The "Unicode Bug"> を参照してください。

=head2 Interaction with Extensions

(エクステンションとの相互作用)

=begin original

When Perl exchanges data with an extension, the extension should be
able to understand the UTF8 flag and act accordingly. If the
extension doesn't recognize that flag, it's likely that the extension
will return incorrectly-flagged data.

=end original

Perl がエクステンションとデータをやり取りするとき、そのエクステンションは
UTF8 フラグを理解し、また、それに従った振る舞いをすべきです。
エクステンションがこのフラグを認識しない場合、そのエクステンションは
正しくないフラグがついたデータを返す可能性があります。

=begin original

So if you're working with Unicode data, consult the documentation of
every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.

=end original

そのため、もし Unicode データを扱おうというのであれば、 Unicode データの
交換に関して何らかの記述があるのなら使うモジュールすべてのドキュメントを
調べてください。
ドキュメントが Unicode に関して何の言及もしていないのなら、最悪のケースを
考慮し、そしてそのモジュールがどのように実装されているかを知るために
ソースを見ることになるかもしれません。
完全に Perl で書かれたモジュールは問題を引き起こしません。
他のプログラミング言語で書かれている直接または間接にアクセスするコードに
リスクがあるのです。

=begin original

For affected functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.

=end original

影響を受けた関数のための、データの劣化(data corruption)を防ぐ単純な
戦略とは、交換するデータのエンコーディングを常に明確にするということです。
エクステンションが取り扱うことができると知っているエンコーディングを
選択してください。
エクステンションに渡す引数を選択したエンコーディングに変換し、
エクステンションから返ってきた結果をそのエンコーディングから
逆方向に変換します。
変換を行ってくれるラッパ関数を書いておいて、
エクステンションが追いついた時に関数を変更できるようにしておきます。

=begin original

To provide an example, let's say the popular C<Foo::Bar::escape_html>
function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw UTF-8 and convert the result back to
Perl's internal representation like so:

=end original

例として、まだ Unicode データを取り扱うようにはできていない、
有名な C<Foo::Bar::escape_html> について述べましょう。
ラッパ関数は引数を生の UTF-8 に変換し、結果を Perl の内部表現に
逆変換します:

    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }

=begin original

Sometimes, when the extension does not convert data but just stores
and retrieves them, you will be able to use the otherwise
dangerous L<C<Encode::_utf8_on()>|Encode/_utf8_on> function. Let's say
the popular C<Foo::Bar> extension, written in C, provides a C<param>
method that lets you store and retrieve data according to these prototypes:

=end original

エクステンションがデータを変換しないけれども格納したり取り出したりするときに、
ときとして危険な L<C<Encode::_utf8_on()>|Encode/_utf8_on> 関数以外のものを
使うことができるかもしれません。
C で書かれていて、データを以下のプロトタイプに従って格納したり
取り出したりする C<param> メソッドを持っている
有名な C<Foo::Bar> エクステンションについて述べてみましょう:

    $self->param($name, $value);            # set a scalar
    $value = $self->param($name);           # retrieve a scalar

=begin original

If it does not yet provide support for any encoding, one could write a
derived class with such a C<param> method:

=end original

どのエンコーディングもまだサポートしていないのなら、
以下のような C<param> メソッドを持った派生クラスを
記述することができるでしょう:

    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self->SUPER::param($name,$value);
      } else {
        my $ret = $self->SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }

=begin original

Some extensions provide filters on data entry/exit points, such as
C<DB_File::filter_store_key> and family. Look out for such filters in
the documentation of your extensions, they can make the transition to
Unicode data much easier.

=end original

一部のエクステンションはデータのエントリ/脱出ポイントでフィルターを
提供しています; たとえば C<DB_File::filter_store_key> とその仲間です。
あなた使うエクステンションのドキュメントにあるそのようなフィルターに
注意してください; それらは Unicode データの変化をより容易にします。

=head2 Speed

(速度)

=begin original

Some functions are slower when working on UTF-8 encoded strings than
on byte encoded strings.  All functions that need to hop over
characters such as C<length()>, C<substr()> or C<index()>, or matching
regular expressions can work B<much> faster when the underlying data are
byte-encoded.

=end original

一部の関数は UTF-8 でエンコードされた文字列に対して適用したときにバイト
エンコードされた文字列に対するときよりも遅くなります。
文字に対して働く必要のある C<length()>, C<substr()>, C<index()> 
のような関数のすべてと正規表現マッチングは、データが
バイトエンコードされているときには B<かなり> 早く動作できます。

=begin original

In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1
a caching scheme was introduced which will hopefully make the slowness
somewhat less spectacular, at least for some operations.  In general,
operations with UTF-8 encoded strings are still slower. As an example,
the Unicode properties (character classes) like C<\p{Nd}> are known to
be quite a bit slower (5-20 times) than their simpler counterparts
like C<\d> (then again, there are hundreds of Unicode characters matching C<Nd>
compared with the 10 ASCII characters matching C<d>).

=end original

Perl 5.8.0 ではこの遅さはしばしば目立つものでした; Perl 5.8.1 では
少なくとも一部の操作については、遅さを改善することを期待する
キャッシングスキーム(caching scheme)が導入されました。
一般的には、UTF-8 エンコードされた文字列に対する操作はまだ遅いものです。
たとえば、C<\p{Nd}> のような Unicode の特性(文字クラス)は対応する
C<\d> のような単純なものよりも目立って遅い(5 倍から10 倍)ことが
知られています(繰り返しますが、C<d> は 10 の ASCII 文字に対して
マッチするのに対して C<Nd> は数百の Unicode 文字にマッチします)。

=head2 Problems on EBCDIC platforms

(EBCDIC プラットフォームでの問題)

=begin original

There are several known problems with Perl on EBCDIC platforms.  If you
want to use Perl there, send email to perlbug@perl.org.

=end original

EBCDIC プラットフォームの Perl にはいくつかの既知の問題があります。
そのような環境で Perl を使いたいなら、perlbug@perl.org にメールを
送ってください。

=begin original

In earlier versions, when byte and character data were concatenated,
the new string was sometimes created by
decoding the byte strings as I<ISO 8859-1 (Latin-1)>, even if the
old Unicode string used EBCDIC.

=end original

以前のバージョンでは、バイトデータと文字データを連結すると、
古い Unicode 文字列が EBCDIC を使っていたとしても、新しい文字列は
バイト文字列を I<ISO 8859-1 (Latin-1)> としてデコードして
作成されることがありました。

=begin original

If you find any of these, please report them as bugs.

=end original

これらのどれかを発見したら、どうかバグとして報告してください。

=head2 Porting code from perl-5.6.X

(perl 5.6.X からコードを移植する)

=begin original

Perl 5.8 has a different Unicode model from 5.6. In 5.6 the programmer
was required to use the C<utf8> pragma to declare that a given scope
expected to deal with Unicode data and had to make sure that only
Unicode data were reaching that scope. If you have code that is
working with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will continue
to work under 5.6, so you should be safe to try them out.

=end original

Perl 5.8 は 5.6 とは異なる Unicode モデルを持っています。
5.6 ではプログラマは、ある与えられたスコープが Unicode データを
取り扱うのと Unicode データだけがそのスコープにあることを宣言するのに
C<utf8> プラグマの使用を要求されていました。
5.6 で動いていたプログラムを持っているのなら、以下に挙げる微調整を施す
必要があるでしょう。
例は 5.6 でも動くように書かれているので、安心して試すことができます。

=over 3

=item *

=begin original

A filehandle that should read or write UTF-8

=end original

UTF-8 で読み書きすべきファイルハンドル

  if ($] > 5.008) {
    binmode $fh, ":encoding(utf8)";
  }

=item *

=begin original

A scalar that is going to be passed to some extension

=end original

何らかのエクステンションに渡そうとするスカラ

=begin original

Be it C<Compress::Zlib>, C<Apache::Request> or any extension that has no
mention of Unicode in the manpage, you need to make sure that the
UTF8 flag is stripped off. Note that at the time of this writing
(January 2012) the mentioned modules are not UTF-8-aware. Please
check the documentation to verify if this is still true.

=end original

C<Compress::Zlib>, C<Apache::Request> などの、マニュアルページに Unicode に
関する記載がない何らかのエクステンションで、確実に UTF8 フラグが
オフにする必要があります。
これを書いている時点(2012 年 1 月)では、上記のモジュールは
UTF-8 対応でないことに注意してください。
これがまだ真であるのなら、ドキュメントをチェックして確かめてください。

  if ($] > 5.008) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }

=item *

=begin original

A scalar we got back from an extension

=end original

エクステンションから返ってきたスカラ

=begin original

If you believe the scalar comes back as UTF-8, you will most likely
want the UTF8 flag restored:

=end original

そのスカラが UTF-8 として返ってきたものだと信じているのなら、
UTF-8 フラグをリストアしたいと考えるでしょう:

  if ($] > 5.008) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }

=item *

=begin original

Same thing, if you are really sure it is UTF-8

=end original

同様に、UTF-8 だと確信しているのなら

  if ($] > 5.008) {
    require Encode;
    Encode::_utf8_on($val);
  }

=item *

=begin original

A wrapper for L<DBI> C<fetchrow_array> and C<fetchrow_hashref>

=end original

L<DBI> の C<fetchrow_array> と C<fetchrow_hashref> へのラッパ

=begin original

When the database contains only UTF-8, a wrapper function or method is
a convenient way to replace all your C<fetchrow_array> and
C<fetchrow_hashref> calls. A wrapper function will also make it easier to
adapt to future enhancements in your database driver. Note that at the
time of this writing (January 2012), the DBI has no standardized way
to deal with UTF-8 data. Please check the L<DBI documentation|DBI> to verify if
that is still true.

=end original

データベースが UTF-8 のみから構成されているとき、ラッパ関数や
ラッパメソッドはあなたの C<fetchrow_array> や C<fetchrow_hashref> の
呼び出しを置き換えるのに便利な方法でしょう。
ラッパ関数はまた、あなたの使っているデータベースドライバが
将来拡張されたときに適用しやすくするでしょう。
このドキュメントを書いている時点(2012 年 1 月)では、DBI は UTF-8 のデータを
扱う標準的な方法を持っていません。
これがまだ真なら L<DBI の文書|DBI> をチェックして確かめてください。

  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] < 5.008) {
      return $sth->$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth->$what;
        for (@arr) {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth->$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            && /[^\000-\177]/
            && Encode::_utf8_on($_) for $ret->{$k};
          }
          return $ret;
        } else {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }

=item *

=begin original

A large scalar that you know can only contain ASCII

=end original

ASCII だけが含まれていると分かっている大きなスカラ

=begin original

Scalars that contain only ASCII and are marked as UTF-8 are sometimes
a drag to your program. If you recognize such a situation, just remove
the UTF8 flag:

=end original

ASCII だけから構成されているのに UTF8 として印付けされているスカラが
あなたのプログラムへ引きずりこまれることがあります。
そのような場合を認識したならば、単に UTF-8 フラグを取り除いてください:

  utf8::downgrade($val) if $] > 5.008;

=back

=head1 SEE ALSO

L<perlunitut>, L<perluniintro>, L<perluniprops>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlvar/"${^UNICODE}">
L<http://www.unicode.org/reports/tr44>).

=cut

=begin meta

Translate: KIMURA Koichi (-5.8.5)
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.10.0-)
Status: in progress

=end meta

