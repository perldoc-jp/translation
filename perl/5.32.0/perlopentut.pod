
=encoding euc-jp

=head1 NAME

=begin original

perlopentut - simple recipes for opening files and pipes in Perl

=end original

perlopentut - Perl ¤Ç¥Õ¥¡¥¤¥ë¤ò³«¤¤¤¿¤ê¥Ñ¥¤¥×¤ò»È¤Ã¤¿¤ê¤¹¤ë¤¿¤á¤Î´ÊÃ±¤Ê¥ì¥·¥Ô

=head1 DESCRIPTION

=begin original

Whenever you do I/O on a file in Perl, you do so through what in Perl is
called a B<filehandle>.  A filehandle is an internal name for an external
file.  It is the job of the C<open> function to make the association
between the internal name and the external name, and it is the job
of the C<close> function to break that association.

=end original

Perl ¤Ç¥Õ¥¡¥¤¥ë¤ËÂÐ¤·¤ÆÆþ½ÐÎÏ¤ò¤¹¤ë¤È¤­¡¢Perl ¤Ç¤Ï B<¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë> ¤È
¸Æ¤Ð¤ì¤ë¤â¤Î¤òÄÌ¤·¤Æ¹Ô¤¤¤Þ¤¹¡£
¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ï³°Éô¥Õ¥¡¥¤¥ë¤ËÂÐ¤¹¤ëÆâÉôÌ¾¤Ç¤¹¡£
C<open> ´Ø¿ô¤Î»Å»ö¤ÏÆâÉôÌ¾¤È³°ÉôÌ¾¤ò´ØÏ¢¤Å¤±¤ë¤³¤È¤Ç¡¢C<close> ´Ø¿ô¤Ï
´ØÏ¢¤Å¤±¤ò²õ¤¹¤³¤È¤Ç¤¹¡£

=begin original

For your convenience, Perl sets up a few special filehandles that are
already open when you run.  These include C<STDIN>, C<STDOUT>, C<STDERR>,
and C<ARGV>.  Since those are pre-opened, you can use them right away
without having to go to the trouble of opening them yourself:

=end original

ÊØÍø¤Ê¤è¤¦¤Ë¡¢Perl ¤Ï¼Â¹Ô³«»Ï»þ¤Ë´û¤Ë³«¤¤¤Æ¤¤¤ë¤¤¤¯¤Ä¤«¤ÎÆÃÊÌ¤Ê
¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤òÀßÄê¤·¤Þ¤¹¡£
¤½¤ì¤Ï C<STDIN>, C<STDOUT>, C<STDERR>, C<ARGV> ¤Ç¤¹¡£
¤³¤ì¤é¤Ï´û¤Ë³«¤¤¤Æ¤¤¤ë¤Î¤Ç¡¢¼«Ê¬¤Ç¤³¤ì¤é¤ò³«¤¯¤È¤­¤ÎÌäÂê¤ò¼õ¤±¤ë¤³¤È¤Ê¤¯
Àµ¤·¤¯»È¤¦¤³¤È¤¬¤Ç¤­¤Þ¤¹¡£

    print STDERR "This is a debugging message.\n";

    print STDOUT "Please enter something: ";
    $response = <STDIN> // die "how come no input?";
    print STDOUT "Thank you!\n";

    while (<ARGV>) { ... }

=begin original

As you see from those examples, C<STDOUT> and C<STDERR> are output
handles, and C<STDIN> and C<ARGV> are input handles.  They are
in all capital letters because they are reserved to Perl, much
like the C<@ARGV> array and the C<%ENV> hash are.  Their external
associations were set up by your shell.

=end original

¤³¤ì¤é¤ÎÎã¤Ç¸«¤é¤ì¤ë¤è¤¦¤Ë¡¢C<STDOUT> ¤È C<STDERR> ¤Ï½ÐÎÏ¥Ï¥ó¥É¥ë¤Ç¡¢
C<STDIN> ¤È C<ARGV> ¤ÏÆþÎÏ¥Ï¥ó¥É¥ë¤Ç¤¹¡£
¤³¤ì¤é¤Ï C<@ARGV> ÇÛÎó¤ä C<%ENV> ¥Ï¥Ã¥·¥å¤ÈÆ±ÍÍ¤Ë Perl ¤Ë¤è¤Ã¤Æ
Í½Ìó¤µ¤ì¤Æ¤¤¤ë¤Î¤Ç¡¢Á´¤ÆÂçÊ¸»ú¤Ë¤Ê¤Ã¤Æ¤¤¤Þ¤¹¡£
¤³¤ì¤é¤Î³°Éô´ØÏ¢¤Å¤±¤Ï¥·¥§¥ë¤Ë¤è¤Ã¤Æ¹Ô¤ï¤ì¤Þ¤¹¡£

=begin original

You will need to open every other filehandle on your own. Although there
are many variants, the most common way to call Perl's open() function
is with three arguments and one return value:

=end original

¤½¤ÎÂ¾¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ï¼«Ê¬¤Ç³«¤¯É¬Í×¤¬¤¢¤ê¤Þ¤¹¡£
Â¿¤¯¤Î¥Ð¥ê¥¨¡¼¥·¥ç¥ó¤Ï¤¢¤ê¤Þ¤¹¤¬¡¢Perl ¤Î open() ´Ø¿ô¤ò³«¤¯ºÇ¤â°ìÈÌÅª¤ÊÊýË¡¤Ï
3 °ú¿ô¤È°ì¤Ä¤ÎÊÖ¤êÃÍ¤Î¤â¤Î¤Ç¤¹:

=begin original

C<    I<OK> = open(I<HANDLE>, I<MODE>, I<PATHNAME>)>

=end original

C<    I<OK> = open(I<HANDLE>, I<MODE>, I<PATHNAME>)>

=begin original

Where:

=end original

¤³¤³¤Ç:

=over

=item I<OK>

=begin original

will be some defined value if the open succeeds, but
C<undef> if it fails;

=end original

¤³¤ì¤Ï¡¢³«¤¯¤Î¤ËÀ®¸ù¤¹¤ì¤Ð²¿¤é¤«¤ÎÄêµÁ¤µ¤ì¤¿ÃÍ¡¢¼ºÇÔ¤¹¤ì¤Ð C<undef> ¤Ç¤¹;

=item I<HANDLE>

=begin original

should be an undefined scalar variable to be filled in by the
C<open> function if it succeeds;

=end original

¤³¤ì¤Ï¡¢À®¸ù¤¹¤ì¤Ð C<open> ´Ø¿ô¤Ë¤è¤Ã¤ÆËä¤á¤é¤ì¤ëÌ¤ÄêµÁ¤Î¥¹¥«¥éÊÑ¿ô¤Ç¤¹;

=item I<MODE>

=begin original

is the access mode and the encoding format to open the file with;

=end original

¤³¤ì¤Ï¥Õ¥¡¥¤¥ë¤ò³«¤¯¤È¤­¤Î¥¢¥¯¥»¥¹¥â¡¼¥É¤È¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°·¿¼°¤Ç¤¹;

=item I<PATHNAME>

=begin original

is the external name of the file you want opened.

=end original

¤³¤ì¤Ï³«¤­¤¿¤¤¥Õ¥¡¥¤¥ë¤Î³°ÉôÌ¾¤Ç¤¹¡£

=back

=begin original

Most of the complexity of the C<open> function lies in the many
possible values that the I<MODE> parameter can take on.

=end original

C<open> ´Ø¿ô¤ÎÊ£»¨¤µ¤ÎÂçÉôÊ¬¤Ï¡¢I<MODE> °ú¿ô¤¬Â¿¤¯¤ÎÃÍ¤ò
¼è¤ë¤³¤È¤Î¤Ç¤­¤ë¤³¤È¤Ë¤¢¤ê¤Þ¤¹¡£

=begin original

One last thing before we show you how to open files: opening
files does not (usually) automatically lock them in Perl.  See
L<perlfaq5> for how to lock.

=end original

¥Õ¥¡¥¤¥ë¤Î³«¤­Êý¤òÀâÌÀ¤¹¤ëÁ°¤ËºÇ¸å¤Ë°ì¸À: Perl ¤Ç¤Ï¥Õ¥¡¥¤¥ë¤ò³«¤¤¤Æ¤â
(ÉáÄÌ¤Ï)¼«Æ°Åª¤Ë¥í¥Ã¥¯¤¹¤ë¤³¤È¤Ï¤·¤Þ¤»¤ó¡£
¥í¥Ã¥¯¤ÎÊýË¡¤Ë¤Ä¤¤¤Æ¤Ï L<perlfaq5> ¤ò»²¾È¤·¤Æ¤¯¤À¤µ¤¤¡£

=head1 Opening Text Files

(¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤ò³«¤¯)

=head2 Opening Text Files for Reading

(ÆÉ¤ß¹þ¤ßÍÑ¤Ë¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤ò³«¤¯)

=begin original

If you want to read from a text file, first open it in
read-only mode like this:

=end original

¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤òÆÉ¤ß¹þ¤ß¤¿¤¤¾ì¹ç¡¢¤Þ¤º¼¡¤Î¤è¤¦¤ËÆÉ¤ß¹þ¤ßÀìÍÑ¥â¡¼¥É¤Ç
³«¤­¤Þ¤¹:

    my $filename = "/some/path/to/a/textfile/goes/here";
    my $encoding = ":encoding(UTF-8)";
    my $handle   = undef;     # this will be filled in on success

    open($handle, "< $encoding", $filename)
        || die "$0: can't open $filename for reading: $!";

=begin original

As with the shell, in Perl the C<< "<" >> is used to open the file in
read-only mode.  If it succeeds, Perl allocates a brand new filehandle for
you and fills in your previously undefined C<$handle> argument with a
reference to that handle.

=end original

¥·¥§¥ë¤ÈÆ±ÍÍ¤Ë¡¢Perl ¤Ç¤â¥Õ¥¡¥¤¥ë¤òÆÉ¤ß¹þ¤ßÀìÍÑ¥â¡¼¥É¤Ç³«¤¯¤¿¤á¤Ë
C<< "<" >> ¤¬»È¤ï¤ì¤Þ¤¹¡£
¤³¤ì¤ËÀ®¸ù¤¹¤ë¤È¡¢Perl ¤Ï¿·¤·¤¤¥Õ¥¡¥¤¥ë¥¢¥ó¥É¥ë¤ò³ä¤êÅö¤Æ¡¢Ì¤ÄêµÁ¤À¤Ã¤¿
C<$handle> °ú¿ô¤Ë¤½¤Î¥Ï¥ó¥É¥ë¤Ø¤Î¥ê¥Õ¥¡¥ì¥ó¥¹¤òÀßÄê¤·¤Þ¤¹¡£

=begin original

Now you may use functions like C<readline>, C<read>, C<getc>, and
C<sysread> on that handle.  Probably the most common input function
is the one that looks like an operator:

=end original

¤³¤ì¤Ç¤³¤Î¥Ï¥ó¥É¥ë¤ËÂÐ¤·¤Æ C<readline>, C<read>, C<getc>,
C<sysread> ¤Î¤è¤¦¤Ê´Ø¿ô¤¬»È¤¨¤Þ¤¹¡£
¤ª¤½¤é¤¯ºÇ¤â°ìÈÌÅª¤ÊÆþÎÏ´Ø¿ô¤Ï±é»»»Ò¤Î¤è¤¦¤Ë¸«¤¨¤ë¤â¤Î¤Ç¤·¤ç¤¦:

    $line = readline($handle);
    $line = <$handle>;          # same thing

=begin original

Because the C<readline> function returns C<undef> at end of file or
upon error, you will sometimes see it used this way:

=end original

C<readline> ´Ø¿ô¤Ï¥Õ¥¡¥¤¥ë½ªÃ¼¤ä¥¨¥é¡¼¤Î¤È¤­¤Ë C<undef> ¤òÊÖ¤¹¤Î¤Ç¡¢
»þ¡¹¼¡¤Î¤è¤¦¤Ë»È¤ï¤ì¤Æ¤¤¤ë¤Î¤ò¸«¤ë¤Ç¤·¤ç¤¦:

    $line = <$handle>;
    if (defined $line) {
        # do something with $line
    }
    else {
        # $line is not valid, so skip it
    }

=begin original

You can also just quickly C<die> on an undefined value this way:

=end original

¤Þ¤¿¡¢¼¡¤Î¤è¤¦¤Ë¤·¤ÆÃ±¤ËÌ¤ÄêµÁÃÍ¤ËÂÐ¤·¤Æ¤¹¤Ð¤ä¤¯ C<die> ¤¹¤ë¤³¤È¤â¤Ç¤­¤Þ¤¹:

    $line = <$handle> // die "no input found";

=begin original

However, if hitting EOF is an expected and normal event, you do not want to
exit simply because you have run out of input.  Instead, you probably just want
to exit an input loop.  You can then test to see if an actual error has caused
the loop to terminate, and act accordingly:

=end original

¤·¤«¤·¡¢EOF ¤ËÅþÃ£¤¹¤ë¤Î¤¬ÁÛÄê¤µ¤ì¤Æ¤¤¤ÆÄÌ¾ï¤Î½ÐÍè»ö¤Î¾ì¹ç¤Ï¡¢
ÆþÎÏ¤¬¤Ê¤¯¤Ê¤Ã¤¿¤À¤±¤Ç½ªÎ»¤·¤¿¤¯¤¢¤ê¤Þ¤»¤ó¡£
¤½¤¦¤Ç¤Ï¤Ê¤¯¡¢Ã±¤ËÆþÎÏ¥ë¡¼¥×¤ò½ªÎ»¤·¤¿¤¤¤Ç¤·¤ç¤¦¡£
¼ÂºÝ¤Î¥¨¥é¡¼¤¬¥ë¡¼¥×¤ò½ªÎ»¤µ¤»¤¿¤Î¤«¤ò¥Æ¥¹¥È¤·¤Æ¡¢Å¬ÀÚ¤Ë¹ÔÆ°¤Ç¤­¤Þ¤¹:

    while (<$handle>) {
        # do something with data in $_
    }
    if ($!) {
        die "unexpected error while reading from $filename: $!";
    }

=begin original

B<A Note on Encodings>: Having to specify the text encoding every time
might seem a bit of a bother.  To set up a default encoding for C<open> so
that you don't have to supply it each time, you can use the C<open> pragma:

=end original

B<¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤Ë´Ø¤¹¤ëÃí°Õ>: ¥Æ¥­¥¹¥È¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤òËè²ó»ØÄê¤¹¤ë
É¬Í×¤¬¤¢¤ë¤Î¤Ï¾¯¤·ÌÌÅÝ¤Ë´¶¤¸¤ë¤«¤â¤·¤ì¤Þ¤»¤ó¡£
Ëè²óÀßÄê¤¹¤ëÉ¬Í×¤¬¤Ê¤¤¤è¤¦¤Ë C<open> ¤Î¤¿¤á¤Î¥Ç¥Õ¥©¥ë¥È¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤ò
ÀßÄê¤¹¤ë¤¿¤á¤Ë¡¢C<open> ¥×¥é¥°¥Þ¤ò»È¤¨¤Þ¤¹:

    use open qw< :encoding(UTF-8) >;

=begin original

Once you've done that, you can safely omit the encoding part of the
open mode:

=end original

°ìÅÙ¤³¤ì¤ò¹Ô¤¨¤Ð¡¢open ¥â¡¼¥É¤«¤é¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤ÎÉôÊ¬¤ò°ÂÁ´¤Ë¾ÊÎ¬¤Ç¤­¤Þ¤¹:

    open($handle, "<", $filename)
        || die "$0: can't open $filename for reading: $!";

=begin original

But never use the bare C<< "<" >> without having set up a default encoding
first.  Otherwise, Perl cannot know which of the many, many, many possible
flavors of text file you have, and Perl will have no idea how to correctly
map the data in your file into actual characters it can work with.  Other
common encoding formats including C<"ASCII">, C<"ISO-8859-1">,
C<"ISO-8859-15">, C<"Windows-1252">, C<"MacRoman">, and even C<"UTF-16LE">.
See L<perlunitut> for more about encodings.

=end original

¤·¤«¤·¡¢Àè¤Ë¥Ç¥Õ¥©¥ë¥È¤Î¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤òÀßÄê¤¹¤ë¤³¤È¤Ê¤¯Íç¤Î
C<< "<" >> ¤ò»È¤¦¤³¤È¤Ï·è¤·¤Æ¤·¤Ê¤¤¤Ç¤¯¤À¤µ¤¤¡£
¤µ¤â¤Ê¤±¤ì¤Ð¡¢Perl ¤Ï¤È¤Æ¤â¤È¤Æ¤â¤È¤Æ¤â¤¿¤¯¤µ¤ó¤¢¤ë¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤Î
¼ïÎà¤Î¤¦¤Á¤É¤ì¤«¤òÃÎ¤ë¤³¤È¤¬¤Ç¤­¤º¡¢Perl ¤Ï¤¢¤Ê¤¿¤Î¥Õ¥¡¥¤¥ë¤Î¥Ç¡¼¥¿¤ò
Æ°ºî¤µ¤»¤ë¤¿¤á¤Î¼ÂºÝ¤ÎÊ¸»ú¤Ë¥Þ¥Ã¥Ô¥ó¥°¤¹¤ë¤³¤È¤¬¤Ç¤­¤Þ¤»¤ó¡£
¤½¤ÎÂ¾¤Î¤è¤¯¤¢¤ë¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°·Á¼°¤Ë¤Ï
C<"ASCII">, C<"ISO-8859-1">,
C<"ISO-8859-15">, C<"Windows-1252">, C<"MacRoman"> ¤ª¤è¤Ó¡¢
C<"UTF-16LE"> ¤¹¤é¤â¤¢¤ê¤Þ¤¹¡£
¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤Ë´Ø¤¹¤ë¤µ¤é¤Ê¤ë¾ðÊó¤Ë¤Ä¤¤¤Æ¤Ï L<perlunitut> ¤ò
»²¾È¤·¤Æ¤¯¤À¤µ¤¤¡£

=head2 Opening Text Files for Writing

(½ñ¤­¹þ¤ßÍÑ¤Ë¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤ò³«¤¯)

=begin original

When you want to write to a file, you first have to decide what to do about
any existing contents of that file.  You have two basic choices here: to
preserve or to clobber.

=end original

¥Õ¥¡¥¤¥ë¤Ë½ñ¤­¹þ¤ß¤¿¤¤¾ì¹ç¡¢¤½¤Î¥Õ¥¡¥¤¥ë¤Î´ûÂ¸¤ÎÆâÍÆ¤ò¤É¤¦¤¹¤ë¤«¤ò
¤Þ¤º·èÄê¤¹¤ëÉ¬Í×¤¬¤¢¤ê¤Þ¤¹¡£
Æó¤Ä¤Î´ðËÜÅª¤ÊÁªÂò»è¤¬¤¢¤ê¤Þ¤¹: ÊÝÂ¸¤¹¤ë¤«¾å½ñ¤­¤¹¤ë¤«¤Ç¤¹¡£

=begin original

If you want to preserve any existing contents, then you want to open the file
in append mode.  As in the shell, in Perl you use C<<< ">>" >>> to open an
existing file in append mode.  C<<< ">>" >>> creates the file if it does not
already exist.

=end original

´ûÂ¸¤ÎÆâÍÆ¤òÊÝÂ¸¤·¤¿¤¤¾ì¹ç¡¢¥Õ¥¡¥¤¥ë¤òÄÉµ­¥â¡¼¥É¤Ç³«¤­¤Þ¤¹¡£
¥·¥§¥ë¤ÈÆ±ÍÍ¤Ë¡¢ Perl ¤Ç¤â´ûÂ¸¤Î¥Õ¥¡¥¤¥ë¤òÄÉµ­¥â¡¼¥É¤Ç³«¤¯¤¿¤á¤Ë
C<<< ">>" >>> ¤¬»È¤ï¤ì¤Þ¤¹¡£
¥Õ¥¡¥¤¥ë¤¬¤Ê¤¤¾ì¹ç¡¢C<<< ">>" >>> ¤Ï¥Õ¥¡¥¤¥ë¤òºî¤ê¤Þ¤¹¡£

    my $handle   = undef;
    my $filename = "/some/path/to/a/textfile/goes/here";
    my $encoding = ":encoding(UTF-8)";

    open($handle, ">> $encoding", $filename)
        || die "$0: can't open $filename for appending: $!";

=begin original

Now you can write to that filehandle using any of C<print>, C<printf>,
C<say>, C<write>, or C<syswrite>.

=end original

¤³¤ì¤Ç¤³¤Î¥Ï¥ó¥É¥ë¤ËÂÐ¤·¤Æ C<print>, C<printf>,
C<say>, C<write>, C<syswrite> ¤ò»È¤Ã¤Æ½ñ¤­¹þ¤á¤Þ¤¹¡£

=begin original

As noted above, if the file does not already exist, then the append-mode open
will create it for you.  But if the file does already exist, its contents are
safe from harm because you will be adding your new text past the end of the
old text.

=end original

Á°½Ò¤·¤¿¤è¤¦¤Ë¡¢¥Õ¥¡¥¤¥ë¤¬´û¤ËÂ¸ºß¤·¤Æ¤¤¤Ê¤¤¾ì¹ç¡¢ÄÉµ­¥â¡¼¥É¤Ç³«¤¯¤È
¥Õ¥¡¥¤¥ë¤òºî¤ê¤Þ¤¹¡£
¤·¤«¤·¥Õ¥¡¥¤¥ë¤¬´û¤ËÂ¸ºß¤·¤Æ¤¤¤ë¾ì¹ç¡¢¤½¤ÎÆâÍÆ¤ÏÊÝ¸î¤µ¤ì¤Þ¤¹; ¿·¤·¤¤¥Æ¥­¥¹¥È¤Ï
´ûÂ¸¤Î¥Æ¥­¥¹¥È¤ÎËöÈø¤ËÄÉ²Ã¤µ¤ì¤ë¤«¤é¤Ç¤¹¡£

=begin original

On the other hand, sometimes you want to clobber whatever might already be
there.  To empty out a file before you start writing to it, you can open it
in write-only mode:

=end original

°ìÊý¡¢»þ¡¹¡¢´û¤Ë²¿¤«¤¬¤¢¤Ã¤Æ¤â¾å½ñ¤­¤·¤¿¤¤¤È¤­¤â¤¢¤ê¤Þ¤¹¡£
½ñ¤­¹þ¤ß¤ò»Ï¤á¤ëÁ°¤Ë¥Õ¥¡¥¤¥ë¤ò¾Ã¤¹¤¿¤á¤Ë¡¢½ñ¤­¹þ¤ßÀìÍÑ¥â¡¼¥É¤Ç
³«¤¯¤³¤È¤¬¤Ç¤­¤Þ¤¹:

    my $handle   = undef;
    my $filename = "/some/path/to/a/textfile/goes/here";
    my $encoding = ":encoding(UTF-8)";

    open($handle, "> $encoding", $filename)
        || die "$0: can't open $filename in write-open mode: $!";

=begin original

Here again Perl works just like the shell in that the C<< ">" >> clobbers
an existing file.

=end original

¤³¤³¤ÇºÆ¤Ó Perl ¤Ï¥·¥§¥ë¤ÈÆ±ÍÍ¤ËÆ°ºî¤·¡¢C<< ">" >> ¤Ï´ûÂ¸¤Î¥Õ¥¡¥¤¥ë¤ò
¾å½ñ¤­¤·¤Þ¤¹¡£

=begin original

As with the append mode, when you open a file in write-only mode,
you can now write to that filehandle using any of C<print>, C<printf>,
C<say>, C<write>, or C<syswrite>.

=end original

ÄÉµ­¥â¡¼¥É¤ÈÆ±ÍÍ¤Ë¡¢¥Õ¥¡¥¤¥ë¤ò½ñ¤­¹þ¤ß¥â¡¼¥É¤Ç³«¤¯¤È¡¢
C<print>, C<printf>, C<say>, C<write>, C<syswrite> ¤ò»È¤Ã¤Æ
¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ë½ñ¤­¹þ¤á¤ë¤è¤¦¤Ë¤Ê¤ê¤Þ¤¹¡£

=begin original

What about read-write mode?  You should probably pretend it doesn't exist,
because opening text files in read-write mode is unlikely to do what you
would like.  See L<perlfaq5> for details.

=end original

ÆÉ¤ß½ñ¤­¥â¡¼¥É¤Ë¤Ä¤¤¤Æ¤Ï?
¤ª¤½¤é¤¯¤½¤ì¤ÏÂ¸ºß¤·¤Ê¤¤¤È¤¤¤¦¤Õ¤ê¤ò¤·¤¿Êý¤¬¤è¤¤¤Ç¤·¤ç¤¦;
¤Ê¤¼¤Ê¤é¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤òÆÉ¤ß½ñ¤­¥â¡¼¥É¤Ç³«¤¤¤Æ¤â
¤ª¤½¤é¤¯¤¢¤Ê¤¿¤¬Ë¾¤ó¤Ç¤¤¤ë¤³¤È¤ò¤·¤Ê¤¤¤«¤é¤Ç¤¹¡£
¾Ü¤·¤¯¤Ï L<perlfaq5> ¤ò»²¾È¤·¤Æ¤¯¤À¤µ¤¤¡£

=head1 Opening Binary Files

(¥Ð¥¤¥Ê¥ê¥Õ¥¡¥¤¥ë¤ò³«¤¯)

=begin original

If the file to be opened contains binary data instead of text characters,
then the C<MODE> argument to C<open> is a little different.  Instead of
specifying the encoding, you tell Perl that your data are in raw bytes.

=end original

³«¤³¤¦¤È¤·¤Æ¤¤¤ë¥Õ¥¡¥¤¥ë¤¬¥Æ¥­¥¹¥ÈÊ¸»ú¤Ç¤Ï¤Ê¤¯¥Ð¥¤¥Ê¥ê¥Ç¡¼¥¿¤¬´Þ¤Þ¤ì¤Æ¤¤¤ë
¾ì¹ç¡¢C<open> ¤Î C<MODE> °ú¿ô¤Ï¾¯¤·°Û¤Ê¤ë¤â¤Î¤Ë¤Ê¤ê¤Þ¤¹¡£
¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤ò»ØÄê¤¹¤ëÂå¤ï¤ê¤Ë¡¢¥Ç¡¼¥¿¤¬À¸¤Î¥Ð¥¤¥ÈÎó¤Ç¤¢¤ë¤³¤È¤ò
Perl ¤ËÃÎ¤é¤»¤Þ¤¹¡£

    my $filename = "/some/path/to/a/binary/file/goes/here";
    my $encoding = ":raw :bytes"
    my $handle   = undef;     # this will be filled in on success

=begin original

And then open as before, choosing C<<< "<" >>>, C<<< ">>" >>>, or
C<<< ">" >>> as needed:

=end original

¤½¤ì¤«¤éÁ°½Ò¤ÎÄÌ¤ê¡¢É¬Í×¤Ë±þ¤¸¤Æ
C<<< "<" >>>, C<<< ">>" >>>, C<<< ">" >>> ¤òÁª¤Ó¤Þ¤¹:

    open($handle, "< $encoding", $filename)
        || die "$0: can't open $filename for reading: $!";

    open($handle, ">> $encoding", $filename)
        || die "$0: can't open $filename for appending: $!";

    open($handle, "> $encoding", $filename)
        || die "$0: can't open $filename in write-open mode: $!";

=begin original

Alternately, you can change to binary mode on an existing handle this way:

=end original

¤¢¤ë¤¤¤Ï¡¢¼¡¤Î¤è¤¦¤Ë¤·¤Æ´û¤ËÂ¸ºß¤·¤Æ¤¤¤ë¥Ï¥ó¥É¥ë¤ò¥Ð¥¤¥Ê¥ê¥â¡¼¥É¤Ë
ÊÑ¤¨¤ë¤³¤È¤¬½ÐÍè¤Þ¤¹:

    binmode($handle)    || die "cannot binmode handle";

=begin original

This is especially handy for the handles that Perl has already opened for you.

=end original

¤³¤ì¤Ï¡¢Perl ¤¬´û¤Ë³«¤¤¤Æ¤¤¤ë¥Ï¥ó¥É¥ë¤ËÂÐ¤·¤ÆÆÃ¤ËÍ­ÍÑ¤Ç¤¹¡£

    binmode(STDIN)      || die "cannot binmode STDIN";
    binmode(STDOUT)     || die "cannot binmode STDOUT";

=begin original

You can also pass C<binmode> an explicit encoding to change it on the fly.
This isn't exactly "binary" mode, but we still use C<binmode> to do it:

=end original

¤Þ¤¿¡¢¤½¤Î¾ì¤ÇÊÑ¹¹¤¹¤ë¤¿¤á¤Ë C<binmode> ¤ËÌÀ¼¨Åª¤Ë¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤ò
ÅÏ¤¹¤³¤È¤â¤Ç¤­¤Þ¤¹¡£
¤³¤ì¤ÏÀµ³Î¤Ë¤Ï¡Ö¥Ð¥¤¥Ê¥ê¡×¥â¡¼¥É¤Ç¤Ï¤¢¤ê¤Þ¤»¤ó¤¬¡¢¤½¤ì¤Ç¤â
¤³¤ì¤ò¤¹¤ë¤¿¤á¤Ë C<binmode> ¤ò»È¤¤¤Þ¤¹:

  binmode(STDIN,  ":encoding(MacRoman)") || die "cannot binmode STDIN";
  binmode(STDOUT, ":encoding(UTF-8)")    || die "cannot binmode STDOUT";

=begin original

Once you have your binary file properly opened in the right mode, you can
use all the same Perl I/O functions as you used on text files.  However,
you may wish to use the fixed-size C<read> instead of the variable-sized
C<readline> for your input.

=end original

°ìÃ¶¥Ð¥¤¥Ê¥ê¥Õ¥¡¥¤¥ë¤òÀµ¤·¤¤¥â¡¼¥É¤ÇÅ¬ÀÚ¤Ë³«¤¯¤È¡¢¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤Ç
»È¤Ã¤¿¤â¤Î¤ÈÁ´¤ÆÆ±¤¸ Perl I/O ´Ø¿ô¤ò»È¤¨¤Þ¤¹¡£
¤·¤«¤·¡¢ÆþÎÏ¤ËÂÐ¤·¤Æ²ÄÊÑÄ¹¤Î C<readline> ¤Ç¤Ï¤Ê¤¯¸ÇÄêÄ¹¤Î
C<read> ¤ò»È¤Ã¤¿Êý¤¬ÎÉ¤¤¤Ç¤·¤ç¤¦¡£

=begin original

Here's an example of how to copy a binary file:

=end original

¼¡¤Î¤â¤Î¤Ï¥Ð¥¤¥Ê¥ê¥Õ¥¡¥¤¥ë¤ò¥³¥Ô¡¼¤¹¤ëÎã¤Ç¤¹:

    my $BUFSIZ   = 64 * (2 ** 10);
    my $name_in  = "/some/input/file";
    my $name_out = "/some/output/flie";

    my($in_fh, $out_fh, $buffer);

    open($in_fh,  "<", $name_in)
        || die "$0: cannot open $name_in for reading: $!";
    open($out_fh, ">", $name_out)
        || die "$0: cannot open $name_out for writing: $!";

    for my $fh ($in_fh, $out_fh)  {
        binmode($fh)               || die "binmode failed";
    }

    while (read($in_fh, $buffer, $BUFSIZ)) {
        unless (print $out_fh $buffer) {
            die "couldn't write to $name_out: $!";
        }
    }

    close($in_fh)       || die "couldn't close $name_in: $!";
    close($out_fh)      || die "couldn't close $name_out: $!";

=head1 Opening Pipes

(¥Ñ¥¤¥×¤ò³«¤¯)

=begin original

Perl also lets you open a filehandle into an external program or shell
command rather than into a file. You can do this in order to pass data
from your Perl program to an external command for further processing, or
to receive data from another program for your own Perl program to
process.

=end original

Perl ¤Ï¤Þ¤¿¡¢¥Õ¥¡¥¤¥ë¤Ç¤Ï¤Ê¤¯³°Éô¥×¥í¥°¥é¥à¤ä¥·¥§¥ë¥³¥Þ¥ó¥É¤Ø¤Î
¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤â³«¤­¤Þ¤¹¡£
¤³¤ì¤ò¡¢¹¹¤Ê¤ë½èÍý¤Î¤¿¤á¤Ë Perl ¥×¥í¥°¥é¥à¤«¤é³°Éô¥³¥Þ¥ó¥É¤ØÅÏ¤¹¤¿¤á¡¢
¤Þ¤¿¤Ï½èÍý¤¹¤ë Perl ¥×¥í¥°¥é¥à¤Î¤¿¤á¤ËÂ¾¤Î¥×¥í¥°¥é¥à¤«¤é¥Ç¡¼¥¿¤ò
¼õ¤±¼è¤ë¤¿¤á¤Ë¹Ô¤¨¤Þ¤¹¡£

=begin original

Filehandles into commands are also known as I<pipes>, since they work on
similar inter-process communication principles as Unix pipelines. Such a
filehandle has an active program instead of a static file on its
external end, but in every other sense it works just like a more typical
file-based filehandle, with all the techniques discussed earlier in this
article just as applicable.

=end original

¥³¥Þ¥ó¥É¤Ø¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ï¡¢I<¥Ñ¥¤¥×> ¤È¤·¤Æ¤âÃÎ¤é¤ì¤Þ¤¹;
Unix ¥Ñ¥¤¥×¥é¥¤¥ó¤È¤¤¤¦»÷¤¿¤è¤¦¤Ê¥×¥í¥»¥¹´ÖÄÌ¿®¸¶Â§¤Ë´ð¤Å¤¤¤Æ
Æ°ºî¤¹¤ë¤«¤é¤Ç¤¹¡£
¤½¤Î¤è¤¦¤Ê¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ï¡¢³°Â¦¤¬ÀÅÅª¤Ê¥Õ¥¡¥¤¥ë¤Ç¤Ï¤Ê¤¯
Æ°ºîÃæ¤Î¥×¥í¥°¥é¥à¤Ç¤¹¤¬¡¢¤½¤ì°Ê³°¤ÎÅÀ¤Ë¤Ä¤¤¤Æ¤Ï
¤è¤êÅµ·¿Åª¤Ê¥Õ¥¡¥¤¥ë¥Ù¡¼¥¹¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤È¤Á¤ç¤¦¤ÉÆ±¤¸¤è¤¦¤Ë
Æ°ºî¤·¡¢¤³¤ÎÊ¸½ñ¤Ç´û¤ËµÄÏÀ¤·¤¿Á´¤Æ¤Î¥Æ¥¯¥Ë¥Ã¥¯¤¬ÍøÍÑ²ÄÇ½¤Ç¤¹¡£

=begin original

As such, you open a pipe using the same C<open> call that you use for
opening files, setting the second (C<MODE>) argument to special
characters that indicate either an input or an output pipe. Use C<"-|"> for a
filehandle that will let your Perl program read data from an external
program, and C<"|-"> for a filehandle that will send data to that
program instead.

=end original

2 ÈÖÌÜ¤Î (C<MODE>) °ú¿ô¤Ë¥Ñ¥¤¥×¤ÎÆþÎÏ¤Þ¤¿¤Ï½ÐÎÏ¤ò¼¨¤¹ÆÃ¼ì¤ÊÊ¸»ú¤ò
ÀßÄê¤¹¤ë¤³¤È¤Ç¡¢¥Õ¥¡¥¤¥ë¤ò³«¤¯¤Î¤Ë»È¤¦¤Î¤ÈÆ±¤¸ C<open> ¤Ç
¥Ñ¥¤¥×¤ò³«¤­¤Þ¤¹¡£
Perl ¥×¥í¥°¥é¥à¤¬³°Éô¥×¥í¥°¥é¥à¤«¤é¥Ç¡¼¥¿¤òÆÉ¤ß¹þ¤à¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ë¤Ï
C<"-|"> ¤ò»È¤¤¤Þ¤¹; ¥×¥í¥°¥é¥à¤Ë¥Ç¡¼¥¿¤òÁ÷¤ë¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ë¤Ï
C<"|-"> ¤ò»È¤¤¤Þ¤¹¡£

=head2 Opening a pipe for reading

(ÆÉ¤ß¹þ¤ßÍÑ¤Ë¥Ñ¥¤¥×¤ò³«¤¯)

=begin original

Let's say you'd like your Perl program to process data stored in a nearby
directory called C<unsorted>, which contains a number of textfiles.
You'd also like your program to sort all the contents from these files
into a single, alphabetically sorted list of unique lines before it
starts processing them.

=end original

¤¿¤¯¤µ¤ó¤Î¥Æ¥­¥¹¥È¥Õ¥¡¥¤¥ë¤¬´Þ¤Þ¤ì¤Æ¤¤¤ë¡¢C<unsorted> ¤È¸Æ¤Ð¤ì¤ë
¶á¤¯¤Î¥Ç¥£¥ì¥¯¥È¥ê¤ËÊÝ´É¤µ¤ì¤Æ¤¤¤ë¥Ç¡¼¥¿¤ò½èÍý¤¹¤ë
Perl ¥×¥í¥°¥é¥à¤¬Íß¤·¤¤¤È¤·¤Þ¤·¤ç¤¦¡£
¤Þ¤¿¡¢½èÍý¤ò³«»Ï¤¹¤ëÁ°¤Ë¡¢Ê£¿ô¤Î¥Õ¥¡¥¤¥ë¤òÃ±°ì¤Î¡¢¥æ¥Ë¡¼¥¯¤Ê¹Ô¤ò
¥¢¥ë¥Õ¥¡¥Ù¥Ã¥È½ç¤Ë¥½¡¼¥È¤·¤¿¤¤¤È¤·¤Þ¤¹¡£

=begin original

You could do this through opening an ordinary filehandle into each of
those files, gradually building up an in-memory array of all the file
contents you load this way, and finally sorting and filtering that array
when you've run out of files to load. I<Or>, you could offload all that
merging and sorting into your operating system's own C<sort> command by
opening a pipe directly into its output, and get to work that much
faster.

=end original

¤½¤ì¤¾¤ì¤Î¥Õ¥¡¥¤¥ë¤ËÂÐ¤·¤ÆÄÌ¾ï¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤ò³«¤­¡¢
¤³¤Î¤è¤¦¤Ë¤·¤ÆÆÉ¤ß¹þ¤ó¤ÀÁ´¤Æ¤Î¥Õ¥¡¥¤¥ë¤ÎÆâÍÆ¤ò½ù¡¹¤Ë¥á¥â¥êÆâ¤ÎÇÛÎó¤Ë
¹½ÃÛ¤·¡¢ÆÉ¤ß¹þ¤à¥Õ¥¡¥¤¥ë¤¬¤Ê¤¯¤Ê¤Ã¤¿¤éºÇ¸å¤Ë¥½¡¼¥È¤È¥Õ¥£¥ë¥¿¥ê¥ó¥°¤ò¤¹¤ë¡¢
¤È¤¤¤¦·Á¤Ç¤³¤ì¤ò¹Ô¤¦¤³¤È¤â½ÐÍè¤Þ¤¹¡£
I<¤¢¤ë¤¤¤Ï>¡¢·ë¹ç¤È¥½¡¼¥È¤ò¥ª¥Ú¥ì¡¼¥Æ¥£¥ó¥°¼«¿È¤Î C<sort> ¥³¥Þ¥ó¥É¤Ë
Ç¤¤»¤Æ¡¢¤½¤Î½ÐÎÏ¤òÄ¾ÀÜ¥Ñ¥¤¥×¤Ç³«¤¯¤³¤È¤Ç¡¢ô£¤«¤ËÂ®¤¯ºî¶È¤¹¤ë¤³¤È¤â½ÐÍè¤Þ¤¹¡£

=begin original

Here's how that might look:

=end original

°Ê²¼¤Ï¡¢¤³¤ì¤¬¤É¤Î¤è¤¦¤Ë¸«¤¨¤ë¤«¤Ç¤¹:

    open(my $sort_fh, '-|', 'sort -u unsorted/*.txt')
        or die "Couldn't open a pipe into sort: $!";

    # And right away, we can start reading sorted lines:
    while (my $line = <$sort_fh>) {
        #
        # ... Do something interesting with each $line here ...
        #
    }

=begin original

The second argument to C<open>, C<"-|">, makes it a read-pipe into a
separate program, rather than an ordinary filehandle into a file.

=end original

C<open> ¤Î 2 ÈÖÌÜ¤Î°ú¿ô¤Ç¤¢¤ë C<"-|"> ¤Ï¡¢¥Õ¥¡¥¤¥ë¤Ø¤ÎÄÌ¾ï¤Î
¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Ç¤Ï¤Ê¤¯¡¢ÊÌ¸Ä¤Î¥×¥í¥°¥é¥à¤Ø¤ÎÆÉ¤ß¹þ¤ß¥Ñ¥¤¥×¤Ë¤·¤Þ¤¹¡£

=begin original

Note that the third argument to C<open> is a string containing the
program name (C<sort>) plus all its arguments: in this case, C<-u> to
specify unqiue sort, and then a fileglob specifying the files to sort.
The resulting filehandle C<$sort_fh> works just like a read-only (C<<
"<" >>) filehandle, and your program can subsequently read data
from it as if it were opened onto an ordinary, single file.

=end original

C<open> ¤Î 3 ÈÖÌÜ¤Î°ú¿ô¤Ï¡¢
¥×¥í¥°¥é¥àÌ¾ (C<sort>) ¤È¤½¤ÎÁ´¤Æ¤Î°ú¿ô¤ò´Þ¤ó¤ÀÊ¸»úÎó¤Ç¤¹:
¤³¤Î¾ì¹ç¡¢C<-u> ¤Ï¥æ¥Ë¡¼¥¯¥½¡¼¥È¤ò»ØÄê¤·¡¢¤½¤ì¤«¤é¥Õ¥¡¥¤¥ë¥°¥í¥Ö¤Ï
¥½¡¼¥È¤¹¤ë¥Õ¥¡¥¤¥ë¤ò»ØÄê¤¹¤ë¤³¤È¤ËÃí°Õ¤·¤Æ¤¯¤À¤µ¤¤¡£
·ë²Ì¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë C<$sort_fh> ¤Ï
¤Á¤ç¤¦¤ÉÆÉ¤ß¹þ¤ßÀìÍÑ (C<< "<" >>) ¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤Î¤è¤¦¤ËÆ°ºî¤·¡¢
¥×¥í¥°¥é¥à¤Ï¡¢ÄÌ¾ï¤ÎÃ±°ì¤Î¥Õ¥¡¥¤¥ë¤¬³«¤«¤ì¤¿¤«¤Î¤è¤¦¤Ë¡¢
°ú¤­Â³¤¤¤Æ¤½¤³¤«¤é¥Ç¡¼¥¿¤òÆÉ¤ß¹þ¤à¤³¤È¤¬¤Ç¤­¤Þ¤¹¡£

=head2 Opening a pipe for writing

(½ñ¤­¹þ¤ßÍÑ¤Ë¥Ñ¥¤¥×¤ò³«¤¯)

=begin original

Continuing the previous example, let's say that your program has
completed its processing, and the results sit in an array called
C<@processed>. You want to print these lines to a file called
C<numbered.txt> with a neatly formatted column of line-numbers.

=end original

Á°²ó¤ÎÎã¤ÎÂ³¤­¤È¤·¤Æ¡¢¥×¥í¥°¥é¥à¤Î½èÍý¤ò´°À®¤µ¤»¤Æ¡¢
·ë²Ì¤Ï C<@processed> ¤È¸Æ¤Ð¤ì¤ëÇÛÎó¤ËÆþ¤Ã¤Æ¤¤¤ë¤È¤·¤Þ¤·¤ç¤¦¡£
¤³¤ì¤é¤Î¹Ô¤ò C<numbered.txt> ¤È¤¤¤¦¥Õ¥¡¥¤¥ëÌ¾¤Ë¡¢
¤¤¤¤´¶¤¸¤ËÀ°·Á¤µ¤ì¤¿¹ÔÈÖ¹æ¤ÎÎó¤È¶¦¤Ë½ÐÎÏ¤·¤¿¤¤¤È¤·¤Þ¤¹¡£

=begin original

Certainly you could write your own code to do this — or, once again,
you could kick that work over to another program. In this case, C<cat>,
running with its own C<-n> option to activate line numbering, should do
the trick:

=end original

³Î¤«¤Ë¤³¤ì¤ò¤¹¤ë¥³¡¼¥É¤ò¼«Ê¬¤Ç½ñ¤¯¤³¤È¤â¤Ç¤­¤Þ¤¹ - ¤¢¤ë¤¤¤Ï¡¢ºÆ¤Ó¡¢
¤³¤Îºî¶È¤òÂ¾¤Î¥×¥í¥°¥é¥à¤ËÁ÷¤ë¤³¤È¤â¤Ç¤­¤Þ¤¹¡£
¤³¤Î¾ì¹ç¡¢C<cat> ¤ò¡¢¹ÔÈÖ¹æÉÕ¤±¤òÍ­¸ú¤Ë¤¹¤ë C<-n> ¥ª¥×¥·¥ç¥ó¹þ¤ß¤Ç
¼Â¹Ô¤¹¤ë¤Ë¤Ï¡¢¼¡¤Îµ»¤ò»È¤¤¤Þ¤¹:

    open(my $cat_fh, '|-', 'cat -n > numbered.txt')
        or die "Couldn't open a pipe into cat: $!";

    for my $line (@processed) {
        print $cat_fh $line;
    }

=begin original

Here, we use a second C<open> argument of C<"|-">, signifying that the
filehandle assigned to C<$cat_fh> should be a write-pipe. We can then
use it just as we would a write-only ordinary filehandle, including the
basic function of C<print>-ing data to it.

=end original

¤³¤³¤Ç¡¢C<open> ¤Î 2 ÈÖÌÜ¤Î°ú¿ô¤Ë C<"|-"> ¤ò»È¤¤¤Þ¤¹;
¤³¤ì¤Ë¤è¤ê¡¢C<$cat_fh> ¤ËÂåÆþ¤µ¤ì¤ë¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤¬½ñ¤­¹þ¤ß
¥Ñ¥¤¥×¤Ç¤¢¤ë¤³¤È¤ò¼¨¤·¤Þ¤¹¡£
¤½¤ì¤«¤é¡¢¥Ç¡¼¥¿¤ò C<print> ¤¹¤ë´ðËÜÅª¤Ê´Ø¿ô¤ò´Þ¤á¤Æ¡¢
½ñ¤­¹þ¤ßÀìÍÑ¤ÎÉáÄÌ¤Î¥Õ¥¡¥¤¥ë¥Ï¥ó¥É¥ë¤ò»È¤¦¤Î¤ÈÆ±¤¸¤è¤¦¤Ë¤³¤ì¤ò»È¤¨¤Þ¤¹¡£

=begin original

Note that the third argument, specifying the command that we wish to
pipe to, sets up C<cat> to redirect its output via that C<< ">" >>
symbol into the file C<numbered.txt>. This can start to look a little
tricky, because that same symbol would have meant something
entirely different had it showed it in the second argument to C<open>!
But here in the third argument, it's simply part of the shell command that
Perl will open the pipe into, and Perl itself doesn't invest any special
meaning to it.

=end original

¥Ñ¥¤¥×¤·¤¿¤¤¥³¥Þ¥ó¥É¤ò»ØÄê¤¹¤ë 3 ÈÖÌÜ¤Î°ú¿ô¤Ï¡¢
C<cat> ¤Î½ÐÎÏ¤ò C<< ">" >> µ­¹æ¤ò»È¤Ã¤Æ¥Õ¥¡¥¤¥ë C<numbered.txt> ¤Ë
¥ê¥À¥¤¥ì¥¯¥È¤¹¤ë¤è¤¦¤Ë»ØÄê¤·¤Æ¤¤¤ë¤³¤È¤ËÃí°Õ¤·¤Æ¤¯¤À¤µ¤¤¡£
¤³¤ì¤ÏºÇ½é¤Ï¾¯¤·¤ª¤«¤·¤¯¸«¤¨¤ë¤«¤â¤·¤ì¤Þ¤»¤ó;
¤³¤ÎÆ±¤¸µ­¹æ¤Ï¡¢C<open> ¤Î 2 ÈÖÌÜ¤Î°ú¿ô¤Ç¤ÏÁ´¤¯°ã¤¦¤â¤Î¤ò°ÕÌ£¤¹¤ë¤«¤é¤Ç¤¹!
¤·¤«¤·¡¢¤³¤³ 3 ÈÖÌÜ¤Î°ú¿ô¤Ç¤Ï¡¢¤³¤ì¤ÏÃ±¤Ë Perl ¤¬¥Ñ¥¤¥×¤ò³«¤¯
¥·¥§¥ë¥³¥Þ¥ó¥É¤Î°ìÉô¤Ç¤¢¤ê¡¢Perl ¼«¿È¤Ï¤³¤ì¤Ë²¿¤ÎÆÃÊÌ¤Ê°ÕÌ£¤âÍ¿¤¨¤Þ¤»¤ó¡£

=head2 Expressing the command as a list

(¥³¥Þ¥ó¥É¤ò¥ê¥¹¥È¤È¤·¤ÆÉ½¸½¤¹¤ë)

=begin original

For opening pipes, Perl offers the option to call C<open> with a list
comprising the desired command and all its own arguments as separate
elements, rather than combining them into a single string as in the
examples above. For instance, we could have phrased the C<open> call in
the first example like this:

=end original

¥Ñ¥¤¥×¤ò³«¤¯¤¿¤á¤Ë¡¢Perl ¤Ï¡¢ÌÜÅª¤Î¥³¥Þ¥ó¥É¤È¤½¤ì¼«¿È¤Î°ú¿ô¤ò¡¢
Á°½Ò¤ÎÎã¤Î¤è¤¦¤ËÃ±°ì¤ÎÊ¸»úÎó¤È¤·¤Æ·ë¹ç¤¹¤ë¤Î¤Ç¤Ï¤Ê¤¯¡¢
ÊÌ¸Ä¤ÎÍ×ÁÇ¤È¤·¤Æ¹½À®¤µ¤ì¤¿¥ê¥¹¥È¤Ç C<open> ¤ò¸Æ¤Ó½Ð¤¹¤È¤¤¤¦
ÁªÂò»è¤òÄó¶¡¤·¤Æ¤¤¤Þ¤¹¡£
Îã¤¨¤Ð¡¢ºÇ½é¤ÎÎã¤Î C<open> ¸Æ¤Ó½Ð¤·¤Ï¼¡¤Î¤è¤¦¤Ë½ñ¤±¤Þ¤¹:

    open(my $sort_fh, '-|', 'sort', '-u', glob('unsorted/*.txt'))
        or die "Couldn't open a pipe into sort: $!";

=begin original

When you call C<open> this way, Perl invokes the given command directly,
bypassing the shell. As such, the shell won't try to interpret any
special characters within the command's argument list, which might
overwise have unwanted effects. This can make for safer, less
error-prone C<open> calls, useful in cases such as passing in variables
as arguments, or even just referring to filenames with spaces in them.

=end original

¤³¤ÎÊýË¡¤Ç C<open> ¤ò¸Æ¤Ó½Ð¤¹¾ì¹ç¡¢
Perl ¤Ï¥·¥§¥ë¤ò¥Ð¥¤¥Ñ¥¹¤·¤Æ»ØÄê¤µ¤ì¤¿¥³¥Þ¥ó¥É¤òÄ¾ÀÜµ¯Æ°¤·¤Þ¤¹¡£
¥·¥§¥ë¤Ï¥³¥Þ¥ó¥ÉÏ©¤Î°ú¿ô¥ê¥¹¥È¤ÎÃæ¤ÎÆÃ¼ìÊ¸»ú¤ò²ò¼á¤·¤è¤¦¤È¤Ï¤·¤Þ¤»¤ó;
¤µ¤â¤Ê¤±¤ì¤ÐË¾¤Þ¤Ê¤¤¸ú²Ì¤òÀ¸¤à¤³¤È¤¬¤¢¤ê¤Þ¤¹¡£
¤³¤ì¤Ï¤è¤ê°ÂÁ´¤Ç¡¢C<open> ¸Æ¤Ó½Ð¤·¤Î¸í¤ê¤ò¸º¤é¤·¡¢
°ú¿ô¤È¤·¤ÆÊÑ¿ô¤ÎÆâÍÆ¤òÅÏ¤¹¤è¤¦¤Ê¾ì¹ç¤ËÍ­ÍÑ¤Ç¡¢
Ã±¤Ë¶õÇò¤ò´Þ¤à¥Õ¥¡¥¤¥ë¤ò»²¾È¤¹¤ë¾ì¹ç¤Ë¤â°ÂÁ´¤Ç¤¹¡£

=begin original

However, when you I<do> want to pass a meaningful metacharacter to the
shell, such with the C<"*"> inside that final C<unsorted/*.txt> argument
here, you can't use this alternate syntax. In this case, we have worked
around it via Perl's handy C<glob> built-in function, which evaluates
its argument into a list of filenames — and we can safely pass that
resulting list right into C<open>, as shown above.

=end original

¤·¤«¤·¡¢¥·¥§¥ë¤Ë°ÕÌ£¤Î¤¢¤ë¥á¥¿Ê¸»ú¤ò I<ÅÏ¤·¤¿¤¤>¡¢
Îã¤¨¤ÐºÇ½ªÅª¤Ê C<unsorted/*.txt> ¤ÎÃæ¤Î C<"*"> ¤Î¤è¤¦¤Ê¾ì¹ç¡¢
¤³¤ÎÂåÂØÊ¸Ë¡¤Ï»È¤¨¤Þ¤»¤ó¡£
¤³¤Î¾ì¹ç¡¢°ú¿ô¤ò¥Õ¥¡¥¤¥ëÌ¾¤È¤·¤ÆÉ¾²Á¤¹¤ë Perl ¤ÎÊØÍø¤Ê C<glob> ÁÈ¤ß¹þ¤ß´Ø¿ô¤Ç
²óÈò¤·¤Þ¤¹; ¤½¤·¤ÆÁ°½Ò¤·¤¿¤è¤¦¤Ë¡¢·ë²Ì¤Î¥ê¥¹¥È¤ò C<open> ¤Ë°ÂÁ´¤Ë
ÅÏ¤»¤Þ¤¹¡£

=begin original

Note also that representing piped-command arguments in list form like
this doesn't work on every platform. It will work on any Unix-based OS
that provides a real C<fork> function (e.g. macOS or Linux), as well as
on Windows when running Perl 5.22 or later.

=end original

¤Þ¤¿¡¢¤³¤Î¤è¤¦¤Ê¥ê¥¹¥È·Á¼°¤Ç¤Î¥Ñ¥¤¥×¥³¥Þ¥ó¥É°ú¿ôÉ½¸½¤Ï¡¢Á´¤Æ¤Î
¥×¥é¥Ã¥È¥Õ¥©¡¼¥à¤ÇÆ°ºî¤¹¤ë¤ï¤±¤Ç¤Ï¤Ê¤¤¤³¤È¤ËÃí°Õ¤·¤Æ¤¯¤À¤µ¤¤¡£
¿¿¤Î C<fork> ´Ø¿ô¤òÄó¶¡¤¹¤ë Unix ¥Ù¡¼¥¹¤Î OS (Îã¤¨¤Ð macOS ¤ä Linux)¡¢
¤ª¤è¤Ó Perl 5.22 °Ê¹ß¤Î Windows ¤Ç¤ÏÆ°ºî¤·¤Þ¤¹¡£

=head1 SEE ALSO

=begin original

The full documentation for L<C<open>|perlfunc/open FILEHANDLE,MODE,EXPR>
provides a thorough reference to this function, beyond the best-practice
basics covered here.

=end original

L<C<open>|perlfunc/open FILEHANDLE,MODE,EXPR> ¤Î´°Á´¤ÊÊ¸½ñ¤Ï¡¢
¤³¤³¤Ç¥«¥Ð¡¼¤·¤Æ¤¤¤ë¥Ù¥¹¥È¥×¥é¥¯¥Æ¥£¥¹¥Ù¡¼¥¹¤Î¤â¤Î¤òÄ¶¤¨¤Æ¡¢
¤³¤Î´Ø¿ô¤Î´°Á´¤Ê¥ê¥Õ¥¡¥ì¥ó¥¹¤òÄó¶¡¤·¤Þ¤¹¡£

=head1 AUTHOR and COPYRIGHT

Copyright 2013 Tom Christiansen; now maintained by Perl5 Porters

This documentation is free; you can redistribute it and/or modify it under
the same terms as Perl itself.

=begin meta

Translate: SHIRAKTA Kentaro <argrath@ub32.org>
Status: completed

=end meta

