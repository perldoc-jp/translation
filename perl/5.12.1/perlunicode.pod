
=encoding euc-jp

=head1 NAME

=begin original

perlunicode - Unicode support in Perl

=end original

perlunicode - Perl における Unicode サポート

=head1 DESCRIPTION

=head2 Important Caveats

(重要な警告)

=begin original

Unicode support is an extensive requirement. While Perl does not
implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.

=end original

Uncode サポートは大規模な要求です。
Perl は標準 Unicode や付随する技術的なレポートを一つ残らず
実装しているわけではありませんが、多くの Unicode 機能を
サポートしています。

=begin original

People who want to learn to use Unicode in Perl, should probably read
L<the Perl Unicode tutorial, perlunitut|perlunitut>, before reading
this reference document.

=end original

Perl で Unicode を使うことを学びたい人は、多分このリファレンスを読む前に
L<the Perl Unicode tutorial, perlunitut|perlunitut> を
読んだ方がよいでしょう。

=over 4

=item Input and Output Layers

(入出力層)

=begin original

Perl knows when a filehandle uses Perl's internal Unicode encodings
(UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with
the ":utf8" layer.  Other encodings can be converted to Perl's
encoding on input or from Perl's encoding on output by use of the
":encoding(...)"  layer.  See L<open>.

=end original

Perl は、ファイルハンドルが ":utf8" 層を指定してオープンされると、
ファイルハンドルが Perl の内部 Unicode エンコーディング
(UTF-8, または EBCDIC の時は UTF-EBCDIC) を使うことが分かります。 
その他のエンコーディングは、":encoding(...)" 層を使うことで、
入力時の Perl のエンコーディングへの変換や出力時の Perl の
エンコーディングからの変換を行えます。
L<open> を参照してください。

=begin original

To indicate that Perl source itself is in UTF-8, use C<use utf8;>.

=end original

Perl のソース自身が UTF-8 であることを示すには、C<use utf8;> を
使ってください。

=item Regular Expressions

(正規表現)

=begin original

The regular expression compiler produces polymorphic opcodes.  That is,
the pattern adapts to the data and automatically switches to the Unicode
character scheme when presented with data that is internally encoded in
UTF-8, or instead uses a traditional byte scheme when presented with
byte data.

=end original

正規表現コンパイラは多態的なオペコードを生成します。
つまり、パターンはデータに対して適用され、データが内部で UTF-8 で
エンコードされている場合には Unicode 文字スキームに自動的に
切り替わります; さもなければ、バイトデータで表されている場合には
伝統的なバイトスキームが使われます。

=item C<use utf8> still needed to enable UTF-8/UTF-EBCDIC in scripts

=begin original

As a compatibility measure, the C<use utf8> pragma must be explicitly
included to enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identifier names) on
ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based
machines.  B<These are the only times when an explicit C<use utf8>
is needed.>  See L<utf8>.

=end original

互換性のために、ASCII ベースのマシンにおいて Perl スクリプトそれ自身の
中の UTF-8 を(文字列や正規表現リテラル、あるいは変数名で) 認識可能に
するためや、EBCDIC ベースのマシンで UTF-EBCDIC を認識させるために
C<use utf8> プラグマを明示的に含めなければなりません。
B<これらは明示的に C<use utf8> が必要な唯一の場合です。>
L<utf8> を参照してください。

=item BOM-marked scripts and UTF-16 scripts autodetected

=begin original

If a Perl script begins marked with the Unicode BOM (UTF-16LE, UTF16-BE,
or UTF-8), or if the script looks like non-BOM-marked UTF-16 of either
endianness, Perl will correctly read in the script as Unicode.
(BOMless UTF-8 cannot be effectively recognized or differentiated from
ISO 8859-1 or other eight-bit encodings.)

=end original

Unicode BOM (UTF-16LE, UTF16-BE, またはUTF-8)で Perl スクリプトが
始まっていたり、スクリプトが BOM がついていない
UTF-16(BE か LE のいずれか) であった場合、Perl はそのスクリプトを
Unicode であるとして正しく読み込みます。
(BOM がない UTF-8 は、効率的に ISO 8859-1 などの 8 ビットエンコーディングと
区別したり認識することができません。)

=item C<use encoding> needed to upgrade non-Latin-1 byte strings

=begin original

By default, there is a fundamental asymmetry in Perl's Unicode model:
implicit upgrading from byte strings to Unicode strings assumes that
they were encoded in I<ISO 8859-1 (Latin-1)>, but Unicode strings are
downgraded with UTF-8 encoding.  This happens because the first 256
codepoints in Unicode happens to agree with Latin-1.

=end original

デフォルトでは、Perl の Unicode モデルにおける基本的な非対称があります:
バイト文字列から Unicode 文字列への暗黙の昇格はその文字列が
I<ISO 8859-1 (Latin-1)> でエンコードされているものと仮定しますが、
Unicode 文字列からのダウングレードは
UTF-8 エンコーディングへと行われます。
これは Unicode の最初の 256 文字が Latin-1 と共通であるからです。

=begin original

See L</"Byte and Character Semantics"> for more details.

=end original

詳細は L</"Byte and Character Semantics"> を参照してください。

=back

=head2 Byte and Character Semantics

(バイトと文字のセマンティクス)

=begin original

Beginning with version 5.6, Perl uses logically-wide characters to
represent strings internally.

=end original

バージョン 5.6 から、Perl は論理的なワイド文字を内部的な文字列の
表現のために使っています。

=begin original

In future, Perl-level operations will be expected to work with
characters rather than bytes.

=end original

将来は、Perl レベルの操作はバイトではなく文字に対して働くことになるでしょう。

=begin original

However, as an interim compatibility measure, Perl aims to
provide a safe migration path from byte semantics to character
semantics for programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to
character semantics.  For operations where this determination cannot
be made without additional information from the user, Perl decides in
favor of compatibility and chooses to use byte semantics.

=end original

しかしながら、一時的な互換性の措置として、Perl は
プログラムに対するバイトセマンティクスから文字セマンティクスへの
安全な移行パスを提供することを目指します。
入力データが文字であると Perl が曖昧さなく決定できる操作については、
Perl は文字セマンティクスに切り替えます。
ユーザーからの付加的な情報抜きに決定することができない操作については
Perl は互換性の観点からバイトセマンティクスを選択します。

=begin original

Under byte semantics, when C<use locale> is in effect, Perl uses the
semantics associated with the current locale.  Absent a C<use locale>, and
absent a C<use feature 'unicode_strings'> pragma, Perl currently uses US-ASCII
(or Basic Latin in Unicode terminology) byte semantics, meaning that characters
whose ordinal numbers are in the range 128 - 255 are undefined except for their
ordinal numbers.  This means that none have case (upper and lower), nor are any
a member of character classes, like C<[:alpha:]> or C<\w>.  (But all do belong
to the C<\W> class or the Perl regular expression extension C<[:^alpha:]>.)

=end original

バイトセマンティクスでは、C<use locale> が有効の場合、Perl は
現在のロケールに関連づけられたセマンティクスを使います。
C<use locale> がなく、C<use feature 'unicode_strings'> もない場合、
Perl は現在のところ US-ASCII (または Unicode の用語では Basic Latin) バイト
セマンティクスを使います; つまり番号 128 - 255 の範囲の文字は、
その番号以外では未定義です。
つまり、大文字小文字はなく、C<[:alpha:]> や C<\w> のような、
どの文字クラスにも含まれません。
(しかし C<\W> クラスや Perl の正規表現拡張 C<[:^alpha:]> には属します。)

=begin original

This behavior preserves compatibility with earlier versions of Perl,
which allowed byte semantics in Perl operations only if
none of the program's inputs were marked as being a source of Unicode
character data.  Such data may come from filehandles, from calls to
external programs, from information provided by the system (such as %ENV),
or from literals and constants in the source text.

=end original

この動作は Perl の以前のバージョンとの互換性を維持し、プログラムの
入力が Unicode の文字データのソースであるとマークされていない場合にのみ
Perl の操作でバイトセマンティクスを許可します。
そのようなデータは、ファイルハンドル、外部プログラムの呼び出し、
システムから提供される情報(%ENV のような)、ソーステキスト中のリテラルや
定数といったものからくるものです。

=begin original

The C<bytes> pragma will always, regardless of platform, force byte
semantics in a particular lexical scope.  See L<bytes>.

=end original

C<bytes> プラグマは常に、プラットフォームとは無関係に、特定の
レキシカルスコープにおいてバイトセマンティクスを強制します。
L<bytes> を参照してください。

=begin original

The C<use feature 'unicode_strings'> pragma is intended to always, regardless
of platform, force Unicode semantics in a particular lexical scope.  In
release 5.12, it is partially implemented, applying only to case changes.
See L</The "Unicode Bug"> below.

=end original

The C<use feature 'unicode_strings'> pragma is intended to always, regardless
of platform, force Unicode semantics in a particular lexical scope.  In
release 5.12, it is partially implemented, applying only to case changes.
See L</The "Unicode Bug"> below.
(TBT)

=begin original

The C<utf8> pragma is primarily a compatibility device that enables
recognition of UTF-(8|EBCDIC) in literals encountered by the parser.
Note that this pragma is only required while Perl defaults to byte
semantics; when character semantics become the default, this pragma
may become a no-op.  See L<utf8>.

=end original

C<utf8> プラグマは主としてパーサが遭遇するリテラル中の UTF-(8|EBCDIC) の
認識を有効にする互換デバイス(compatibility device)です。
このプラグマは Perl のデフォルトがバイトセマンティクスであるときにのみ
必要であることに注意してください; 文字セマンティクスが
デフォルトである場合には、このプラグマは何もしません。
L<utf8> を参照してください。

=begin original

Unless explicitly stated, Perl operators use character semantics
for Unicode data and byte semantics for non-Unicode data.
The decision to use character semantics is made transparently.  If
input data comes from a Unicode source--for example, if a character
encoding layer is added to a filehandle or a literal Unicode
string constant appears in a program--character semantics apply.
Otherwise, byte semantics are in effect.  The C<bytes> pragma should
be used to force byte semantics on Unicode data, and the C<use feature
'unicode_strings'> pragma to force Unicode semantics on byte data (though in
5.12 it isn't fully implemented).

=end original

明示的に指定されない限り、Perl の演算子は Unicode データに対しては
文字セマンティクスを用い、非 Unicode データに対しては
バイトセマンティクスを用います。
文字セマンティクスの使用の決定はトランスペアレントに行われます。
もし入力データが Unicode ソースから来たもの -- たとえば、
文字エンコーディング層がファイルハンドルに附加されているか
リテラルの Unicode 文字列定数がプログラムの中にある -- のであれば
文字セマンティクスが適用されます。
そうでなければ、バイトセマンティクスが有効になります。
C<bytes> プラグマは Unicode データに対してバイトセマンティクスを
強制するときに使って、C<use feature 'unicode_strings'> プラグマを
バイトデータで Unicode セマンティクスを強制するために使えます
(しかし 5.12 ではこれは完全には実装されていません)。

=begin original

If strings operating under byte semantics and strings with Unicode
character data are concatenated, the new string will have
character semantics.  This can cause surprises: See L</BUGS>, below.
You can choose to be warned when this happens.  See L<encoding::warnings>.

=end original

バイトセマンティクスの元での文字列の操作で、Unicode 文字データが
連結された文字列であった場合、新たな文字列は文字セマンティックスを
保ちます。
これは驚きを引き起こすかもしれません: 後述する L</BUGS> を
参照してください。
これが起きたときに警告されるようにすることを選択できます。
L<encoding::warnings> を参照してください。

=begin original

Under character semantics, many operations that formerly operated on
bytes now operate on characters. A character in Perl is
logically just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes internally, but
this internal detail is mostly hidden for Perl code.
See L<perluniintro> for more.

=end original

文字セマンティクスの元では、伝統的にバイトに対して働いていた操作の多くが
文字に対して働きます。
Perl における文字は論理的には 0 から 2**31 までの範囲の数値です。
大きな文字は内部的にはより長いシーケンスにエンコードされる可能性が
ありますが、この内部の詳細は Perl プログラムからほとんど隠されています。
詳細は L<perluniintro> を参照してください。

=head2 Effects of Character Semantics

(文字セマンティクスの効果)

=begin original

Character semantics have the following effects:

=end original

文字セマンティクスは以下の効果を持っています:

=over 4

=item *

=begin original

Strings--including hash keys--and regular expression patterns may
contain characters that have an ordinal value larger than 255.

=end original

文字列 -- ハッシュのキーを含め -- と正規表現パターンは序数値として 255 を
超える値を持つ文字を含めることができます。

=begin original

If you use a Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a BOM or C<use utf8>, the latter requires a BOM.)

=end original

プログラムを編集するのに Unicode エディタを使っているのであれば、Unicode の
文字 UTF-8 か UTF-16 のエンコーディングコーディングでリテラル文字列に
含めることができます。
(前者は BOM か C<use utf8> を必要とし、後者は BOM を必要とします。)

=begin original

Unicode characters can also be added to a string by using the C<\N{U+...}>
notation.  The Unicode code for the desired character, in hexadecimal,
should be placed in the braces, after the C<U>. For instance, a smiley face is
C<\N{U+263A}>.

=end original

Unicode の文字は C<\x{...}> 表記を使うことにより文字列に
追加することもできます。
その表現される Unicode コードは、16 進でブレースに囲みます。
たとえば、smiley face は C<\N{U+263A}> です。

=begin original

Alternatively, you can use the C<\x{...}> notation for characters 0x100 and
above.  For characters below 0x100 you may get byte semantics instead of
character semantics;  see L</The "Unicode Bug">.  On EBCDIC machines there is
the additional problem that the value for such characters gives the EBCDIC
character rather than the Unicode one.

=end original

Alternatively, you can use the C<\x{...}> notation for characters 0x100 and
above.  For characters below 0x100 you may get byte semantics instead of
character semantics;  see L</The "Unicode Bug">.  On EBCDIC machines there is
the additional problem that the value for such characters gives the EBCDIC
character rather than the Unicode one.
(TBT)

=begin original

Additionally, if you

=end original

これに加えて、

   use charnames ':full';

=begin original

you can use the C<\N{...}> notation and put the official Unicode
character name within the braces, such as C<\N{WHITE SMILING FACE}>.
See L<charnames>.

=end original

とすると C<\N{...}> 表記を使うことができ、公式な Unicode 文字名を
C<\N{WHITE SMILING FACE}> のようにブレースの中に置くことができます。
L<charnames> を参照してください。

=item *

=begin original

If an appropriate L<encoding> is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl does not currently attempt to canonicalize variable
names.

=end original

適切な L<encoding> が指定されていれば、Perl スクリプトの中の識別子で
表意文字を含めた Unicode の英数字を含めることができます。
Perl は現在、変数名を正規化しようとはしません。

=item *

=begin original

Regular expressions match characters instead of bytes.  "." matches
a character instead of a byte.

=end original

正規表現はバイトではなく文字にマッチします。
"." は一バイトではなく、ひとつの文字にマッチします。

=item *

=begin original

Character classes in regular expressions match characters instead of
bytes and match against the character properties specified in the
Unicode properties database.  C<\w> can be used to match a Japanese
ideograph, for instance.

=end original

正規表現中の文字クラスはバイトではなく文字にマッチし、Unicode の
特性データベースで定義されている文字特性に対してマッチを行います。
たとえば、C<\w> は日本語の表意文字にマッチさせるために使うことができます。

=item *

=begin original

Named Unicode properties, scripts, and block ranges may be used like
character classes via the C<\p{}> "matches property" construct and
the C<\P{}> negation, "doesn't match property".
See L</"Unicode Character Properties"> for more details.

=end original

Named Unicode properties, scripts, and block ranges may be used like
character classes via the C<\p{}> "matches property" construct and
the C<\P{}> negation, "doesn't match property".
See L</"Unicode Character Properties"> for more details.
(TBT)

=begin original

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.
See L</"User-Defined Character Properties"> for more details.

=end original

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.
See L</"User-Defined Character Properties"> for more details.
(TBT)

=item *

=begin original

The special pattern C<\X> matches a logical character, an "extended grapheme
cluster" in Standardese.  In Unicode what appears to the user to be a single
character, for example an accented C<G>, may in fact be composed of a sequence
of characters, in this case a C<G> followed by an accent character.  C<\X>
will match the entire sequence.

=end original

特殊なパターン C<\X> は論理文字、標準で言うところの
「拡張書記素クラスタ」にマッチングします。
Unicode では、ユーザーには単一の文字、例えばアクセント付きの C<G> に
見えるものが、実際には文字の並び、この場合では C<G> に引き続いて
アクセント文字から構成されるかもしれません。
C<\X> は並び全体にマッチングします。

=item *

=begin original

The C<tr///> operator translates characters instead of bytes.  Note
that the C<tr///CU> functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).

=end original

C<tr///> 演算子はバイトではなく文字で変換します。
C<tr///CU> は削除されたことに注意してください。
同様のことを行うには pack('U0', ...) と pack('C0', ...) を
参照してください。

=item *

=begin original

Case translation operators use the Unicode case translation tables
when character input is provided.  Note that C<uc()>, or C<\U> in
interpolated strings, translates to uppercase, while C<ucfirst>,
or C<\u> in interpolated strings, translates to titlecase in languages
that make the distinction (which is equivalent to uppercase in languages
without the distinction).

=end original

大小文字の変換演算子は Unicode の大小文字変換テーブルを、文字の入力が
あったときに使用します。
C<uc()> や展開文字列中の C<\U> は大文字に変換し、C<ucfirst> や
展開文字列中の C<\u> はその言語で区別されているときに
タイトルケースに変換します (これは、区別がない言語では大文字と等価です)。

=item *

=begin original

Most operators that deal with positions or lengths in a string will
automatically switch to using character positions, including
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sprintf()>, C<write()>, and C<length()>.  An operator that
specifically does not switch is C<vec()>.  Operators that really don't
care include operators that treat strings as a bucket of bits such as
C<sort()>, and operators dealing with filenames.

=end original

文字列の位置や長さを取り扱う演算子の大部分は自動的に文字の位置を
使うように変更されました; これには C<chop()>, C<chomp()>, C<substr()>,
C<pos()>, C<index()>, C<rindex()>, C<sprintf()>, C<write()>, C<length()> が
含まれます。
C<vec()> は変更されていません。
文字列をビットのバケツのように扱う C<sort()>、ファイル名を取り扱う演算子は
文字かどうかを気にしません。

=item *

=begin original

The C<pack()>/C<unpack()> letter C<C> does I<not> change, since it is often
used for byte-oriented formats.  Again, think C<char> in the C language.

=end original

C<pack()>/C<unpack()> の文字 C<C> は I<変更されていません>; なぜなら、
これらはしばしばバイト指向の書式のために使われるからです。
繰り返しますが、C 言語の C<char> を考えてください。

=begin original

There is a new C<U> specifier that converts between Unicode characters
and code points. There is also a C<W> specifier that is the equivalent of
C<chr>/C<ord> and properly handles character values even if they are above 255.

=end original

Unicode の文字と符号位置の間の変換を行う新たな C<U> 指定子があります。
C<chr>/C<ord> と等価で、文字の値が 255 を超えていても適切に扱える
C<W> 指定子もあります。

=item *

=begin original

The C<chr()> and C<ord()> functions work on characters, similar to
C<pack("W")> and C<unpack("W")>, I<not> C<pack("C")> and
C<unpack("C")>.  C<pack("C")> and C<unpack("C")> are methods for
emulating byte-oriented C<chr()> and C<ord()> on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.

=end original

C<chr()> 関数と C<ord()> 関数は C<pack("W")> や C<unpack("W")> のように
文字に対して働き、C<pack("C")> や C<unpack("C")> のようには I<働きません>。
C<pack("C")> と C<unpack("C")> は Unicode 文字列においてバイト指向の
C<chr()> や C<ord()> をエミュレートするためのメソッドです。
これらのメソッドが Unicode 文字列の内部エンコーディングを明らかにするので、
通常はケアする必要はありません。

=item *

=begin original

The bit string operators, C<& | ^ ~>, can operate on character data.
However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use C<~> (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (C<~($x|$y) eq ~$x&~$y> and C<~($x&$y) eq ~$x|~$y>)
will not hold.  The reason for this mathematical I<faux pas> is that
the complement cannot return B<both> the 8-bit (byte-wide) bit
complement B<and> the full character-wide bit complement.

=end original

ビット文字列演算子 C<& | ^ ~> は文字データを操作できます。
しかし、例えば全ての文字の値が 255 以下のときに
ビット文字列演算を使った場合の後方互換性のために、
256 以上の値の文字と 255 以下の値の文字の両方が含まれている文字列に
C<~> (ビット補数) を使うべきではありません。
最も重要なことは、ド・モルガンの法則 (C<~($x|$y) eq ~$x&~$y> と
C<~($x&$y) eq ~$x|~$y>) が成り立たないということです。
この数学的な I<過失> の理由は補数(complement)が 8 ビットのビット補数
B<および> 文字幅のビット補数の B<両方> を返すことができないためです。

=item *

=begin original

You can define your own mappings to be used in lc(),
lcfirst(), uc(), and ucfirst() (or their string-inlined versions).
See L</"User-Defined Case Mappings"> for more details.

=end original

lc(), lcfirst(), uc(), ucfirst() (およびこれらの
文字列インライン版) で使える独自のマッピングを定義できます。
更なる詳細については L</"User-Defined Case Mappings"> を参照してください。

=back

=over 4

=item *

=begin original

And finally, C<scalar reverse()> reverses by character rather than by byte.

=end original

そして最後に、C<scalar reverse()> はバイト単位ではなく文字単位で
反転を行います。

=back

=head2 Unicode Character Properties

(Unicode 文字特性)

=begin original

Most Unicode character properties are accessible by using regular expressions.
They are used like character classes via the C<\p{}> "matches property"
construct and the C<\P{}> negation, "doesn't match property".

=end original

ほとんどの Unicode 文字特性は正規表現を使ってアクセス可能です。
それらは C<\p{}> "matches property" 構造やその否定形の C<\P{}>
"doesn't match property" を使った文字クラスで使うことができます。

=begin original

For instance, C<\p{Uppercase}> matches any character with the Unicode
"Uppercase" property, while C<\p{L}> matches any character with a
General_Category of "L" (letter) property.  Brackets are not
required for single letter properties, so C<\p{L}> is equivalent to C<\pL>.

=end original

たとえば、C<\p{Uppercase}> は Unicode の "Uppercase" 特性を持つ任意の
文字にマッチし、C<\p{L}> は一般カテゴリ "L" (letter) 特性を持つ任意の
文字にマッチします。
ブラケットは一文字の特性では省略することができるので、C<\p{L}> は
C<\pL> と等価です。

=begin original

More formally, C<\p{Uppercase}> matches any character whose Unicode Uppercase
property value is True, and C<\P{Uppercase}> matches any character whose
Uppercase property value is False, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively

=end original

More formally, C<\p{Uppercase}> matches any character whose Unicode Uppercase
property value is True, and C<\P{Uppercase}> matches any character whose
Uppercase property value is False, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively
(TBT)

=begin original

This formality is needed when properties are not binary, that is if they can
take on more values than just True and False.  For example, the Bidi_Class (see
L</"Bidirectional Character Types"> below), can take on a number of different
values, such as Left, Right, Whitespace, and others.  To match these, one needs
to specify the property name (Bidi_Class), and the value being matched against
(Left, Right, I<etc.>).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.

=end original

This formality is needed when properties are not binary, that is if they can
take on more values than just True and False.  For example, the Bidi_Class (see
L</"Bidirectional Character Types"> below), can take on a number of different
values, such as Left, Right, Whitespace, and others.  To match these, one needs
to specify the property name (Bidi_Class), and the value being matched against
(Left, Right, I<etc.>).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.
(TBT)

=begin original

All Unicode-defined character properties may be written in these compound forms
of C<\p{property=value}> or C<\p{property:value}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

=end original

All Unicode-defined character properties may be written in these compound forms
of C<\p{property=value}> or C<\p{property:value}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.
(TBT)

=begin original

Most Unicode character properties have at least two synonyms (or aliases if you
prefer), a short one that is easier to type, and a longer one which is more
descriptive and hence it is easier to understand what it means.  Thus the "L"
and "Letter" above are equivalent and can be used interchangeably.  Likewise,
"Upper" is a synonym for "Uppercase", and we could have written
C<\p{Uppercase}> equivalently as C<\p{Upper}>.  Also, there are typically
various synonyms for the values the property can be.   For binary properties,
"True" has 3 synonyms: "T", "Yes", and "Y"; and "False has correspondingly "F",
"No", and "N".  But be careful.  A short form of a value for one property may
not mean the same thing as the same short form for another.  Thus, for the
General_Category property, "L" means "Letter", but for the Bidi_Class property,
"L" means "Left".  A complete list of properties and synonyms is in
L<perluniprops>.

=end original

Most Unicode character properties have at least two synonyms (or aliases if you
prefer), a short one that is easier to type, and a longer one which is more
descriptive and hence it is easier to understand what it means.  Thus the "L"
and "Letter" above are equivalent and can be used interchangeably.  Likewise,
"Upper" is a synonym for "Uppercase", and we could have written
C<\p{Uppercase}> equivalently as C<\p{Upper}>.  Also, there are typically
various synonyms for the values the property can be.   For binary properties,
"True" has 3 synonyms: "T", "Yes", and "Y"; and "False has correspondingly "F",
"No", and "N".  But be careful.  A short form of a value for one property may
not mean the same thing as the same short form for another.  Thus, for the
General_Category property, "L" means "Letter", but for the Bidi_Class property,
"L" means "Left".  A complete list of properties and synonyms is in
L<perluniprops>.
(TBT)

=begin original

Upper/lower case differences in the property names and values are irrelevant,
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, in most cases, white space and even
hyphens can be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is employed is in the middle of numbers, and the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to the non-word characters) and
hyphens, and non-interior underscores.

=end original

Upper/lower case differences in the property names and values are irrelevant,
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators so C<\p{   Upper  }> and C<\p{ Upper_case : Y }> are
equivalent to these as well.  In fact, in most cases, white space and even
hyphens can be added or deleted anywhere.  So even C<\p{ Up-per case = Yes}> is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is employed is in the middle of numbers, and the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to the non-word characters) and
hyphens, and non-interior underscores.
(TBT)

=begin original

You can also use negation in both C<\p{}> and C<\P{}> by introducing a caret
(^) between the first brace and the property name: C<\p{^Tamil}> is
equal to C<\P{Tamil}>.

=end original

C<\p{}> と C<\P{}> の両方で、キャレット(^) を最初のブレースと
特性名の間に置くことによって意味を反転することができます:
C<\p{^Tamil}> は C<\P{Tamil}> と等価です。

=head3 B<General_Category>

=begin original

Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<http://www.unicode.org/reports/tr44>).

=end original

Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<http://www.unicode.org/reports/tr44>).
(TBT)

=begin original

The compound way of writing these is like C<\p{General_Category=Number}>
(short, C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.

=end original

The compound way of writing these is like C<\p{General_Category=Number}>
(short, C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.
(TBT)

=begin original

Here are the short and long forms of the General Category properties:

=end original

以下は、Unicode の一般カテゴリ特性(General Category properties) の
短形式と長形式です:

    Short       Long

    L           Letter
    LC, L&      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter

    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark

    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation

    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol

    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator

    C           Other
    Cc          Control	(also Cntrl)
    Cf          Format
    Cs          Surrogate   (not usable)
    Co          Private_Use
    Cn          Unassigned

=begin original

Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
C<LC> and C<L&> are special cases, which are aliases for the set of
C<Ll>, C<Lu>, and C<Lt>.

=end original

単一文字の特性は同じ文字で始まる二文字の任意のサブ特性に含まれる
すべての文字にマッチします。
C<LC> と C<L&> は特別なケースで、これは C<Ll>, C<Lu>, C<Lt> の別名です。

=begin original

Because Perl hides the need for the user to understand the internal
representation of Unicode characters, there is no need to implement
the somewhat messy concept of surrogates. C<Cs> is therefore not
supported.

=end original

Perl はユーザーが Unicode 文字の内部表現について理解する必要が
ないようにしているので、サロゲートの面倒なコンセプトについて
実装する必要はありません。
従って、C<Cs> はサポートされていません。

=head3 B<Bidirectional Character Types>

(B<双方向文字型>)

=begin original

Because scripts differ in their directionality--Hebrew is
written right to left, for example--Unicode supplies these properties in
the Bidi_Class class:

=end original

用字はその方向性で異なるので--たとえばヘブライ語は右から左に書きます --
Unicode は以下の特性を Bidi_Class クラスで提供しています:

    Property    Meaning

    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals

=begin original

This property is always written in the compound form.
For example, C<\p{Bidi_Class:R}> matches characters that are normally
written right to left.

=end original

この特性は常に複合形式で書かれます。
たとえば、C<\p{Bidi_Class:R}> は通常右から左に書く文字にマッチします。

=head3 B<Scripts>

(B<用字>)

=begin original

The world's languages are written in a number of scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrllic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

=end original

The world's languages are written in a number of scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrllic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.
(TBT)

=begin original

The Unicode Script property gives what script a given character is in,
and can be matched with the compound form like C<\p{Script=Hebrew}> (short:
C<\p{sc=hebr}>).  Perl furnishes shortcuts for all script names.  You can omit
everything up through the equals (or colon), and simply write C<\p{Latin}> or
C<\P{Cyrillic}>.

=end original

The Unicode Script property gives what script a given character is in,
and can be matched with the compound form like C<\p{Script=Hebrew}> (short:
C<\p{sc=hebr}>).  Perl furnishes shortcuts for all script names.  You can omit
everything up through the equals (or colon), and simply write C<\p{Latin}> or
C<\P{Cyrillic}>.
(TBT)

=begin original

A complete list of scripts and their shortcuts is in L<perluniprops>.

=end original

用字とその省略形の完全な一覧は L<perluniprops> にあります。

=head3 B<Use of "Is" Prefix>

(B<"Is" 接頭辞の使用>)

=begin original

For backward compatibility (with Perl 5.6), all properties mentioned
so far may have C<Is> or C<Is_> prepended to their name, so C<\P{Is_Lu}>, for
example, is equal to C<\P{Lu}>, and C<\p{IsScript:Arabic}> is equal to
C<\p{Arabic}>.

=end original

(Perl 5.6 との)後方互換性のため、すべての特性はその名前の前に C<Is>
または C<Is_> を置くことができます; したがって、C<\P{Is_Lu}> は C<\P{Lu}> と
等価で、C<\p{IsScript:Arabic}> は C<\p{Arabic}> と等価です。

=head3 B<Blocks>

(B<ブロック>)

=begin original

In addition to B<scripts>, Unicode also defines B<blocks> of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the "Basic Latin"
block is all characters whose ordinals are between 0 and 127, inclusive, in
other words, the ASCII characters.  The "Latin" script contains some letters
from this block as well as several more, like "Latin-1 Supplement",
"Latin Extended-A", I<etc.>, but it does not contain all the characters from
those blocks. It does not, for example, contain digits, because digits are
shared across many scripts. Digits and similar groups, like punctuation, are in
the script called C<Common>.  There is also a script called C<Inherited> for
characters that modify other characters, and inherit the script value of the
controlling character.

=end original

B<用字> に加え、Unicode では文字の B<ブロック> を定義しています。
用字とブロックの違いは、用字のコンセプトが自然言語に
密着したものであるのに対して、ブロックのコンセプトは連続した番号を持つ
Unicode 文字のグループに基づいたより人工的なグループ分けであることです。
たとえば、"Basic Latin" ブロックは番号 0 から 127 までの全ての文字、
言い換えると ASCII 文字です。
"Latin" 用字は、このブロックの文字と、"Latin-1 Supplement",
"Latin Extended-A" I<など> のいくつかのブロックの文字を含んでいますが、
それらのブロックのすべての文字を含んではいません。
例を挙げると、数字は多くの用字を越えて共有されているので、
(Latin 用字は)数字を含みません。
数字と、句読点のような同様のグループは C<Common> と呼ばれる用字にあります。
他の文字を修正して、制御文字の用字の値を継承する文字のための C<Inherited> と
呼ばれる用字もあります。

=begin original

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<http://www.unicode.org/reports/tr24>

=end original

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<http://www.unicode.org/reports/tr24>
(TBT)

=begin original

The Script property is likely to be the one you want to use when processing
natural language; the Block property may be useful in working with the nuts and
bolts of Unicode.

=end original

The Script property is likely to be the one you want to use when processing
natural language; the Block property may be useful in working with the nuts and
bolts of Unicode.
(TBT)

=begin original

Block names are matched in the compound form, like C<\p{Block: Arrows}> or
C<\p{Blk=Hebrew}>.  Unlike most other properties only a few block names have a
Unicode-defined short name.  But Perl does provide a (slight) shortcut:  You
can say, for example C<\p{In_Arrows}> or C<\p{In_Hebrew}>.  For backwards
compatibility, the C<In> prefix may be omitted if there is no naming conflict
with a script or any other property, and you can even use an C<Is> prefix
instead in those cases.  But it is not a good idea to do this, for a couple
reasons:

=end original

ブロック名は C<\p{Block: Arrows}> や C<\p{Blk=Hebrew}> のような
復号形式でマッチングします。
その他のほとんどの特性と違って、いくつかのブロック名だけが Unicode が
定義した短い名前を持ちます。
しかし Perl は(多少の)ショートカットを提供します: 例えば C<\p{In_Arrows}> や
C<\p{In_Hebrew}> のように書けます。  
後方互換性のために、C<In> 接頭辞は用字や他のプロパティと衝突しなければ
省略することも可能ですし、このような場合で C<Is> 接頭辞を使うこともできます。
しかしそうするのはいい考えではありません; いくつかの理由があります:

=over 4

=item 1

=begin original

It is confusing.  There are many naming conflicts, and you may forget some.
For example, C<\p{Hebrew}> means the I<script> Hebrew, and NOT the I<block>
Hebrew.  But would you remember that 6 months from now?

=end original

混乱します。
多くの名前の衝突があり、一部を忘れているかもしれません。
例えば、C<\p{Hebrew}> はヘブライ I<用字> を意味し、
ヘブライ I<ブロック> ではありません。
しかし 6 ヶ月後まで覚えていられますか?

=item 2

=begin original

It is unstable.  A new version of Unicode may pre-empt the current meaning by
creating a property with the same name.  There was a time in very early Unicode
releases when C<\p{Hebrew}> would have matched the I<block> Hebrew; now it
doesn't.

=end original

It is unstable.  A new version of Unicode may pre-empt the current meaning by
creating a property with the same name.  There was a time in very early Unicode
releases when C<\p{Hebrew}> would have matched the I<block> Hebrew; now it
doesn't.
(TBT)

=back

=begin original

Some people just prefer to always use C<\p{Block: foo}> and C<\p{Script: bar}>
instead of the shortcuts, for clarity, and because they can't remember the
difference between 'In' and 'Is' anyway (or aren't confident that those who
eventually will read their code will know).

=end original

Some people just prefer to always use C<\p{Block: foo}> and C<\p{Script: bar}>
instead of the shortcuts, for clarity, and because they can't remember the
difference between 'In' and 'Is' anyway (or aren't confident that those who
eventually will read their code will know).
(TBT)

=begin original

A complete list of blocks and their shortcuts is in L<perluniprops>.

=end original

ブロックとその省略形の完全な一覧は L<perluniprops> にあります。

=head3 B<Other Properties>

(B<その他の特性>)

=begin original

There are many more properties than the very basic ones described here.
A complete list is in L<perluniprops>.

=end original

ここで記述したとても基本的なものよりもとても多くの特性があります。
完全な一覧は L<perluniprops> です。

=begin original

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  A number of these are just synonyms for the
Unicode ones, but some are genunine extensions, including a couple that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<http://www.unicode.org/reports/tr18>).

=end original

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  A number of these are just synonyms for the
Unicode ones, but some are genunine extensions, including a couple that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<http://www.unicode.org/reports/tr18>).
(TBT)

=begin original

This section gives some details on all the extensions that aren't synonyms for
compound-form Unicode properties (for those, you'll have to refer to the
L<Unicode Standard|http://www.unicode.org/reports/tr44>.

=end original

This section gives some details on all the extensions that aren't synonyms for
compound-form Unicode properties (for those, you'll have to refer to the
L<Unicode Standard|http://www.unicode.org/reports/tr44>.
(TBT)

=over

=item B<C<\p{All}>>

=begin original

This matches any of the 1_114_112 Unicode code points.  It is a synonym for
C<\p{Any}>.

=end original

これは任意の 1_114_112 Unicode 符号位置にマッチングします。
これは C<\p{Any}> の同義語です。

=item B<C<\p{Alnum}>>

=begin original

This matches any C<\p{Alphabetic}> or C<\p{Decimal_Number}> character.

=end original

これは任意の C<\p{Alphabetic}> または C<\p{Decimal_Number}> 文字に
マッチングします。

=item B<C<\p{Any}>>

=begin original

This matches any of the 1_114_112 Unicode code points.  It is a synonym for
C<\p{All}>.

=end original

これは任意の 1_114_112 Unicode 符号位置にマッチングします。
これは C<\p{All}> の同義語です。

=item B<C<\p{Assigned}>>

=begin original

This matches any assigned code point; that is, any code point whose general
category is not Unassigned (or equivalently, not Cn).

=end original

これは任意の割り当てられた符号位置にマッチングします; つまり、一般カテゴリが
Unassigned ではない(または同等に Cn ではない) 符号位置です。

=item B<C<\p{Blank}>>

=begin original

This is the same as C<\h> and C<\p{HorizSpace}>:  A character that changes the
spacing horizontally.

=end original

これは C<\h> および C<\p{HorizSpace}> と同じです: スペースを垂直に変更する
文字です。

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (Short: C<\p{Dt=NonCanon}>)

=begin original

Matches a character that has a non-canonical decomposition.

=end original

非正準分解文字にマッチングします。

=begin original

To understand the use of this rarely used property=value combination, it is
necessary to know some basics about decomposition.
Consider a character, say H.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side and/or the other, I<etc.>  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base H, and a
character for each of the possible marks, and they can be combined variously
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
This is called an "extended grapheme cluster".  (Perl furnishes the C<\X>
construct to match such sequences.)

=end original

To understand the use of this rarely used property=value combination, it is
necessary to know some basics about decomposition.
Consider a character, say H.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side and/or the other, I<etc.>  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base H, and a
character for each of the possible marks, and they can be combined variously
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
This is called an "extended grapheme cluster".  (Perl furnishes the C<\X>
construct to match such sequences.)
(TBT)

=begin original

But Unicode's intent is to unify the existing character set standards and
practices, and a number of pre-existing standards have single characters that
mean the same thing as some of these combinations.  An example is ISO-8859-1,
which has quite a few of these in the Latin-1 range, an example being "LATIN
CAPITAL LETTER E WITH ACUTE".  Because this character was in this pre-existing
standard, Unicode added it to its repertoire.  But this character is considered
by Unicode to be equivalent to the sequence consisting of first the character
"LATIN CAPITAL LETTER E", then the character "COMBINING ACUTE ACCENT".

=end original

But Unicode's intent is to unify the existing character set standards and
practices, and a number of pre-existing standards have single characters that
mean the same thing as some of these combinations.  An example is ISO-8859-1,
which has quite a few of these in the Latin-1 range, an example being "LATIN
CAPITAL LETTER E WITH ACUTE".  Because this character was in this pre-existing
standard, Unicode added it to its repertoire.  But this character is considered
by Unicode to be equivalent to the sequence consisting of first the character
"LATIN CAPITAL LETTER E", then the character "COMBINING ACUTE ACCENT".
(TBT)

=begin original

"LATIN CAPITAL LETTER E WITH ACUTE" is called a "pre-composed" character, and
the equivalence with the sequence is called canonical equivalence.  All
pre-composed characters are said to have a decomposition (into the equivalent
sequence) and the decomposition type is also called canonical.

=end original

"LATIN CAPITAL LETTER E WITH ACUTE" is called a "pre-composed" character, and
the equivalence with the sequence is called canonical equivalence.  All
pre-composed characters are said to have a decomposition (into the equivalent
sequence) and the decomposition type is also called canonical.
(TBT)

=begin original

However, many more characters have a different type of decomposition, a
"compatible" or "non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the pre-composed
character.  An example, again in the Latin-1 range, is the "SUPERSCRIPT ONE".
It is kind of like a regular digit 1, but not exactly; its decomposition
into the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see L<http://www.unicode.org/reports/tr44>), including one
called "compat" which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen. 

=end original

However, many more characters have a different type of decomposition, a
"compatible" or "non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the pre-composed
character.  An example, again in the Latin-1 range, is the "SUPERSCRIPT ONE".
It is kind of like a regular digit 1, but not exactly; its decomposition
into the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see L<http://www.unicode.org/reports/tr44>), including one
called "compat" which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen. 
(TBT)

=begin original

Note that most Unicode characters don't have a decomposition, so their
decomposition type is "None".

=end original

Note that most Unicode characters don't have a decomposition, so their
decomposition type is "None".
(TBT)

=begin original

Perl has added the C<Non_Canonical> type, for your convenience, to mean any of
the compatibility decompositions.

=end original

Perl has added the C<Non_Canonical> type, for your convenience, to mean any of
the compatibility decompositions.
(TBT)

=item B<C<\p{Graph}>>

=begin original

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.

=end original

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.
(TBT)

=item B<C<\p{HorizSpace}>>

=begin original

This is the same as C<\h> and C<\p{Blank}>:  A character that changes the
spacing horizontally.

=end original

This is the same as C<\h> and C<\p{Blank}>:  A character that changes the
spacing horizontally.
(TBT)

=item B<C<\p{In=*}>> 

=begin original

This is a synonym for C<\p{Present_In=*}>

=end original

これは C<\p{Present_In=*}> の同義語です。

=item B<C<\p{PerlSpace}>>

=begin original

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>.

=end original

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>.
(TBT)

=begin original

Mnemonic: Perl's (original) space

=end original

記憶法: Perl の (元々の) スペース

=item B<C<\p{PerlWord}>>

=begin original

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>

=end original

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>
(TBT)

=begin original

Mnemonic: Perl's (original) word.

=end original

記憶法: Perl の (元々の) 単語。

=item B<C<\p{PosixAlnum}>>

=begin original

This matches any alphanumeric character in the ASCII range, namely
C<[A-Za-z0-9]>.

=end original

This matches any alphanumeric character in the ASCII range, namely
C<[A-Za-z0-9]>.
(TBT)

=item B<C<\p{PosixAlpha}>>

=begin original

This matches any alphabetic character in the ASCII range, namely C<[A-Za-z]>.

=end original

This matches any alphabetic character in the ASCII range, namely C<[A-Za-z]>.
(TBT)

=item B<C<\p{PosixBlank}>>

=begin original

This matches any blank character in the ASCII range, namely C<S<[ \t]>>.

=end original

This matches any blank character in the ASCII range, namely C<S<[ \t]>>.
(TBT)

=item B<C<\p{PosixCntrl}>>

=begin original

This matches any control character in the ASCII range, namely C<[\x00-\x1F\x7F]>

=end original

This matches any control character in the ASCII range, namely C<[\x00-\x1F\x7F]>
(TBT)

=item B<C<\p{PosixDigit}>>

=begin original

This matches any digit character in the ASCII range, namely C<[0-9]>.

=end original

This matches any digit character in the ASCII range, namely C<[0-9]>.
(TBT)

=item B<C<\p{PosixGraph}>>

=begin original

This matches any graphical character in the ASCII range, namely C<[\x21-\x7E]>.

=end original

This matches any graphical character in the ASCII range, namely C<[\x21-\x7E]>.
(TBT)

=item B<C<\p{PosixLower}>>

=begin original

This matches any lowercase character in the ASCII range, namely C<[a-z]>.

=end original

This matches any lowercase character in the ASCII range, namely C<[a-z]>.
(TBT)

=item B<C<\p{PosixPrint}>>

=begin original

This matches any printable character in the ASCII range, namely C<[\x20-\x7E]>.
These are the graphical characters plus SPACE.

=end original

This matches any printable character in the ASCII range, namely C<[\x20-\x7E]>.
These are the graphical characters plus SPACE.
(TBT)

=item B<C<\p{PosixPunct}>>

=begin original

This matches any punctuation character in the ASCII range, namely
C<[\x21-\x2F\x3A-\x40\x5B-\x60\x7B-\x7E]>.  These are the
graphical characters that aren't word characters.  Note that the Posix standard
includes in its definition of punctuation, those characters that Unicode calls
"symbols."

=end original

This matches any punctuation character in the ASCII range, namely
C<[\x21-\x2F\x3A-\x40\x5B-\x60\x7B-\x7E]>.  These are the
graphical characters that aren't word characters.  Note that the Posix standard
includes in its definition of punctuation, those characters that Unicode calls
"symbols."
(TBT)

=item B<C<\p{PosixSpace}>>

=begin original

This matches any space character in the ASCII range, namely
C<S<[ \f\n\r\t\x0B]>> (the last being a vertical tab).

=end original

This matches any space character in the ASCII range, namely
C<S<[ \f\n\r\t\x0B]>> (the last being a vertical tab).
(TBT)

=item B<C<\p{PosixUpper}>>

=begin original

This matches any uppercase character in the ASCII range, namely C<[A-Z]>.

=end original

This matches any uppercase character in the ASCII range, namely C<[A-Z]>.
(TBT)

=item B<C<\p{Present_In: *}>>    (Short: C<\p{In=*}>)

=begin original

This property is used when you need to know in what Unicode version(s) a
character is.

=end original

This property is used when you need to know in what Unicode version(s) a
character is.
(TBT)

=begin original

The "*" above stands for some two digit Unicode version number, such as
C<1.1> or C<4.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.

=end original

The "*" above stands for some two digit Unicode version number, such as
C<1.1> or C<4.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.
(TBT)

=begin original

For example, C<U+0041> "LATIN CAPITAL LETTER A" was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became "LATIN SMALL LETTER Y WITH LOOP", so the only "*" that
would match it are 5.1, 5.2, and later.

=end original

For example, C<U+0041> "LATIN CAPITAL LETTER A" was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became "LATIN SMALL LETTER Y WITH LOOP", so the only "*" that
would match it are 5.1, 5.2, and later.
(TBT)

=begin original

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.

=end original

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.
(TBT)

=begin original

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl Present_In property; just be aware of that.

=end original

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl Present_In property; just be aware of that.
(TBT)

=begin original

Another confusion with both these properties is that the definition is not
that the code point has been assigned, but that the meaning of the code point
has been determined.  This is because 66 code points will always be
unassigned, and, so the Age for them is the Unicode version the decision to
make them so was made in.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character and C<\p{Present_In: 3.1}> and up
matches as well.

=end original

Another confusion with both these properties is that the definition is not
that the code point has been assigned, but that the meaning of the code point
has been determined.  This is because 66 code points will always be
unassigned, and, so the Age for them is the Unicode version the decision to
make them so was made in.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character and C<\p{Present_In: 3.1}> and up
matches as well.
(TBT)

=item B<C<\p{Print}>>

=begin original

This matches any character that is graphical or blank, except controls.

=end original

This matches any character that is graphical or blank, except controls.
(TBT)

=item B<C<\p{SpacePerl}>>

=begin original

This is the same as C<\s>, including beyond ASCII.

=end original

This is the same as C<\s>, including beyond ASCII.
(TBT)

=begin original

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
which both the Posix standard and Unicode consider to be space.)

=end original

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
which both the Posix standard and Unicode consider to be space.)
(TBT)

=item B<C<\p{VertSpace}>>

=begin original

This is the same as C<\v>:  A character that changes the spacing vertically.

=end original

This is the same as C<\v>:  A character that changes the spacing vertically.
(TBT)

=item B<C<\p{Word}>>

=begin original

This is the same as C<\w>, including beyond ASCII.

=end original

This is the same as C<\w>, including beyond ASCII.
(TBT)

=back

=head2 User-Defined Character Properties

(ユーザ定義文字特性)

=begin original

You can define your own binary character properties by defining subroutines
whose names begin with "In" or "Is".  The subroutines can be defined in any
package.  The user-defined properties can be used in the regular expression
C<\p> and C<\P> constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its package in the
C<\p> or C<\P> construct.

=end original

あなた自身のバイナリ文字特性を、"In" または "Is" で始まる名前のサブルーチンを
定義することによって持つことができます。
そのサブルーチンは任意のパッケージで定義することができます。
ユーザー定義特性は正規表現の C<\p> 構造や C<\P> 構造で使うことができます;
もしユーザー定義特性をそれがあるパッケージ以外で使いたいのであれば、
パッケージ名を C<\p> (もしくは C<\P>)のために指定する必要があります。

    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }

=begin original

Note that the effect is compile-time and immutable once defined.

=end original

この効果はコンパイル時のもので、一度定義してしまったら
変更できないことに注意してください。

=begin original

The subroutines must return a specially-formatted string, with one
or more newline-separated lines.  Each line must be one of the following:

=end original

サブルーチンは、ひとつ以上の改行で区切られた特定の形式の文字列を
返さなければなりません。
各行は以下のいずれかの形式でなければなりません:

=over 4

=item *

=begin original

A single hexadecimal number denoting a Unicode code point to include.

=end original

含まれる Unicode 符号位置を示す 1 つの 16 進数。

=item *

=begin original

Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denoting a range of Unicode code points to include.

=end original

含まれる Unicode の符号位置の範囲を示す、
水平的空白(スペースもしくはタブ)によって区切られる 2 つの 16 進数。

=item *

=begin original

Something to include, prefixed by "+": a built-in character
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

("+" を前置して) その特性に含めるもの:
("utf8::" が前置された) 組み込みの文字特性もしくはユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to exclude, prefixed by "-": an existing character
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

("-" を前置して) その特性から除外するもの:
("utf8::" が前置された) 組み込みの文字特性もしくはユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to negate, prefixed "!": an existing character
property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

=end original

("!" を前置して)否定を取るもの:
("utf8::" が前置された) 組み込みの文字特性もしくはユーザー定義の文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=item *

=begin original

Something to intersect with, prefixed by "&": an existing character
property (prefixed by "utf8::") or a user-defined character property,
for all the characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal code point.

=end original

("&" を前置して)共通集合を取るもの:
特性にある文字以外の全ての文字のための
("utf8::" が前置された) 既に存在する文字特性またはユーザー定義文字特性;
範囲のための 2 つの 16 進符号位置; あるいは単一の 16 進符号位置。

=back

=begin original

For example, to define a property that covers both the Japanese
syllabaries (hiragana and katakana), you can define

=end original

例えば、両方の日本語の音節(ひらがなとカタカナ)を対象とする特性を
定義するには、以下のように定義します

    sub InKana {
	return <<END;
    3040\t309F
    30A0\t30FF
    END
    }

=begin original

Imagine that the here-doc end marker is at the beginning of the line.
Now you can use C<\p{InKana}> and C<\P{InKana}>.

=end original

ヒアドキュメントの終端マーカーは行の先頭に置かれることを思い出してください。
これで、C<\p{InKana}> や C<\P{InKana}> を使うことができます。

=begin original

You could also have used the existing block property names:

=end original

すでに存在しているブロック特性名を使うこともできます:

    sub InKana {
	return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }

=begin original

Suppose you wanted to match only the allocated characters,
not the raw block ranges: in other words, you want to remove
the non-characters:

=end original

生のブロック範囲ではなく、割り当てられた文字のみにマッチさせたいと
考えているとしましょう: 言い換えれば、文字以外のものを
取り除きたいということです:

    sub InKana {
	return <<'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }

=begin original

The negation is useful for defining (surprise!) negated classes.

=end original

否定は否定クラスを定義するのに便利です。

    sub InNotKana {
	return <<'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }

=begin original

Intersection is useful for getting the common characters matched by
two (or more) classes.

=end original

共通集合(intersection)は二つ以上のクラスにマッチする共通の文字を得るのに
便利です。

    sub InFooAndBar {
        return <<'END';
    +main::Foo
    &main::Bar
    END
    }

=begin original

It's important to remember not to use "&" for the first set; that
would be intersecting with nothing (resulting in an empty set).

=end original

最初の集合に "&" を使わないということを忘れないでください;
そうしてしまうと空との共通集合を取ってしまいます(結果は空集合です)。

=head2 User-Defined Case Mappings

(ユーザ定義の大文字・小文字の対応関係)

=begin original

You can also define your own mappings to be used in the lc(),
lcfirst(), uc(), and ucfirst() (or their string-inlined versions).
The principle is similar to that of user-defined character
properties: to define subroutines
with names like C<ToLower> (for lc() and lcfirst()), C<ToTitle> (for
the first character in ucfirst()), and C<ToUpper> (for uc(), and the
rest of the characters in ucfirst()).

=end original

同様に、lc()、lcfirst()、uc()、ucfirst() (あるいはその文字列組み込み版)で
あなた自身の対応関係を定義することもできます。
原則は
ユーザー定義文字特性の場合と似ています: C<ToLower> (lc() と lcfirst()用), 
C<ToTitle> (ucfirst() の最初の文字用), C<ToUpper> (uc() 用と ucfirst() の
残りの文字用) のような名前のサブルーチンを定義します。

=begin original

The string returned by the subroutines needs to be two hexadecimal numbers
separated by two tabulators: the two numbers being, respectively, the source
code point and the destination code point.  For example:

=end original

サブルーチンから返される文字列は二つのタブで区切られた二つの 16 進数を
必要とします: 二つの数値はそれぞれ、ソースの符号位置と
デスティネーションの符号位置です。
例を挙げましょう:

    sub ToUpper {
	return <<END;
    0061\t\t0041
    END
    }

=begin original

defines an uc() mapping that causes only the character "a"
to be mapped to "A"; all other characters will remain unchanged.

=end original

これは、"a" の文字のみを "A" にマッピングして
その他のすべての文字は変更しないという uc() のマッピングを定義しています。

=begin original

(For serious hackers only)  The above means you have to furnish a complete
mapping; you can't just override a couple of characters and leave the rest
unchanged.  You can find all the mappings in the directory
C<$Config{privlib}>/F<unicore/To/>.  The mapping data is returned as the
here-document, and the C<utf8::ToSpecFoo> are special exception mappings
derived from <$Config{privlib}>/F<unicore/SpecialCasing.txt>.  The "Digit" and
"Fold" mappings that one can see in the directory are not directly
user-accessible, one can use either the C<Unicode::UCD> module, or just match
case-insensitively (that's when the "Fold" mapping is used).

=end original

(真剣なハッカー専用)
上述したことは、完全なマッピングを提供する必要があるということです;
一部の文字を上書きして、残りを変更せずに残しておくことは出来ません。
C<$Config{privlib}>/F<unicore/To/> というディレクトリに全てのマッピングが
あります。
マッピングデータはヒアドキュメントとして返され、C<utf8::ToSpecFoo> は
C<$Config{privlib}>/F<unicore/SpecialCasing.txt> から派生した特殊な
例外マッピングです。
そのディレクトリで見つけることのできる "Digit" と "Fold" のマッピングは
ユーザーがダイレクトにアクセスできず、C<Unicode::UCD> モジュールを使うか
大小文字を無視してマッピングします("Fold" マッピングが使われているとき)。

=begin original

The mappings will only take effect on scalars that have been marked as having
Unicode characters, for example by using C<utf8::upgrade()>.
Old byte-style strings are not affected.

=end original

対応関係は、例えば C<utf8::upgrade()> を使って、スカラが Unicode 文字を
保持しているとしてマークされているときにのみ効果があります。
古いバイト形式の文字列には影響を及ぼしません。

=begin original

The mappings are in effect for the package they are defined in.

=end original

The mappings are in effect for the package they are defined in.
(TBT)

=head2 Character Encodings for Input and Output

(入出力のための文字エンコーディング)

=begin original

See L<Encode>.

=end original

L<Encode> を参照してください。

=head2 Unicode Regular Expression Support Level

(Unicode 正規表現対応レベル)

=begin original

The following list of Unicode support for regular expressions describes
all the features currently supported.  The references to "Level N"
and the section numbers refer to the Unicode Technical Standard #18,
"Unicode Regular Expressions", version 11, in May 2005.

=end original

以下に挙げるリストは、現在対応している全ての機能を記述する、
正規表現のための Unicode 対応のリストです。
"Level N" に対する参照とセクション番号は
Unicode Technical Standard #18,
"Unicode Regular Expressions", version 11, in May 2005
を参照しています。

=over 4

=item *

Level 1 - Basic Unicode Support

        RL1.1   Hex Notation                        - done          [1]
        RL1.2   Properties                          - done          [2][3]
        RL1.2a  Compatibility Properties            - done          [4]
        RL1.3   Subtraction and Intersection        - MISSING       [5]
        RL1.4   Simple Word Boundaries              - done          [6]
        RL1.5   Simple Loose Matches                - done          [7]
        RL1.6   Line Boundaries                     - MISSING       [8]
        RL1.7   Supplementary Code Points           - done          [9]

        [1]  \x{...}
        [2]  \p{...} \P{...}
	[3]  supports not only minimal list, but all Unicode character
	     properties (see L</Unicode Character Properties>)
        [4]  \d \D \s \S \w \W \X [:prop:] [:^prop:]
        [5]  can use regular expression look-ahead [a] or
             user-defined character properties [b] to emulate set operations
        [6]  \b \B
	[7]  note that Perl does Full case-folding in matching (but with bugs),
	     not Simple: for example U+1F88 is equivalent to U+1F00 U+03B9,
             not with 1F80.  This difference matters mainly for certain Greek
             capital letters with certain modifiers: the Full case-folding
             decomposes the letter, while the Simple case-folding would map
             it to a single character.
        [8]  should do ^ and $ also on U+000B (\v in C), FF (\f), CR (\r),
             CRLF (\r\n), NEL (U+0085), LS (U+2028), and PS (U+2029);
             should also affect <>, $., and script line numbers;
             should not split lines within CRLF [c] (i.e. there is no empty
             line between \r and \n)
        [9]  UTF-8/UTF-EBDDIC used in perl allows not only U+10000 to U+10FFFF
             but also beyond U+10FFFF [d]

=begin original

[a] You can mimic class subtraction using lookahead.
For example, what UTS#18 might write as

=end original

[a] class subtraction を先読みを使って模倣することができます。
たとえば、以下の UTR #18 は

    [{Greek}-[{UNASSIGNED}]]

=begin original

in Perl can be written as:

=end original

以下のように Perl で記述できます:

    (?!\p{Unassigned})\p{InGreekAndCoptic}
    (?=\p{Assigned})\p{InGreekAndCoptic}

=begin original

But in this particular example, you probably really want

=end original

しかし、この特定の例では、あなたが実際に望んでいたのは次のものでしょう

    \p{GreekAndCoptic}

=begin original

which will match assigned characters known to be part of the Greek script.

=end original

これは Greek 用字の一部として知られている assigned character にマッチします。

=begin original

Also see the Unicode::Regex::Set module, it does implement the full
UTS#18 grouping, intersection, union, and removal (subtraction) syntax.

=end original

同様に Unicode::Regex::Set モジュールを参照してください; これは
UTR #18 のグルーピング、intersection、union, removal(substraction)構文を
フルに実装しています。

=begin original

[b] '+' for union, '-' for removal (set-difference), '&' for intersection
(see L</"User-Defined Character Properties">)

=end original

[b] 結合のためには '+'、除去(差集合)のためには '-'、
共通集合のためには '&' です
(L</"User-Defined Character Properties"> を参照してください)

=begin original

[c] Try the C<:crlf> layer (see L<PerlIO>).

=end original

[c] C<:crlf> 層を試してください (L<PerlIO> を参照してください)。

=begin original

[d] U+FFFF will currently generate a warning message if 'utf8' warnings are
    enabled

=end original

[d] 'utf8' 警告が有効なら、現在のところ U+FFFF は警告を出力します

=item *

Level 2 - Extended Unicode Support

        RL2.1   Canonical Equivalents           - MISSING       [10][11]
        RL2.2   Default Grapheme Clusters       - MISSING       [12]
        RL2.3   Default Word Boundaries         - MISSING       [14]
        RL2.4   Default Loose Matches           - MISSING       [15]
        RL2.5   Name Properties                 - MISSING       [16]
        RL2.6   Wildcard Properties             - MISSING

        [10] see UAX#15 "Unicode Normalization Forms"
        [11] have Unicode::Normalize but not integrated to regexes
        [12] have \X but we don't have a "Grapheme Cluster Mode"
        [14] see UAX#29, Word Boundaries
        [15] see UAX#21 "Case Mappings"
        [16] have \N{...} but neither compute names of CJK Ideographs
             and Hangul Syllables nor use a loose match [e]

=begin original

[e] C<\N{...}> allows namespaces (see L<charnames>).

=end original

[e] C<\N{...}> は名前空間を許可します (L<charnames> を参照してください)。

=item *

Level 3 - Tailored Support

        RL3.1   Tailored Punctuation            - MISSING
        RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
        RL3.3   Tailored Word Boundaries        - MISSING
        RL3.4   Tailored Loose Matches          - MISSING
        RL3.5   Tailored Ranges                 - MISSING
        RL3.6   Context Matching                - MISSING       [19]
        RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
        RL3.9   Possible Match Sets             - MISSING
        RL3.10  Folded Matching                 - MISSING       [20]
        RL3.11  Submatchers                     - MISSING

        [17] see UAX#10 "Unicode Collation Algorithms"
        [18] have Unicode::Collate but not integrated to regexes
        [19] have (?<=x) and (?=x), but look-aheads or look-behinds should see
             outside of the target substring
        [20] need insensitive matching for linguistic features other than case;
             for example, hiragana to katakana, wide and narrow, simplified Han
             to traditional Han (see UTR#30 "Character Foldings")

=back

=head2 Unicode Encodings

(Unicode のエンコーディング)

=begin original

Unicode characters are assigned to I<code points>, which are abstract
numbers.  To use these numbers, various encodings are needed.

=end original

Unicode 文字は抽象的な数値である I<符号位置> にアサインされています。
これらの数値を使うために、さまざまなエンコーディングが必要となります。

=over 4

=item *

UTF-8

=begin original

UTF-8 is a variable-length (1 to 6 bytes, current character allocations
require 4 bytes), byte-order independent encoding. For ASCII (and we
really do mean 7-bit ASCII, not another 8-bit encoding), UTF-8 is
transparent.

=end original

UTF-8 は可変長(1 から 6 バイト; 現在の文字配置では 4 バイトを要求します)で、
バイトの並び順に依存しないエンコーディングです。
ASCII(ここでは 7-bit ASCII のことで、他の 8-bit エンコーディングのことでは
ありません)と UTF-8 は透過です。

=begin original

The following table is from Unicode 3.2.

=end original

以下のテーブルは Unicode 3.2 のものです。

 Code Points		1st Byte  2nd Byte  3rd Byte  4th Byte

   U+0000..U+007F	00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF	E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++++ utf16 surrogates, not legal utf8 +++++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF	F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF	F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF	F4        80..8F    80..BF    80..BF

=begin original

Note the gaps before several of the byte entries above marked by '*'.  These are
caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).

=end original

上記で '*' のマークが付いているいくつかのバイトエントリの前の
隙間に注意してください。
これらは、正当な UTF-8 が最短でないエンコードを避けるために
あります: 技術的には UTF-8 エンコードは一つの符号位置を複数の方法で
表すことができますが、これは明示的に禁止されていて、可能な限り最短の
エンコードが常に使われます(そしてそれが Perl のすることです)。

=begin original

Another way to look at it is via bits:

=end original

これを見るもう一つの方法はビット単位で見ることです:

 Code Points                    1st Byte   2nd Byte  3rd Byte  4th Byte

                    0aaaaaaa     0aaaaaaa
            00000bbbbbaaaaaa     110bbbbb  10aaaaaa
            ccccbbbbbbaaaaaa     1110cccc  10bbbbbb  10aaaaaa
  00000dddccccccbbbbbbaaaaaa     11110ddd  10cccccc  10bbbbbb  10aaaaaa

=begin original

As you can see, the continuation bytes all begin with "10", and the
leading bits of the start byte tell how many bytes there are in the
encoded character.

=end original

見ての通り、後続バイトはすべて "10" から始まっていて、開始バイトの
先行ビットはエンコードされた文字がどのくらいの長さであるかを示しています。

=item *

UTF-EBCDIC

=begin original

Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.

=end original

UTF-8 と似ていますが、UTF-8 が ASCII-safe であるように EBCDIC-safe です。

=item *

=begin original

UTF-16, UTF-16BE, UTF-16LE, Surrogates, and BOMs (Byte Order Marks)

=end original

UTF-16, UTF-16BE, UTF-16LE, サロゲート, BOM (Byte Order Marks)

=begin original

The followings items are mostly for reference and general Unicode
knowledge, Perl doesn't use these constructs internally.

=end original

以下の項目はほとんど参照および一般的な Unicode 知識のためのもので、
Perl はこれらの構造を内部で使っていません。

=begin original

UTF-16 is a 2 or 4 byte encoding.  The Unicode code points
C<U+0000..U+FFFF> are stored in a single 16-bit unit, and the code
points C<U+10000..U+10FFFF> in two 16-bit units.  The latter case is
using I<surrogates>, the first 16-bit unit being the I<high
surrogate>, and the second being the I<low surrogate>.

=end original

UTF-16 は 2 バイトもしくは 4 バイトのエンコーディングです。
C<U+0000..U+FFFF> の範囲の Unicode の符号位置はひとつの 16 ビット
ユニットに収められ、C<U+10000..U+10FFFF> の範囲の符号位置は 2 つの
16 ビットユニットに収められます。
後者をサロゲート(surrogates) と呼びます; 最初の 16 ビットユニットは
I<high surrogate> で、二番目は I<low surrogate> となります。

=begin original

Surrogates are code points set aside to encode the C<U+10000..U+10FFFF>
range of Unicode code points in pairs of 16-bit units.  The I<high
surrogates> are the range C<U+D800..U+DBFF> and the I<low surrogates>
are the range C<U+DC00..U+DFFF>.  The surrogate encoding is

=end original

サロゲートは Unicode の符号位置の C<U+10000..U+10FFFF> の範囲を
16 ビットユニットのペアで表現する集合です。
I<high surrogates> は C<U+D800..U+DBFF> の範囲で、I<low surrogates> は
C<U+DC00..U+DFFF> の範囲です。
サロゲートのエンコーディングは

	$hi = ($uni - 0x10000) / 0x400 + 0xD800;
	$lo = ($uni - 0x10000) % 0x400 + 0xDC00;

=begin original

and the decoding is

=end original

であり、デコードは以下のようなものです

	$uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);

=begin original

If you try to generate surrogates (for example by using chr()), you
will get a warning, if warnings are turned on, because those code
points are not valid for a Unicode character.

=end original

(たとえば chr() を使って)サロゲートを生成しようとしたならば、警告が
有効であれば警告が発生するでしょう; なぜなら、そういった符号位置は
Unicode 文字としては正しいものではないからです。

=begin original

Because of the 16-bitness, UTF-16 is byte-order dependent.  UTF-16
itself can be used for in-memory computations, but if storage or
transfer is required either UTF-16BE (big-endian) or UTF-16LE
(little-endian) encodings must be chosen.

=end original

16-bitness のため、UTF-16 はバイトの並び順に依存します。
UTF-16 それ自身はメモリ内の計算に使うことができますが、格納や転送の際には
UTF-16BE (ビッグエンディアン)か UTF-16LE (リトルエンディアン)の
いずれかのエンコーディングを選択しなければなりません。

=begin original

This introduces another problem: what if you just know that your data
is UTF-16, but you don't know which endianness?  Byte Order Marks, or
BOMs, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point C<U+FEFF> is the BOM.

=end original

このことは別の問題を引き起こします: あなたのデータが UTF-16 であることだけを
知っていて、そのバイト並び順を知らなかったとしたら?
バイト順マーク (Byte Order Marks)、略して BOM はこれを解決します。
バイト並びのマーカーとしての機能のために Unicode では特殊な文字が
予約されています: その文字は符号位置の C<U+FEFF> です。

=begin original

The trick is that if you read a BOM, you will know the byte order,
since if it was written on a big-endian platform, you will read the
bytes C<0xFE 0xFF>, but if it was written on a little-endian platform,
you will read the bytes C<0xFF 0xFE>.  (And if the originating platform
was writing in UTF-8, you will read the bytes C<0xEF 0xBB 0xBF>.)

=end original

このトリックは、BOM を読み込んだときにバイト順がわかるということです;
ビッグエンディアンのプラットフォームで書かれたものならなら
C<0xFE 0xFF> を読み出し、リトルエンディガンのプラットフォームで
書かれたものなら C<0xFF 0xFE> を読み出します。
(そしてもし元のプラットフォームで UTF-8 で書かれたものならば
C<0xEF 0xBB 0xBF> というバイト列を読むことになるでしょう。)

=begin original

The way this trick works is that the character with the code point
C<U+FFFE> is guaranteed not to be a valid Unicode character, so the
sequence of bytes C<0xFF 0xFE> is unambiguously "BOM, represented in
little-endian format" and cannot be C<U+FFFE>, represented in big-endian
format".  (Actually, C<U+FFFE> is legal for use by your program, even for
input/output, but better not use it if you need a BOM.  But it is "illegal for
interchange", so that an unsuspecting program won't get confused.)

=end original

このトリックがうまくいくのは符号位置 C<U+FFFE> の文字は正当な
Unicode 文字でないということによって、C<0xFF 0xFE> という並びは紛れなく
"リトルエンディアンフォーマットの BOM" であって
"ビッグエンディアンの C<U+FFFE>" とはならないのです。
(実際のところ、C<U+FFFE> は、あなたのプログラムで使う分には、たとえ
入出力のためでも、合法です; しかし、BOM が必要な場合には使わないでください。
しかしこれは "illegal for interchange" なので、疑うことを知らない
プログラムを混乱させてはいけません。)

=item *

UTF-32, UTF-32BE, UTF-32LE

=begin original

The UTF-32 family is pretty much like the UTF-16 family, expect that
the units are 32-bit, and therefore the surrogate scheme is not
needed.  The BOM signatures will be C<0x00 0x00 0xFE 0xFF> for BE and
C<0xFF 0xFE 0x00 0x00> for LE.

=end original

UTF-32 ファミリーは UTF-16 ファミリーと良く似ていますが、ユニットが
32 ビットで、そのためサロゲート方式の必要がないという点が異なります。
BOM シグネチャは BE では C<0x00 0x00 0xFE 0xFF> に、
LE では C<0xFF 0xFE 0x00 0x00> になります。

=item *

UCS-2, UCS-4

=begin original

Encodings defined by the ISO 10646 standard.  UCS-2 is a 16-bit
encoding.  Unlike UTF-16, UCS-2 is not extensible beyond C<U+FFFF>,
because it does not use surrogates.  UCS-4 is a 32-bit encoding,
functionally identical to UTF-32.

=end original

ISO 10646 標準で定義されているエンコーディングです。
UCS-2 は 16 ビットエンコーディングです。
UTF-16 とは異なり、UCS-2 は C<U+FFFF> を超えた範囲に拡張できません;
これはサロゲートを使わないためです。
UCS-4 は 32 ビットエンコーディングで、機能的には UTF-32 と同じです。

=item *

UTF-7

=begin original

A seven-bit safe (non-eight-bit) encoding, which is useful if the
transport or storage is not eight-bit safe.  Defined by RFC 2152.

=end original

7 ビットセーフ(非 8 ビット)エンコーディングで、8 ビットセーフでない
転送や格納に便利です。
RFC 2152 によって定義されています。

=back

=head2 Security Implications of Unicode

(Unicode のセキュリティへの影響)

=begin original

Read L<Unicode Security Considerations|http://www.unicode.org/reports/tr36>.
Also, note the following:

=end original

L<Unicode Security Considerations|http://www.unicode.org/reports/tr36> を
呼んでください。
また、以下のことに注意してください:

=over 4

=item *

=begin original

Malformed UTF-8

=end original

不正な UTF-8

=begin original

Unfortunately, the specification of UTF-8 leaves some room for
interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of UTF-8 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a UTF-8 connection.  Perl always generates the
shortest length UTF-8, and with warnings on, Perl will warn about
non-shortest length UTF-8 along with other malformations, such as the
surrogates, which are not real Unicode code points.

=end original

残念ながら、UTF-8 の仕様ではひとつの Unicode 文字の入力から
何バイトのエンコードされた出力として解釈するのかについていくらかの
余地があります。
厳密にいえば、可能な限り最も短い UTF-8 バイト列が生成されるべきです;
なぜなら、そうしないと UTF-8 コネクションの終わりにおいて、入力バッファが
オーバーフローする可能性があるからです。
Perl は常に最も短い長さの UTF-8 を生成し、本当の Unicode の符号位置でない
サロゲートのような不正な形式の最短でない UTF-8 に関して警告を発します。

=item *

=begin original

Regular expressions behave slightly differently between byte data and
character (Unicode) data.  For example, the "word character" character
class C<\w> will work differently depending on if data is eight-bit bytes
or Unicode.

=end original

正規表現はバイトデータと文字(Unicode)データとでまったく異なる
振る舞いをします。
たとえば、単語文字("word character")クラス C<\w> はそのデータが
8 ビットバイトか Unicode かに依存して異なる働きをします。

=begin original

In the first case, the set of C<\w> characters is either small--the
default set of alphabetic characters, digits, and the "_"--or, if you
are using a locale (see L<perllocale>), the C<\w> might contain a few
more letters according to your language and country.

=end original

第一の場合、C<\w> 文字の集合は相対的に小さいものです -- アルファベット、
数字、そして "_" のデフォルト集合 -- もしくはロケール(L<perllocale> を参照)を
使っているのであれば、C<\w> はあなたの使っている言語や国に応じていくつかの
文字が増えているかもしれません。

=begin original

In the second case, the C<\w> set of characters is much, much larger.
Most importantly, even in the set of the first 256 characters, it will
probably match different characters: unlike most locales, which are
specific to a language and country pair, Unicode classifies all the
characters that are letters I<somewhere> as C<\w>.  For example, your
locale might not think that LATIN SMALL LETTER ETH is a letter (unless
you happen to speak Icelandic), but Unicode does.

=end original

第二の場合、C<\w> の文字集合は相対的に大きなものになります。
最も重要なことは、最初の 256 文字の集合にあってさえ異なる文字と
マッチする可能性があるということです: 言語と国のペアで指定される
大部分のロケールと異なり、Unicode のクラス分けは I<どこかにある>
すべての文字を C<\w> に属するものとします。
たとえば、あなたの使っているロケールは LATIN SMALL LETTER ETH が
(アイスランド語を使っていない限り)属していないとみなしているでしょうが、
Unicode は属するものとしてみなすのです。

=begin original

As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to characters should happen.  Characters shouldn't get
downgraded to bytes, either.  It is possible to accidentally mix bytes
and characters, however (see L<perluniintro>), in which case C<\w> in
regular expressions might start behaving differently.  Review your
code.  Use warnings and the C<strict> pragma.

=end original

すでに述べている通り、Perl は二つの世界のそれぞれに片方の足
(二つのひづめ?) を突っ込んでいます: 古いバイトの世界と新しい文字の世界で、
必要に応じてバイトから文字に昇格します。
もしあなたの古いコードが明示的に Unicode を使っていないのなら、文字への
切り替えが自動的になされることはありません。
文字はバイトにダウングレードされるべきではありません。
偶発的にバイトと文字が混じる可能性がありますが(L<perluniintro> を参照)、
そのような場合正規表現中の C<\w> は異なるふるまいをするかもしれません。
あなたのコードをレビューしてください。
warnings と C<strict> プラグマを使ってください。

=back

=head2 Unicode in Perl on EBCDIC

(EBCDIC 上の Perl での Unicode)

=begin original

The way Unicode is handled on EBCDIC platforms is still
experimental.  On such platforms, references to UTF-8 encoding in this
document and elsewhere should be read as meaning the UTF-EBCDIC
specified in Unicode Technical Report 16, unless ASCII vs. EBCDIC issues
are specifically discussed. There is no C<utfebcdic> pragma or
":utfebcdic" layer; rather, "utf8" and ":utf8" are reused to mean
the platform's "natural" 8-bit encoding of Unicode. See L<perlebcdic>
for more discussion of the issues.

=end original

EBCDIC プラットフォームでの Unicode の扱い方は未だ実験的です。
このようなプラットフォームでは、この文書やその他での
UTF-8 エンコーディングへの言及は、特に ASCII 対 EBCDIC 問題について
議論されている場合でない限りは、Unicode Technical Report 16 で
定義されている UTF-EBCDIC を意味するものとして読むべきです。
C<utfebcdic> プラグマや ":utfebcdic" 層はありません;
代わりに、"utf8" と ":utf8" が、そのプラットフォームの「自然な」
Unicode の 8 ビットエンコーディングを意味するように再利用されています。
この問題に関する更なる議論については L<perlebcdic> を参照してください。

=head2 Locales

(ロケール)

=begin original

Usually locale settings and Unicode do not affect each other, but
there are a couple of exceptions:

=end original

通常ロケールの設定と Unicode は互いに影響を及ぼすことはありませんが、
いくつかの例外があります:

=over 4

=item *

=begin original

You can enable automatic UTF-8-ification of your standard file
handles, default C<open()> layer, and C<@ARGV> by using either
the C<-C> command line switch or the C<PERL_UNICODE> environment
variable, see L<perlrun> for the documentation of the C<-C> switch.

=end original

デフォルトの C<open()> 層や C<@ARGV> の標準ファイルハンドルの自動的な
UTF-8 化を、C<-C> コマンドラインスイッチか環境変数 C<PERL_UNICODE> によって
有効にできます; C<-C> スイッチについての説明は L<perlrun> を
参照してください。

=item *

=begin original

Perl tries really hard to work both with Unicode and the old
byte-oriented world. Most often this is nice, but sometimes Perl's
straddling of the proverbial fence causes problems.

=end original

Perl は Unicode と古いバイト指向の世界の両方で働くために苦労しています。
ほとんどの場合はうまくいきますが、ときには Perl が二股をかけていることが
問題を引き起こすこともあります。

=back

=head2 When Unicode Does Not Happen

(Unicode ではない場合)

=begin original

While Perl does have extensive ways to input and output in Unicode,
and few other 'entry points' like the @ARGV which can be interpreted
as Unicode (UTF-8), there still are many places where Unicode (in some
encoding or another) could be given as arguments or received as
results, or both, but it is not.

=end original

Perl には入出力を Unicode で行うための多数の方法があり、
@ARGV のように Unicode (UTF-8) として解釈できるようなその他の
「エントリポイント」はほとんどない一方、(何らかのエンコーディングで)
Unicode が引数として与えられたり結果として返されるべきにも関わらず、
そうなっていない場所も未だ多くあります。

=begin original

The following are such interfaces.  Also, see L</The "Unicode Bug">.
For all of these interfaces Perl
currently (as of 5.8.3) simply assumes byte strings both as arguments
and results, or UTF-8 strings if the C<encoding> pragma has been used.

=end original

以下に挙げるのはそのようなインターフェースです。
また、L</The "Unicode Bug"> を参照してください。
これらすべてが現在の Perl(5.8.3) では単純に引数と戻り値の両方が
バイト文字列か、C<encoding> プラグマが使われていれば UTF-8 文字列で
あると仮定しています。

=begin original

One reason why Perl does not attempt to resolve the role of Unicode in
these cases is that the answers are highly dependent on the operating
system and the file system(s).  For example, whether filenames can be
in Unicode, and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for the qx and system: how well will the
'command line interface' (and which of them?) handle Unicode?

=end original

このようなケースにおいて、Perl がなぜ Unicode による解決を
しないのかの理由の一つは、答えがオペレーティングシステムや
ファイルシステムに強く依存しているからです。
たとえば、ファイル名が Unicode で記述できてエンコーディングが
合っていたとしてもそれは移植性のあるコンセプトではないのです。
同様なことが qx や system にも言えます:
「コマンドラインインターフェース」は Unicode をどのように
扱うのでしょうか?

=over 4

=item *

chdir, chmod, chown, chroot, exec, link, lstat, mkdir,
rename, rmdir, stat, symlink, truncate, unlink, utime, -X

=item *

%ENV

=item *

=begin original

glob (aka the <*>)

=end original

glob (または <*>)

=item *

open, opendir, sysopen

=item *

=begin original

qx (aka the backtick operator), system

=end original

qx (または逆クォート演算子), system

=item *

readdir, readlink

=back

=head2 The "Unicode Bug"

(「Unicode バグ」)

=begin original

The term, the "Unicode bug" has been applied to an inconsistency with the
Unicode characters whose ordinals are in the Latin-1 Supplement block, that
is, between 128 and 255.  Without a locale specified, unlike all other
characters or code points, these characters have very different semantics in
byte semantics versus character semantics.

=end original

「Unicode バグ」("Unicode bug")という用語は、番号が
Latin-1 Supplement ブロック、つまり 128 から 255 にある Unicode 文字の
非一貫性に対して使われます。
ロケール指定がない場合、その他の文字や符号位置とは異なり、これらの文字は
バイトセマンティクスと文字セマンティクスでとても異なったセマンティクスです。

=begin original

In character semantics they are interpreted as Unicode code points, which means
they have the same semantics as Latin-1 (ISO-8859-1).

=end original

文字セマンティクスでは Unicode 符号位置として解釈され、Latin-1
(ISO-8859-1) と同じセマンティクスを持ちます。

=begin original

In byte semantics, they are considered to be unassigned characters, meaning
that the only semantics they have is their ordinal numbers, and that they are
not members of various character classes.  None are considered to match C<\w>
for example, but all match C<\W>.  (On EBCDIC platforms, the behavior may
be different from this, depending on the underlying C language library
functions.)

=end original

バイトセマンティクスでは、未定義文字として扱われ、保持している
セマンティクスはその番号だけで、様々な文字クラスのメンバにはならないことを
意味します。
例えばどれも C<\w> にはマッチングしませんが、全て C<\W> にマッチングします。
(EBCDIC プラットフォームでは、振る舞いはこれとは異なり、基礎となる
C 言語ライブラリ関数に依存します。)

=begin original

The behavior is known to have effects on these areas:

=end original

この振る舞いは以下のような領域で影響があることが分かっています:

=over 4

=item *

=begin original

Changing the case of a scalar, that is, using C<uc()>, C<ucfirst()>, C<lc()>,
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in regular expression
substitutions.

=end original

Changing the case of a scalar, that is, using C<uc()>, C<ucfirst()>, C<lc()>,
and C<lcfirst()>, or C<\L>, C<\U>, C<\u> and C<\l> in regular expression
substitutions.
(TBT)

=item *

=begin original

Using caseless (C</i>) regular expression matching

=end original

Using caseless (C</i>) regular expression matching
(TBT)

=item *

=begin original

Matching a number of properties in regular expressions, such as C<\w>

=end original

Matching a number of properties in regular expressions, such as C<\w>
(TBT)

=item *

=begin original

User-defined case change mappings.  You can create a C<ToUpper()> function, for
example, which overrides Perl's built-in case mappings.  The scalar must be
encoded in utf8 for your function to actually be invoked.

=end original

User-defined case change mappings.  You can create a C<ToUpper()> function, for
example, which overrides Perl's built-in case mappings.  The scalar must be
encoded in utf8 for your function to actually be invoked.
(TBT)

=back

=begin original

This behavior can lead to unexpected results in which a string's semantics
suddenly change if a code point above 255 is appended to or removed from it,
which changes the string's semantics from byte to character or vice versa.  As
an example, consider the following program and its output:

=end original

これの振る舞いにより、符号位置 255 を超える文字が追加されたり
削除されたりすると、文字列のセマンティックスがバイトから文字へ(または
その逆へ)突然変更されるという予想外の結果を引き起こすことがあります。
例えば、以下のようなプログラムとその出力を考えます:

 $ perl -le'
     $s1 = "\xC2";
     $s2 = "\x{2660}";
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1

=begin original

If there's no C<\w> in C<s1> or in C<s2>, why does their concatenation have one?

=end original

C<s1> や C<s2> に C<\w> がなければ、なぜこれらの結合は一つになるのでしょう?

=begin original

This anomaly stems from Perl's attempt to not disturb older programs that
didn't use Unicode, and hence had no semantics for characters outside of the
ASCII range (except in a locale), along with Perl's desire to add Unicode
support seamlessly.  The result wasn't seamless: these characters were
orphaned.

=end original

This anomaly stems from Perl's attempt to not disturb older programs that
didn't use Unicode, and hence had no semantics for characters outside of the
ASCII range (except in a locale), along with Perl's desire to add Unicode
support seamlessly.  The result wasn't seamless: these characters were
orphaned.
(TBT)

=begin original

Work is being done to correct this, but only some of it was complete in time
for the 5.12 release.  What has been finished is the important part of the case
changing component.  Due to concerns, and some evidence, that older code might
have come to rely on the existing behavior, the new behavior must be explicitly
enabled by the feature C<unicode_strings> in the L<feature> pragma, even though
no new syntax is involved.

=end original

Work is being done to correct this, but only some of it was complete in time
for the 5.12 release.  What has been finished is the important part of the case
changing component.  Due to concerns, and some evidence, that older code might
have come to rely on the existing behavior, the new behavior must be explicitly
enabled by the feature C<unicode_strings> in the L<feature> pragma, even though
no new syntax is involved.
(TBT)

=begin original

See L<perlfunc/lc> for details on how this pragma works in combination with
various others for casing.  Even though the pragma only affects casing
operations in the 5.12 release, it is planned to have it affect all the
problematic behaviors in later releases: you can't have one without them all.

=end original

See L<perlfunc/lc> for details on how this pragma works in combination with
various others for casing.  Even though the pragma only affects casing
operations in the 5.12 release, it is planned to have it affect all the
problematic behaviors in later releases: you can't have one without them all.
(TBT)

=begin original

In the meantime, a workaround is to always call utf8::upgrade($string), or to
use the standard module L<Encode>.   Also, a scalar that has any characters
whose ordinal is above 0x100, or which were specified using either of the
C<\N{...}> notations will automatically have character semantics.

=end original

今のところの回避方法は
常に utf8::upgrade($string) を呼び出すか標準モジュール L<Encode> を
使うことです。
Also, a scalar that has any characters
whose ordinal is above 0x100, or which were specified using either of the
C<\N{...}> notations will automatically have character semantics.
(TBT)

=head2 Forcing Unicode in Perl (Or Unforcing Unicode in Perl)

(Unicode を Perl に強制する (あるいは Unicode でないことを Perl に強制する))

=begin original

Sometimes (see L</"When Unicode Does Not Happen"> or L</The "Unicode Bug">)
there are situations where you simply need to force a byte
string into UTF-8, or vice versa.  The low-level calls
utf8::upgrade($bytestring) and utf8::downgrade($utf8string[, FAIL_OK]) are
the answers.

=end original

ときとして(L</When Unicode Does Not Happen> を参照)、バイト列を
UTF-8 であるように強制したりその逆を行う場合があるかもしれません。
低レベルの呼び出し utf8::upgrade($bytestring) と
utf8::downgrade($utf8string[, FAIL_OK]) がその回答です。

=begin original

Note that utf8::downgrade() can fail if the string contains characters
that don't fit into a byte.

=end original

utf8::downgrade() は、バイトに収まらない文字を含む文字列の場合は
失敗することがあることに注意してください。

=begin original

Calling either function on a string that already is in the desired state is a
no-op.

=end original

Calling either function on a string that already is in the desired state is a
no-op.
(TBT)

=head2 Using Unicode in XS

(XS で Unicode を使う)

=begin original

If you want to handle Perl Unicode in XS extensions, you may find the
following C APIs useful.  See also L<perlguts/"Unicode Support"> for an
explanation about Unicode at the XS level, and L<perlapi> for the API
details.

=end original

Perl の Unicode を XS 拡張で取り扱いたいと思うのなら、以下に挙げる
API 群が便利かも知れません。
XS レベルでの Unicode に関しての説明は L<perlguts/"Unicode Support"> を、
API の詳細については L<perlapi> を参照してください。

=over 4

=item *

=begin original

C<DO_UTF8(sv)> returns true if the C<UTF8> flag is on and the bytes
pragma is not in effect.  C<SvUTF8(sv)> returns true if the C<UTF8>
flag is on; the bytes pragma is ignored.  The C<UTF8> flag being on
does B<not> mean that there are any characters of code points greater
than 255 (or 127) in the scalar or that there are even any characters
in the scalar.  What the C<UTF8> flag means is that the sequence of
octets in the representation of the scalar is the sequence of UTF-8
encoded code points of the characters of a string.  The C<UTF8> flag
being off means that each octet in this representation encodes a
single character with code point 0..255 within the string.  Perl's
Unicode model is not to use UTF-8 until it is absolutely necessary.

=end original

C<DO_UTF8(sv)> は C<UTF8> フラグがオンでバイトプラグマが効果を
もっていないときに真を返します。
C<SvUTF8(sv)> は C<UTF8> がオンのとき、バイトプラグマの状態には
関係なく真を返します。
C<UTF8> フラグはスカラの中で 255(もしくは127)を超える符号位置の文字が
あるということを I<意味しません>。
C<UTF8> フラグの意味するところは、スカラ中のそのオクテットの並びが
文字列としてUTF-8でエンコードされた符号位置の並びだということです。
C<UTF8> フラグがオフであるということは文字列の中のエンコードされた
文字が 0..255 の範囲でエンコードされたオクテットであることを意味します。
Perl の Unicode モデルは本当に必要となるまで UTF-8 を使用しません。

=item *

=begin original

C<uvchr_to_utf8(buf, chr)> writes a Unicode character code point into
a buffer encoding the code point as UTF-8, and returns a pointer
pointing after the UTF-8 bytes.  It works appropriately on EBCDIC machines.

=end original

C<uvchr_to_utf8(buf, chr)> は Unicode の文字符号位置を UTF-8 で
エンコードされたの符号位置としてバッファに書き込みます;
そして、その UTF-8 バイトの後を指し示すポインタを返します。
これは EBCDIC のマシンでも適切に動作します。

=item *

=begin original

C<utf8_to_uvchr(buf, lenp)> reads UTF-8 encoded bytes from a buffer and
returns the Unicode character code point and, optionally, the length of
the UTF-8 byte sequence.  It works appropriately on EBCDIC machines.

=end original

C<utf8_to_uvchr(buf, lenp)> はバッファから UTF-8 エンコードされたバイトを
読み出し、Unicode の文字符号位置と、オプションでその
UTF-8 バイトシーケンスの長さを返します。
これは EBCDIC のマシンでも適切に動作します。

=item *

=begin original

C<utf8_length(start, end)> returns the length of the UTF-8 encoded buffer
in characters.  C<sv_len_utf8(sv)> returns the length of the UTF-8 encoded
scalar.

=end original

C<utf8_length(start, end)> は UTF-8 エンコードされたバッファの長さを
文字で返します。
C<sv_len_utf8(sv)> は UTF-8 エンコードされたスカラの長さを返します。

=item *

=begin original

C<sv_utf8_upgrade(sv)> converts the string of the scalar to its UTF-8
encoded form.  C<sv_utf8_downgrade(sv)> does the opposite, if
possible.  C<sv_utf8_encode(sv)> is like sv_utf8_upgrade except that
it does not set the C<UTF8> flag.  C<sv_utf8_decode()> does the
opposite of C<sv_utf8_encode()>.  Note that none of these are to be
used as general-purpose encoding or decoding interfaces: C<use Encode>
for that.  C<sv_utf8_upgrade()> is affected by the encoding pragma
but C<sv_utf8_downgrade()> is not (since the encoding pragma is
designed to be a one-way street).

=end original

C<sv_utf8_upgrade(sv)> はスカラの文字列をその UTF-8 エンコードされた
形式に変換します。
C<sv_utf8_downgrade(sv)> は(可能であれば)その反対の動作をします。
C<sv_utf8_encode(sv)> は C<sv_utf8_upgrade> に似ていますが、
C<UTF8> フラグをセットしない点が異なります。
C<sv_utf8_decode()> は C<sv_utf8_encode()> の逆を行います。
これらの欠如が一般的な目的のエンコーディングやデコーディングの
インターフェースとして使われていることに注意してください:
C<use Encode> がそのためにあります。
C<sv_utf8_upgrade()> はエンコーディングプラグマに影響を受けますが、
C<sv_utf8_downgrade()> はそうではありません(なぜならエンコーディング
プラグマは一方通行にデザインされているからです)。

=item *

=begin original

C<is_utf8_char(s)> returns true if the pointer points to a valid UTF-8
character.

=end original

C<is_utf8_char(s)> はポインタが正しい UTF-8 文字を指し示しているときに
真を返します。

=item *

=begin original

C<is_utf8_string(buf, len)> returns true if C<len> bytes of the buffer
are valid UTF-8.

=end original

C<is_utf8_string(buf, len)> はバッファの C<len> バイトが正しい
UTF-8 文字であるときに真を返します。

=item *

=begin original

C<UTF8SKIP(buf)> will return the number of bytes in the UTF-8 encoded
character in the buffer.  C<UNISKIP(chr)> will return the number of bytes
required to UTF-8-encode the Unicode character code point.  C<UTF8SKIP()>
is useful for example for iterating over the characters of a UTF-8
encoded buffer; C<UNISKIP()> is useful, for example, in computing
the size required for a UTF-8 encoded buffer.

=end original

C<UTF8SKIP(buf)> はバッファの中にある UTF-8 エンコードされた文字の
バイト数を返します。
C<UNISKIP(chr)> は UTF-8 エンコードする Unicode 文字の符号位置が要求する
バイト数を返します。
C<UTF8SKIP()> は UTF-8 エンコードされたバッファの文字に対して繰り返しを
行うような例に便利です; C<UNISKIP()> はたとえば、UTF-8 エンコードされた
バッファの要求する大きさを計算するのに便利です。

=item *

=begin original

C<utf8_distance(a, b)> will tell the distance in characters between the
two pointers pointing to the same UTF-8 encoded buffer.

=end original

C<utf8_distance(a, b)> は同じ UTF-8 エンコードされたバッファをさす
二つのポインタの間の文字単位の距離を返します。

=item *

=begin original

C<utf8_hop(s, off)> will return a pointer to a UTF-8 encoded buffer
that is C<off> (positive or negative) Unicode characters displaced
from the UTF-8 buffer C<s>.  Be careful not to overstep the buffer:
C<utf8_hop()> will merrily run off the end or the beginning of the
buffer if told to do so.

=end original

C<utf8_hop(s, off)> は、UTF-8 バッファ C<s> から Unicode で C<off> 文字分
(正数でも負数でも) 移動した UTF-8 エンコーディングバッファへの
ポインタを返します。
バッファを超えないように注意してください: C<utf8_hop()> は、そう
指示されれば何も気にせずにバッファの先頭や末尾を踏み越えます。

=item *

=begin original

C<pv_uni_display(dsv, spv, len, pvlim, flags)> and
C<sv_uni_display(dsv, ssv, pvlim, flags)> are useful for debugging the
output of Unicode strings and scalars.  By default they are useful
only for debugging--they display B<all> characters as hexadecimal code
points--but with the flags C<UNI_DISPLAY_ISPRINT>,
C<UNI_DISPLAY_BACKSLASH>, and C<UNI_DISPLAY_QQ> you can make the
output more readable.

=end original

C<pv_uni_display(dsv, spv, len, pvlim, flags)> と
C<sv_uni_display(dsv, ssv, pvlim, flags)> は Unicode の文字列やスカラの
出力をデバッグするのに便利です。
デフォルトではデバッグのみに便利です -- B<すべての> 文字を
16 進の符号位置として表示します -- しかし C<UNI_DISPLAY_ISPRINT>,
C<UNI_DISPLAY_BACKSLASH>, C<UNI_DISPLAY_QQ> というフラグを
与えることによって、出力を読みやすくできます。

=item *

=begin original

C<ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> can be used to
compare two strings case-insensitively in Unicode.  For case-sensitive
comparisons you can just use C<memEQ()> and C<memNE()> as usual.

=end original

C<ibcmp_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)> は Unicode に
おいて大小文字を無視した文字列比較に使うことができます。
大小文字を意識した比較には通常どおり C<memEQ()> や C<memNE()> を
使うことができます。

=back

=begin original

For more information, see L<perlapi>, and F<utf8.c> and F<utf8.h>
in the Perl source code distribution.

=end original

もっと詳しい情報は、L<perlapi> と、Perl のソースコード配布の
F<utf8.c> と F<utf8.h> を参照してください。

=head2 Hacking Perl to work on earlier Unicode versions (for very serious hackers only)

(以前の Unicode のバージョンで動作させるように Perl をハックする (とても真剣なハッカー専用))

=begin original

Perl by default comes with the latest supported Unicode version built in, but
you can change to use any earlier one.

=end original

Perl はデフォルトでは最新の Unicode バージョンが組み込まれていますが、
より古いものに変更することができます。

=begin original

Download the files in the version of Unicode that you want from the Unicode web
site L<http://www.unicode.org>).  These should replace the existing files in
C<\$Config{privlib}>/F<unicore>.  (C<\%Config> is available from the Config
module.)  Follow the instructions in F<README.perl> in that directory to change
some of their names, and then run F<make>.

=end original

Download the files in the version of Unicode that you want from the Unicode web
site L<http://www.unicode.org>).  These should replace the existing files in
C<\$Config{privlib}>/F<unicore>.  (C<\%Config> is available from the Config
module.)  Follow the instructions in F<README.perl> in that directory to change
some of their names, and then run F<make>.
(TBT)

=begin original

It is even possible to download them to a different directory, and then change
F<utf8_heavy.pl> in the directory C<\$Config{privlib}> to point to the new
directory, or maybe make a copy of that directory before making the change, and
using C<@INC> or the C<-I> run-time flag to switch between versions at will
(but because of caching, not in the middle of a process), but all this is
beyond the scope of these instructions.

=end original

It is even possible to download them to a different directory, and then change
F<utf8_heavy.pl> in the directory C<\$Config{privlib}> to point to the new
directory, or maybe make a copy of that directory before making the change, and
using C<@INC> or the C<-I> run-time flag to switch between versions at will
(but because of caching, not in the middle of a process), but all this is
beyond the scope of these instructions.
(TBT)

=head1 BUGS

=head2 Interaction with Locales

(ロケールとの相互作用)

=begin original

Use of locales with Unicode data may lead to odd results.  Currently,
Perl attempts to attach 8-bit locale info to characters in the range
0..255, but this technique is demonstrably incorrect for locales that
use characters above that range when mapped into Unicode.  Perl's
Unicode support will also tend to run slower.  Use of locales with
Unicode is discouraged.

=end original

Unicode データと共にロケールを使うことはおかしな結果を
もたらすことになりやすいです。
現在のところ、Perl は文字に 0..255 の範囲の 8 ビットロケールを
割り当てようとしていますが、このテクニックは Unicode に
マップしようとしたときに先の範囲の文字を使用するロケールに対して
明らかに正しくありません。
Perl の Unicode サポートはまた、遅くなりがちです。
Unicode といっしょにロケールを使うことはお勧めできません。

=head2 Problems with characters in the Latin-1 Supplement range

(Latin-1 Supplement の範囲の文字の問題)

=begin original

See L</The "Unicode Bug">

=end original

L</The "Unicode Bug"> を参照してください。

=head2 Problems with case-insensitive regular expression matching

(大文字小文字を無視した正規表現マッチングでの問題)

=begin original

There are problems with case-insensitive matches, including those involving
character classes (enclosed in [square brackets]), characters whose fold
is to multiple characters (such as the single character LATIN SMALL LIGATURE
FFL matches case-insensitively with the 3-character string C<ffl>), and
characters in the Latin-1 Supplement.

=end original

There are problems with case-insensitive matches, including those involving
character classes (enclosed in [square brackets]), characters whose fold
is to multiple characters (such as the single character LATIN SMALL LIGATURE
FFL matches case-insensitively with the 3-character string C<ffl>), and
characters in the Latin-1 Supplement.
(TBT)

=head2 Interaction with Extensions

(エクステンションとの相互作用)

=begin original

When Perl exchanges data with an extension, the extension should be
able to understand the UTF8 flag and act accordingly. If the
extension doesn't know about the flag, it's likely that the extension
will return incorrectly-flagged data.

=end original

Perl がエクステンションとデータをやり取りするとき、そのエクステンションは
UTF8 フラグを理解し、また、それに従った振る舞いをすべきです。
エクステンションがこのフラグについて何も知らなければ、そのエクステンションは
正しくないフラグがついたデータを返す可能性があります。

=begin original

So if you're working with Unicode data, consult the documentation of
every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.

=end original

そのため、もし Unicode データを扱おうというのであれば、 Unicode データの
交換に関して何らかの記述があるのなら使うモジュールすべてのドキュメントを
調べてください。
ドキュメントが Unicode に関して何の言及もしていないのなら、最悪のケースを
考慮し、そしてそのモジュールがどのように実装されているかを知るために
ソースを見ることになるかもしれません。
完全に Perl で書かれたモジュールは問題を引き起こしません。
他のプログラミング言語で書かれている直接または間接にアクセスするコードに
リスクがあるのです。

=begin original

For affected functions, the simple strategy to avoid data corruption is
to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.

=end original

影響を受けた関数のための、データの劣化(data corruption)を防ぐ単純な
戦略とは、交換するデータのエンコーディングを常に明確にするということです。
エクステンションが取り扱うことができると知っているエンコーディングを
選択してください。
エクステンションに渡す引数を選択したエンコーディングに変換し、
エクステンションから返ってきた結果をそのエンコーディングから
逆方向に変換します。
変換を行ってくれるラッパ関数を書いておいて、
エクステンションが追いついた時に関数を変更できるようにしておきます。

=begin original

To provide an example, let's say the popular Foo::Bar::escape_html
function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw UTF-8 and convert the result back to
Perl's internal representation like so:

=end original

例として、まだ Unicode データを取り扱うようにはできていない、
有名な Foo::Bar::escape_html について述べましょう。
ラッパ関数は引数を生の UTF-8 に変換し、結果を Perl の内部表現に
逆変換します:

    sub my_escape_html ($) {
      my($what) = shift;
      return unless defined $what;
      Encode::decode_utf8(Foo::Bar::escape_html(Encode::encode_utf8($what)));
    }

=begin original

Sometimes, when the extension does not convert data but just stores
and retrieves them, you will be in a position to use the otherwise
dangerous Encode::_utf8_on() function. Let's say the popular
C<Foo::Bar> extension, written in C, provides a C<param> method that
lets you store and retrieve data according to these prototypes:

=end original

エクステンションがデータを変換しないけれども格納したり取り出したりするときに、
ときとして危険な Encode::_utf8_on() 関数以外のものを
使うことがあるかもしれません。
C で書かれていて、データを以下のプロトタイプに従って格納したり
取り出したりする C<param> メソッドを持っている
有名な C<Foo::Bar> エクステンションについて述べてみましょう:

    $self->param($name, $value);            # set a scalar
    $value = $self->param($name);           # retrieve a scalar

=begin original

If it does not yet provide support for any encoding, one could write a
derived class with such a C<param> method:

=end original

どのエンコーディングもまだサポートしていないのなら、
以下のような C<param> メソッドを持った派生クラスを
記述することができるでしょう:

    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self->SUPER::param($name,$value);
      } else {
        my $ret = $self->SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }

=begin original

Some extensions provide filters on data entry/exit points, such as
DB_File::filter_store_key and family. Look out for such filters in
the documentation of your extensions, they can make the transition to
Unicode data much easier.

=end original

一部のエクステンションはデータのエントリ/脱出ポイントでフィルターを
提供しています; たとえば DB_File::filter_store_keyとその仲間です。
あなた使うエクステンションのドキュメントにあるそのようなフィルターに
注意してください; それらは Unicode データの変化をより容易にします。

=head2 Speed

(速度)

=begin original

Some functions are slower when working on UTF-8 encoded strings than
on byte encoded strings.  All functions that need to hop over
characters such as length(), substr() or index(), or matching regular
expressions can work B<much> faster when the underlying data are
byte-encoded.

=end original

一部の関数は UTF-8 でエンコードされた文字列に対して適用したときにバイト
エンコードされた文字列に対するときよりも遅くなります。
文字に対して働く必要のある length()、substr()、index()のような関数のすべてと
正規表現マッチングは、データが
バイトエンコードされているときには B<かなり> 早く動作できます。

=begin original

In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1
a caching scheme was introduced which will hopefully make the slowness
somewhat less spectacular, at least for some operations.  In general,
operations with UTF-8 encoded strings are still slower. As an example,
the Unicode properties (character classes) like C<\p{Nd}> are known to
be quite a bit slower (5-20 times) than their simpler counterparts
like C<\d> (then again, there 268 Unicode characters matching C<Nd>
compared with the 10 ASCII characters matching C<d>).

=end original

Perl 5.8.0 ではこの遅さはしばしば目立つものでした; Perl 5.8.1 では
少なくとも一部の操作については、遅さを改善することを期待する
キャッシングスキーム(caching scheme)が導入されました。
一般的には、UTF-8 エンコードされた文字列に対する操作はまだ遅いものです。
たとえば、C<\p{Nd}> のような Unicode の特性(文字クラス)は対応する
C<\d> のような単純なものよりも目立って遅い(5 倍から10 倍)ことが
知られています(繰り返しますが、C<d> は 10 の ASCII 文字に対して
マッチするのに対して C<Nd> は 268 の Unicode 文字にマッチします)。

=head2 Problems on EBCDIC platforms

(EBCDIC プラットフォームでの問題)

=begin original

There are a number of known problems with Perl on EBCDIC platforms.  If you
want to use Perl there, send email to perlbug@perl.org.

=end original

EBCDIC プラットフォームの Perl には多くの既知の問題があります。
そのような環境で Perl を使いたいなら、perlbug@perl.org にメールを
送ってください。

=begin original

In earlier versions, when byte and character data were concatenated,
the new string was sometimes created by
decoding the byte strings as I<ISO 8859-1 (Latin-1)>, even if the
old Unicode string used EBCDIC.

=end original

以前のバージョンでは、バイトデータと文字データを連結すると、
古い Unicode 文字列が EBCDIC を使っていたとしても、新しい文字列は
バイト文字列を I<ISO 8859-1 (Latin-1)> としてデコードして
作成されることがありました。

=begin original

If you find any of these, please report them as bugs.

=end original

これらのどれかを発見したら、どうかバグとして報告してください。

=head2 Porting code from perl-5.6.X

(perl 5.6.X からコードを移植する)

=begin original

Perl 5.8 has a different Unicode model from 5.6. In 5.6 the programmer
was required to use the C<utf8> pragma to declare that a given scope
expected to deal with Unicode data and had to make sure that only
Unicode data were reaching that scope. If you have code that is
working with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will continue
to work under 5.6, so you should be safe to try them out.

=end original

Perl 5.8 は 5.6 とは異なる Unicode モデルを持っています。
5.6 ではプログラマは、ある与えられたスコープが Unicode データを
取り扱うのと Unicode データだけがそのスコープにあることを宣言するのに
C<utf8> プラグマの使用を要求されていました。
5.6 で動いていたプログラムを持っているのなら、以下に挙げる微調整を施す
必要があるでしょう。
例は 5.6 でも動くように書かれているので、安心して試すことができます。

=over 4

=item *

=begin original

A filehandle that should read or write UTF-8

=end original

UTF-8 で読み書きすべきファイルハンドル

  if ($] > 5.007) {
    binmode $fh, ":encoding(utf8)";
  }

=item *

=begin original

A scalar that is going to be passed to some extension

=end original

何らかのエクステンションに渡そうとするスカラ

=begin original

Be it Compress::Zlib, Apache::Request or any extension that has no
mention of Unicode in the manpage, you need to make sure that the
UTF8 flag is stripped off. Note that at the time of this writing
(October 2002) the mentioned modules are not UTF-8-aware. Please
check the documentation to verify if this is still true.

=end original

Compress::Zlib、Apache::Request などの、マニュアルページに Unicode に
関する記載がない何らかのエクステンションで、確実に UTF8 フラグが
オフにする必要があります。
これを書いている時点(2002 年 10 月)では、上記のモジュールは
UTF-8 対応でないことに注意してください。
これがまだ真であるのなら、ドキュメントをチェックして確かめてください。

  if ($] > 5.007) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }

=item *

=begin original

A scalar we got back from an extension

=end original

エクステンションから返ってきたスカラ

=begin original

If you believe the scalar comes back as UTF-8, you will most likely
want the UTF8 flag restored:

=end original

そのスカラが UTF-8 として返ってきたものだと信じているのなら、
UTF-8 フラグをリストアしたいと考えるでしょう:

  if ($] > 5.007) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }

=item *

=begin original

Same thing, if you are really sure it is UTF-8

=end original

同様に、UTF-8 だと確信しているのなら

  if ($] > 5.007) {
    require Encode;
    Encode::_utf8_on($val);
  }

=item *

=begin original

A wrapper for fetchrow_array and fetchrow_hashref

=end original

fetchrow_array と fetchrow_hashref へのラッパ

=begin original

When the database contains only UTF-8, a wrapper function or method is
a convenient way to replace all your fetchrow_array and
fetchrow_hashref calls. A wrapper function will also make it easier to
adapt to future enhancements in your database driver. Note that at the
time of this writing (October 2002), the DBI has no standardized way
to deal with UTF-8 data. Please check the documentation to verify if
that is still true.

=end original

データベースが UTF-8 のみから構成されているとき、ラッパ関数や
ラッパメソッドはあなたの fetchrow_array や fetchrow_hashref の呼び出しを
置き換えるのに便利な方法でしょう。
ラッパ関数はまた、あなたの使っているデータベースドライバが
将来拡張されたときに適用しやすくするでしょう。
このドキュメントを書いている時点(2002 年 10 月)では、DBI は UTF-8 のデータを
扱う標準的な方法を持っていません。
これがまだ真ならドキュメントをチェックして確かめてください。

  sub fetchrow {
    my($self, $sth, $what) = @_; # $what is one of fetchrow_{array,hashref}
    if ($] < 5.007) {
      return $sth->$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth->$what;
        for (@arr) {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth->$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret->{$k};
          }
          return $ret;
        } else {
          defined && /[^\000-\177]/ && Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }

=item *

=begin original

A large scalar that you know can only contain ASCII

=end original

ASCII だけが含まれていると分かっている大きなスカラ

=begin original

Scalars that contain only ASCII and are marked as UTF-8 are sometimes
a drag to your program. If you recognize such a situation, just remove
the UTF8 flag:

=end original

ASCII だけから構成されているのに UTF8 として印付けされているスカラが
あなたのプログラムへ引きずりこまれることがあります。
そのような場合を認識したならば、単に UTF-8 フラグを取り除いてください:

  utf8::downgrade($val) if $] > 5.007;

=back

=head1 SEE ALSO

L<perlunitut>, L<perluniintro>, L<perluniprops>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlvar/"${^UNICODE}">
L<http://www.unicode.org/reports/tr44>).

=cut

=begin meta

Translate: KIMURA Koichi (-5.8.5)
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.10.0-)
Status: in progress

=end meta

