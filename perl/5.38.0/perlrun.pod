
=encoding utf8

=head1 NAME

=begin original

perlrun - how to execute the Perl interpreter

=end original

perlrun - Perl インタプリタの起動方法

=head1 SYNOPSIS

B<perl>	S<[ B<-gsTtuUWX> ]>
	S<[ B<-h?v> ] [ B<-V>[:I<configvar>] ]>
	S<[ B<-cw> ] [ B<-d>[B<t>][:I<debugger>] ] [ B<-D>[I<number/list>] ]>
	S<[ B<-pna> ] [ B<-F>I<pattern> ] [ B<-l>[I<octal>] ] [ B<-0>[I<octal/hexadecimal>] ]>
	S<[ B<-I>I<dir> ] [ B<-m>[B<->]I<module> ] [ B<-M>[B<->]I<'module...'> ] [ B<-f> ]>
	S<[ B<-C [I<number/list>] >]>
	S<[ B<-S> ]>
	S<[ B<-x>[I<dir>] ]>
	S<[ B<-i>[I<extension>] ]>
	S<[ [B<-e>|B<-E>] I<'command'> ] [ B<--> ] [ I<programfile> ] [ I<argument> ]...>

=head1 DESCRIPTION

=begin original

The normal way to run a Perl program is by making it directly
executable, or else by passing the name of the source file as an
argument on the command line.  (An interactive Perl environment
is also possible--see L<perldebug> for details on how to do that.)
Upon startup, Perl looks for your program in one of the following
places:

=end original

Perl プログラムを実行する普通の方法は、直接実行できる形にするか、
コマンドラインの引数としてソースファイルの名前を渡すことです。
(対話的な Perl 環境もあります -- どのようにするかの詳細については
L<perldebug> を参照してください。)
実行にあたって、Perl は指定されたプログラムを以下に示す場所で
探します:

=over 4

=item 1.

=begin original

Specified line by line via L<-e|/-e commandline> or L<-E|/-E commandline>
switches on the command line.

=end original

コマンドライン上で L<-e|/-e commandline> か
L<-E|/-E commandline> のスイッチで指定された行。

=item 2.

=begin original

Contained in the file specified by the first filename on the command line.
(Note that systems supporting the C<#!> notation invoke interpreters this
way. See L</Location of Perl>.)

=end original

コマンドライン上で最初のファイル名として示されたファイルの中。
(C<#!> 記法をサポートしているシステムでは、このようにして
インタプリタを呼び出します。
L</Location of Perl> を参照してください。)

=item 3.

=begin original

Passed in implicitly via standard input.  This works only if there are
no filename arguments--to pass arguments to a STDIN-read program you
must explicitly specify a "-" for the program name.

=end original

標準入力から暗黙に渡される。
ファイル名を示す引数が無い場合にのみうまくいきます--STDIN から読み込む
プログラムに引数を渡すには、プログラム名として明示的に "-" を
指定しなくてはなりません、

=back

=begin original

With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a L</-x> switch, in which case it
scans for the first line starting with C<#!> and containing the word
"perl", and starts there instead.  This is useful for running a program
embedded in a larger message.  (In this case you would indicate the end
of the program using the C<__END__> token.)

=end original

2 番目、3 番目の方法では、L</-x> スイッチを指定した場合を除いて、
Perl は入力ファイルを最初から解析し始めます; B<-x> スイッチを指定した
場合には、まず、最初に C<#!> と "perl" という文字列を含む行を探し、
そこから解析を始めます。
これは、大きなテキストにプログラムを埋め込んで、実行するようなときに便利です。
(この場合、プログラムの終わりは、トークン C<__END__> を使って
示すとよいでしょう。)

=begin original

The C<#!> line is always examined for switches as the line is being
parsed.  Thus, if you're on a machine that allows only one argument
with the C<#!> line, or worse, doesn't even recognize the C<#!> line, you
still can get consistent switch behaviour regardless of how Perl was
invoked, even if L</-x> was used to find the beginning of the program.

=end original

C<#!> を含む行のスイッチが必ず解析されるようになりました。
つまり、C<#!> の行で引数が一つしか許されない、あるいはもっと悪く、
C<#!> の行が認識されないといったシステムで運用している場合にも、
L</-x> でプログラムの開始位置を見つけた場合を含め、どのように Perl が
起動されたかによらず、一貫したスイッチの動作を期待できるようになっています。

=begin original

Because historically some operating systems silently chopped off
kernel interpretation of the C<#!> line after 32 characters, some
switches may be passed in on the command line, and some may not;
you could even get a "-" without its letter, if you're not careful.
You probably want to make sure that all your switches fall either
before or after that 32-character boundary.  Most switches don't
actually care if they're processed redundantly, but getting a "-"
instead of a complete switch could cause Perl to try to execute
standard input instead of your program.  And a partial L<-I|/-Idirectory>
switch could also cause odd results.

=end original

歴史的なオペレーティングシステムの中にはカーネルによる C<#!> 行の解釈が、
エラーなしに 32 文字で打ち切られてしまうものがありますので、あるスイッチは
コマンドラインに渡され、あるスイッチは渡されないといったことが起こります;
注意しないと、文字が続かない "-" だけが渡されるといったことも
起こり得ます。
すべてのスイッチが、確実に 32 文字境界の前か後ろかのどちらかに
なるようにしたいことでしょう。
多くのスイッチは、余分に処理されても問題ありませんが、完全なスイッチの
代わりに "-" が入っていた場合には、プログラムの代わりに、標準入力を Perl に
実行させることになってしまいます。
L<-I|/-Idirectory> スイッチが中途半端になった場合にも
おかしな結果となり得ます。

=begin original

Some switches do care if they are processed twice, for instance
combinations of L<-l|/-l[octnum]> and L<-0|/-0[octalE<sol>hexadecimal]>.
Either put all the switches after the 32-character boundary (if
applicable), or replace the use of B<-0>I<digits> by
C<BEGIN{ $/ = "\0digits"; }>.

=end original

2 回実行されることに注意する必要のあるスイッチもあります; 例えば
L<-l|/-l[octnum]> と L<-0|/-0[octalE<sol>hexadecimal]> の組み合わせです。
(可能なら) 両方のスイッチが 32 文字境界の後ろにいくようにするか、
B<-0>I<digits> を C<BEGIN{ $/ = "\0digits"; }> で置き換えてください。

=begin original

Parsing of the C<#!> switches starts wherever "perl" is mentioned in the line.
The sequences "-*" and "- " are specifically ignored so that you could,
if you were so inclined, say

=end original

C<#!> スイッチの解析は、行内で "perl" が示された位置から始まります。
とりわけ "-*" と "- " という文字の並びは無視されますので、以下のように
書くと:

    #!/bin/sh
    #! -*- perl -*- -p
    eval 'exec perl -x -wS $0 ${1+"$@"}'
        if 0;

=begin original

to let Perl see the L</-p> switch.

=end original

Perl に L</-p> スイッチを渡すことができます。

=begin original

A similar trick involves the I<env> program, if you have it.

=end original

似たようなトリックは(持っていれば) I<env> プログラムでも使えます。

    #!/usr/bin/env perl

=begin original

The examples above use a relative path to the perl interpreter,
getting whatever version is first in the user's path.  If you want
a specific version of Perl, say, perl5.14.1, you should place
that directly in the C<#!> line's path.

=end original

上の例は Perl インタプリタに相対パスを使って、
ユーザーの PATH で最初にあったバージョンを使います。
もし特定のバージョンの Perl、例えば perl5.14.1 が使いたいなら、
C<#!> 行のパスに直接書くべきです。

=begin original

If the C<#!> line does not contain the word "perl" nor the word "indir",
the program named after the C<#!> is executed instead of the Perl
interpreter.  This is slightly bizarre, but it helps people on machines
that don't do C<#!>, because they can tell a program that their SHELL is
F</usr/bin/perl>, and Perl will then dispatch the program to the correct
interpreter for them.

=end original

C<#!> 行に "perl" や "indir" という語が含まれていなければ、C<#!> の後に
指定されたプログラムが Perl インタプリタの代わりに実行されます。
これは少し変わっていますが、C<#!> が行なえないマシンを使っている方には
有効でしょう; プログラムに対して使っている SHELL が F</usr/bin/perl> だと
言っておけば、Perl が正しいインタプリタを起動してくれるからです。

=begin original

After locating your program, Perl compiles the entire program to an
internal form.  If there are any compilation errors, execution of the
program is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

=end original

プログラムの場所が特定できたなら、Perl はプログラム全体を内部形式に
コンパイルし始めます。
コンパイルエラーが見つかった時には、プログラムの実行は行なわれません。
(これは、構文エラーがある場合にも、途中まで実行される可能性のある、
典型的なシェルのスクリプトと異なる点です。)

=begin original

If the program is syntactically correct, it is executed.  If the program
runs off the end without hitting an exit() or die() operator, an implicit
C<exit(0)> is provided to indicate successful completion.

=end original

プログラムが構文的に正しければ、実行されることになります。
プログラムが、exit() 演算子にも die() 演算子にも当たらないで最後まで
到達すると、正常に完了したことを示すために、暗黙の C<exit(0)> が
行なわれます。

=head2 #! and quoting on non-Unix systems
X<hashbang> X<#!>

(非 Unix システムでの #! とクォート)

=begin original

Unix's C<#!> technique can be simulated on other systems:

=end original

Unix の C<#!> のテクニックは他のシステムでもシミュレートされています。

=over 4

=item OS/2

=begin original

Put

=end original

以下のように

    extproc perl -S -your_switches

=begin original

as the first line in C<*.cmd> file (L</-S> due to a bug in cmd.exe's
`extproc' handling).

=end original

C<*.cmd> ファイルの最初の行に書いてください (L</-S> は cmd.exe の
`extproc' の扱いのバグを引き起こします)。

=item MS-DOS

=begin original

Create a batch file to run your program, and codify it in
C<ALTERNATE_SHEBANG> (see the F<dosish.h> file in the source
distribution for more information).

=end original

プログラムを実行するバッチファイルを作って、C<ALTERNATE_SHEBANG> で
コード化してください (さらなる情報についてはソース配布パッケージの
F<dosish.h> ファイルを参照してください)。

=item Win95/NT

=begin original

The Win95/NT installation, when using the ActiveState installer for Perl,
will modify the Registry to associate the F<.pl> extension with the perl
interpreter.  If you install Perl by other means (including building from
the sources), you may have to modify the Registry yourself.  Note that
this means you can no longer tell the difference between an executable
Perl program and a Perl library file.

=end original

Win95/NT でのインストールにおいて、ActiveState の Perl 用インストーラを
使った場合は、拡張子 F<.pl> を Perl インタプリタに関連付けるよう
レジストリを変更します。
他の方法で Perl をインストールした場合(ソースから構築した場合を含みます)、
レジストリを自分で変更する必要があります。
これは実行可能な Perl プログラムと Perl ライブラリファイルとの
違いがなくなってしまうことに注意してください。

=item VMS

=begin original

Put

=end original

以下のように

 $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
 $ exit++ + ++$status != 0 and $exit = $status = undef;

=begin original

at the top of your program, where B<-mysw> are any command line switches you
want to pass to Perl.  You can now invoke the program directly, by saying
C<perl program>, or as a DCL procedure, by saying C<@program> (or implicitly
via F<DCL$PATH> by just using the name of the program).

=end original

プログラムの先頭に書いてください; ここで B<-mysw> は Perl に渡したい
コマンドラインスイッチです。
これで C<perl program> として直接プログラムを起動できますし、
C<@program> として(あるいは F<DCL$PATH> 経由でプログラム名を使って)
DSL 手続きとして起動できます。

=begin original

This incantation is a bit much to remember, but Perl will display it for
you if you say C<perl "-V:startperl">.

=end original

この決まり文句は覚えるには少々長すぎますが、C<perl "-V:startperl"> とすれば
Perl がこれを表示してくれます。

=back

=begin original

Command-interpreters on non-Unix systems have rather different ideas
on quoting than Unix shells.  You'll need to learn the special
characters in your command-interpreter (C<*>, C<\> and C<"> are
common) and how to protect whitespace and these characters to run
one-liners (see L<-e|/-e commandline> below).

=end original

非 Unix システムのコマンドインタプリタはクォートに関して Unix シェルと
異なった考え方をしています。
お使いのコマンドインタプリタの特殊文字について (C<*>, C<\>, C<"> は
一般的です)、そして一行で起動するために(後述する L<-e|/-e commandline> を
参照してください)空白や特殊文字を保護する方法について学ぶ必要があるでしょう。

=begin original

On some systems, you may have to change single-quotes to double ones,
which you must I<not> do on Unix or Plan 9 systems.  You might also
have to change a single % to a %%.

=end original

システムによってはシングルクォートをダブルクォートに変更する必要が
あるかもしれません; しかし Unix や Plan9 のシステムでは
I<してはいけません>。
また、単体の % を %% に変更する必要があるかもしれません。

=begin original

For example:

=end original

例えば:

    # Unix
    perl -e 'print "Hello world\n"'

    # MS-DOS, etc.
    perl -e "print \"Hello world\n\""

    # VMS
    perl -e "print ""Hello world\n"""

=begin original

The problem is that none of this is reliable: it depends on the
command and it is entirely possible neither works.  If I<4DOS> were
the command shell, this would probably work better:

=end original

問題は、これらはどれも信頼性がないことです: これはコマンドに依存し、どれも
動かないかもしれません。
I<4DOS> がコマンドシェルなら、おそらくよりよく動きます:

    perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

=begin original

B<CMD.EXE> in Windows NT slipped a lot of standard Unix functionality in
when nobody was looking, but just try to find documentation for its
quoting rules.

=end original

Windows NT の B<CMD.EXE> は誰も見ていない間に多くの標準 Unix 機能が
入り込んでいますが、クォートのルールに関しては
ドキュメントを探してみてください。

=begin original

There is no general solution to all of this.  It's just a mess.

=end original

この辺りのことに関する一般的な解決方法はありません。
まったくぐちゃぐちゃです。

=head2 Location of Perl
X<perl, location of interpreter>

(Perl の位置)

=begin original

It may seem obvious to say, but Perl is useful only when users can
easily find it.  When possible, it's good for both F</usr/bin/perl>
and F</usr/local/bin/perl> to be symlinks to the actual binary.  If
that can't be done, system administrators are strongly encouraged
to put (symlinks to) perl and its accompanying utilities into a
directory typically found along a user's PATH, or in some other
obvious and convenient place.

=end original

当たり前のように聞こえるかもしれませんが、
Perl はユーザーが簡単に発見できる場合にのみ有用です。
可能なら、F</usr/bin/perl> と F</usr/local/bin/perl> の両方に
実際のバイナリへのシンボリックリンクを置くというのはよい考えです。
もしこれが無理なら、システム管理者は Perl と付随するユーティリティ (への
シンボリックリンク) を、典型的にユーザーの PATH で見付かるディレクトリか、
その他の明らかで便利な場所に置くべきです。

=begin original

In this documentation, C<#!/usr/bin/perl> on the first line of the program
will stand in for whatever method works on your system.  You are
advised to use a specific path if you care about a specific version.

=end original

このドキュメントでは、C<#!/usr/bin/perl> とプログラムの先頭に書けば
システムの全てのメソッドが実行できるものとしています。
特定のバージョンを使いたい場合は、特定のパスを使うか:

    #!/usr/local/bin/perl5.14

=begin original

or if you just want to be running at least version, place a statement
like this at the top of your program:

=end original

あるいは単に最低限のバージョンを指定した場合は、
以下のような行をプログラムの先頭に置いてください:

    use v5.14;

=head2 Command Switches
X<perl, command switches> X<command switches>

(コマンドスイッチ)

=begin original

As with all standard commands, a single-character switch may be
clustered with the following switch, if any.

=end original

全ての標準コマンドと同様に、1 文字のスイッチは、次に続くスイッチが
あれば、それとつなげることができます。

    #!/usr/bin/perl -spi.orig	# same as -s -p -i.orig

=begin original

A C<--> signals the end of options and disables further option processing. Any
arguments after the C<--> are treated as filenames and arguments.

=end original

C<--> はオプションの末尾を示してさらなるオプション処理を無効にします。
C<--> の後ろの引数は全てファイル名と引数として扱われます。

=begin original

Switches include:

=end original

スイッチ一覧:

=over 5

=item B<-0>[I<octal/hexadecimal>]
X<-0> X<$/>

=begin original

specifies the input record separator (C<$/>) as an octal or
hexadecimal number.  If there are no digits, the null character is the
separator.  Other switches may precede or follow the digits.  For
example, if you have a version of I<find> which can print filenames
terminated by the null character, you can say this:

=end original

入力レコードセパレータ (C<$/>) を 8 進数または 16 進数で示します。
digits を指定しないと、ヌル文字がセパレータになります。
他のスイッチを前に置いてもかまいませんし、digits のあとに
つなげてもかまいません。
たとえば、ファイル名をヌル文字で区切って表示できる I<find> があれば:

    find . -name '*.orig' -print0 | perl -n0e unlink

=begin original

The special value 00 will cause Perl to slurp files in paragraph mode.

=end original

00 という特別な値は、Perl にパラグラフモードで、ファイルを読ませます。

=begin original

Any value 0400 or above will cause Perl to slurp files whole, but by convention
the value 0777 is the one normally used for this purpose. The L</-g> flag
is a simpler alias for it.

=end original

0400 以上の任意の値は、Perl にファイル全体を読ませることになりますが、
規約により、普通はこの目的のために値 0777 を使います。
L</-g> フラグはこれのより簡単な別名です。

=begin original

You can also specify the separator character using hexadecimal notation:
B<-0xI<HHH...>>, where the C<I<H>> are valid hexadecimal digits.  Unlike
the octal form, this one may be used to specify any Unicode character, even
those beyond 0xFF.  So if you I<really> want a record separator of 0777,
specify it as B<-0x1FF>.  (This means that you cannot use the L</-x> option
with a directory name that consists of hexadecimal digits, or else Perl
will think you have specified a hex number to B<-0>.)

=end original

16 進数の記法 B<-0xI<HHH...>> を使ってセパレータ文字を指定することもできます;
ここで C<I<H>> は 16 進数として有効な文字です。
8 進数形式と違って、これは 0xFF を超えたものを含む任意の Unicode 文字を
指定するために使われるかもしれません。
それで、I<本当に> 0777 のレコード区切りを使いたいなら、B<-0x1FF> として
指定してください。
(これは L</-x> オプションで 16 進数の数値からなるディレクトリ名を指定できない
ことを意味します; さもなければ Perl は指定された 16 進数を B<-0> と
扱います。)

=item B<-a>
X<-a> X<autosplit>

=begin original

turns on autosplit mode when used with a L</-n> or L</-p>.  An implicit
split command to the @F array is done as the first thing inside the
implicit while loop produced by the L</-n> or L</-p>.

=end original

L</-n> や L</-p> といっしょに用いると、自動 split モードになります。
L</-n> や L</-p> で作られる暗黙のループ内の最初の文として、
配列 @F への暗黙の split コマンドが実行されます。

    perl -ane 'print pop(@F), "\n";'

=begin original

is equivalent to

=end original

は以下のものと等価です。

    while (<>) {
	@F = split(' ');
	print pop(@F), "\n";
    }

=begin original

An alternate delimiter may be specified using L<-F|/-Fpattern>.

=end original

L<-F|/-Fpattern> を使って区切文字を変更することができます。

=begin original

B<-a> implicitly sets L</-n>.

=end original

B<-a> は暗黙に L</-n> を設定します。

=item B<-C [I<number/list>]>
X<-C>

=begin original

The B<-C> flag controls some of the Perl Unicode features.

=end original

B<-C>フラグは Perl Unicode 機能のいくつかを制御します。

=begin original

As of 5.8.1, the B<-C> can be followed either by a number or a list
of option letters.  The letters, their numeric values, and effects
are as follows; listing the letters is equal to summing the numbers.

=end original

5.8.1 から、B<-C> フラグは数値またはオプション文字のリストを
つけることが出来ます。
指定可能な文字と数値およびその効果は以下の通りです;
文字のリストは数値の合計と同じです。

=begin original

    I     1   STDIN is assumed to be in UTF-8
    O     2   STDOUT will be in UTF-8
    E     4   STDERR will be in UTF-8
    S     7   I + O + E
    i     8   UTF-8 is the default PerlIO layer for input streams
    o    16   UTF-8 is the default PerlIO layer for output streams
    D    24   i + o
    A    32   the @ARGV elements are expected to be strings encoded
              in UTF-8
    L    64   normally the "IOEioA" are unconditional, the L makes
              them conditional on the locale environment variables
              (the LC_ALL, LC_CTYPE, and LANG, in the order of
              decreasing precedence) -- if the variables indicate
              UTF-8, then the selected "IOEioA" are in effect
    a   256   Set ${^UTF8CACHE} to -1, to run the UTF-8 caching
              code in debugging mode.

=end original

    I     1   STDIN は UTF-8 と仮定する
    O     2   STDOUT は UTF-8 と仮定する
    E     4   STDERR は UTF-8 と仮定する
    S     7   I + O + E
    i     8   UTF-8 は入力ストリームのデフォルト PerlIO 層
    o    16   UTF-8 は出力ストリームのデフォルト PerlIO 層
    D    24   i + o
    A    32   @ARGV の要素は UTF-8 でエンコードされた文字列と推測する
    L    64   通常は "IOEioA" は無条件ですが、
              L はロケール環境変数(LC_ALL, LC_CTYPE, LANG, 優先度順)によって
              条件付きとなります  -- もし変数が UTF-8 を示していれば、
              選択された "IOEioA" が有効になります
    a   256   デバッグモードで UTF-8 キャッシュコードを実行するために、
              ${^UTF8CACHE} を -1 にセットする。

=for documenting_the_underdocumented
perl.h gives W/128 as PERL_UNICODE_WIDESYSCALLS "/* for Sarathy */"

=for todo
perltodo mentions Unicode in %ENV and filenames. I guess that these will be
options e and f (or F).

=begin original

For example, B<-COE> and B<-C6> will both turn on UTF-8-ness on both
STDOUT and STDERR.  Repeating letters is just redundant, not cumulative
nor toggling.

=end original

例えば、B<-COE> と B<-C6> はどちらも STDOUT と STDERR を UTF-8 化します。
同じ文字を繰り返しても冗長なだけで、加算されたりトグルになったりはしません。

=begin original

The C<io> options mean that any subsequent open() (or similar I/O
operations) in main program scope will have the C<:utf8> PerlIO layer
implicitly applied to them, in other words, UTF-8 is expected from any
input stream, and UTF-8 is produced to any output stream.  This is just
the default set via L<C<${^OPEN}>|perlvar/${^OPEN}>,
with explicit layers in open() and with binmode() one can
manipulate streams as usual.  This has no effect on code run in modules.

=end original

C<io> オプションは main プログラムスコープで引き続く open() (あるいは同様の
I/O 操作) において暗黙的に C<:utf8> PerlIO 層が適用されます; 言い換えると、
入力ストリームでは UTF-8 が想定され、出力ストリームはUTF-8 で出力されます。
これは単に L<C<${^OPEN}>|perlvar/${^OPEN}> で設定されたデフォルトであり、
通常どおり open() と binmode() で明示的に変更できます。
これはモジュールの中で実行されるコードには無効です。

=begin original

B<-C> on its own (not followed by any number or option list), or the
empty string C<""> for the L</PERL_UNICODE> environment variable, has the
same effect as B<-CSDL>.  In other words, the standard I/O handles and
the default C<open()> layer are UTF-8-fied I<but> only if the locale
environment variables indicate a UTF-8 locale.  This behaviour follows
the I<implicit> (and problematic) UTF-8 behaviour of Perl 5.8.0.
(See L<perl581delta/UTF-8 no longer default under UTF-8 locales>.)

=end original

B<-C> が単体で(数値やオプションリストなし)起動されるか、
L</PERL_UNICODE> 環境変数が空文字列 C<""> の場合、B<-CSDL> と
同じ効果となります。
言い換えると、標準 I/O 操作とデフォルトの C<open()> 層はロケール環境変数が
UTF-8 ロケールを示している場合 I<のみ> UTF-8 化されます。
この振る舞いは Perl 5.8.0 での I<暗黙の> (そして問題のある) UTF-8 に
関する振る舞いと同じです。
(L<perl581delta/UTF-8 no longer default under UTF-8 locales> を
参照してください。)

=begin original

You can use B<-C0> (or C<"0"> for C<PERL_UNICODE>) to explicitly
disable all the above Unicode features.

=end original

B<-C0> (あるいは C<PERL_UNICODE> に C<"0">) を指定すると
明示的に上記の全ての Unicode 機能を無効にします。

=begin original

The read-only magic variable C<${^UNICODE}> reflects the numeric value
of this setting.  This variable is set during Perl startup and is
thereafter read-only.  If you want runtime effects, use the three-arg
open() (see L<perlfunc/open>), the two-arg binmode() (see L<perlfunc/binmode>),
and the C<open> pragma (see L<open>).

=end original

読み込み専用のマジック変数 C<${^UNICODE}> にこの設定の数値表現が
反映されます。
これは Perl 起動時にセットされる変数で、読み込み専用です。
実行中に効果を得たい場合は、3 引数の open() (L<perlfunc/open> 参照),
2 引数の binmode() (L<perlfunc/binmode> 参照), C<open> プラグマ
(L<open> 参照) を使ってください。

=begin original

(In Perls earlier than 5.8.1 the B<-C> switch was a Win32-only switch
that enabled the use of Unicode-aware "wide system call" Win32 APIs.
This feature was practically unused, however, and the command line
switch was therefore "recycled".)

=end original

(5.8.1 以前の Perl では B<-C> スイッチは Win32 専用のスイッチで、
Unicode 対応の "ワイド文字システムコール" Win32 API を使うためのものでした。
この機能は事実上使われませんでしたが、コマンドラインスイッチは
"再利用" されました。)

=begin original

B<Note:> Since perl 5.10.1, if the B<-C> option is used on the C<#!> line,
it must be specified on the command line as well, since the standard streams
are already set up at this point in the execution of the perl interpreter.
You can also use binmode() to set the encoding of an I/O stream.

=end original

B<注意:> perl 5.10.1 から、B<-C> スイッチが C<#!> 行で使われると、
コマンドラインでも指定しなければなりません; なぜなら標準ストリームは
perl インタプリタ実行のこの地点で既に設定されているからです。
I/O ストリームのエンコーディングの設定に binmode() も使えます。

=item B<-c>
X<-c>

=begin original

causes Perl to check the syntax of the program and then exit without
executing it.  Actually, it I<will> execute any C<BEGIN>, C<UNITCHECK>,
or C<CHECK> blocks and any C<use> statements: these are considered as
occurring outside the execution of your program.  C<INIT> and C<END>
blocks, however, will be skipped.

=end original

Perl にスクリプトの構文のチェックを行なわせ、実行せずに
終了するようにします。
実際には、C<BEGIN>, C<UNITCHECK>, C<CHECK> ブロックと C<use> 文は
I<実行します>: これらはプログラムの実行の外側にあるものと
考えられます。
C<INIT> と C<END> ブロックはスキップされます。

=item B<-d>
X<-d> X<-dt>

=item B<-dt>

=begin original

runs the program under the Perl debugger.  See L<perldebug>.
If B<t> is specified, it indicates to the debugger that threads
will be used in the code being debugged.

=end original

Perl デバッガの下でプログラムを実行します。
L<perldebug> を参照してください。
B<t> が指定されると、デバッグするコードがスレッドを使っていることを
デバッガに示します。

=item B<-d:>I<MOD[=bar,baz]>
X<-d> X<-dt>

=item B<-dt:>I<MOD[=bar,baz]>

=begin original

runs the program under the control of a debugging, profiling, or tracing
module installed as C<Devel::I<MOD>>. E.g., B<-d:DProf> executes the
program using the C<Devel::DProf> profiler.  As with the L<-M|/-M[-]module>
flag, options may be passed to the C<Devel::I<MOD>> package where they will
be received and interpreted by the C<Devel::I<MOD>::import> routine.  Again,
like B<-M>, use -B<-d:-I<MOD>> to call C<Devel::I<MOD>::unimport> instead of
import.  The comma-separated list of options must follow a C<=> character.
If B<t> is specified, it indicates to the debugger that threads will be used
in the code being debugged.  See L<perldebug>.

=end original

C<Devel::I<MOD>> としてインストールされる デバッグ、プロファイリング、
トレースモジュールの制御下でプログラムを実行します。
つまり、B<-d:DProf> は C<Devel::DProf> プロファイラを使って
プログラムを実行します。
L<-M|/-M[-]module> フラグと共に使うと、オプションは
C<Devel::I<MOD>> パッケージに渡され、C<Devel::I<MOD>::import> ルーチンで
解釈されます。
再び、B<-M> と同様、インポートではなく C<Devel::I<MOD>::unimport> を
呼び出すには -B<-d:-I<MOD>> を使ってください。
オプションをコンマ区切りのリストにするときは C<=> の文字の後に
続けなければなりません。
B<t> が指定されると、デバッグするコードがスレッドを使っていることを
デバッガに示します。
L<perldebug> を参照してください。

=item B<-D>I<letters>
X<-D> X<DEBUGGING> X<-DDEBUGGING>

=item B<-D>I<number>

=begin original

sets debugging flags. This switch is enabled only if your perl binary has
been built with debugging enabled: normal production perls won't have
been.

=end original

デバッグフラグを設定します。
このオプションは、perl バイナリがデバッグを有効にしてビルドされている
場合にのみ有効になります: 通常の製品版 perl は有効になりません。

=begin original

For example, to watch how perl executes your program, use B<-Dtls>.
Another nice value is B<-Dx>, which lists your compiled syntax tree, and
B<-Dr> displays compiled regular expressions; the format of the output is
explained in L<perldebguts>.

=end original

例えば、スクリプトがどのように実行されるかを見るには、B<-Dtls> を
使ってください。
この他に役に立つ値としては、コンパイルされた構文ツリーを表示する、
B<-Dx> があげられます;
B<-Dr> は、コンパイルした正規表現を表示します; 出力形式については
L<perldebguts> に説明があります。

=begin original

As an alternative, specify a number instead of list of letters (e.g.,
B<-D14> is equivalent to B<-Dtls>):

=end original

文字のリストの代わりに数字を指定することもできます
(たとえば、B<-D14> は B<-Dtls> と等価です):

=begin original

         1  p  Tokenizing and parsing (with v, displays parse
               stack)
         2  s  Stack snapshots (with v, displays all stacks)
         4  l  Context (loop) stack processing
         8  t  Trace execution
        16  o  Method and overloading resolution
        32  c  String/numeric conversions
        64  P  Print profiling info, source file input state
       128  m  Memory and SV allocation
       256  f  Format processing
       512  r  Regular expression parsing and execution
      1024  x  Syntax tree dump
      2048  u  Tainting checks
      4096  U  Unofficial, User hacking (reserved for private,
               unreleased use)
      8192  h  Show hash randomization debug output (changes to
               PL_hash_rand_bits and their origin)
     16384  X  Scratchpad allocation
     32768  D  Cleaning up
     65536  S  Op slab allocation
    131072  T  Tokenizing
    262144  R  Include reference counts of dumped variables
               (eg when using -Ds)
    524288  J  show s,t,P-debug (don't Jump over) on opcodes within
               package DB
   1048576  v  Verbose: use in conjunction with other flags to
               increase the verbosity of the output.  Is a no-op on
               many of the other flags
   2097152  C  Copy On Write
   4194304  A  Consistency checks on internal structures
   8388608  q  quiet - currently only suppresses the "EXECUTING"
               message
  16777216  M  trace smart match resolution
  33554432  B  dump suBroutine definitions, including special
               Blocks like BEGIN
  67108864  L  trace Locale-related info; what gets output is very
               subject to change
 134217728  i  trace PerlIO layer processing.  Set PERLIO_DEBUG to
               the filename to trace to.
 268435456  y  trace y///, tr/// compilation and execution

=end original

         1  p  トークン化と構文解析 (v と併用されると、パーススタックの表示)
         2  s  スタックの表示 (v と併用されると、全てのスタックの表示)
         4  l  コンテキスト(ループ)スタックの処理
         8  t  実行のトレース
        16  o  メソッドとオーバーロードの解決
        32  c  文字列/数値変換
        64  P  プロファイリング情報、ソースファイル入力状態の表示
       128  m  メモリと SV の配置
       256  f  フォーマットの処理
       512  r  正規表現の解析と実効
      1024  x  構文トリーのダンプ
      2048  u  汚染チェック
      4096  U  非公式な、ユーザーハック (プライベートな、リリースされない
               利用法のために予約)
      8192  h  ハッシュランダム化のデバッグ出力を表示 (PL_hash_rand_bits と
               その元の変更)
     16384  X  スクラッチパッドの配置
     32768  D  全消去
     65536  S  op スラブアロケーション
    131072  T  トークン化
    262144  R  ダンプされた変数のリファレンスカウントを含む(-Dsのとき)
    524288  J  DB パッケージの中での s,t,P デバッグコードを表示(飛び越えない)
   1048576  v  詳細: 他のフラグと組み合わせて出力の詳細度を上げる。
               その他の多くのフラグでは何もしない
   2097152  C  コピーオンライト
   4194304  A  内部構造の一貫性チェック
   8388608  q  静粛 - 現在のところ "EXECUTING" メッセージだけを抑制する
  16777216  M  スマートマッチングの解決をトレース
  33554432  B  BEGIN のような特殊ブロックを含む、suBroutine 定義のダンプ
  67108864  L  ロケール関連の情報をトレース; 出力内容は変更される可能性が高い
 134217728  i  PerlIO 層処理のトレース。PERLIO_DEBUG に
               トレースするファイル名を設定すること。
 268435456  y  y///, tr/// のコンパイルと実行をトレース

=begin original

All these flags require B<-DDEBUGGING> when you compile the Perl
executable (but see C<:opd> in L<Devel::Peek> or L<re/'debug' mode>
which may change this).
See the L<INSTALL> file in the Perl source distribution
for how to do this.

=end original

これらの全てのフラグは Perl 実行ファイルをコンパイルするときに
B<-DDEBUGGING> が指定されている必要があります
(但しこれを変更するかもしれない L<Devel::Peek> の C<:opd> や
L<re/'debug' mode> を参照してください)。
そうするためにどうすればいいかについては Perl のソース配布パッケージの
L<INSTALL> ファイルを参照してください。

=begin original

If you're just trying to get a print out of each line of Perl code
as it executes, the way that C<sh -x> provides for shell scripts,
you can't use Perl's B<-D> switch.  Instead do this

=end original

シェルスクリプトにおける C<sh -x> のように、単に今実行している Perl の
コードを表示したい場合は、Perl の B<-D> スイッチは使えません。
代わりに以下のようにしてください:

  # If you have "env" utility
  env PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # Bourne shell syntax
  $ PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # csh syntax
  % (setenv PERLDB_OPTS "NonStop=1 AutoTrace=1 frame=2"; perl -dS program)

=begin original

See L<perldebug> for details and variations.

=end original

詳細とバリエーションについては L<perldebug> を参照してください。

=item B<-e> I<commandline>
X<-e>

=begin original

may be used to enter one line of program.  If B<-e> is given, Perl
will not look for a filename in the argument list.  Multiple B<-e>
commands may be given to build up a multi-line script.  Make sure
to use semicolons where you would in a normal program.

=end original

1 行のプログラムを指定するのに使用します。
B<-e> が指定されると Perl は引数のリストからはファイル名を探しません。
複数の -e コマンドで、複数行のスクリプトを構成することができます。
通常のプログラムでセミコロンを置くところには、セミコロンを使うことに
気を付けてください。

=item B<-E> I<commandline>
X<-E>

=begin original

behaves just like L<-e|/-e commandline>, except that it implicitly
enables all optional features (in the main compilation unit). See
L<feature>.

=end original

L<-e|/-e commandline> と同様に振る舞いますが、暗黙に全てのオプション機能を
(main コンパイル単位で)有効にします。
L<feature> を参照してください。

=item B<-f>
X<-f> X<sitecustomize> X<sitecustomize.pl>

=begin original

Disable executing F<$Config{sitelib}/sitecustomize.pl> at startup.

=end original

起動時の F<$Config{sitelib}/sitecustomize.pl> の実行を無効化します。

=begin original

Perl can be built so that it by default will try to execute
F<$Config{sitelib}/sitecustomize.pl> at startup (in a BEGIN block).
This is a hook that allows the sysadmin to customize how Perl behaves.
It can for instance be used to add entries to the @INC array to make Perl
find modules in non-standard locations.

=end original

Perl は実行時に (BEGIN ブロックの中で) デフォルトで
F<$Config{sitelib}/sitecustomize.pl> を実行しようとさせるように
ビルドできます。
これはシステム管理者が、Perl がどのように振る舞うかをカスタマイズするための
フックです。
例えば、Perl が非標準の位置にあるモジュールを見つけられるように @INC 配列に
エントリを追加するために使えます。

=begin original

Perl actually inserts the following code:

=end original

Perl は実際には以下のコードを挿入します:

    BEGIN {
        do { local $!; -f "$Config{sitelib}/sitecustomize.pl"; }
            && do "$Config{sitelib}/sitecustomize.pl";
    }

=begin original

Since it is an actual C<do> (not a C<require>), F<sitecustomize.pl>
doesn't need to return a true value. The code is run in package C<main>,
in its own lexical scope. However, if the script dies, C<$@> will not
be set.

=end original

実際には (C<require> ではなく) C<do> なので、F<sitecustomize.pl> は
真の値を返す必要はありません。
このコードは C<main> パッケージで、独自のレキシカルスコープで動作します。
しかし、スクリプトが die すると、C<$@> は設定されません。

=begin original

The value of C<$Config{sitelib}> is also determined in C code and not
read from C<Config.pm>, which is not loaded.

=end original

C<$Config{sitelib}> の値は C コードで決定され、C<Config.pm> は
読み込まれないので、ここの値は使われません。

=begin original

The code is executed I<very> early. For example, any changes made to
C<@INC> will show up in the output of `perl -V`. Of course, C<END>
blocks will be likewise executed very late.

=end original

コードは I<とても> 早くに実行されます。
例えば、C<@INC> への変更は `perl -V` の出力に表示されます。
もちろん、C<END> ブロックは同様にとても遅くに実行されます。

=begin original

To determine at runtime if this capability has been compiled in your
perl, you can check the value of C<$Config{usesitecustomize}>.

=end original

この機能がコンパイルされているかどうかを実行時に決定するために、
C<$Config{usesitecustomize}> の値をチェックできます。

=item B<-F>I<pattern>
X<-F>

=begin original

specifies the pattern to split on for L</-a>. The pattern may be
surrounded by C<//>, C<"">, or C<''>, otherwise it will be put in single
quotes. You can't use literal whitespace or NUL characters in the pattern.

=end original

L</-a> のための、split を行なう正規表現を指定します。
パターンは C<//>, C<"">, C<''> で囲むか、シングルクォートの中に書きます。
パターン中にリテラルな空白や NUL 文字は使えません。

=begin original

B<-F> implicitly sets both L</-a> and L</-n>.

=end original

B<-F> は暗黙に L</-a> と L</-n> の両方を設定します。

=item B<-g>
X<-g>

=begin original

undefines the input record separator (C<L<$E<sol>|perlvar/$E<sol>>>) and thus
enables the slurp mode. In other words, it causes Perl to read whole
files at once, instead of line by line.

=end original

入力レコード区切り文字 (C<L<$E<sol>|perlvar/$E<sol>>>) を未定義化して、
吸い込みモードを有効にします。
言い換えると、Perl は行単位ではなくファイル全体を一度に
読み込むようになります。

=begin original

This flag is a simpler alias for L<-0777|/-0[octalE<sol>hexadecimal]>.

=end original

このフラグは L<-0777|/-0[octalE<sol>hexadecimal]> のより簡単な別名です。

=begin original

Mnemonics: gobble, grab, gulp.

=end original

記憶法: gobble, grab, gulp.

=item B<-h>
X<-h>

=begin original

prints a summary of the options.

=end original

オプションの一覧を表示します。

=item B<-?>
X<-?>

=begin original

synonym for B<-h>: prints a summary of the options.

=end original

B<-h> の同義語: オプションの一覧を表示します。

=item B<-i>[I<extension>]
X<-i> X<in-place>

=begin original

specifies that files processed by the C<E<lt>E<gt>> construct are to be
edited in-place.  It does this by renaming the input file, opening the
output file by the original name, and selecting that output file as the
default for print() statements.  The extension, if supplied, is used to
modify the name of the old file to make a backup copy, following these
rules:

=end original

C<E<lt>E<gt>> の構文で処理されたファイルを置き換えるための拡張子を
指定します。
これは、入力ファイルをリネームし、元の名前で出力ファイルを open し、
print() 文のデフォルトとしてその出力ファイルを select することで行ないます。
extension が指定されると、昔の内容のバックアップを行なう
ファイル名の拡張子として、元のファイル名に付け加えられます。

=begin original

If no extension is supplied, and your system supports it, the original
I<file> is kept open without a name while the output is redirected to
a new file with the original I<filename>.  When perl exits, cleanly or not,
the original I<file> is unlinked.

=end original

extension が指定されず、システムが対応しているなら、元の I<file> は名前なしで
開いたままになる一方、出力は元の I<filename> の新しいファイルに
リダイレクトされます。
クリーンかどうかに関わらず、perl が終了した時点で、元の I<file> は
アンリンクされます。

=begin original

If the extension doesn't contain a C<*>, then it is appended to the
end of the current filename as a suffix.  If the extension does
contain one or more C<*> characters, then each C<*> is replaced
with the current filename.  In Perl terms, you could think of this
as:

=end original

extension に C<*> が含まれていない場合、現在のファイル名の末尾に
接尾子として付け加えられます。
extension に一つ以上の C<*> の文字がある場合、
それぞれの C<*> は現在のファイル名で置き換えられます。
Perl 的に書くと、以下のようになります:

    ($backup = $extension) =~ s/\*/$file_name/g;

=begin original

This allows you to add a prefix to the backup file, instead of (or in
addition to) a suffix:

=end original

以下のようにすると、(接尾子の代わりに、あるいは接尾子に加えて)
バックアップファイルに接頭子をつけることができます。

 $ perl -pi'orig_*' -e 's/bar/baz/' fileA  # backup to
                                           # 'orig_fileA'

=begin original

Or even to place backup copies of the original files into another
directory (provided the directory already exists):

=end original

元のファイルのバックアップコピーを(既にある)他のディレクトリに作ることも
できます:

 $ perl -pi'old/*.orig' -e 's/bar/baz/' fileA  # backup to
                                               # 'old/fileA.orig'

=begin original

These sets of one-liners are equivalent:

=end original

以下の一行スクリプトは全て等価です:

 $ perl -pi -e 's/bar/baz/' fileA          # overwrite current file
 $ perl -pi'*' -e 's/bar/baz/' fileA       # overwrite current file

 $ perl -pi'.orig' -e 's/bar/baz/' fileA   # backup to 'fileA.orig'
 $ perl -pi'*.orig' -e 's/bar/baz/' fileA  # backup to 'fileA.orig'

=begin original

From the shell, saying

=end original

シェルから以下のように起動すると:

    $ perl -p -i.orig -e "s/foo/bar/; ... "

=begin original

is the same as using the program:

=end original

プログラムで以下のようにするのと同じで:

    #!/usr/bin/perl -pi.orig
    s/foo/bar/;

=begin original

which is equivalent to

=end original

以下とほぼ等価です:

    #!/usr/bin/perl
    $extension = '.orig';
    LINE: while (<>) {
	if ($ARGV ne $oldargv) {
	    if ($extension !~ /\*/) {
		$backup = $ARGV . $extension;
	    }
	    else {
		($backup = $extension) =~ s/\*/$ARGV/g;
	    }
	    rename($ARGV, $backup);
	    open(ARGVOUT, ">$ARGV");
	    select(ARGVOUT);
	    $oldargv = $ARGV;
	}
	s/foo/bar/;
    }
    continue {
	print;	# this prints to original filename
    }
    select(STDOUT);

=begin original

except that the B<-i> form doesn't need to compare $ARGV to $oldargv to
know when the filename has changed.  It does, however, use ARGVOUT for
the selected filehandle.  Note that STDOUT is restored as the default
output filehandle after the loop.

=end original

違うのは、B<-i> の形式が、いつファイル名が変わったかを知るために、
$ARGV と $oldargv を比較する必要がないことです。
しかしながら、選択するファイルハンドルとして ARGVOUT は使用します。
ループのあとは、STDOUT がデフォルトのファイルハンドルとして再設定されます。

=begin original

As shown above, Perl creates the backup file whether or not any output
is actually changed.  So this is just a fancy way to copy files:

=end original

上述の通り、Perl はバックアップファイルを実際に出力が変更されたかどうかに
関わらず作成します。
従って、以下はファイルをコピーする変わった方法となります:

    $ perl -p -i'/some/file/path/*' -e 1 file1 file2 file3...
or
    $ perl -p -i'.orig' -e 1 file1 file2 file3...

=begin original

You can use C<eof> without parentheses to locate the end of each input
file, in case you want to append to each file, or reset line numbering
(see example in L<perlfunc/eof>).

=end original

個々のファイルの終わりに何かを付け加えたいときや、行番号を
リセットしたいような場合に、個々の入力ファイルの終わりを知るために、
括弧の無い C<eof> を使うことができます (L<perlfunc/eof> の例を
参照してください)。

=begin original

If, for a given file, Perl is unable to create the backup file as
specified in the extension then it will skip that file and continue on
with the next one (if it exists).

=end original

与えられたファイルに対して、Perl が指定された拡張子でバックアップファイルを
作れない場合、そのファイルはスキップされて(もしあれば)次のファイルに
移って継続します。

=begin original

For a discussion of issues surrounding file permissions and B<-i>, see
L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber
protected files?  Isn't this a bug in Perl?>.

=end original

ファイルのパーミッションと B<-i> に関する議論については、
L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?> を
参照してください。

=begin original

You cannot use B<-i> to create directories or to strip extensions from
files.

=end original

B<-i> は、ディレクトリを作ったり、ファイルの拡張子を取り除いたりは
できません。

=begin original

Perl does not expand C<~> in filenames, which is good, since some
folks use it for their backup files:

=end original

Perl は C<~> を展開しません; これはバックアップファイルを以下のようにして
作る人々のためにはよいことです。

    $ perl -pi~ -e 's/foo/bar/' file1 file2 file3...

=begin original

Note that because B<-i> renames or deletes the original file before
creating a new file of the same name, Unix-style soft and hard links will
not be preserved.

=end original

B<-i> は同じ名前で新しいファイルを作る前に元のファイルをリネームまたは
削除するので、Unix 形式のソフトリンクやハードリンクは保存されないことに
注意してください。

=begin original

Finally, the B<-i> switch does not impede execution when no
files are given on the command line.  In this case, no backup is made
(the original file cannot, of course, be determined) and processing
proceeds from STDIN to STDOUT as might be expected.

=end original

最後に、B<-i> スイッチは、コマンドラインでファイルが指定されなくても
実行を妨げません。
この場合、バックアップファイルは作成されず(もちろん、元のファイルが
決定できません)、予想通り、STDIN から STDOUT に処理が行われます。

=item B<-I>I<directory>
X<-I> X<@INC>

=begin original

Directories specified by B<-I> are prepended to the search path for
modules (C<@INC>).

=end original

B<-I> で指定されたディレクトリはモジュールの検索パス(C<@INC>)に
加えられます。

=item B<-l>[I<octnum>]
X<-l> X<$/> X<$\>

=begin original

enables automatic line-ending processing.  It has two separate
effects.  First, it automatically chomps C<$/> (the input record
separator) when used with L</-n> or L</-p>.  Second, it assigns C<$\>
(the output record separator) to have the value of I<octnum> so
that any print statements will have that separator added back on.
If I<octnum> is omitted, sets C<$\> to the current value of
C<$/>.  For instance, to trim lines to 80 columns:

=end original

自動の行末処理を行なうようにします。
これには、2 つの独立した機能があります。
1 つには、L</-n> や L</-p> を使ったときに、自動的に C<$/>(入力レコード
セパレータ)を chomp します。
2 つめに octnum を C<$\>(出力レコードセパレータ) に代入し、print 文で
セパレータを追加できるようにします。
octnum を指定しなかった場合には、その時点の C<$/> の値をC<$\> に
設定します。
たとえば、行を 80 カラムに切り詰めるには以下のようにします:

    perl -lpe 'substr($_, 80) = ""'

=begin original

Note that the assignment C<$\ = $/> is done when the switch is processed,
so the input record separator can be different than the output record
separator if the B<-l> switch is followed by a
L<-0|/-0[octalE<sol>hexadecimal]> switch:

=end original

C<$\ = $/> という代入は、B<-l> スイッチが処理されるときに
実行されるときに行なわれますので、B<-l> スイッチの後に
L<-0|/-0[octalE<sol>hexadecimal]> スイッチを置くようにすれば、
入力レコードセパレータを、
出力レコードセパレータと違うようにもできます:

    gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

=begin original

This sets C<$\> to newline and then sets C<$/> to the null character.

=end original

これはまず、C<$\> に改行 (C<$/> のデフォルト値) を設定し、
それから C<$/> にヌル文字を設定します。

=item B<-m>[B<->]I<module>
X<-m> X<-M>

=item B<-M>[B<->]I<module>

=item B<-M>[B<->]I<'module ...'>

=item B<-[mM]>[B<->]I<module=arg[,arg]...>

=begin original

B<-m>I<module> executes C<use> I<module> C<();> before executing your
program.  This loads the module, but does not call its C<import> method,
so does not import subroutines and does not give effect to a pragma.

=end original

B<-m>I<module> はプログラムの実行前に C<use> I<module> C<();> を
実行します。
これはモジュールを読み込みますが、その C<import> メソッドは呼び出さないので、
サブルーチンをインポートすることはできず、プラグマの効果もありません。

=begin original

B<-M>I<module> executes C<use> I<module> C<;> before executing your
program.  This loads the module and calls its C<import> method, causing
the module to have its default effect, typically importing subroutines
or giving effect to a pragma.
You can use quotes to add extra code after the module name,
e.g., C<'-MI<MODULE> qw(foo bar)'>.

=end original

B<-M>I<module> はプログラムの実行前に C<use> I<module> C<;> を実行します。
これはモジュールを読み込んで、その C<import> メソッドを呼び出すので、
モジュールの (典型的にはサブルーチンのインポートやプラグマの降下のような)
デフォルトの効果が引き起こされます。
モジュール名の後ろに追加のコードを加えるためにクォートを使うこともできます;
つまり C<'-MI<MODULE> qw(foo bar)'> などです。

=begin original

If the first character after the B<-M> or B<-m> is a dash (B<->)
then the 'use' is replaced with 'no'.
This makes no difference for B<-m>.

=end original

B<-M> または B<-m> の後の最初の文字がダッシュ(B<->)の場合、
'use' の代わりに 'no' が使われます。
これは B<-m> で違いはありません。

=begin original

A little builtin syntactic sugar means you can also say
B<-mI<MODULE>=foo,bar> or B<-MI<MODULE>=foo,bar> as a shortcut for
B<'-MI<MODULE> qw(foo bar)'>.  This avoids the need to use quotes when
importing symbols.  The actual code generated by B<-MI<MODULE>=foo,bar> is
C<use module split(/,/,q{foo,bar})>.  Note that the C<=> form
removes the distinction between B<-m> and B<-M>; that is,
B<-mI<MODULE>=foo,bar> is the same as B<-MI<MODULE>=foo,bar>.

=end original

小さい組み込みのシンタックスシュガーとして、 B<'-MI<MODULE> qw(foo bar)'> の
代わりに B<-mI<MODULE>=foo,bar> または B<-MI<MODULE>=foo,bar> と
書くことができます。
これで、インポートするシンボルにクォートを使わなくてもよいようになります。
B<-MI<MODULE>=foo,bar> で生成される実際のコードは
C<use module split(/,/,q{foo,bar})> です。
C<=> の形は B<-m> と B<-M> の間の違いを取り除くことに注意してください;
これは、B<-mI<MODULE>=foo,bar> は B<-MI<MODULE>=foo,bar> と
同じということです。

=begin original

A consequence of the C<split> formulation
is that B<-MI<MODULE>=number> never does a version check,
unless C<I<MODULE>::import()> itself is set up to do a version check, which
could happen for example if I<MODULE> inherits from L<Exporter>.

=end original

C<split> 操作の結果、例えば I<MODULE> が L<Exporter> を継承していたりして、
C<I<MODULE>::import()> 自身がバージョンチェックを行うように設定されていない限り
B<-MI<MODULE>=number> は決してバージョンチェックは行いません。

=item B<-n>
X<-n>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like I<sed -n> or
I<awk>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように Perl に
指示します; I<sed -n> や I<awk> のようにファイル名引数上で繰り返しを
行なうことになります:

  LINE:
    while (<>) {
	...		# your program goes here
    }

=begin original

Note that the lines are not printed by default.  See L</-p> to have
lines printed.  If a file named by an argument cannot be opened for
some reason, Perl warns you about it and moves on to the next file.

=end original

デフォルトでは、各行が印字されることはありません。
各行の印字を行なうには L</-p> を参照してください。
引数で指定されたファイルがなんらかの理由でオープンできなかった場合、
Perl は警告を出して次のファイルに移ります。

=begin original

Also note that C<< <> >> passes command line arguments to
L<perlfunc/open>, which doesn't necessarily interpret them as file names.
See  L<perlop> for possible security implications.

=end original

また、C<< <> >> はコマンドライン引数を L<perlfunc/open> に渡し、これは
ファイル名として解釈する必要はないことに注意してください。
可能性のあるセキュリティの影響については L<perlop> を参照してください。

=begin original

Here is an efficient way to delete all files that haven't been modified for
at least a week:

=end original

以下にあげるのは、少なくとも 1 週間以上更新されていないファイルを効率的に
削除するものです:

    find . -mtime +7 -print | perl -nle unlink

=begin original

This is faster than using the B<-exec> switch of I<find> because you don't
have to start a process on every filename found (but it's not faster
than using the B<-delete> switch available in newer versions of I<find>.
It does suffer from the bug of mishandling newlines in pathnames, which
you can fix if you follow the example under
L<-0|/-0[octalE<sol>hexadecimal]>.

=end original

これは、ファイル名が見つかるごとにプロセスを起動しなくて済みますので、
I<find> の B<-exec> スイッチを使うよりも速くなります
(しかし、より新しい I<find> で利用可能な B<-delete> オプションを使うより
速くはないです)。
これはパス名に改行コードがあるとうまく扱えないバグの影響を受けますので、
L<-0|/-0[octalE<sol>hexadecimal]> の例に従うことで修正できます。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit program loop, just as in I<awk>.

=end original

I<awk> と同じように、暗黙に実行されるプログラムループの前後に実行される
コードを指定するために、C<BEGIN> ブロックと C<END> ブロックを
使うことができます。

=item B<-p>
X<-p>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like I<sed>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように Perl に
指示します; I<sed> のようにファイル名引数上で繰り返しを行なうことに
なります:

  LINE:
    while (<>) {
	...		# your program goes here
    } continue {
	print or die "-p destination: $!\n";
    }

=begin original

If a file named by an argument cannot be opened for some reason, Perl
warns you about it, and moves on to the next file.  Note that the
lines are printed automatically.  An error occurring during printing is
treated as fatal.  To suppress printing use the L</-n> switch.  A B<-p>
overrides a B<-n> switch.

=end original

引数で指定されたファイルが何らかの理由でオープンできない場合、
Perl は警告を出し、次のファイルに移ります。
各行は、自動的に印字されることになります。
印字中のエラーは致命的とみなされます。
印字を抑制するには、L</-n> スイッチを使ってください。
B<-p> は B<-n> スイッチを無効にします。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit loop, just as in I<awk>.

=end original

I<awk> と同じように、暗黙に実行されるループの前後に実行されるコードを
指定するために、C<BEGIN> ブロックと C<END> ブロックを使うことができます。

=item B<-s>
X<-s>

=begin original

enables rudimentary switch parsing for switches on the command
line after the program name but before any filename arguments (or before
an argument of B<-->).  Any switch found there is removed from @ARGV and sets the
corresponding variable in the Perl program, in the main package.  The following program
prints "1" if the program is invoked with a B<-xyz> switch, and "abc"
if it is invoked with B<-xyz=abc>.

=end original

コマンドライン上のプログラム名の後から、ファイル名引数
(または引数 B<-->) の前までのスイッチのための、原始的な解析を
行なえるようにします。
ここで見つかったスイッチは、@ARGV から取り除かれ、対応する Perl プログラムの
main パッケージの変数に設定されます。
以下のプログラムは、B<-xyz> というスイッチを付けて実行された時にだけ、
"1" と表示し、B<-xyz=abc> と起動された時に "abc" と表示します。

    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }

=begin original

Do note that a switch like B<--help> creates the variable C<${-help}>, which is
not compliant with C<use strict "refs">.  Also, when using this option on a
script with warnings enabled you may get a lot of spurious "used only once"
warnings. For these reasons, use of B<-s> is discouraged. See L<Getopt::Long>
for much more flexible switch parsing.

=end original

B<--help> のようなスイッチは変数 C<${-help}> を作成するので、
C<use strict "refs"> を満たさないことに注意してください。
また、警告を有効にしたスクリプトでこのオプションを使うと、大量の
"used only once" という偽警告がでることになります。
これらの理由により、B<-s> の仕様は非推奨です。
はるかに柔軟なオプションのパース方法については L<Getopt::Long>  を
参照してください。

=item B<-S>
X<-S>

=begin original

makes Perl use the L</PATH> environment variable to search for the
program unless the name of the program contains path separators.

=end original

プログラム名にパスセパレータを含まないとき、
Perl がプログラムを探すときに環境変数 L</PATH> を参照するようにします。

=begin original

On some platforms, this also makes Perl append suffixes to the
filename while searching for it.  For example, on Win32 platforms,
the ".bat" and ".cmd" suffixes are appended if a lookup for the
original name fails, and if the name does not already end in one
of those suffixes.  If your Perl was compiled with C<DEBUGGING> turned
on, using the L<-Dp|/-Dletters> switch to Perl shows how the search
progresses.

=end original

プラットフォームによっては、Perl はファイルを探すときに拡張子を
追加します。
例えば Win32 プラットフォームでは、元々のファイル名で検索が失敗した場合、
".bat" と ".cmd" の拡張子が追加されます; 但し既にそのような拡張子が
ついていない場合だけです。
Perl が C<DEBUGGING> を有効にしてコンパイルされていた場合、
L<-Dp|/-Dletters> スイッチを
使うことでどのように検索が行われているかを表示させることができます。

=begin original

Typically this is used to emulate C<#!> startup on platforms that don't
support C<#!>.  It's also convenient when debugging a script that uses C<#!>,
and is thus normally found by the shell's $PATH search mechanism.

=end original

これは、C<#!> をサポートしていないプラットフォームで、C<#!> による実行を
エミュレートするために使います。
また、C<#!> を使ったスクリプトで、通常はシェルの $PATH 検索メカニズムで
見つけられるようなスクリプトをデバッグするのにも便利です。

=begin original

This example works on many platforms that have a shell compatible with
Bourne shell:

=end original

この例は Bourne shell 互換のシェルを持つ多くのプラットフォームで動きます:

    #!/usr/bin/perl
    eval 'exec /usr/bin/perl -wS $0 ${1+"$@"}'
	    if 0; # ^ Run only under a shell

=begin original

The system ignores the first line and feeds the program to F</bin/sh>,
which proceeds to try to execute the Perl program as a shell script.
The shell executes the second line as a normal shell command, and thus
starts up the Perl interpreter.  On some systems $0 doesn't always
contain the full pathname, so the L</-S> tells Perl to search for the
program if necessary.  After Perl locates the program, it parses the
lines and ignores them because the check 'if 0' is never true.
If the program will be interpreted by csh, you will need
to replace C<${1+"$@"}> with C<$*>, even though that doesn't understand
embedded spaces (and such) in the argument list.  To start up I<sh> rather
than I<csh>, some systems may have to replace the C<#!> line with a line
containing just a colon, which will be politely ignored by Perl.  Other
systems can't control that, and need a totally devious construct that
will work under any of I<csh>, I<sh>, or Perl, such as the following:

=end original

システムは、最初の行を無視し、プログラムを F</bin/sh> に渡し、
F</bin/sh> は Perl プログラムをシェルプログラムとして実行しようとします。
シェルは 2 行目を通常のシェルコマンドとして実行し、Perl インタプリタを
起動することになります。
$0 にフルパス名が入っているとは限らないシステムもありますので、
L</-S> が Perl に必要に応じてプログラムを探すように指示します。
Perl がプログラムを見つけると、これらの行の解析を始めますが、
'if 0' が真になることがないため、無視することになります。
プログラムが csh で解釈される場合には、たとえファイル名内に埋め込まれた
スペースなどを扱うことができなくても C<${1+"$@"}> を C<$*> で
置き換える必要があるかもしれません。
I<csh> ではなく、I<sh> を起動するように、いくつかのシステムでは、C<#!> の行を
Perl も無視することになっている、コロンだけの行で置き換える必要が
あるかもしれません。
そういった制御が効かないシステムでは、I<csh> でも I<sh> でも
Perl でも使える、回りくどい方法を使うことが必要です:

	eval '(exit $?0)' && eval 'exec perl -wS $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -wS $0 $argv:q'
		if 0; # ^ Run only under a shell

=begin original

If the filename supplied contains directory separators (and so is an
absolute or relative pathname), and if that file is not found,
platforms that append file extensions will do so and try to look
for the file with those extensions added, one by one.

=end original

ファイル名にディレクトリセパレータが含まれていた場合
(そしてそれが絶対パスまたは相対パスだった場合)、そしてそのファイルが
なかった場合、ファイル拡張子を追加するプラットフォームでは
ひとつずつ拡張子を追加して、ファイルを探します。

=begin original

On DOS-like platforms, if the program does not contain directory
separators, it will first be searched for in the current directory
before being searched for on the PATH.  On Unix platforms, the
program will be searched for strictly on the PATH.

=end original

DOS 風のプラットフォームでは、プログラムにディレクトリセパレータが
含まれていなかった場合、PATH を探す前に最初にカレントディレクトリを
探します。
Unix プラットフォームでは、プログラムは厳密に PATH からのみ探されます。

=item B<-t>
X<-t>

=begin original

Like L</-T>, but taint checks will issue warnings rather than fatal
errors.  These warnings can now be controlled normally with C<no warnings
qw(taint)>.

=end original

L</-T> と同様ですが、汚染チェックは致命的エラーではなく警告を発生させます。
この警告は通常通り C<no warnings qw(taint)> で制御できます。

=begin original

B<Note: This is not a substitute for C<-T>!> This is meant to be
used I<only> as a temporary development aid while securing legacy code:
for real production code and for new secure code written from scratch,
always use the real L</-T>.

=end original

B<注意: これは C<-T> の代用品ではありません!>
これは昔のコードを安全にするのを助けるために一時的に使用されるため
I<だけの> ものです:
本当の製品版コードと最初から書く安全なコードのためには常に本当の
L</-T> を使ってください。

=begin original

This has no effect if your perl was built without taint support.

=end original

これは perl 汚染チェック対応なしでビルドされている場合は
何の効果もありません。

=item B<-T>
X<-T>

=begin original

turns on "taint" so you can test them.  Ordinarily
these checks are done only when running setuid or setgid.  It's a
good idea to turn them on explicitly for programs that run on behalf
of someone else whom you might not necessarily trust, such as CGI
programs or any internet servers you might write in Perl.  See
L<perlsec> for details.  For security reasons, this option must be
seen by Perl quite early; usually this means it must appear early
on the command line or in the C<#!> line for systems which support
that construct.

=end original

「汚染」チェックをオンにして、テストできるようにします。
通常、このチェックは setuid や setgid のスクリプトを実行するときにだけ、
行なわれます。
CGI プログラムやインターネットサーバーを Perl で書くときのように、
信用できるとは限らない人が動かすようなプログラムではこれを明示的に
有効にするのはいい考えです。
詳細については L<perlsec> を参照してください。
セキュリティ上の理由から、このオプションは Perl にかなり早く
渡さなければなりません; これは通常コマンドラインの最初の方につけるか、
C<#!> 構造に対応するシステムではここに書くかです。

=item B<-u>
X<-u>

=begin original

This switch causes Perl to dump core after compiling your
program.  You can then in theory take this core dump and turn it
into an executable file by using the I<undump> program (not supplied).
This speeds startup at the expense of some disk space (which you
can minimize by stripping the executable).  (Still, a "hello world"
executable comes out to about 200K on my machine.)  If you want to
execute a portion of your program before dumping, use the C<CORE::dump()>
function instead.  Note: availability of I<undump> is platform
specific and may not be available for a specific port of Perl.

=end original

このスイッチはプログラムのコンパイル後、コアダンプを
行なうようにします。
理論的には、このコアダンプを持ってきて(Perl の配布では提供されていませんが)
I<undump> プログラムを使って、実行ファイルに変換することができます。
これは多少ディスク容量を食いますが (実行ファイルを strip することで
少しは減ります)、実行開始を速くすることができます。
(減らしても、"hello world" の実行ファイルは、私のマシンで 200K 程に
なります。)
ダンプする前に部分的にプログラムを実行しておきたい場合には、
このスイッチの代わりに C<CORE::dump()> 関数を使ってください。
注意: I<undump> が実行できるのは特定の環境下ですし、
これが使えない移植バージョンの Perl もあるでしょう。

=item B<-U>
X<-U>

=begin original

allows Perl to do unsafe operations.  Currently the only "unsafe"
operations are attempting to unlink directories while running as superuser
and running setuid programs with fatal taint checks turned into warnings.
Note that warnings must be enabled along with this option to actually
I<generate> the taint-check warnings.

=end original

Perl に安全でない操作を許可します。
現在のところ唯一の「安全でない」操作はスーパーユーザとして実行されている
ときにディレクトリを削除しようとすることと、致命的な汚染チェックを
警告に変更して setuid プログラムを実行することです。
このオプションは実際に汚染チェック警告が I<生成される> ときに
有効でなければならないことに注意してください。

=item B<-v>
X<-v>

=begin original

prints the version and patchlevel of your perl executable.

=end original

Perl 実行ファイルのバージョンとパッチレベルを表示します。

=item B<-V>
X<-V>

=begin original

prints summary of the major perl configuration values and the current
values of @INC.

=end original

Perl の主な設定値と @INC の現在の値を表示します。

=item B<-V:>I<configvar>

=begin original

Prints to STDOUT the value of the named configuration variable(s),
with multiples when your C<I<configvar>> argument looks like a regex (has
non-letters).  For example:

=end original

指定された設定変数の値を STDOUT に表示します;
C<I<configvar>> 引数が正規表現のように見えるもの(英字以外を含んでいる)の
場合は複数表示します。
例えば:

    $ perl -V:libc
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.*
	libpth='/usr/local/lib /lib /usr/lib';
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	lib_ext='.a';
	libc='/lib/libc-2.2.4.so';
	libperl='libperl.a';
	....

=begin original

Additionally, extra colons can be used to control formatting.  A
trailing colon suppresses the linefeed and terminator ";", allowing
you to embed queries into shell commands.  (mnemonic: PATH separator
":".)

=end original

さらに、追加のコロンはフォーマットの制御に使います。
末尾のコロンは改行と終端子 ";" を抑制し、シェルコマンド中にクエリを
組み込めるようにします。
(記憶法: PATH セパレータ ":"。)

    $ echo "compression-vars: " `perl -V:z.*: ` " are here !"
    compression-vars:  zcat='' zip='zip'  are here !

=begin original

A leading colon removes the "name=" part of the response, this allows
you to map to the name you need.  (mnemonic: empty label)

=end original

先頭のコロンはレスポンスの "name=" の部分を削除し、必要な名前に
マッピングできるようにします。
(記憶法: 空ラベル)

    $ echo "goodvfork="`./perl -Ilib -V::usevfork`
    goodvfork=false;

=begin original

Leading and trailing colons can be used together if you need
positional parameter values without the names.  Note that in the case
below, the C<PERL_API> params are returned in alphabetical order.

=end original

もし位置パラメータの値を名前なしで必要なら、先頭のコロンと末尾のコロンを
両方使えます。
以下の場合、C<PERL_API> パラメータはアルファベット順に返されることに
注意してください。

    $ echo building_on `perl -V::osname: -V::PERL_API_.*:` now
    building_on 'linux' '5' '1' '9' now

=item B<-w>
X<-w>

=begin original

prints warnings about dubious constructs, such as variable names
mentioned only once and scalar variables used
before being set; redefined subroutines; references to undefined
filehandles; filehandles opened read-only that you are attempting
to write on; values used as a number that don't I<look> like numbers;
using an array as though it were a scalar; if your subroutines
recurse more than 100 deep; and innumerable other things.

=end original

1 度しか使われない変数名、設定される前に使われている変数、サブルーチンの
再定義、未定義のファイルハンドルの参照や、読み込み専用でオープンした
ファイルハンドルへの書き込み、数値に I<見えない> 値を数値として使った場合、
配列をスカラであるかのように使った場合、100 段階以上のサブルーティンの再帰、
その他たくさんの疑わしい事に警告を出します。

=begin original

This switch really just enables the global C<$^W> variable; normally,
the lexically scoped C<use warnings> pragma is preferred. You
can disable or promote into fatal errors specific warnings using
C<__WARN__> hooks, as described in L<perlvar> and L<perlfunc/warn>.
See also L<perldiag> and L<perltrap>.  A fine-grained warning
facility is also available if you want to manipulate entire classes
of warnings; see L<warnings>.

=end original

このスイッチは実際にはグローバルな C<$^W> 変数を有効にするだけです;
普通は、レキシカルスコープの C<use warnings> プラグマが推奨されます。
C<__WARN__> フックを使って特定の警告を無効にしたり致命的エラーにしたり
できます; これについては L<perlvar> と L<perlfunc/warn> を参照してください。
L<perldiag> と L<perltrap> も参照してください。
もし警告のクラス全体を操作したいなら、粒度の細かい警告機能もあります;
L<warnings> を参照してください。

=item B<-W>
X<-W>

=begin original

Enables all warnings regardless of C<no warnings> or C<$^W>.
See L<warnings>.

=end original

C<no warnings> や C<$^W> の設定に関わらず全ての警告を有効にします。
L<warnings> を参照してください。

=item B<-X>
X<-X>

=begin original

Disables all warnings regardless of C<use warnings> or C<$^W>.
See L<warnings>.

=end original

C<use warnings> や C<$^W> の設定に関わらず全ての警告を無効にします。
L<warnings> を参照してください。

=begin original

Forbidden in C<L</PERL5OPT>>.

=end original

C<L</PERL5OPT>> では禁止されています。

=item B<-x>
X<-x>

=item B<-x>I<directory>

=begin original

tells Perl that the program is embedded in a larger chunk of unrelated
text, such as in a mail message.  Leading garbage will be
discarded until the first line that starts with C<#!> and contains the
string "perl".  Any meaningful switches on that line will be applied.

=end original

メールのような大きな無関係のテキストのかたまりの中にプログラムが
埋め込まれている事を Perl に伝えます。
最初の C<#!> で始まり、"perl" という文字列を含む行までの、先行するゴミは
捨てられます。
その行にある意味を持つスイッチは適用されます。

=begin original

All references to line numbers by the program (warnings, errors, ...)
will treat the C<#!> line as the first line.
Thus a warning on the 2nd line of the program, which is on the 100th
line in the file will be reported as line 2, not as line 100.
This can be overridden by using the C<#line> directive.
(See L<perlsyn/"Plain Old Comments (Not!)">)

=end original

プログラムによる行番号への全ての参照 (警告、エラー…) は C<#!> 行を
最初の行として扱います。
従って、プログラムの 2 番目の行 (ファイルとしては 100 行目) での警告は
100 行目ではなく 2 行目として報告されます。
これは C<#line> 指示子を使って上書きできます。
(L<perlsyn/"Plain Old Comments (Not!)"> を参照してください)

=begin original

If a directory name is specified, Perl will switch to that directory
before running the program.  The B<-x> switch controls only the
disposal of leading garbage.  The program must be terminated with
C<__END__> if there is trailing garbage to be ignored;  the program
can process any or all of the trailing garbage via the C<DATA> filehandle
if desired.

=end original

ディレクトリ名が指定されると、Perl はプログラムの実行前にそのディレクトリに
変更します。
B<-x> オプションは前に付いているごみを捨てることのみを制御します。
もし後ろに無視する必要のあるごみが付いているなら、プログラムは C<__END__> で
終了していなければなりません; もし望むなら、C<DATA> ファイルハンドル経由で
後ろに付いているごみの一部または全てをプログラムで処理できます。

=begin original

The directory, if specified, must appear immediately following the B<-x>
with no intervening whitespace.

=end original

ディレクトリが指定される場合は、これは B<-x> の直後、空白なしに
引き続かなければなりません。

=back

=head1 ENVIRONMENT
X<perl, environment variables>

(環境変数)

=over 12

=item HOME
X<HOME>

=begin original

Used if C<chdir> has no argument.

=end original

C<chdir> の引数がないときに使われます。

=item LOGDIR
X<LOGDIR>

=begin original

Used if C<chdir> has no argument and L</HOME> is not set.

=end original

C<chdir> の引数がなく、L</HOME> がセットされていないときに使われます。

=item PATH
X<PATH>

=begin original

Used in executing subprocesses, and in finding the program if L</-S> is
used.

=end original

サブプロセスを実行するときと、L</-S> が指定されたときにプログラムを
探すのに使われます。

=item PERL5LIB
X<PERL5LIB>

=begin original

A list of directories in which to look for Perl library files before
looking in the standard library.
Any architecture-specific and version-specific directories,
such as F<version/archname/>, F<version/>, or F<archname/> under the
specified locations are automatically included if they exist, with this
lookup done at interpreter startup time.  In addition, any directories
matching the entries in C<$Config{inc_version_list}> are added.
(These typically would be for older compatible perl versions installed
in the same directory tree.)

=end original

Perl のライブラリファイルを探すときに標準ライブラリを
探す前に探すディレクトリのリストです。
特定の場所における F<version/archname/>, F<version/>, F<archname/> のような
アーキテクチャ依存とバージョン依存のディレクトリは、もしあれば自動的に
追加されます; この検索はインタプリタ起動時に行われます。
さらに、C<$Config{inc_version_list}> のエントリにマッチングするディレクトリが
追加されます。
(これらは典型的には同じディレクトリツリーにより古い互換性のある perl が
インストールされている場合のためのものです。)

=begin original

If PERL5LIB is not defined, L</PERLLIB> is used.  Directories are separated
(like in PATH) by a colon on Unixish platforms and by a semicolon on
Windows (the proper path separator being given by the command C<perl
-V:I<path_sep>>).

=end original

PERL5LIB が定義されていなければ、L</PERLLIB> が使われます。
ディレクトリは(PATH と同様に)Unix 風のプラットフォームではコロンで区切られ、
Windows ではセミコロンで区切られます(適切なパス区切り文字は
C<perl -V:path_sep> コマンドでわかります)。

=begin original

When running taint checks, either because the program was running setuid or
setgid, or the L</-T> or L</-t> switch was specified, neither PERL5LIB nor
L</PERLLIB> is consulted. The program should instead say:

=end original

プログラムが setuid または setgid で実行されているか、L</-T> または L</-t> の
スイッチが指定されて、汚染チェック付きで動作している場合、PERL5LIB も
L</PERLLIB> も使われません。
代わりにプログラム中で以下のようにするべきです:

    use lib "/my/directory";

=item PERL5OPT
X<PERL5OPT>

=begin original

Command-line options (switches).  Switches in this variable are treated
as if they were on every Perl command line.  Only the B<-[CDIMTUWdmtw]>
switches are allowed.  When running taint checks (either because the
program was running setuid or setgid, or because the L</-T> or L</-t>
switch was used), this variable is ignored.  If PERL5OPT begins with
B<-T>, tainting will be enabled and subsequent options ignored.  If
PERL5OPT begins with B<-t>, tainting will be enabled, a writable dot
removed from @INC, and subsequent options honored.

=end original

コマンドラインオプション(スイッチ)です。
この変数のスイッチは全ての Perl コマンドラインで指定されたかのように
扱われます。
B<-[CDIMTUWdmtw]> オプションのみが有効です。
(プログラムが setuid または setgid で実行されているか、
L</-T> または L</-t> スイッチが指定されて)汚染チェック付きで動作している場合、
この変数は無視されます。
PERL5OPT が B<-T> で始まっている場合、汚染チェックが有効となり、引き続く
オプションは無視されます。
PERL5OPT が B<-t> で始まっている場合、汚染チェックが有効となり、
書き込み可能なドットは @INC から削除され、引き続くオプションも有効に
なります。

=item PERLIO
X<PERLIO>

=begin original

A space (or colon) separated list of PerlIO layers. If perl is built
to use PerlIO system for IO (the default) these layers affect Perl's IO.

=end original

空白(またはコロン)で区切られた PerlIO 層のリストです。
perl が IO に PerlIO システムを使うようにコンパイルされている場合
(これがデフォルトです)、これらの層が perl の IO に影響を与えます。

=begin original

It is conventional to start layer names with a colon (for example, C<:perlio>) to
emphasize their similarity to variable "attributes". But the code that parses
layer specification strings, which is also used to decode the PERLIO
environment variable, treats the colon as a separator.

=end original

層名をコロンで始める (例えば C<:perlio>) のは、変数の「属性」との
類似性を強調するための慣習です。
しかし層指定文字列をパースするコード(PERLIO 環境変数をデコードするためにも
使われます)は、コロンを区切りとして使います。

=begin original

An unset or empty PERLIO is equivalent to the default set of layers for
your platform; for example, C<:unix:perlio> on Unix-like systems
and C<:unix:crlf> on Windows and other DOS-like systems.

=end original

PERLIO をセットしない、または空文字列をセットすると、プラットフォームの
デフォルトの層の組み合わせと等価です; 
例えば、Unix 風のシステムでは C<:unix:perlio> で、Windows やその他の
DOS 風のシステムは C<:unix:crlf> です。

=begin original

The list becomes the default for I<all> Perl's IO. Consequently only built-in
layers can appear in this list, as external layers (such as C<:encoding()>) need
IO in order to load them!  See L<"open pragma"|open> for how to add external
encodings as defaults.

=end original

このリストは I<全ての> Perl の IO のデフォルトとなります。
従って組み込みの層のみがこのリストに記述可能です; なぜなら
(C<:encoding()> のような)外部読み込みの層はロードするために
IO が必要だからです!
デフォルトとして外部エンコーディングを追加する方法については
L<"open pragma"|open> を参照してください。

=begin original

Layers it makes sense to include in the PERLIO environment
variable are briefly summarized below. For more details see L<PerlIO>.

=end original

PERLIO 環境変数に加えることが妥当な層の簡単な一覧を以下に示します。
詳細については L<PerlIO> を参照してください。

=over 8

=item :crlf
X<:crlf>

=begin original

A layer which does CRLF to C<"\n"> translation distinguishing "text" and
"binary" files in the manner of MS-DOS and similar operating systems,
and also provides buffering similar to C<:perlio> on these architectures.

=end original

"テキスト"と"バイナリ"ファイルを識別する CRLF から C<"\n"> への変換を
MS-DOS 及び似たようなオペレーティングシステムの方式で行い
それらのアーキテクチャの C<:perlio> と同様のバッファリングを提供する層です。

=item :perlio
X<:perlio>

=begin original

This is a re-implementation of stdio-like buffering written as a
PerlIO layer.  As such it will call whatever layer is below it for
its operations, typically C<:unix>.

=end original

これは stdio 風のバッファリングを PerlIO 層として再実装したものです。
従ってどのような層からも操作時に呼び出されます(典型的には C<:unix>)。

=item :stdio
X<:stdio>

=begin original

This layer provides a PerlIO interface by wrapping system's ANSI C "stdio"
library calls. The layer provides both buffering and IO.
Note that the C<:stdio> layer does I<not> do CRLF translation even if that
is the platform's normal behaviour. You will need a C<:crlf> layer above it
to do that.

=end original

この層はシステムの ANSI C "stdio" ライブラリコールをラップした
PerlIO インターフェースを提供します。
この層はバッファリングと IO の両方を提供します。
C<:stdio> 層は CRLF 変換を I<行わない> ことに注意してください; たとえそれが
プラットフォームの通常の振る舞いであっても、です。
これを行うためには C<:crlf> 層が必要です。

=item :unix
X<:unix>

=begin original

Low-level layer that calls C<read>, C<write>, C<lseek>, etc.

=end original

C<read>, C<write>, C<lseek> などを呼び出す低レベル層です。

=back

=begin original

The default set of layers should give acceptable results on all platforms.

=end original

全てのプラットフォームでデフォルトの層の組み合わせは納得できる結果に
なっているはずです。

=begin original

For Unix platforms that will be the equivalent of ":unix:perlio" or ":stdio".
Configure is set up to prefer the ":stdio" implementation if the system's library
provides for fast access to the buffer (not common on modern architectures);
otherwise, it uses the ":unix:perlio" implementation.

=end original

Unix プラットフォームではこれは ":unix:perlio" または ":stdio" と等価です。
Configure スクリプトは、システムのライブラリがバッファへの高速アクセス方法を
提供する場合 (最近のアーキテクチャでは一般的ではありません) は
":stdio" 実装を使うよう設定します; そうでなければ
":unix:perlio" 実装を使います。

=begin original

On Win32 the default in this release (5.30) is ":unix:crlf". Win32's ":stdio"
has a number of bugs/mis-features for Perl IO which are somewhat depending
on the version and vendor of the C compiler. Using our own C<:crlf> layer as
the buffer avoids those issues and makes things more uniform.

=end original

このリリース (5.30) では Win32 でのデフォルトは":unix:crlf"です。
Win32 の":stdio" は perl IO にとって、C コンパイラのベンダー/バージョン依存の
大量のバグ/仕様漏れがあります。
バッファとして自身の C<:crlf> 層を使うことでこれらの問題を回避し、
物事をより一貫したものにします。

=begin original

This release (5.30) uses C<:unix> as the bottom layer on Win32, and so still
uses the C compiler's numeric file descriptor routines.

=end original

このリリース (5.30) では Win32 での基底層として C<:unix> を使うことで、未だに
C コンパイラの数値のファイル記述子ルーチンを使います。

=begin original

The PERLIO environment variable is completely ignored when Perl
is run in taint mode.

=end original

PERLIO 環境変数は、Perl が汚染モードで実行されるときには完全に無視されます。

=item PERLIO_DEBUG
X<PERLIO_DEBUG>

=begin original

If set to the name of a file or device when Perl is run with the
L<-Di|/-Dletters> command-line switch, the logging of certain operations
of the PerlIO subsystem will be redirected to the specified file rather
than going to stderr, which is the default. The file is opened in append
mode. Typical uses are in Unix:

=end original

Perl が L<-Di|/-Dletters> コマンドラインオプション付きで実行されているときに、
ファイルまたはデバイスの名前をセットすると、PerlIO サブシステムのいくつかの
操作のログが、デフォルトである stderr ではなく、指定されたファイルに
リダイレクトされます。
ファイルは追記モードで記録されます。
Unix での典型的な使い方は以下の通りです:

   % env PERLIO_DEBUG=/tmp/perlio.log perl -Di script ...

=begin original

and under Win32, the approximately equivalent:

=end original

Win32 では以下がほぼ等価です:

   > set PERLIO_DEBUG=CON
   perl -Di script ...

=begin original

This functionality is disabled for setuid scripts, for scripts run
with L</-T>, and for scripts run on a Perl built without C<-DDEBUGGING>
support.

=end original

この機能は、setuid されたスクリプトや L</-T> で実行されているスクリプト、
あるいは C<-DDEBUGGING> 対応なしでビルドされた Perl で実行された場合は
無効になります。

=item PERLLIB
X<PERLLIB>

=begin original

A list of directories in which to look for Perl library
files before looking in the standard library.
If L</PERL5LIB> is defined, PERLLIB is not used.

=end original

Perl のライブラリファイルを探すときに標準ライブラリを
探す前に探すディレクトリのリストです。
L</PERL5LIB> が定義されていると、PERLLIB は使われません。

=begin original

The PERLLIB environment variable is completely ignored when Perl
is run in taint mode.

=end original

PERLLIB 環境変数は、Perl が汚染モードで実行されるときには完全に
無視されます。

=item PERL5DB
X<PERL5DB>

=begin original

The command used to load the debugger code.  The default is:

=end original

デバッガコードを読み込むのに使われるコマンドです。
デフォルトは以下の通り:

	BEGIN { require "perl5db.pl" }

=begin original

The PERL5DB environment variable is only used when Perl is started with
a bare L</-d> switch.

=end original

PERL5DB 環境変数は Perl が裸の L</-d> スイッチで開始されたときにのみ
使われます。

=item PERL5DB_THREADED
X<PERL5DB_THREADED>

=begin original

If set to a true value, indicates to the debugger that the code being
debugged uses threads.

=end original

真の値にセットされると、デバッグするコードがスレッドを使うことをデバッガに
示します。

=item PERL5SHELL (specific to the Win32 port)
X<PERL5SHELL>

=begin original

On Win32 ports only, may be set to an alternative shell that Perl must use
internally for executing "backtick" commands or system().  Default is
C<cmd.exe /x/d/c> on WindowsNT and C<command.com /c> on Windows95.  The
value is considered space-separated.  Precede any character that
needs to be protected, like a space or backslash, with another backslash.

=end original

Win32 版だけのもので、
"バッククォート" コマンドや system() を実行するために Perl が内部的に
使わなければならない代替シェルを指定します。
デフォルトは WindowsNT では C<cmd.exe /x/d/c>、Windows95 では
C<command.com /c> です。
値はスペース区切りと考えられます。
空白やバックスラッシュのような、保護する必要がある文字の前には
バックスラッシュがつけられます。

=begin original

Note that Perl doesn't use COMSPEC for this purpose because
COMSPEC has a high degree of variability among users, leading to
portability concerns.  Besides, Perl can use a shell that may not be
fit for interactive use, and setting COMSPEC to such a shell may
interfere with the proper functioning of other programs (which usually
look in COMSPEC to find a shell fit for interactive use).

=end original

COMSPEC の値はユーザーによってかなり様々で、移植性の問題を引き起こすので、
Perl はこの目的に COMSPEC は使わないことに注意してください。
さらに、Perl は対話的な用途には向かないシェルも利用できますが、
COMSPEC にそのようなシェルを指定すると他のプログラム
(普通は対話的な用途に適したシェルを探すのに COMSPEC を使います)の適切な
利用を邪魔するかもしれません。

=begin original

Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked
when running external commands.  It is recommended that
you explicitly set (or delete) C<$ENV{PERL5SHELL}> when running
in taint mode under Windows.

=end original

Perl 5.10.0 と 5.8.8 以前では、PERL5SHELL は外部コマンドを実行するときに
汚染チェックされませんでした。
Windows 上で汚染モードで実行するときには、明示的に C<$ENV{PERL5SHELL}> を
設定(または削除)することを勧めます。

=item PERL_ALLOW_NON_IFS_LSP (specific to the Win32 port)
X<PERL_ALLOW_NON_IFS_LSP>

=begin original

Set to 1 to allow the use of non-IFS compatible LSPs (Layered Service Providers).
Perl normally searches for an IFS-compatible LSP because this is required
for its emulation of Windows sockets as real filehandles.  However, this may
cause problems if you have a firewall such as I<McAfee Guardian>, which requires
that all applications use its LSP but which is not IFS-compatible, because clearly
Perl will normally avoid using such an LSP.

=end original

1 にセットすると、IFS 非互換の LSP (Layered Service Providers) を
使えるようにします。
Perl は普通 IFS 互換の LSP を探します; Windows のソケットを本当の
ファイルハンドルとしてエミュレートするために必要だからです。
しかし、これは全てのアプリケーションが IFS 非互換の自身の LSP を使うことを
求める I<McAfee Guardian> のようなファイアウォールでは問題が起きます;
明らかに、Perl は普通そのような LSP を使うことを避けるからです。

=begin original

Setting this environment variable to 1 means that Perl will simply use the
first suitable LSP enumerated in the catalog, which keeps I<McAfee Guardian>
happy--and in that particular case Perl still works too because I<McAfee
Guardian>'s LSP actually plays other games which allow applications
requiring IFS compatibility to work.

=end original

この環境変数を 1 にセットすることで、 Perl は単にカタログに挙げられている
もののうち最初の適切な LSP を使用し、これにより I<McAfee Guardian> は
幸せなままです--そしてこの特定の場合においては、I<McAfee Guardian> の LSP は
実際には動作するために IFS 互換である必要があるアプリケーションのために
小細工をしているので、 Perl も正しく動きます。

=item PERL_DEBUG_MSTATS
X<PERL_DEBUG_MSTATS>

=begin original

Relevant only if Perl is compiled with the C<malloc> included with the Perl
distribution; that is, if C<perl -V:d_mymalloc> is "define".

=end original

Perl が Perl 配布パッケージに含まれる malloc ルーチンを使って
コンパイルされている場合にのみ有効です; つまり C<perl -V:d_mymalloc> が
"define" の場合です。

=begin original

If set, this dumps out memory statistics after execution.  If set
to an integer greater than one, also dumps out memory statistics
after compilation.

=end original

設定されると、実行後にメモリ状況が表示されます。
1 を超える数値が設定されると、コンパイル後にもメモリ状況を表示します。

=item PERL_DESTRUCT_LEVEL
X<PERL_DESTRUCT_LEVEL>

=begin original

Controls the behaviour of global destruction of objects and other
references.  See L<perlhacktips/PERL_DESTRUCT_LEVEL> for more information.

=end original

オブジェクトやその他のリファレンスのグローバルな
デストラクタの振る舞いを制御します。
さらなる情報については L<perlhack/PERL_DESTRUCT_LEVEL> を参照してください。

=item PERL_DL_NONLAZY
X<PERL_DL_NONLAZY>

=begin original

Set to C<"1"> to have Perl resolve I<all> undefined symbols when it loads
a dynamic library.  The default behaviour is to resolve symbols when
they are used.  Setting this variable is useful during testing of
extensions, as it ensures that you get an error on misspelled function
names even if the test suite doesn't call them.

=end original

1 にセットすると、 Perl は B<全ての> 未定義シンボルをダイナミック
ライブラリをロードしたときに解決します。
デフォルトの振る舞いは使われるときにシンボルを解決します。
この変数を設定することで、拡張機能のテスト時にたとえテストスイートが
呼び出さなくても関数名のスペルミスによるエラーを確実に受け取ることが
できるので便利です。

=item PERL_ENCODING
X<PERL_ENCODING>

=begin original

If using the C<use encoding> pragma without an explicit encoding name, the
PERL_ENCODING environment variable is consulted for an encoding name.

=end original

C<use encoding> プラグマを明示的なエンコーディング名を指定せずに使用した場合、
PERL_ENCODING 環境変数がエンコーディング名として使われます。

=item PERL_HASH_SEED
X<PERL_HASH_SEED>

=begin original

(Since Perl 5.8.1, new semantics in Perl 5.18.0)  Used to override
the randomization of Perl's internal hash function. The value is expressed
in hexadecimal, and may include a leading 0x. Truncated patterns
are treated as though they are suffixed with sufficient 0's as required.

=end original

(Perl 5.8.1 から; 新しい意味論は Perl 5.18.0 から)
Perl の内部ハッシュ関数のランダム化をオーバーライドするために使います。
値は 16 進数で表現され、先頭の 0x を含んでいてもかまいません。
切りつめられたパターンは、必要な分の 0 が前置されているものとして扱われます。

=begin original

If the option is provided, and C<PERL_PERTURB_KEYS> is NOT set, then
a value of '0' implies C<PERL_PERTURB_KEYS=0>/C<PERL_PERTURB_KEYS=NO>
and any other value implies
C<PERL_PERTURB_KEYS=2>/C<PERL_PERTURB_KEYS=DETERMINISTIC>. See the
documentation for L<PERL_PERTURB_KEYS|/PERL_PERTURB_KEYS> for important
caveats regarding the C<DETERMINISTIC> mode.

=end original

オプションが指定されて、C<PERL_PERTURB_KEYS> が設定されていないと、
値 '0' は 
C<PERL_PERTURB_KEYS=0>/C<PERL_PERTURB_KEYS=NO> として扱い、その他の値は
C<PERL_PERTURB_KEYS=2>/C<PERL_PERTURB_KEYS=DETERMINISTIC> として扱います。
C<DETERMINISTIC> モードに関する重要な問題点については
L<PERL_PERTURB_KEYS|/PERL_PERTURB_KEYS> の文書を参照してください。

=begin original

B<PLEASE NOTE: The hash seed is sensitive information>. Hashes are
randomized to protect against local and remote attacks against Perl
code. By manually setting a seed, this protection may be partially or
completely lost.

=end original

B<ハッシュの種は微妙な問題であることに注意してください>。
ハッシュは Perl コードに対するローカル・リモート攻撃から守るために
ランダム化されます。
手動で種を設定することによりこの守りは部分的に、あるいは完全に失われます。

=begin original

See L<perlsec/"Algorithmic Complexity Attacks">, L</PERL_PERTURB_KEYS>, and
L</PERL_HASH_SEED_DEBUG> for more information.

=end original

さらなる情報については L<perlsec/"Algorithmic Complexity Attacks">,
L</PERL_PERTURB_KEYS>, L</PERL_HASH_SEED_DEBUG> を参照してください。

=item PERL_PERTURB_KEYS
X<PERL_PERTURB_KEYS>

=begin original

(Since Perl 5.18.0)  Set to C<"0"> or C<"NO"> then traversing keys
will be repeatable from run to run for the same C<PERL_HASH_SEED>.
Insertion into a hash will not change the order, except to provide
for more space in the hash. When combined with setting PERL_HASH_SEED
this mode is as close to pre 5.18 behavior as you can get.

=end original

(Perl 5.18.0 から)  C<"0"> または C<"NO"> を設定すると、同じ
C<PERL_HASH_SEED> でのキーの探索順序は毎回同じになります。
ハッシュへの挿入は、ハッシュの容量が増える場合を除き、順序を変更しません。
PERL_HASH_SEED を設定することと組み合わせると、可能な限り 5.18 より前の
振る舞いに近づきます。

=begin original

When set to C<"1"> or C<"RANDOM"> then traversing keys will be randomized.
Every time a hash is inserted into the key order will change in a random
fashion. The order may not be repeatable in a following program run
even if the PERL_HASH_SEED has been specified. This is the default
mode for perl when no PERL_HASH_SEED has been explicitly provided.

=end original

C<"1"> または C<"RANDOM"> を設定すると、キーの探索はランダム化されます。
ハッシュにキーが挿入される毎に、順序はランダムに変わります。
順序は、PERL_HASH_SEED が指定されていても、プログラムを再び実行したときに
再現できません。
これは、PERL_HASH_SEED が明示的に設定されていない場合は、
perl のデフォルトのモードです。

=begin original

When set to C<"2"> or C<"DETERMINISTIC"> then inserting keys into a hash
will cause the key order to change, but in a way that is repeatable from
program run to program run, provided that the same hash seed is used,
and that the code does not itself perform any non-deterministic
operations and also provided exactly the same environment context.
Adding or removing an environment variable may and likely will change
the key order. If any part of the code builds a hash using non-
deterministic keys, for instance a hash keyed by the stringified form of
a reference, or the address of the objects it contains, then this may
and likely will have a global effect on the key order of *every* hash in
the process. To work properly this setting MUST be coupled with the
L<PERL_HASH_SEED|/"PERL_HASH_SEED"> to produce deterministic results,
and in fact, if you do set the C<PERL_HASH_SEED> explicitly you do not
need to set this as well, it will be automatically set to this mode.

=end original

C<"2"> または C<"DETERMINISTIC"> に設定すると、ハッシュへのキーの挿入によって
キーの順序が変わりますが、同じハッシュキーが使われ、
コード自体が非決定的な操作をせず、正確に同じ環境コンテキストを
提供すれば、プログラムを再び実行したときには再現可能です。
環境変数を追加または削除すると、おそらくキーの順序が変わりますう。
コードのどこかが非決定的なキーを使ったハッシュ、
例えばリファレンスの文字列化形式や、それを含むオブジェクトのアドレスを
キーにしたハッシュを構築すると、これはおそらくプロセス中の
「全ての」ハッシュのキーの順序にグローバルな影響を与えます。
これが正しく動作するには、決定的な結果を生成するために
L<PERL_HASH_SEED|/"PERL_HASH_SEED"> と共に使われなければならず、
実際の所、C<PERL_HASH_SEED> を明示的に設定した場合、
これも設定する必要はありません; 自動的にこのモードに設定されます。

=begin original

B<NOTE:> Use of this option is considered insecure, and is intended only
for debugging non-deterministic behavior in Perl's hash function. Do
not use it in production.

=end original

B<注意:> このオプションはセキュアではないと考えられていて、Perl のハッシュ関数の
非決定的な振る舞いのデバッグ専用であることを意図しています。
製品で使わないでください。

=begin original

See L<perlsec/"Algorithmic Complexity Attacks"> and L</PERL_HASH_SEED>
and L</PERL_HASH_SEED_DEBUG> for more information. You can get and set the
key traversal mask for a specific hash by using the C<hash_traversal_mask()>
function from L<Hash::Util>.

=end original

さらなる情報については L<perlsec/"Algorithmic Complexity Attacks">,
L</PERL_HASH_SEED>, L</PERL_HASH_SEED_DEBUG> を参照してください。
L<Hash::Util> にある C<hash_traversal_mask()> を使うことで、特定のハッシュに
対するキー探索マスクを取得および設定できます。

=item PERL_HASH_SEED_DEBUG
X<PERL_HASH_SEED_DEBUG>

=begin original

(Since Perl 5.8.1.)  Set to C<"1"> to display (to STDERR) information
about the hash function, seed, and what type of key traversal
randomization is in effect at the beginning of execution.  This, combined
with L</PERL_HASH_SEED> and L</PERL_PERTURB_KEYS> is intended to aid in
debugging nondeterministic behaviour caused by hash randomization.

=end original

(Perl 5.8.1 から。)
これを C<"1"> に設定すると、実行開始時にハッシュ関数、種、どの種類のキー横断
ランダム化が有効かに関する情報を画面(STDERR)に出力します。
これは L</PERL_HASH_SEED> および L</PERL_PERTURB_KEYS> と組み合わせることで
ハッシュのランダム化による非決定的な振る舞いのデバッグを助けることを
目的としています。

=begin original

B<Note> that any information about the hash function, especially the hash
seed is B<sensitive information>: by knowing it, one can craft a denial-of-service
attack against Perl code, even remotely; see L<perlsec/"Algorithmic Complexity Attacks">
for more information. B<Do not disclose the hash seed> to people who
don't need to know it. See also L<C<hash_seed()>|Hash::Util/hash_seed> and
L<C<hash_traversal_mask()>|Hash::Util/hash_traversal_mask>.

=end original

ハッシュ関数に関する情報、特にハッシュの種は B<微妙な問題> であることに
B<注意してください>: これを知ることで、リモートからでも Perl のコードに対して
サービス拒否攻撃を仕掛けることが出来ます; さらなる情報については
L<perlsec/"Algorithmic Complexity Attacks"> を参照してください。
知る必要のない人々に対して B<ハッシュの種を公開しないでください>。
L<C<hash_seed()>|Hash::Util/hash_seed> と
L<C<hash_traversal_mask()>|Hash::Util/hash_traversal_mask> も
参照してください。

=begin original

An example output might be:

=end original

出力の例は以下のようなものです:

 HASH_FUNCTION = ONE_AT_A_TIME_HARD HASH_SEED = 0x652e9b9349a7a032 PERTURB_KEYS = 1 (RANDOM)

=item PERL_MEM_LOG
X<PERL_MEM_LOG>

=begin original

If your Perl was configured with B<-Accflags=-DPERL_MEM_LOG>, setting
the environment variable C<PERL_MEM_LOG> enables logging debug
messages. The value has the form C<< <I<number>>[m][s][t] >>, where
C<I<number>> is the file descriptor number you want to write to (2 is
default), and the combination of letters specifies that you want
information about (m)emory and/or (s)v, optionally with
(t)imestamps. For example, C<PERL_MEM_LOG=1mst> logs all
information to stdout. You can write to other opened file descriptors
in a variety of ways:

=end original

Perl が B<-Accflags=-DPERL_MEM_LOG> で設定されていると、環境変数
C<PERL_MEM_LOG> を設定することでデバッグメッセージのログ出力を有効にします。
値は C<< <I<number>>[m][s][t] >> の形式で、C<I<number>> は書き込みたい
ファイル記述子番号 (デフォルトは 2)、文字の組み合わせはメモリ (m) と SV(s) で、
オプションとしてタイプスタンプ (t) です。
例えば、C<PERL_MEM_LOG=1mst> は全てのログ情報を標準出力に出力します。
応用として、開いている他のファイル記述子に書き込むこともできます:

  $ 3>foo3 PERL_MEM_LOG=3m perl ...

=item PERL_ROOT (specific to the VMS port)
X<PERL_ROOT>

=begin original

A translation-concealed rooted logical name that contains Perl and the
logical device for the @INC path on VMS only.  Other logical names that
affect Perl on VMS include PERLSHR, PERL_ENV_TABLES, and
SYS$TIMEZONE_DIFFERENTIAL, but are optional and discussed further in
L<perlvms> and in F<README.vms> in the Perl source distribution.

=end original

Perl と VMS 専用の @INC のための論理デバイスを含む、
変換が隠されたルートとなる論理名です。
VMS の Perl に影響を与えるその他の論理名としては PERLSHR, PERL_ENV_TABLES,
SYS$TIMEZONE_DIFFERENTIAL がありますが、これらはオプションです;
詳細については Perl ソース配布パッケージの L<perlvms> と F<README.vms> で
議論されています。

=item PERL_SIGNALS
X<PERL_SIGNALS>

=begin original

Available in Perls 5.8.1 and later.  If set to C<"unsafe">, the pre-Perl-5.8.0
signal behaviour (which is immediate but unsafe) is restored.  If set
to C<safe>, then safe (but deferred) signals are used.  See
L<perlipc/"Deferred Signals (Safe Signals)">.

=end original

Perl 5.8.1 以降で有効です。
これに C<unsafe> をセットすると、Perl 5.8.0 以前のシグナルの振る舞い
(直接的ですが安全ではありません)が復元されます。
C<safe> をセットすると安全な(しかし遅延する)シグナルが使われます。
L<perlipc/"Deferred Signals (Safe Signals)"> を参照してください。

=item PERL_UNICODE
X<PERL_UNICODE>

=begin original

Equivalent to the L<-C|/-C [numberE<sol>list]> command-line switch.  Note
that this is not a boolean variable. Setting this to C<"1"> is not the
right way to "enable Unicode" (whatever that would mean).  You can use
C<"0"> to "disable Unicode", though (or alternatively unset PERL_UNICODE
in your shell before starting Perl).  See the description of the
L<-C|/-C [numberE<sol>list]> switch for more information.

=end original

L<-C|/-C [numberE<sol>list]> コマンドラインスイッチと等価です。
これは真偽値変数ではないことに注意してください。
これを C<"1"> にセットすることは(どんな意味においても)「Unicode を
有効にする」ための正しい方法ではありません。
しかし、「Unicode を無効にする」ために C<"0"> をセットすることは出来ます
(あるいは Perl の起動前にあなたのお使いのシェルで PERL_UNICODE を
未設定にすることでも出来ます)。
さらなる情報については L<-C|/-C [numberE<sol>list]> スイッチの説明を
参照してください。

=item PERL_USE_UNSAFE_INC
X<PERL_USE_UNSAFE_INC>

=begin original

If perl has been configured to not have the current directory in
L<C<@INC>|perlvar/@INC> by default, this variable can be set to C<"1">
to reinstate it.  It's primarily intended for use while building and
testing modules that have not been updated to deal with "." not being in
C<@INC> and should not be set in the environment for day-to-day use.

=end original

perl がデフォルトで L<C<@INC>|perlvar/@INC> にカレントディレクトリを
含まないように設定されている場合、
これを再設定するためにこの変数を C<"1"> にできます。
これは、C<@INC> に "." がなくても動作するように更新されていないモジュールの
ビルドとテストのために使うことを第一の目的としているので、
日常使用環境では設定するべきではありません。

=item SYS$LOGIN (specific to the VMS port)
X<SYS$LOGIN>

=begin original

Used if chdir has no argument and L</HOME> and L</LOGDIR> are not set.

=end original

chdir の引数がなく、L</HOME> と
L</LOGDIR> がセットされていないときに使われます。

=item PERL_INTERNAL_RAND_SEED
X<PERL_INTERNAL_RAND_SEED>

=begin original

Set to a non-negative integer to seed the random number generator used
internally by perl for a variety of purposes.

=end original

様々な目的のために、perl によって内部で使われる乱数生成器の種となる
非負整数を設定します。

=begin original

Ignored if perl is run setuid or setgid.  Used only for some limited
startup randomization (hash keys) if C<-T> or C<-t> perl is started
with tainting enabled.

=end original

perl が setuid または setgid で実行されている場合は無視されます。
C<-T> や C<-t> perl が汚染モードを有効にして開始された場合、
一部の制限されたランダム化の設定(ハッシュキー)のみに使われます。

=begin original

Perl may be built to ignore this variable.

=end original

Perl はこの変数を無視するようにビルドされているかもしれません。

=item PERL_RAND_SEED
X<PERL_RAND_SEED>

=begin original

When set to an integer value this value will be used to seed the perl
internal random number generator used for C<rand()> when it is used
without an explicit C<srand()> call or for when an explicit no-argument
C<srand()> call is made.

=end original

When set to an integer value this value will be used to seed the perl
internal random number generator used for C<rand()> when it is used
without an explicit C<srand()> call or for when an explicit no-argument
C<srand()> call is made.
(TBT)

=begin original

Normally calling C<rand()> prior to calling C<srand()> or calling
C<srand()> explicitly with no arguments should result in the random
number generator using "best efforts" to seed the generator state with a
relatively high quality random seed. When this environment variable is
set then the seeds used will be deterministically computed from the
value provided in the env var in such a way that the application process
and any forks or threads should continue to have their own unique seed but
that the program may be run twice with identical results as far as
C<rand()> goes (assuming all else is equal).

=end original

Normally calling C<rand()> prior to calling C<srand()> or calling
C<srand()> explicitly with no arguments should result in the random
number generator using "best efforts" to seed the generator state with a
relatively high quality random seed. When this environment variable is
set then the seeds used will be deterministically computed from the
value provided in the env var in such a way that the application process
and any forks or threads should continue to have their own unique seed but
that the program may be run twice with identical results as far as
C<rand()> goes (assuming all else is equal).
(TBT)

=begin original

PERL_RAND_SEED is intended for performance measurements and debugging
and is explicitly NOT intended for stable testing. The only guarantee is
that a specific perl executable will produce the same results twice in a
row, there is no guarantee that the results will be the same between
perl releases or on different architectures.

=end original

PERL_RAND_SEED is intended for performance measurements and debugging
and is explicitly NOT intended for stable testing. The only guarantee is
that a specific perl executable will produce the same results twice in a
row, there is no guarantee that the results will be the same between
perl releases or on different architectures.
(TBT)

=begin original

Ignored if perl is run setuid or setgid.

=end original

Ignored if perl is run setuid or setgid.
(TBT)

=back

=begin original

Perl also has environment variables that control how Perl handles data
specific to particular natural languages; see L<perllocale>.

=end original

特定の自然言語に特有のデータを Perl がどのように扱うかを制御する
環境変数もあります; L<perllocale> を参照してください。

=begin original

Perl and its various modules and components, including its test frameworks,
may sometimes make use of certain other environment variables.  Some of
these are specific to a particular platform.  Please consult the
appropriate module documentation and any documentation for your platform
(like L<perlsolaris>, L<perllinux>, L<perlmacosx>, L<perlwin32>, etc) for
variables peculiar to those specific situations.

=end original

Perl および様々なモジュールと、テストフレームワークを含む構成要素は、
ときどきその他の特定の環境変数を使うかもしれません。
その一部は特定のプラットフォームに固有です。
そのような特定の状況に特有の変数については適切なモジュールの文書と
(L<perlsolaris>, L<perllinux>, L<perlmacosx>, L<perlwin32> などのような)
プラットフォームの文書を参照してください。

=begin original

Perl makes all environment variables available to the program being
executed, and passes these along to any child processes it starts.
However, programs running setuid would do well to execute the following
lines before doing anything else, just to keep people honest:

=end original

Perl は、実行されたプログラムへの全ての環境変数を利用可能にし、
子プロセスが開始されたときにはそれらを渡します。
しかし、setuid で動作するプログラムは何かをする前に、単に人々に変な気を
起こさせないために以下のコードを入れておくのがよいです。

    $ENV{PATH}  = "/bin:/usr/bin";    # or whatever you need
    $ENV{SHELL} = "/bin/sh" if exists $ENV{SHELL};
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

=head1 ORDER OF APPLICATION

(適用の順序)

=begin original

Some options, in particular C<-I>, C<-M>, C<PERL5LIB> and C<PERL5OPT> can
interact, and the order in which they are applied is important.

=end original

一部のオプション、特に C<-M>, C<PERL5LIB>, C<PERL5OPT> は相互作用するので、
これらが適用される順序は重要です。

=begin original

Note that this section does not document what I<actually> happens inside the
perl interpreter, it documents what I<effectively> happens.

=end original

この節は、perl インタプリタの中で I<実際に> 何が起きるかを
記述しているのではなく、I<事実上> 何が起きるかを記述していることに
注意してください。

=over

=item -I

=begin original

The effect of multiple C<-I> options is to C<unshift> them onto C<@INC>
from right to left. So for example:

=end original

複数 C<-I> オプションを指定した効果は、
これらを右から左に C<@INC> に C<unshift> します。
それで、例えば:

    perl -I 1 -I 2 -I 3

=begin original

will first prepend C<3> onto the front of C<@INC>, then prepend C<2>, and
then prepend C<1>. The result is that C<@INC> begins with:

=end original

はまず C<@INC> の先頭に C<3> を追加し、それから C<2> を追加し、
それから C<1> を追加します。
結果として、C<@INC> は次で始まります:

    qw(1 2 3)

=item -M

=begin original

Multiple C<-M> options are processed from left to right. So this:

=end original

複数の C<-M> オプションは、左から右に処理されます。
それで、これは:

    perl -Mlib=1 -Mlib=2 -Mlib=3

=begin original

will first use the L<lib> pragma to prepend C<1> to C<@INC>, then
it will prepend C<2>, then it will prepend C<3>, resulting in an C<@INC>
that begins with:

=end original

まず C<@INC> の先頭に C<1> を追加するために L<lib> プラグマが使われ、
それから C<2> を追加し、それから C<3> 追加して、結果として C<@INC> は
次のもので始まります:

    qw(3 2 1)

=item the PERL5LIB environment variable

=begin original

This contains a list of directories, separated by colons. The entire list
is prepended to C<@INC> in one go. This:

=end original

これはコロンで区切られたディレクトリのリストを含みます。
リスト全体は一度に C<@INC> の先頭に追加されます。
これは:

    PERL5LIB=1:2:3 perl

=begin original

will result in an C<@INC> that begins with:

=end original

C<@INC> が次のもので始まる結果となります:

    qw(1 2 3)

=item combinations of -I, -M and PERL5LIB

(-I, -M, PERL5LIB の組み合わせ)

=begin original

C<PERL5LIB> is applied first, then all the C<-I> arguments, then all the
C<-M> arguments. This:

=end original

C<PERL5LIB> は最初に適用され、それから全ての C<-I> 引数、それから全ての
C<-M> 引数です。
これは:

    PERL5LIB=e1:e2 perl -I i1 -Mlib=m1 -I i2 -Mlib=m2

=begin original

will result in an C<@INC> that begins with:

=end original

C<@INC> が次のもので始まる結果となります:

    qw(m2 m1 i1 i2 e1 e2)

=item the PERL5OPT environment variable

=begin original

This contains a space separated list of switches. We only consider the
effects of C<-M> and C<-I> in this section.

=end original

これはスペースで区切られたオプションのリストです。
この節では C<-M> と C<-I> の効果だけを考慮します。

=begin original

After normal processing of C<-I> switches from the command line, all
the C<-I> switches in C<PERL5OPT> are extracted. They are processed from
left to right instead of from right to left. Also note that while
whitespace is allowed between a C<-I> and its directory on the command
line, it is not allowed in C<PERL5OPT>.

=end original

コマンドラインからの C<-I> オプションの通常の処理の後、
C<PERL5OPT> の全ての C<-I> オプションが展開されます。
これらは右から左ではなく、左から右に処理されます。
また、コマンドラインでは C<-I とディレクトリの間に空白が許されますが、
C<PERL5OPT> では許されないことにも注意してください。

=begin original

After normal processing of C<-M> switches from the command line, all
the C<-M> switches in C<PERL5OPT> are extracted. They are processed from
left to right, I<i.e.> the same as those on the command line.

=end original

コマンドラインからの C<-M> オプションの通常の処理の後、
C<PERL5OPT> の全ての C<-M> オプションが展開されました。
これらは左から右に処理されます; I<つまり> コマンドラインと同じです。

=begin original

An example may make this clearer:

=end original

この例でよりはっきりするでしょう:

    export PERL5OPT="-Mlib=optm1 -Iopti1 -Mlib=optm2 -Iopti2"
    export PERL5LIB=e1:e2
    perl -I i1 -Mlib=m1 -I i2 -Mlib=m2

=begin original

will result in an C<@INC> that begins with:

=end original

C<@INC> が次のもので始まる結果となります:

    qw(
        optm2
        optm1

        m2
        m1

        opti2
        opti1

        i1
        i2

        e1
        e2
    )

=item Other complications

(その他の複雑なもの)

=begin original

There are some complications that are ignored in the examples above:

=end original

前述の例で無視されている複雑なものがいくつかあります:

=over

=item arch and version subdirs

(arch と version subdirs)

=begin original

All of C<-I>, C<PERL5LIB> and C<use lib> will also prepend arch and version
subdirs if they are present

=end original

C<-I>, C<PERL5LIB>, C<use lib> の全ては、
(存在すれば) arch と version サブディレクトリが前置されます。

=item sitecustomize.pl

=back

=back

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: SHIRAKATA Kentaro <argrath@ub32.org>
Status: in progress

=end meta

