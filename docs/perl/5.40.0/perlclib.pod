
=encoding utf8

=head1 NAME

=begin original

perlclib - Interacting with standard C library functions

=end original

perlclib - 標準 C ライブラリ関数との相互作用

(訳注: (TBR)がついている段落は「みんなの自動翻訳＠TexTra」による
機械翻訳です。)

=head1 DESCRIPTION

=begin original

The perl interpreter is written in C; XS code also expands to C.
Inevitably, this code will call some functions from the C library,
C<libc>.  This document gives some guidance on interfacing with that
library.

=end original

perl インタプリタは C で書かれています; XS コードも C に展開されます。
必然的に、このコードは C ライブラリ、C<libc> からいくつかの関数を
呼び出します。
この文書では、このライブラリとのインターフェースに関するいくつかの
手引きを提供します。

=begin original

One thing Perl porters should note is that F<perl> doesn't tend to use that
much of the C standard library internally; you'll see very little use of, 
for example, the F<ctype.h> functions in there. This is because Perl
tends to reimplement or abstract standard library functions, so that we
know exactly how they're going to operate.

=end original

Perl porters が注意するべき事のひとつは、F<perl> は内部で C 標準ライブラリを
あまり使わないようにしていると言うことです; 例えば、F<ctype.h> 関数は
ほとんど使われていないことに気付くでしょう。
これは、どのような操作をしようとしているかを正確に知るために、Perl は
標準ライブラリ関数を再実装したり抽象化したりしようとするからです。

=head1 libc functions to avoid

(避けるべき libc 関数)

=begin original

There are many many libc functions.  Most of them are fair game to use,
but some are not.  Some of the possible reasons are:

=end original

libc 関数はとてもたくさんあります。
それらのほとんどは使っても問題ありませんが、一部はそうではありません。
その理由のいくつかは次のようなものです:

=over

=item *

=begin original

They likely will interfere with the perl interpreter's functioning,
such as its bookkeeping, or signal handling, or memory allocation,
or any number of harmful things.

=end original

これらは、perl インタプリタの機能(保守、シグナル処理、メモリ割り当て、
その他の有害なことなど)に干渉する可能性があります。

=item *

=begin original

They aren't implemented on all platforms, but there is an alternative
that is.

=end original

これらは全てのプラットフォームでは実装されていませんが、
代替策があります。

=begin original

Or they may be buggy or deprecated on some or all platforms.

=end original

あるいはこれらは一部または全てのプラットフォームで
バグっぽいか非推奨です。

=item *

=begin original

They aren't suitable for multi-threaded operation, but there is an
alternative that is, and is just as easily usable.

=end original

これらはマルチスレッド操作に適していませんが、
代替策があり、簡単に利用できます。

=begin original

You may not expect your code to ever be used under threads, but code has
a way of being adapted beyond our initial expectations.  If it is just
as easy to use something that can be used under threads, it's better to
use that now, just in case.

=end original

あなたは自分のコードがスレッドの下で使われることを
想定していないかもしれませんが、コードとは私たちの当初の期待を超えて
適応されるものです。
スレッドの下で使えるものを同じように簡単に使えるのであれば、
念のため今すぐ使う方がよいでしょう。

=item *

=begin original

In functions that deal with strings, complications may arise because the
string may be encoded in different ways, for example in UTF-8.  For
these, it is likely better to place the string in a SV and use the Perl
SV string handling functions that contain extensive logic to deal with
this.

=end original

文字列を扱う関数では、文字列が UTF-8 などのさまざまな方法で
エンコードされるため、複雑な問題が発生する可能性があります。
このような場合は、文字列を SV に配置し、これを処理するための
広範なロジックを含む Perl SV 文字列処理関数を使用することをお勧めします。

=item *

=begin original

In functions that deal with numbers, complications may arise because the
numbers get too big or small, and what those limits are depends on the
current platform.  Again, the Perl SV numeric data types have extensive
logic to take care of these kinds of issues.

=end original

数値を扱う関数では、数値が大きすぎたり小さすぎたりするために複雑な問題が
起こる可能性があり、その制限は現在のプラットフォームによって異なります。
繰り返しますが、Perl SV の数値データ型には、このような問題を処理するための
広範なロジックがあります。

=item *

=begin original

They are locale-aware, and your caller may not want this.

=end original

これらはロケールを認識し、呼び出し元はそれを望んでいません。

=back

=begin original

The following commentary and tables give some functions in the first
column that shouldn't be used in C or XS code, with the preferred
alternative (if any) in the second column.

=end original

以降の解説と表では、最初の列に C や XS のコードで使うべきではない関数を示し、
2 番目の列には(もしあれば)好ましい代替関数を示しています。

=head2 Conventions

(規約)

=begin original

In the following tables:

=end original

以下の表で:

=over 3

=item C<~>

=begin original

marks the function as deprecated; it should not be used regardless.

=end original

は関数が廃止予定である印です; とにかく使うべきではありません。

=item C<t>

=begin original

is a type.

=end original

は型です。

=item C<p>

=begin original

is a pointer.

=end original

はポインタです。

=item C<n>

=begin original

is a number.

=end original

は数値です。

=item C<s>

=begin original

is a string.

=end original

は文字列です。

=back

=begin original

C<sv>, C<av>, C<hv>, etc. represent variables of their respective types.

=end original

C<sv>, C<av>, C<hv> などはそれぞれ対応する型の変数です。

=head2 File Operations

(ファイル操作)

=begin original

Instead of the F<stdio.h> functions, you should use the Perl abstraction
layer. Instead of C<FILE*> types, you need to be handling C<PerlIO*>
types.  Don't forget that with the new PerlIO layered I/O abstraction 
C<FILE*> types may not even be available. See also the C<perlapio>
documentation for more information about the following functions:

=end original

F<stdio.h> 関数の代わりに、Perl 抽象層を使うべきです。
C<FILE*> 型の代わりに、C<PerlIO*> 型を扱う必要があります。
新しい PerlIO 層の I/O 抽象化では C<FILE*> 型は利用できないかも知れないことを
忘れないでください。
以下の関数に関するさらなる詳細については C<perlapio> 文書を
参照してください:

  Instead Of:                 Use:

  stdin                       PerlIO_stdin()
  stdout                      PerlIO_stdout()
  stderr                      PerlIO_stderr()

  fopen(fn, mode)             PerlIO_open(fn, mode)
  freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Dep-
                                recated)
  fflush(stream)              PerlIO_flush(perlio)
  fclose(stream)              PerlIO_close(perlio)

=head2 File Input and Output

(ファイル入力と出力)

  Instead Of:                 Use:

  fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)

  [f]getc(stream)             PerlIO_getc(perlio)
  [f]putc(stream, n)          PerlIO_putc(perlio, n)
  ungetc(n, stream)           PerlIO_ungetc(perlio, n)

=begin original

Note that the PerlIO equivalents of C<fread> and C<fwrite> are slightly
different from their C library counterparts:

=end original

C<fread> と C<fwrite> の PerlIO の代用品は C ライブラリの対応物とは
少し違うことに注意してください:

  fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
  fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)

  fputs(s, stream)            PerlIO_puts(perlio, s)

=begin original

There is no equivalent to C<fgets>; one should use C<sv_gets> instead:

=end original

C<fgets> の等価物はありません; 代わりに C<sv_gets> を使うべきです:

  fgets(s, n, stream)         sv_gets(sv, perlio, append)

=head2 File Positioning

(ファイル位置)

  Instead Of:                 Use:

  feof(stream)                PerlIO_eof(perlio)
  fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
  rewind(stream)              PerlIO_rewind(perlio)

  fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
  fsetpos(stream, p)          PerlIO_setpos(perlio, sv)

  ferror(stream)              PerlIO_error(perlio)
  clearerr(stream)            PerlIO_clearerr(perlio)

=head2 Memory Management and String Handling

(メモリ管理と文字列操作)

  Instead Of:                    Use:

  t* p = malloc(n)               Newx(p, n, t)
  t* p = calloc(n, s)            Newxz(p, n, t)
  p = realloc(p, n)              Renew(p, n, t)
  memcpy(dst, src, n)            Copy(src, dst, n, t)
  memmove(dst, src, n)           Move(src, dst, n, t)
  memcpy(dst, src, sizeof(t))    StructCopy(src, dst, t)
  memset(dst, 0, n * sizeof(t))  Zero(dst, n, t)
  memzero(dst, 0)                Zero(dst, n, char)
  free(p)                        Safefree(p)

  strdup(p)                      savepv(p)
  strndup(p, n)                  savepvn(p, n) (Hey, strndup doesn't
                                                exist!)

  strstr(big, little)            instr(big, little)
  memmem(big, blen, little, len) ninstr(big, bigend, little, little_end)
  strcmp(s1, s2)                 strLE(s1, s2) / strEQ(s1, s2)
                                               / strGT(s1,s2)
  strncmp(s1, s2, n)             strnNE(s1, s2, n) / strnEQ(s1, s2, n)

  memcmp(p1, p2, n)              memNE(p1, p2, n)
  !memcmp(p1, p2, n)             memEQ(p1, p2, n)

=begin original

Notice the different order of arguments to C<Copy> and C<Move> than used
in C<memcpy> and C<memmove>.

=end original

C<Copy> および C<Move> の引数の順番は C<memcpy> および C<memmove> と異なる
ことに注意してください。

=begin original

Most of the time, though, you'll want to be dealing with SVs internally
instead of raw C<char *> strings:

=end original

しかし、大抵の場合、生の C<char *> 文字列ではなく内部的に SV を
扱いたいでしょう:

  strlen(s)                   sv_len(sv)
  strcpy(dt, src)             sv_setpv(sv, s)
  strncpy(dt, src, n)         sv_setpvn(sv, s, n)
  strcat(dt, src)             sv_catpv(sv, s)
  strncat(dt, src)            sv_catpvn(sv, s)
  sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)

=begin original

If you do need raw strings, some platforms have safer interfaces, and
Perl makes sure a version of these are available on all platforms:

=end original

生の文字列に何かする必要がある場合、一部のプラットフォームは
より安全なインターフェースを持ち、Perl はこれらのバージョンが
全てのプラットフォームで利用可能であるようにしています:

  strlcat(dt, src, sizeof(dt)) my_strlcat(dt, src, sizeof(dt))
  strlcpy(dt, src, sizeof(dt)) my_strlcpy(dt, src, sizeof(dt))
  strnlen(s)                   my_strnlen(s, maxlen)

=begin original

Note also the existence of C<sv_catpvf> and C<sv_vcatpvfn>, combining
concatenation with formatting.

=end original

連結とフォーマッティングを結合した C<sv_catpvf> および C<sv_vcatpvfn> が
あることにも注意してください。

=begin original

Sometimes instead of zeroing the allocated heap by using Newxz() you
should consider "poisoning" the data.  This means writing a bit
pattern into it that should be illegal as pointers (and floating point
numbers), and also hopefully surprising enough as integers, so that
any code attempting to use the data without forethought will break
sooner rather than later.  Poisoning can be done using the Poison()
macros, which have similar arguments to Zero():

=end original

時々、Newxz() を使って割り当てられたヒープをゼロにする代わりにデータに
「毒入れ」したいかもしれません。
これは、ポインタ(および浮動小数点数)として不正になり、できれば整数としても
十分に驚くべきビットパターンを書き込んで、考えなしにデータを使おうとする
コードが早めに壊れるようにすることです。
毒入れは Zero() と似たような引数を持つ Poison() マクロで行えます:

  PoisonWith(dst, n, t, b)    scribble memory with byte b
  PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
  PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
  Poison(dst, n, t)           equal to PoisonFree(dst, n, t)

=head2 Character Class Tests

(文字クラステスト)

=begin original

There are several types of character class tests that Perl implements.
All are more fully described in L<perlapi/Character classification> and
L<perlapi/Character case changing>.

=end original

Perl が実装しているいくつか種類の文字クラステストがあります。
全ては L<perlapi/Character classification> と
L<perlapi/Character case changing> でより完全に記述されています。

=begin original

The C library routines listed in the table below return values based on
the current locale.  Use the entries in the final column for that
functionality.  The other two columns always assume a POSIX (or C)
locale.  The entries in the ASCII column are only meaningful for ASCII
inputs, returning FALSE for anything else.  Use these only when you
B<know> that is what you want.  The entries in the Latin1 column assume
that the non-ASCII 8-bit characters are as Unicode defines them, the
same as ISO-8859-1, often called Latin 1.

=end original

後述する表に挙げられている C ライブラリルーチンは現在のロケールを基にした
値を返します。
この機能のためには最後の列のエントリを使ってください。
残りの二つの列は常に POSIX (あるいは C) ロケールを仮定します。
ASCII 列のエントリは ASCII 入力でのみ意味を持ち、それ以外では FALSE を
返します。
これが望んでいるものであると B<分かっている> 場合にのみこれを使ってください。
Latin1 列のエントリは、非 ASCII 8 ビット文字は Unicode が定義しているように、
ISO-8859-1 (しばしば Latin 1 と呼ばれます) であると仮定します。

=begin original

  Instead Of:  Use for ASCII:   Use for Latin1:      Use for locale:

=end original

  元:         ASCII 用:         Latin1 用:           ロケール用:

  isalnum(c)  isALPHANUMERIC(c) isALPHANUMERIC_L1(c) isALPHANUMERIC_LC(c)
  isalpha(c)  isALPHA(c)        isALPHA_L1(c)        isALPHA_LC(u )
  isascii(c)  isASCII(c)                             isASCII_LC(c)
  isblank(c)  isBLANK(c)        isBLANK_L1(c)        isBLANK_LC(c)
  iscntrl(c)  isCNTRL(c)        isCNTRL_L1(c)        isCNTRL_LC(c)
  isdigit(c)  isDIGIT(c)        isDIGIT_L1(c)        isDIGIT_LC(c)
  isgraph(c)  isGRAPH(c)        isGRAPH_L1(c)        isGRAPH_LC(c)
  islower(c)  isLOWER(c)        isLOWER_L1(c)        isLOWER_LC(c)
  isprint(c)  isPRINT(c)        isPRINT_L1(c)        isPRINT_LC(c)
  ispunct(c)  isPUNCT(c)        isPUNCT_L1(c)        isPUNCT_LC(c)
  isspace(c)  isSPACE(c)        isSPACE_L1(c)        isSPACE_LC(c)
  isupper(c)  isUPPER(c)        isUPPER_L1(c)        isUPPER_LC(c)
  isxdigit(c) isXDIGIT(c)       isXDIGIT_L1(c)       isXDIGIT_LC(c)

  tolower(c)  toLOWER(c)        toLOWER_L1(c)
  toupper(c)  toUPPER(c)

=begin original

For the corresponding functions like C<iswupper()>, I<etc.>, use
C<isUPPER_uvchr()> for non-locale; or C<isUPPER_LC_uvchr()> for locale.
And use C<toLOWER_uvchr()> instead of C<towlower()>, I<etc.>.  There are
no direct equivalents for locale; best to put the string into an SV.

=end original

C<iswupper()> などの対応する関数では、ロケール以外の場合は
C<isUPPER_uvchr()> を、ロケールの場合は C<isUPPER_LC_uvchr()> を
使ってください。
また、C<towlower()> などの代わりに C<toLOWER_uvchr()> を使います。
ロケールに直接相当するものはありません;
文字列を SV に入れるのが最善です。

=begin original

Don't use any of the functions like C<isalnum_l()>.  Those are
non-portable, and interfere with Perl's internal handling.

=end original

C<isalnum_l()> のような関数はどれも使わないでください。
これらは移植性がなく、Perl の内部処理を妨害します。

=begin original

To emphasize that you are operating only on ASCII characters, you can
append C<_A> to each of the macros in the ASCII column: C<isALPHA_A>,
C<isDIGIT_A>, and so on.

=end original

念を押しておくと、ASCII 文字のみを操作するなら、ASCII の列のそれぞれの
マクロに C<_A> を追加したものが使えます: C<isALPHA_A>, C<isDIGIT_A> などです。

=begin original

(There is no entry in the Latin1 column for C<isascii> even though there
is an C<isASCII_L1>, which is identical to C<isASCII>;  the
latter name is clearer.  There is no entry in the Latin1 column for
C<toupper> because the result can be non-Latin1.  You have to use
C<toUPPER_uvchr>, as described in L<perlapi/Character case changing>.)

=end original

(C<isASCII> と等価な C<isASCII_L1> というものはありますが、C<isascii> の
Latin1 の列はありません; 前者の名前の方が明確です。
C<toupper> の Latin1 の列はありません; 結果は非 Latin1 に
なるかもしれないからです。
L<perlapi/Character case changing> に記述されている C<toUPPER_uvchr> を
使う必要があります。)

=begin original

Note that the libc caseless comparisons are crippled; Unicode
provides a richer set, using the concept of folding.  If you need
more than equality/non-equality, it's probably best to store your
strings in an SV and use SV functions to do the comparision.  Similarly
for collation.

=end original

libc の大文字小文字を区別しない比較は機能しないことに注意してください;
Unicode では、畳み込みの概念を使用して、より豊富な集合を提供します。
等価性/非等価性以上のものが必要な場合は、文字列を SV に格納し、SV 関数を
使って比較を行うのがおそらく最善です。
照合についても同様です。

=head2 F<stdlib.h> functions

(F<stdlib.h> 関数)

  Instead Of:                 Use:

  atof(s)                     my_atof(s) or Atof(s)
  atoi(s)                     grok_atoUV(s, &uv, &e)
  atol(s)                     grok_atoUV(s, &uv, &e)
  strtod(s, &p)               Strtod(s, &p)
  strtol(s, &p, n)            Strtol(s, &p, b)
  strtoul(s, &p, n)           Strtoul(s, &p, b)

=begin original

But note that these are subject to locale; see L</Dealing with locales>.

=end original

しかし、これらはロケールに依存することに注意してください;
L</Dealing with locales> を参照してください。

=begin original

Typical use is to do range checks on C<uv> before casting:

=end original

典型的な使用法は、キャストする前の C<uv> の範囲チェックです:

   int i; UV uv;
   char* end_ptr = input_end;
   if (grok_atoUV(input, &uv, &end_ptr)
       && uv <= INT_MAX)
     i = (int)uv;
     ... /* continue parsing from end_ptr */
   } else {
     ... /* parse error: not a decimal integer in range 0 .. MAX_IV */
   }

=begin original

Notice also the C<grok_bin>, C<grok_hex>, and C<grok_oct> functions in
F<numeric.c> for converting strings representing numbers in the respective
bases into C<NV>s.  Note that grok_atoUV() doesn't handle negative inputs,
or leading whitespace (being purposefully strict).

=end original

それぞれの基数で数値を表現している文字列を C<NV> に変換するための
F<numeric.c> にある C<grok_bin>, C<grok_hex>, C<grok_oct> 関数にも
注目してください。
grok_atoUV() は負の入力や先頭の空白を扱わないことに注意してください
(意図的に厳密にしています)。

=head2 Miscellaneous functions

(さまざまな関数)

=begin original

You should not even B<want> to use F<setjmp.h> functions, but if you
think you do, use the C<JMPENV> stack in F<scope.h> instead.

=end original

F<setjmp.h> 関数を使おうと B<思う> ことすらするべきではありませんが、もし
そう考えているなら、代わりに F<scope.h> の C<JMPENV> スタックを
使ってください。

 ~asctime()              Perl_sv_strftime_tm()
 ~asctime_r()            Perl_sv_strftime_tm()
  chsize()               my_chsize()
 ~ctime()                Perl_sv_strftime_tm()
 ~ctime_r()              Perl_sv_strftime_tm()
 ~cuserid()              DO NOT USE; see its man page
  dirfd()                my_dirfd()
  duplocale()            Perl_setlocale()
 ~ecvt()                 my_snprintf()
 ~endgrent_r()           endgrent()
 ~endhostent_r()         endhostent()
 ~endnetent_r()          endnetent()
 ~endprotoent_r()        endprotoent()
 ~endpwent_r()           endpwent()
 ~endservent_r()         endservent()
 ~endutent()             endutxent()
  exit(n)                my_exit(n)
 ~fcvt()                 my_snprintf()
  freelocale()           Perl_setlocale()
 ~ftw()                  nftw()
  getenv(s)              PerlEnv_getenv(s)
 ~gethostbyaddr()        getaddrinfo()
 ~gethostbyname()        getnameinfo()
 ~getpass()              DO NOT USE; see its man page
 ~getpw()                getpwuid()
 ~getutent()             getutxent()
 ~getutid()              getutxid()
 ~getutline()            getutxline()
 ~gsignal()              DO NOT USE; see its man page
  localeconv()           Perl_localeconv()
  mblen()                mbrlen()
  mbtowc()               mbrtowc()
  newlocale()            Perl_setlocale()
  pclose()               my_pclose()
  popen()                my_popen()
 ~pututline()            pututxline()
 ~qecvt()                my_snprintf()
 ~qfcvt()                my_snprintf()
  querylocale()          Perl_setlocale()
  int rand()             double Drand01()
  srand(n)               { seedDrand01((Rand_seed_t)n);
                           PL_srand_called = TRUE; }
 ~readdir_r()            readdir()
  realloc()              saferealloc(), Renew() or Renewc()
 ~re_comp()              regcomp()
 ~re_exec()              regexec()
 ~rexec()                rcmd()
 ~rexec_af()             rcmd()
  setenv(s, val)         my_setenv(s, val)
 ~setgrent_r()           setgrent()
 ~sethostent_r()         sethostent()
  setlocale()            Perl_setlocale()
  setlocale_r()          Perl_setlocale()
 ~setnetent_r()          setnetent()
 ~setprotoent_r()        setprotoent()
 ~setpwent_r()           setpwent()
 ~setservent_r()         setservent()
 ~setutent()             setutxent()
  sigaction()            rsignal(signo, handler)
 ~siginterrupt()         rsignal() with the SA_RESTART flag instead
  signal(signo, handler) rsignal(signo, handler)
 ~ssignal()              DO NOT USE; see its man page
  strcasecmp()           a Perl foldEQ-family function
  strerror()             sv_string_from_errnum()
  strerror_l()           sv_string_from_errnum()
  strerror_r()           sv_string_from_errnum()
  strftime()             Perl_sv_strftime_tm()
  strtod()               my_strtod() or Strtod()
  system(s)              Don't. Look at pp_system or use my_popen.
 ~tempnam()              mkstemp() or tmpfile()
 ~tmpnam()               mkstemp() or tmpfile()
  tmpnam_r()             mkstemp() or tmpfile()
  uselocale()            Perl_setlocale()
  vsnprintf()            my_vsnprintf()
  wctob()                wcrtomb()
  wctomb()               wcrtomb()
  wsetlocale()           Perl_setlocale()

=begin original

The Perl-furnished alternatives are documented in L<perlapi>, which you
should peruse anyway to see what all is available to you.

=end original

Perl が提供している代替策は L<perlapi> に文書化されています;
とにかく何が利用可能かをよく調べて確認する必要があります。

=begin original

The lists are incomplete.  Think when using an unlisted function if it
seems likely to interfere with Perl.

=end original

この一覧は不完全です。
一覧にない関数を使うときは、
それが Perl を妨害しそうに感じられるかを考えてください。

=head1 Dealing with locales

(ロケールを扱う)

=begin original

Like it or not, your code will be executed in the context of a locale,
as are all C language programs.  See L<perllocale>.  Most libc calls are
not affected by the locale, but a surprising number are:

=end original

好むと好まざるとにかかわらず、すべての C 言語プログラムと同様に、
コードはロケールのコンテキストで実行されます。
L<perllocale> を参照してください。
ほとんどの libc 呼び出しはロケールの影響を受けませんが、次のような
驚くべき数の呼び出しがあります。
(TBR)

 addmntent()           getspent_r()        sethostent()
 alphasort()           getspnam()          sethostent_r()
 asctime()             getspnam_r()        setnetent()
 asctime_r()           getwc()             setnetent_r()
 asprintf()            getwchar()          setnetgrent()
 atof()                glob()              setprotoent()
 atoi()                gmtime()            setprotoent_r()
 atol()                gmtime_r()          setpwent()
 atoll()               grantpt()           setpwent_r()
 btowc()               iconv_open()        setrpcent()
 catopen()             inet_addr()         setservent()
 ctime()               inet_aton()         setservent_r()
 ctime_r()             inet_network()      setspent()
 cuserid()             inet_ntoa()         sgetspent_r()
 daylight              inet_ntop()         shm_open()
 dirname()             inet_pton()         shm_unlink()
 dprintf()             initgroups()        snprintf()
 endaliasent()         innetgr()           sprintf()
 endgrent()            iruserok()          sscanf()
 endgrent_r()          iruserok_af()       strcasecmp()
 endhostent()          isalnum()           strcasestr()
 endhostent_r()        isalnum_l()         strcoll()
 endnetent()           isalpha()           strerror()
 endnetent_r()         isalpha_l()         strerror_l()
 endprotoent()         isascii()           strerror_r()
 endprotoent_r()       isascii_l()         strfmon()
 endpwent()            isblank()           strfmon_l()
 endpwent_r()          isblank_l()         strfromd()
 endrpcent()           iscntrl()           strfromf()
 endservent()          iscntrl_l()         strfroml()
 endservent_r()        isdigit()           strftime()
 endspent()            isdigit_l()         strftime_l()
 err()                 isgraph()           strncasecmp()
 error()               isgraph_l()         strptime()
 error_at_line()       islower()           strsignal()
 errx()                islower_l()         strtod()
 fgetwc()              isprint()           strtof()
 fgetwc_unlocked()     isprint_l()         strtoimax()
 fgetws()              ispunct()           strtol()
 fgetws_unlocked()     ispunct_l()         strtold()
 fnmatch()             isspace()           strtoll()
 forkpty()             isspace_l()         strtoq()
 fprintf()             isupper()           strtoul()
 fputwc()              isupper_l()         strtoull()
 fputwc_unlocked()     iswalnum()          strtoumax()
 fputws()              iswalnum_l()        strtouq()
 fputws_unlocked()     iswalpha()          strverscmp()
 fscanf()              iswalpha_l()        strxfrm()
 fwprintf()            iswblank()          swprintf()
 fwscanf()             iswblank_l()        swscanf()
 getaddrinfo()         iswcntrl()          syslog()
 getaliasbyname_r()    iswcntrl_l()        timegm()
 getaliasent_r()       iswdigit()          timelocal()
 getdate()             iswdigit_l()        timezone
 getdate_r()           iswgraph()          tolower()
 getfsent()            iswgraph_l()        tolower_l()
 getfsfile()           iswlower()          toupper()
 getfsspec()           iswlower_l()        toupper_l()
 getgrent()            iswprint()          towctrans()
 getgrent_r()          iswprint_l()        towlower()
 getgrgid()            iswpunct()          towlower_l()
 getgrgid_r()          iswpunct_l()        towupper()
 getgrnam()            iswspace()          towupper_l()
 getgrnam_r()          iswspace_l()        tzname
 getgrouplist()        iswupper()          tzset()
 gethostbyaddr()       iswupper_l()        ungetwc()
 gethostbyaddr_r()     iswxdigit()         vasprintf()
 gethostbyname()       iswxdigit_l()       vdprintf()
 gethostbyname2()      isxdigit()          verr()
 gethostbyname2_r()    isxdigit_l()        verrx()
 gethostbyname_r()     localeconv()        versionsort()
 gethostent()          localtime()         vfprintf()
 gethostent_r()        localtime_r()       vfscanf()
 gethostid()           MB_CUR_MAX          vfwprintf()
 getlogin()            mblen()             vprintf()
 getlogin_r()          mbrlen()            vscanf()
 getmntent()           mbrtowc()           vsnprintf()
 getmntent_r()         mbsinit()           vsprintf()
 getnameinfo()         mbsnrtowcs()        vsscanf()
 getnetbyaddr()        mbsrtowcs()         vswprintf()
 getnetbyaddr_r()      mbstowcs()          vsyslog()
 getnetbyname()        mbtowc()            vwarn()
 getnetbyname_r()      mktime()            vwarnx()
 getnetent()           nan()               vwprintf()
 getnetent_r()         nanf()              warn()
 getnetgrent()         nanl()              warnx()
 getnetgrent_r()       nl_langinfo()       wcrtomb()
 getprotobyname()      openpty()           wcscasecmp()
 getprotobyname_r()    printf()            wcschr()
 getprotobynumber()    psiginfo()          wcscoll()
 getprotobynumber_r()  psignal()           wcsftime()
 getprotoent()         putpwent()          wcsncasecmp()
 getprotoent_r()       putspent()          wcsnrtombs()
 getpw()               putwc()             wcsrchr()
 getpwent()            putwchar()          wcsrtombs()
 getpwent_r()          regcomp()           wcstod()
 getpwnam()            regexec()           wcstof()
 getpwnam_r()          res_nclose()        wcstoimax()
 getpwuid()            res_ninit()         wcstold()
 getpwuid_r()          res_nquery()        wcstombs()
 getrpcbyname_r()      res_nquerydomain()  wcstoumax()
 getrpcbynumber_r()    res_nsearch()       wcswidth()
 getrpcent_r()         res_nsend()         wcsxfrm()
 getrpcport()          rpmatch()           wctob()
 getservbyname()       ruserok()           wctomb()
 getservbyname_r()     ruserok_af()        wctrans()
 getservbyport()       scandir()           wctype()
 getservbyport_r()     scanf()             wcwidth()
 getservent()          setaliasent()       wordexp()
 getservent_r()        setgrent()          wprintf()
 getspent()            setgrent_r()        wscanf()

=begin original

(The list doesn't include functions that manipulate the locale, such as
C<setlocale()>.)

=end original

(この一覧には、C<setlocale()> のような、ロケールを操作する関数は
含んでいません。)

=begin original

If any of these functions are called directly or indirectly from your
code, you are affected by the current locale.

=end original

これらの関数のどれかを直接または間接に呼び出すと、
現在のロケールの影響を受けます。

=begin original

The first thing to know about this list is that there are better
alternatives to many of the functions, which it's highly likely that you
should be using instead.  See L</libc functions to avoid> above.
This includes using Perl IO L<perlapio>.

=end original

このリストについて最初に知っておくべきことは、多くの関数に対してより
優れた代替手段があるということです。
これらの関数は、代わりに使用する必要がある可能性が非常に高くなります。
上記のL</libc functions to avoid>を参照してください。
これには、Perl IO L<perlapio>の使用も含まれます。
(TBR)

=begin original

The second thing to know is that Perl is documented to not pay attention
to the current locale except for code executed within the scope of a
S<C<use locale>> statement.  If you violate that, you may be creating
bugs, depending on the application.

=end original

二つ目に知っておくべきことは、Perl は S<C<use locale>> 文のスコープ内で
実行されるコードを除いて、現在のロケールに注意を払わないように
文書化されているということです。
これに違反すると、アプリケーションによってはバグが発生する可能性があります。
(TBR)

=begin original

The next thing to know is that many of these functions depend only on
the locale in regards to numeric values.  Your code is likely to have
been written expecting that the decimal point (radix) character is a dot
(U+002E: FULL STOP), and that strings of integer numbers are not
separated into groups (1,000,000 in an American locale means a million;
your code is likely not expecting the commas.)  The good news is that
normally (as of Perl v5.22), your code will get called with the locale
set so those expectations are met.  Explicit action has to be taken to
change this (described a little ways below).  This is accomplished by
Perl not actually switching into a locale that doesn't conform to these
expectations, except when explicitly told to do so.  The Perl
input/output and formatting routines do this switching for you
automatically, if appropriate, and then switch back.  If, for some
reason, you need to do it yourself, the easiest way from C and XS code
is to use the macro L<perlapi/C<WITH_LC_NUMERIC_SET_TO_NEEDED>>.  You
can wrap this macro around an entire block of code that you want to be
executed in the correct environment.  The bottom line is that your code
is likely to work as expected in this regard without you having to take
any action.

=end original

次に知っておくべきことは、これらの関数の多くは数値に関してロケールにのみ
依存しているということです。
コードは、小数点(基数)文字がドット(U+002E:FULL STOP)であり、整数の文字列が
グループに分割されていないことを想定して書かれている可能性があります
(アメリカのロケールでは1,000,000は100万を意味します。
コードはカンマを想定していない可能性があります)。
幸いなことに、通常(Perl v5.22の時点で)、コードはロケールセットで
呼び出されるので、これらの期待が満たされます。
これを変更するには、明示的なアクションを実行する必要があります(以下で
少し説明します)。
これは、明示的に指示された場合を除いて、Perlがこれらの期待に従わない
ロケールに実際に切り替えないことによって達成されます。
Perlの入出力およびフォーマットルーチンは、必要に応じて自動的に切り替えを
行い、その後元に戻します。
何らかの理由で自分で行う必要がある場合、CおよびXSコードから最も簡単な方法は、
マクロL<perlapi/C<WITH_LC_NUMERIC_SET_TO_NEEDED>>を使用することです。
このマクロを、正しい環境で実行したいコードのブロック全体に
ラップすることができます。
要するに、コードは何のアクションも起こさなくても、この点に関して期待通りに
動作する可能性が高いということです。
(TBR)

=begin original

This leaves the remaining functions.  Your code will get called with all
but the numeric locale portions set to the underlying locale.  Often,
the locale is of not much import to your code, and you also won't have
to take any action; things will just work out.  But you should examine
the man pages of the ones you use to verify this.  Often, Perl has
better ways of doing the same functionality.  Consider using SVs and
their access routines rather than calling the low level functions that,
for example, find how many bytes are in a UTF-8 encoded character.

=end original

これにより、残りの関数が残ります。
コードは、数値ロケール部分を除くすべての部分が基礎となるロケールに設定された
状態で呼び出されます。
多くの場合、ロケールはコードにとってあまり重要ではなく、何もアクションを
起こす必要もありません。
物事はうまくいくでしょう。
しかし、これを検証するために使用しているマニュアルページを調べる
必要があります。
多くの場合、Perl には同じ機能を実行するためのより優れた方法があります。
UTF-8 でエンコードされた文字のバイト数を調べるなどの低レベルの関数を
呼び出すのではなく、SV とそのアクセスルーチンを使用することを検討してください。
(TBR)

=begin original

You can determine if you have been called from within the scope of a
S<C<use locale>> by using the boolen macro L<perlapi/C<IN_LOCALE>>.

=end original

真偽値マクロ L<perlapi/C<IN_LOCALE>> を使うことで、
S<C<use locale>> のスコープ内から呼び出されたかどうかを
判定できます。

=begin original

If you need to not be in the underlying locale, you can call
L<perlapi/C<Perl_setlocale>> to change it temporarily to the one you
need (likely the "C" locale), and then change it back before returning.
This can be B<very> problematic on threaded perls on some platforms. See
L</Dealing with embedded perls and threads>.

=end original

基礎となるロケールを使用しない必要がある場合は、
L<perlapi/C<Perl_setlocale>> を呼び出して一時的に必要なロケール
(通常は "C" ロケール)に変更し、戻る前に元に戻すことができます。
これは、一部のプラットフォームでは、スレッド化された perl で B<非常に>
問題になる可能性があります。
L</Handling with embedded perls and threads> を参照してください。
(TBR)

=begin original

A problem with changing the locale of a single category is that mojibake
can arise on some platforms if the C<LC_CTYPE> category and the changed one
are not the same.  On the platforms that that isn't an issue, the
preprocessor directive C<LIBC_HANDLES_MISMATCHED_CTYPE> will be defined.
Otherwise, you may have to change more than one category to correctly
accomplish your task.  And, there will be many locale combinations where
the mojibake likely won't happen, so you won't be confronted with this
until the code gets executed in the field by someone who doesn't speak
your language very well.

=end original

1つのカテゴリのロケールを変更することの問題は、C<LC_CTYPE>カテゴリと
変更されたカテゴリが同じでない場合、一部のプラットフォームでmojibakeが
発生する可能性があることです。
これが問題にならないプラットフォームでは、プリプロセッサディレクティブ
C<LIBC_HANDLES_MISMATCHED_CTYPE>が定義されます。
そうでない場合は、タスクを正しく実行するために複数のカテゴリを変更する
必要があります。
また、mojibakeが発生しない可能性の高いロケールの組み合わせが
数多くあるため、コードがフィールドであなたの言語をあまり話せない人によって
実行されるまで、これに直面することはありません。
(TBR)

=begin original

Earlier we mentioned that explicit action is required to have your code
get called with the numeric portions of the locale not meeting the
the typical expectations of having a dot for the radix character and no
punctuation separating groups of digits.  That action is to call the
function L<perlapi/C<switch_to_global_locale>>.

=end original

前述したように、ロケールの数値部分が、基数文字にドットを持ち、数字の
グループを区切る句読点を持たないという一般的な期待を満たさない状態で
コードを呼び出すには、明示的なアクションが必要です。
そのアクションは、ファンクション
L<perlapi/C<switch_to_global_locale>>を呼び出すことです。
(TBR)

=begin original

C<switch_to_global_locale()> was written initially to cope with the
C<Tk> library, but is general enough for other similar situations.  C<Tk>
changes the global locale to match its expectations (later versions of
it allow this to be turned off).  This presents a conflict with Perl
thinking it also controls the locale.  Calling this function tells Perl to
yield control.  Calling L<perlapi/C<sync_locale>> tells Perl to take
control again, accepting whatever the locale has been changed to in the
interim.  If your code is called during that interim, all portions of
the locale will be the raw underlying values.  Should you need to
manipulate numbers, you are on your own with regard to the radix
character and grouping.  If you find yourself in this situation, it is
generally best to make the interval between the calls to these two
functions as short as possible, and avoid calculations until after perl
has control again.

=end original

C<switch_to_global_locale()>は、当初はC<Tk>ライブラリに対応するために
書かれましたが、他の同様の状況に対しては十分に一般的です。
C<Tk>は、グローバルロケールをその期待に合わせて変更します(C<Tk>の
後のバージョンでは、これをオフにすることができます)。
これは、Perlもロケールを制御していると考えることと矛盾します。
この関数を呼び出すと、Perlは制御を放棄します。
L<perlapi/C<sync_locale>>を呼び出すと、Perlは再び制御を取得し、その間に
ロケールが変更されたものを受け入れます。
その間にコードが呼び出されると、ロケールのすべての部分が
生の基底値になります。
数値を操作する必要がある場合は、基数文字とグループ化に関しては
自分で判断します。
このような状況に陥った場合は、これら2つの関数を呼び出す間隔を
できるだけ短くし、perlが再び制御を得るまで計算を行わないようにするのが
一般的です。
(TBR)

=begin original

It is important for perl to know about all the possible locale
categories on the platform, even if they aren't apparently used in your
program.  Perl knows all of the Linux ones.  If your platform has
others, you can submit an issue at
L<https://github.com/Perl/perl5/issues> for inclusion of it in the next
release.  In the meantime, it is possible to edit the Perl source to
teach it about the category, and then recompile.  Search for instances
of, say, C<LC_PAPER> in the source, and use that as a template to add
the omitted one.

=end original

あなたのプログラムで使われていないように見えても、プラットフォーム上で
可能なすべてのロケールカテゴリをperlが知っていることが重要です。
PerlはLinuxのものをすべて知っています。
もしあなたのプラットフォームに他のものがあれば、
L<https://github.com/Perl/perl5/issues> で問題を提出して、次のリリースに
含めることができます。
その間に、Perlソースを編集してカテゴリについて教え、
再コンパイルすることができます。
たとえば、ソース内でC<LC_PAPER>のインスタンスを検索し、それを
テンプレートとして使用して省略されたものを追加します。
(TBR)

=begin original

There are further complications under multi-threaded operation.  Keep on
reading.

=end original

マルチスレッド操作ではさらに複雑なことがあります。
読み進めてください。

=head1 Dealing with embedded perls and threads

(組み込み perl とスレッドを扱う)

=begin original

It is possible to embed a Perl interpreter within a larger program.  See
L<perlembed>.

=end original

Perl インタプリタをより大きなプログラムに組み込むことができます。
L<perlembed> を参照してください。

=begin original

MULTIPLICITY is the way this is accomplished internally; it is described in
L<perlguts/How multiple interpreters and concurrency are supported>.
Multiple Perl interpreters may be embedded.

=end original

MULTIPLICITY は、これを内部で実現する方法です。
L<perlguts/How multiple interpreters and concurrency are supported> で
説明されています。
複数の Perl インタプリタを埋め込むことができます。
(TBR)

=begin original

It is also possible to compile perl to support threading.  See
L<perlthrtut>.  Perl's implementation of threading requires
MULTIPLICITY, but not the other way around.

=end original

スレッドに対応するように perl をコンパイルすることもできます。
L<perlthrtut> を参照してください。
Perl のスレッド化の実装には多重度が必要ですが、その逆は必要ありません。
(TBR)

=begin original

MULTIPLICITY without threading means that only one thing runs at a time,
so there are no concurrency issues, but each component or instance can
affect the global state, potentially interfering with the execution of
other instance.  This can happen if one instance:

=end original

スレッド化なしの多重度とは、一度に1つのものしか実行されないことを
意味します。
そのため、同時実行の問題はありませんが、各コンポーネントまたは
インスタンスがグローバル状態に影響を与え、他のインスタンスの実行に
干渉する可能性があります。
これは、1つのインスタンスが次の場合に発生する可能性があります。
(TBR)

=over

=item *

=begin original

changes the current working directory

=end original

現在の作業ディレクトリを変える

=item *

=begin original

changes the process's environment

=end original

プロセスの環境を変える

=item *

=begin original

changes the global locale the process is operating under

=end original

プロセスが処理しているグローバルロケールを変える

=item *

=begin original

writes to shared memory or to a shared file

=end original

共有メモリまたは共有ファイルに書き込む

=item *

=begin original

uses a shared file descriptor (including a database iterator)

=end original

(データベース反復子を含む) 共有ファイル記述子を使う

=item *

=begin original

raises a signal that functions in other instances are sensitive to

=end original

他の実体の関数が反応するシグナルを発生させる

=back

=begin original

If your code doesn't do any of these things, nor depends on any of their
values, then Congratulations!!, you don't have to worry about MULTIPLICITY
or threading.  But wait, a surprising number of libc functions do
depend on data global to the process in some way that may not be
immediately obvious.  For example, calling C<L<strtok(3)>> changes the
global state of a process, and thus needs special attention.

=end original

あなたのコードがこれらのことを何も行わず、それらの値にも
依存しないのであれば、おめでとうございます!、
多重度やスレッド化について心配する必要はありません。
しかし、待ってください、驚くほど多くの libc 関数が、すぐには
わからないような方法で、プロセスに対してグローバルなデータに
依存しています。
例えば、C<L<strtok(3)>> を呼び出すと、プロセスのグローバルな
状態が変化するので、特別な注意が必要です。
(TBR)

=begin original

The section 3 libc uses that we know about that have MULTIPLICITY and/or
multi-thread issues are:

=end original

使うと MULTIPLICITY やマルチスレッドの問題があると分かっている
libc のセクション 3 の関数は:

 addmntent()             getrpcent_r()        re_exec()
 alphasort()             getrpcport()         regcomp()
 asctime()               getservbyname()      regerror()
 asctime_r()             getservbyname_r()    regexec()
 asprintf()              getservbyport()      res_nclose()
 atof()                  getservbyport_r()    res_ninit()
 atoi()                  getservent()         res_nquery()
 atol()                  getservent_r()       res_nquerydomain()
 atoll()                 getspent()           res_nsearch()
 basename()              getspent_r()         res_nsend()
 btowc()                 getspnam()           rexec()
 catgets()               getspnam_r()         rexec_af()
 catopen()               getttyent()          rpmatch()
 clearenv()              getttynam()          ruserok()
 clearerr_unlocked()     getusershell()       ruserok_af()
 crypt()                 getutent()           scandir()
 crypt_gensalt()         getutid()            scanf()
 crypt_r()               getutline()          secure_getenv()
 ctermid()               getutxent()          seed48()
 ctermid_r()             getutxid()           seed48_r()
 ctime()                 getutxline()         setaliasent()
 ctime_r()               getwc()              setcontext()
 cuserid()               getwchar()           setenv()
 daylight                getwchar_unlocked()  setfsent()
 dbm_clearerr()          getwc_unlocked()     setgrent()
 dbm_close()             glob()               setgrent_r()
 dbm_delete()            gmtime()             sethostent()
 dbm_error()             gmtime_r()           sethostent_r()
 dbm_fetch()             grantpt()            sethostid()
 dbm_firstkey()          hcreate()            setkey()
 dbm_nextkey()           hcreate_r()          setlocale()
 dbm_open()              hdestroy()           setlocale_r()
 dbm_store()             hdestroy_r()         setlogmask()
 dirname()               hsearch()            setnetent()
 dlerror()               hsearch_r()          setnetent_r()
 dprintf()               iconv()              setnetgrent()
 drand48()               iconv_open()         setprotoent()
 drand48_r()             inet_addr()          setprotoent_r()
 ecvt()                  inet_aton()          setpwent()
 encrypt()               inet_network()       setpwent_r()
 endaliasent()           inet_ntoa()          setrpcent()
 endfsent()              inet_ntop()          setservent()
 endgrent()              inet_pton()          setservent_r()
 endgrent_r()            initgroups()         setspent()
 endhostent()            initstate_r()        setstate_r()
 endhostent_r()          innetgr()            setttyent()
 endnetent()             iruserok()           setusershell()
 endnetent_r()           iruserok_af()        setutent()
 endnetgrent()           isalnum()            setutxent()
 endprotoent()           isalnum_l()          sgetspent()
 endprotoent_r()         isalpha()            sgetspent_r()
 endpwent()              isalpha_l()          shm_open()
 endpwent_r()            isascii()            shm_unlink()
 endrpcent()             isascii_l()          siginterrupt()
 endservent()            isblank()            sleep()
 endservent_r()          isblank_l()          snprintf()
 endspent()              iscntrl()            sprintf()
 endttyent()             iscntrl_l()          srand48()
 endusershell()          isdigit()            srand48_r()
 endutent()              isdigit_l()          srandom_r()
 endutxent()             isgraph()            sscanf()
 erand48()               isgraph_l()          ssignal()
 erand48_r()             islower()            strcasecmp()
 err()                   islower_l()          strcasestr()
 error()                 isprint()            strcoll()
 error_at_line()         isprint_l()          strerror()
 errx()                  ispunct()            strerror_l()
 ether_aton()            ispunct_l()          strerror_r()
 ether_ntoa()            isspace()            strfmon()
 execlp()                isspace_l()          strfmon_l()
 execvp()                isupper()            strfromd()
 execvpe()               isupper_l()          strfromf()
 exit()                  iswalnum()           strfroml()
 __fbufsize()            iswalnum_l()         strftime()
 fcloseall()             iswalpha()           strftime_l()
 fcvt()                  iswalpha_l()         strncasecmp()
 fflush_unlocked()       iswblank()           strptime()
 fgetc_unlocked()        iswblank_l()         strsignal()
 fgetgrent()             iswcntrl()           strtod()
 fgetpwent()             iswcntrl_l()         strtof()
 fgetspent()             iswdigit()           strtoimax()
 fgets_unlocked()        iswdigit_l()         strtok()
 fgetwc()                iswgraph()           strtol()
 fgetwc_unlocked()       iswgraph_l()         strtold()
 fgetws()                iswlower()           strtoll()
 fgetws_unlocked()       iswlower_l()         strtoq()
 fnmatch()               iswprint()           strtoul()
 forkpty()               iswprint_l()         strtoull()
 __fpending()            iswpunct()           strtoumax()
 fprintf()               iswpunct_l()         strtouq()
 __fpurge()              iswspace()           strverscmp()
 fputc_unlocked()        iswspace_l()         strxfrm()
 fputs_unlocked()        iswupper()           swapcontext()
 fputwc()                iswupper_l()         swprintf()
 fputwc_unlocked()       iswxdigit()          swscanf()
 fputws()                iswxdigit_l()        sysconf()
 fputws_unlocked()       isxdigit()           syslog()
 fread_unlocked()        isxdigit_l()         system()
 fscanf()                jrand48()            tdelete()
 __fsetlocking()         jrand48_r()          tempnam()
 fts_children()          l64a()               tfind()
 fts_read()              lcong48()            timegm()
 ftw()                   lcong48_r()          timelocal()
 fwprintf()              lgamma()             timezone
 fwrite_unlocked()       lgammaf()            tmpnam()
 fwscanf()               lgammal()            tmpnam_r()
 gamma()                 localeconv()         tolower()
 gammaf()                localtime()          tolower_l()
 gammal()                localtime_r()        toupper()
 getaddrinfo()           login()              toupper_l()
 getaliasbyname()        login_tty()          towctrans()
 getaliasbyname_r()      logout()             towlower()
 getaliasent()           logwtmp()            towlower_l()
 getaliasent_r()         lrand48()            towupper()
 getchar_unlocked()      lrand48_r()          towupper_l()
 getcontext()            makecontext()        tsearch()
 getc_unlocked()         mallinfo()           ttyname()
 get_current_dir_name()  MB_CUR_MAX           ttyname_r()
 getdate()               mblen()              ttyslot()
 getdate_r()             mbrlen()             twalk()
 getenv()                mbrtowc()            twalk_r()
 getfsent()              mbsinit()            tzname
 getfsfile()             mbsnrtowcs()         tzset()
 getfsspec()             mbsrtowcs()          ungetwc()
 getgrent()              mbstowcs()           unsetenv()
 getgrent_r()            mbtowc()             updwtmp()
 getgrgid()              mcheck()             utmpname()
 getgrgid_r()            mcheck_check_all()   va_arg()
 getgrnam()              mcheck_pedantic()    valloc()
 getgrnam_r()            mktime()             vasprintf()
 getgrouplist()          mprobe()             vdprintf()
 gethostbyaddr()         mrand48()            verr()
 gethostbyaddr_r()       mrand48_r()          verrx()
 gethostbyname()         mtrace()             versionsort()
 gethostbyname2()        muntrace()           vfprintf()
 gethostbyname2_r()      nan()                vfscanf()
 gethostbyname_r()       nanf()               vfwprintf()
 gethostent()            nanl()               vprintf()
 gethostent_r()          newlocale()          vscanf()
 gethostid()             nftw()               vsnprintf()
 getlogin()              nl_langinfo()        vsprintf()
 getlogin_r()            nrand48()            vsscanf()
 getmntent()             nrand48_r()          vswprintf()
 getmntent_r()           openpty()            vsyslog()
 getnameinfo()           perror()             vwarn()
 getnetbyaddr()          posix_fallocate()    vwarnx()
 getnetbyaddr_r()        printf()             vwprintf()
 getnetbyname()          profil()             warn()
 getnetbyname_r()        psiginfo()           warnx()
 getnetent()             psignal()            wcrtomb()
 getnetent_r()           ptsname()            wcscasecmp()
 getnetgrent()           putchar_unlocked()   wcschr()
 getnetgrent_r()         putc_unlocked()      wcscoll()
 getopt()                putenv()             wcsftime()
 getopt_long()           putpwent()           wcsncasecmp()
 getopt_long_only()      putspent()           wcsnrtombs()
 getpass()               pututline()          wcsrchr()
 getprotobyname()        pututxline()         wcsrtombs()
 getprotobyname_r()      putwc()              wcstod()
 getprotobynumber()      putwchar()           wcstof()
 getprotobynumber_r()    putwchar_unlocked()  wcstoimax()
 getprotoent()           putwc_unlocked()     wcstold()
 getprotoent_r()         pvalloc()            wcstombs()
 getpw()                 qecvt()              wcstoumax()
 getpwent()              qfcvt()              wcswidth()
 getpwent_r()            querylocale()        wcsxfrm()
 getpwnam()              rand()               wctob()
 getpwnam_r()            random_r()           wctomb()
 getpwuid()              rcmd()               wctrans()
 getpwuid_r()            rcmd_af()            wctype()
 getrpcbyname()          readdir()            wcwidth()
 getrpcbyname_r()        readdir64()          wordexp()
 getrpcbynumber()        readdir64_r()        wprintf()
 getrpcbynumber_r()      readdir_r()          wscanf()
 getrpcent()             re_comp()            wsetlocale()

=begin original

(If you know of additional functions that are unsafe on some platform or
another, notify us via filing a bug report at
L<https://github.com/Perl/perl5/issues>.)

=end original

(何らかのプラットフォームで安全でない追加機能を知っている場合は、
L<https://github.com/Perl/perl5/issues> にバグレポートを提出して
私たちに通知してください。)
(TBR)

=begin original

Some of these are safe under MULTIPLICITY, problematic only under threading.
If a use doesn't appear in the above list, we think it is MULTIPLICITY
and thread-safe on all platforms.

=end original

これらの中には、MULTIPLICITY の下では安全なものもありますが、
スレッド化の下でのみ問題になります。
上記のリストに用途が表示されない場合は、MULTIPLICITY であり、
すべてのプラットフォームでスレッドセーフであると考えられます。
(TBR)

=begin original

All the uses listed above are function calls, except for these:

=end original

前述の全ての使用は、次のものを除いて関数呼び出しです:

 daylight  MB_CUR_MAX  timezone  tzname

=begin original

There are three main approaches to coping with issues involving these
constructs, each suitable for different circumstances:

=end original

これらの構造に関する問題に対応するには、主に三つの手法があり、
それぞれ異なった状況に適しています:

=over

=item *

=begin original

Don't use them.  Some of them have preferred alternatives.  Use the list
above in L</libc functions to avoid> to replace your uses with ones
that are thread-friendly.  For example I/O, should be done via
L<perlapio>.

=end original

それらを使わない。
それらの中には好ましい代替手段があるものもあります。
上記のリストを L</libc functions to avoid> で使用して、
スレッドフレンドリーなものに置き換えてください。
たとえば、入出力は L<perlapio> を介して行われる必要があります。
(TBR)

=begin original

If you must use them, many, but not all, of them will be ok as long as
their use is confined to a single thread that has no interaction with
conflicting uses in other threads.  You will need to closely examine
their man pages for this, and be aware that vendor documentation is
often imprecise.

=end original

それらを使用する必要がある場合、それらの使用が他のスレッドでの競合する使用と
相互作用しない単一のスレッドに限定されている限り、すべてではなくても
多くのものが使用できます。
これについては、それらのmanページを詳しく調べる必要があります。
また、ベンダーの文書はしばしば不正確であることに注意してください。
(TBR)

=item *

=begin original

Do all your business before any other code can change things.  If you
make changes, change back before returning.

=end original

他のコードが物事を変更する前に作業を終える。
自分で変更する場合は、戻る前に元に戻す。

=item *

=begin original

Save the result of a query of global information to a per-instance area
before allowing another instance to execute.  Then you can work on it at
your leisure.  This might be an automatic C variable for non-pointers,
or something as described above in
C<L<perlxs/Safely Storing Static Data in XS>>.

=end original

別のインスタンスの実行を許可する前に、グローバル情報のクエリの結果を
インスタンスごとの領域に保存する。
そうすれば、自由に作業できます。
これは、ポインタ以外の自動C言語変数、または
C<L<perlxs/Safely Storing Static Data in XS>> で
説明されているようなものです。
(TBR)

=back

=begin original

Without threading, you don't have to worry about being interrupted by
the system giving control to another thread.  With threading, you will
have to uses mutexes, and be concerned with the possibility of deadlock.

=end original

スレッド化を行わなければ、システムが別のスレッドに制御を渡すことによって
中断される心配はありません。
スレッド化では、mutexを使用する必要があり、デッドロックの可能性を考慮する
必要があります。
(TBR)

=head2 Functions always unsuitable for use under multi-threads

(マルチスレッドの下では使うのが常に不適切な関数)

=begin original

A few functions are considered totally unsuited for use in a multi-thread
environment.  These must be called only during single-thread operation.

=end original

いくつかの関数は、マルチスレッド環境での使用にまったく向いていないと
考えられています。
これらはシングルスレッド操作の間でだけ呼び出すようにしなければなりません。

  endusershell()    @getaliasent()      muntrace()   rexec()
  ether_aton()      @getrpcbyname()     profil()     rexec_af()
  ether_ntoa()      @getrpcbynumber()   rcmd()       setusershell()
  fts_children()    @getrpcent()        rcmd_af()    ttyslot()
  fts_read()         getusershell()     re_comp()
 @getaliasbyname()   mtrace()           re_exec()

=begin original

C<@> above marks the functions for which there are preferred alternatives
available on some platforms, and those alternatives may be suitable for
multi-thread use.

=end original

上記の C<@> は、いくつかのプラットフォームで利用可能な望ましい代替手段がある
関数を示していて、それらの代替手段はマルチスレッドでの使用に
適している可能性があります。

=head2 Functions which must be called at least once before starting threads

(スレッドを始める前に少なくとも 1 回呼び出される必要がある関数)

=begin original

Some functions perform initialization on their first call that must be done
while still in a single-thread environment, but subsequent calls are
thread-safe when executed in a critical section.
Therefore, they must be called at least once before switching to
multi-threads:

=end original

一部の関数は、シングルスレッド環境で実行する必要がある最初の呼び出しで
初期化を実行しますが、後続の呼び出しは、クリティカルセクションで
実行される場合はスレッドセーフです。
したがって、マルチスレッドに切り替える前に少なくとも1回は呼び出す
必要があります。
(TBR)

 getutent()  getutline()  getutxid()    mallinfo()  valloc()
 getutid()   getutxent()  getutxline()  pvalloc()

=head2 Functions that are thread-safe when called with appropriate arguments

(適切な引数で呼び出されればスレッドセーフな関数)

=begin original

Some of the functions are thread-safe if called with arguments that
comply with certain (easily met) restrictions.  These are:

=end original

一部の関数は、ある種の(容易に満たせる)条件を満たす引数で呼び出せば
スレッドセーフです。
その関数は:

 ctermid()        mbrlen()      mbsrtowcs()  wcrtomb()
 cuserid()        mbrtowc()     tmpnam()     wcsnrtombs()
 error_at_line()  mbsnrtowcs()  va_arg()     wcsrtombs()

=begin original

See the man pages of each for details.  (For completeness, the list
includes functions that you shouldn't be using anyway because of other
reasons.)

=end original

詳細については、それぞれの man ページを参照してください。
(完全性のために、この一覧には他の理由で使うべきではない
関数も含まれています。)

=head2 Functions vulnerable to signals

(シグナルに脆弱な関数)

=begin original

Some functions are vulnerable to asynchronous signals.  These are:

=end original

一部の関数は非同期シグナルに脆弱です。
それは次のものです:

 getlogin()    getutid()    getutxid()    login()   pututline()  updwtmp()
 getlogin_r()  getutline()  getutxline()  logout()  pututxline() wordexp()
 getutent()    getutxent()  glob()        logwtmp() sleep()

=begin original

Some libc's implement 'system()' thread-safely.  But in others, it also
has signal issues.

=end original

一部の libc は 'system()' をスレッドセーフに実装しています。
しかし一方、シグナルの問題はあります。

=head2 General issues with thread-safety

(スレッドセーフ性に関する一般的な問題)

=begin original

Some libc functions use and/or modify a global state, such as a database.
The libc functions presume that there is only one instance at a time
operating on that database.  Unpredictable results occur if more than one
does, even if the database is not changed.  For example, typically there is
a global iterator for such a data base and that iterator is maintained by
libc, so that each new read from any instance advances it, meaning that no
instance will see all the entries.  The only way to make these thread-safe
is to have an exclusive lock on a mutex from the open call through the
close.  You are advised to not use such databases from more than one
instance at a time.

=end original

libc関数の中には、データベースなどのグローバル状態を使用または変更
(あるいはその両方)するものがあります。
libc関数は、そのデータベースで一度に動作するインスタンスが1つしかないことを
前提としています。
複数のインスタンスが動作すると、データベースが変更されていない場合でも、
予期しない結果が発生します。
たとえば、通常、このようなデータベースにはグローバルイテレータがあり、
そのイテレータはlibcによって維持されます。
そのため、任意のインスタンスから新たに読み取られるたびにそのイテレータが
進められます。
つまり、どのインスタンスもすべてのエントリを参照しません。
これらをスレッドセーフにする唯一の方法は、open呼び出しから
close呼び出しまでの間、mutexに排他ロックを設定することです。
このようなデータベースは、一度に複数のインスタンスから使用しないことを
お薦めします。
(TBR)

=begin original

Other examples of functions that use a global state include pseudo-random
number generators.  Some libc implementations of 'rand()', for example, may
share the data across threads; and others may have per-thread data.  The
shared ones will have unreproducible results, as the threads will vary in
their timings and interactions.  This may be what you want; or it may not
be.  (This particular function is a candidate to be removed from the POSIX
Standard because of these issues.)

=end original

グローバル状態を使用する関数の他の例には、擬似乱数生成器が含まれます。
例えば、「rand()」のlibc実装の中には、スレッド間でデータを
共有するものもあれば、スレッドごとのデータを持つものもあります。
共有されたものは、スレッドのタイミングや相互作用が異なるため、
再現できない結果になります。
これはあなたが望むものかもしれませんし、そうでないかもしれません
(この特定の関数は、これらの問題のためにPOSIX標準から削除される候補です)。
(TBR)

=begin original

Functions that output to a stream also are considered thread-unsafe when
locking is not done.  But the typical consequences are just that the data
is output in an unpredictable order; that outcome may be totally
acceptable to you.

=end original

ストリームに出力する関数も、ロックが行われていない場合はスレッドセーフで
ないと見なされます。
しかし、典型的な結果は、データが予測できない順序で出力されることだけです。
その結果は、完全に受け入れられる可能性があります。
(TBR)

=begin original

Since the current working directory is global to a process, all
instances depend on it.  One instance doing a chdir(2) affects all the
other instances.  In a multi-threaded environment, any libc call that
expects the directory to not change for the duration of its execution
will have undefined results if another thread interrupts it at just the
wrong time and changes the directory.  The man pages only list one such
call, nftw().  But there may be other issues lurking.

=end original

現在の作業ディレクトリはプロセスに対してグローバルであるため、すべての
インスタンスはそれに依存します。
chdir(2)を実行している1つのインスタンスは、他のすべてのインスタンスに
影響を与えます。
マルチスレッド環境では、実行中にディレクトリが変更されないことを想定した
libc呼び出しは、別のスレッドが誤ったタイミングで中断してディレクトリを
変更した場合、未定義の結果になります。
manページには、そのような呼び出しの1つであるnftw()しか記載されていません。
しかし、他にも問題が潜んでいるかもしれない。
(TBR)

=head2 Reentrant equivalent functions

(再入可能な等価な関数)

=begin original

Some functions that are problematic with regard to MULTIPLICITY have
reentrant versions (on some or all platforms) that are better suited,
with fewer (perhaps no) races when run under threads.

=end original

MULTIPLICITYに関して問題のある関数の中には、(一部またはすべての
プラットフォームで)より適した再入可能バージョンを持つものがあり、
スレッドで実行した場合に競合が少なくなります(おそらく発生しません)。
(TBR)

=begin original

Some of these reentrant functions that are available on all platforms
should always be used anyway; they are in the lists directly under
L<libc functions to avoid>.

=end original

すべてのプラットフォームで使用可能なこれらの再入可能な関数のいくつかは、
いずれにしても常に使用する必要があります。
これらの関数は、L<libc functions to avoid>の下に直接リストされています。
(TBR)

=begin original

Others may not be available on some platforms, or have issues that makes
them undesirable to use even when they are available.  Or it may just be
more complicated and tedious to use the reentrant version.  For these,
perl has a mechanism for automatically substituting that reentrant
version when available and desirable, while hiding the complications
from your code.  This feature is enabled by default for code in the Perl
core and its extensions.  To enable it in other XS modules,

=end original

一部のプラットフォームでは使用できないものや、使用できても望ましくない問題が
あるものもあります。
または、再入可能バージョンを使用する方が複雑で退屈な場合もあります。
これらの場合、perlには、コードから複雑さを隠しながら、使用可能で
望ましい場合にその再入可能バージョンを自動的に置換するメカニズムがあります。
この機能は、Perlコアとその拡張機能のコードではデフォルトで
有効になっています。
他のXSモジュールで有効にするには
(TBR)

   #define PERL_REENTRANT

=begin original

It is simpler for you to use the unpreferred version in your code, and
rely on this feature to do the better thing, in part because no
substitution is done if the alternative is not available or desirable on
the platform, nor if threads aren't enabled.  You just write as if there
weren't threads, and you get the better behavior without having to think
about it.

=end original

コード内で好ましくないバージョンを使用し、この機能に依存してより良いことを
行う方が簡単です。
その理由の1つは、プラットフォーム上で代替が使用できない場合や望ましい場合、
またはスレッドが有効になっていない場合には、置換が行われないためです。
スレッドがないかのように書くだけで、それについて考えることなく、より良い
動作を得ることができます。
(TBR)

=begin original

On some platforms the safer library functions may fail if the result
buffer is too small (for example the user group databases may be rather
large, and the reentrant functions may have to carry around a full
snapshot of those databases).  Perl will start with a small buffer, but
keep retrying and growing the result buffer until the result fits.  If
this limitless growing sounds bad for security or memory consumption
reasons you can recompile Perl with C<PERL_REENTRANT_MAXSIZE> #defined
to the maximum number of bytes you will allow.

=end original

いくつかのプラットフォームでは、結果バッファが小さすぎる場合に
より安全なライブラリ関数が失敗を起こすかもしれません
(例えば、ユーザーグループのデータベースがかなり大きく、リエントラントな
関数がこれらのデータベースの完全なスナップショットを
もたらさなければならないような場合)。
Perl は小さなバッファでスタートします; しかし結果が適合するまで結果
バッファの確保を再試行し、大きくしようとします。
この無制限な成長がセキュリティやメモリ消費の理由から好ましくないもので
あるなら、C<PERL_REENTRANT_MAXSIZE> であなたの許す最大バイト数を
#define して Perl を再コンパイルできます。

=begin original

Below is a list of the non-reentrant functions and their reentrant
alternatives.  This substitution is done even on functions that you
shouldn't be using in the first place.  These are marked by a C<*>.  You
should instead use the alternate given in the lists directly under
L<libc functions to avoid>.

=end original

以下は、再入不可関数とその再入可能な代替関数のリストです。
この置換は、最初に使用すべきでない関数に対しても行われます。
これらはC<*>でマークされています。
代わりに、L<libc functions to avoid>の下のリストで直接指定されている
代替関数を使用してください。
(TBR)

=begin original

Even so, some of the preferred alternatives are considered obsolete or
otherwise unwise to use on some platforms.  These are marked with a '?'.
Also, some alternatives aren't Perl-defined functions and aren't in in
the POSIX Standard, so won't be widely available.  These are marked with
'~'.  (Remember that the automatic substitution only happens when they
are available and desirable, so you can just use the unpreferred
alternative.)

=end original

たとえそうであっても、推奨される代替手段のいくつかは、時代遅れであるか、
さもなければ一部のプラットフォームで使用するのは賢明ではないと
考えられています。
これらは'?'でマークされています。
また、いくつかの代替手段はPerlで定義された関数ではなく、POSIX標準にも
含まれていないため、広く利用されることはありません。
これらは'~'でマークされています(自動置換は、それらが利用可能で
望ましい場合にのみ行われることに注意してください。
したがって、推奨されない代替手段を使用することができます)。
(TBR)

 *asctime()             ?asctime_r()
  crypt()               ~crypt_r()
  ctermid()             ~ctermid_r()
 *ctime()               ?ctime_r()
  endgrent()           ?~endgrent_r()
  endhostent()         ?~endhostent_r()
  endnetent()          ?~endnetent_r()
  endprotoent()        ?~endprotoent_r()
  endpwent()           ?~endpwent_r()
  endservent()         ?~endservent_r()
  getgrent()            ~getgrent_r()
  getgrgid()             getgrgid_r()
  getgrnam()             getgrnam_r()
  gethostbyaddr()       ~gethostbyaddr_r()
  gethostbyname()       ~gethostbyname_r()
  gethostent()          ~gethostent_r()
  getlogin()             getlogin_r()
  getnetbyaddr()        ~getnetbyaddr_r()
  getnetbyname()        ~getnetbyname_r()
  getnetent()           ~getnetent_r()
  getprotobyname()      ~getprotobyname_r()
  getprotobynumber()    ~getprotobynumber_r()
  getprotoent()         ~getprotoent_r()
  getpwent()            ~getpwent_r()
  getpwnam()             getpwnam_r()
  getpwuid()             getpwuid_r()
  getservbyname()       ~getservbyname_r()
  getservbyport()       ~getservbyport_r()
  getservent()          ~getservent_r()
  getspnam()            ~getspnam_r()
  gmtime()               gmtime_r()
  localtime()            localtime_r()
  readdir()             ?readdir_r()
  readdir64()           ~readdir64_r()
  setgrent()           ?~setgrent_r()
  sethostent()         ?~sethostent_r()
 *setlocale()          ?~setlocale_r()
  setnetent()          ?~setnetent_r()
  setprotoent()        ?~setprotoent_r()
  setpwent()           ?~setpwent_r()
  setservent()         ?~setservent_r()
 *strerror()             strerror_r()
 *tmpnam()              ~tmpnam_r()
  ttyname()              ttyname_r()

=begin original

The Perl-furnished items are documented in perlapi.

=end original

Perl が提供するものは perlapi に文書化されています。

=begin original

The bottom line is:

=end original

まとめは:

=over

=item For items marked C<*>

=begin original

Replace all uses of these with the preferred alternative given in the
lists directly under L<libc functions to avoid>.

=end original

これらの全ての使用を、L<libc functions to avoid> の直後にある
好ましい代替案で置き換えます。

=item For the remaining items

=begin original

If you really need to use these functions, you have two choices:

=end original

本当にこれらの関数を使う必要があるなら、二つの選択肢があります:

=over

=item If you #define PERL_REENTRANT

=begin original

Use the function in the first column as-is, and let perl do the work of
substituting the function in the right column if available on the
platform, and it is deemed suitable for use.

=end original

最初の列の関数はそのまま使い、右側の列の関数がプラットフォームで
使用可能であり、使用に適していると判断された場合は、
perl に置き換えを行わせます。
(TBR)

=begin original

You should look at the man pages for both versions to find any other
gotchas.

=end original

他のコツを見つけるために、両方のバージョンの man ページを
見る必要があります。

=item If you don't enable automatic substitution

=begin original

You should examine the application's code to determine if the column 1
function presents a real problem under threads given the circumstances
it is used in.  You can go directly to the column 2 replacement, but
beware of the ones that are marked.  Some of those may be nonexistent or
flaky on some platforms.

=end original

アプリケーションのコードを調べて、使用されている状況を考慮して、
column 1関数がスレッドの下で実際に問題を引き起こすかどうかを
判断する必要があります。
column 2の置換に直接進むこともできますが、マークされているものには
注意してください。
これらの中には、プラットフォームによっては存在しないものや
不安定なものもあります。
(TBR)

=back

=back

=head2 Functions that need the environment to be constant

(環境が固定である必要がある関数)

=begin original

Since the environment is global to a process, all instances depend on
it.  One instance changing the environment affects all the other
instances.  Under threads, any libc call that expects the environment to
not change for the duration of its execution will have undefined results
if another thread interrupts it at just the wrong time and changes it.
These are the functions that the man pages list as being sensitive to
that.

=end original

環境はプロセスに対してグローバルであるため、すべてのインスタンスが
それに依存します。
一つのインスタンスが環境を変更すると、他のすべてのインスタンスに
影響を与えます。
スレッドの下では、実行中に環境が変更されないことを期待する libc 呼び出しは、
別のスレッドが誤ったタイミングで割り込みを行い、環境を変更した場合、
未定義の結果となることがあります。
以下は、man ページでそれに敏感であると記載されている関数です。

 catopen()               gethostbyname2()    newlocale()
 ctime()                 gethostbyname2_r()  regerror()
 ctime_r()               gethostbyname_r()   secure_getenv()
 endhostent()            gethostent()        sethostent()
 endhostent_r()          gethostent_r()      sethostent_r()
 endnetent()             gethostid()         setlocale()
 endnetent_r()           getnameinfo()       setlocale_r()
 execlp()                getnetbyname()      setnetent()
 execvp()                getnetent()         setnetent_r()
 execvpe()               getopt()            strftime()
 fnmatch()               getopt_long()       strptime()
 getaddrinfo()           getopt_long_only()  sysconf()
 get_current_dir_name()  getrpcport()        syslog()
 getdate()               glob()              tempnam()
 getdate_r()             gmtime()            timegm()
 getenv()                gmtime_r()          timelocal()
 gethostbyaddr()         localtime()         tzset()
 gethostbyaddr_r()       localtime_r()       vsyslog()
 gethostbyname()         mktime()

=begin original

Many of these functions are problematic under threads for other reasons
as well.  See the man pages for any you use.

=end original

これらの関数の多くはその他の理由でもスレッドの下では問題があります。
使うときには man ページを参照してください。

=begin original

Perl defines mutexes C<ENV_READ_LOCK> and C<ENV_READ_UNLOCK> with which
to wrap calls to these functions.  You need to consider the possibility
of deadlock.  It is expected that a different mechanism will be in place
and preferred for Perl v5.42.

=end original

Perl では、これらの関数の呼び出しをラップするmutex C<ENV_READ_LOCK>
および C<ENV_READ_UNLOCK> が定義されています。
デッドロックの可能性を考慮する必要があります。
Perl v5.42 では、異なる機構が導入され、それが優先されることが想定されます。

=head2 Locale-specific issues

(ロケール固有の問題)

=begin original

C language programs originally had a single locale global to the entire
process.  This was later found to be inadequate for many purposes, so later
extensions changed that, first with Windows, and then POSIX 2008.  In
Windows, you can change any thread at any time to operate either with a
per-thread locale, or with the global one, using a special new libc
function.  In POSIX, the original API operates only on the global
locale, but there is an entirely new API to manipulate either per-thread
locales or the global one.  As with Windows (but using the new API), a
thread can be switched at any time to operate on the global locale, or a
per-thread one.

=end original

C 言語プログラムはもともと、プロセス全体に対してグローバルな単一のロケールを
持っていました。
これは後に多くの目的には不十分であることが判明したため、後の拡張で、最初に
Windows で、次に POSIX 2008 でそれが変更されました。
Windows では、特別な新しい libc 関数を使用して、スレッドごとのロケールまたは
グローバルなロケールのいずれかで動作するように、いつでも任意のスレッドを
変更できます。
POSIX では、元の API はグローバルロケールでのみ動作しますが、スレッドごとの
ロケールまたはグローバルなロケールを操作するためのまったく新しい
API があります。
Windows と同様に(ただし新しい API を使用して)、スレッドはいつでも
グローバルロケールまたはスレッドごとのロケールで動作するように
切り替えることができます。
(TBR)

=begin original

When one instance changes the global locale, all other instances using
the global locale are affected.  Almost all the locale-related functions
in the list directly under L</Dealing with embedded perls and threads>
have undefined behavior if another thread interrupts their execution and
changes the locale.  Under threads, another thread could do exactly that.

=end original

一つのインスタンスがグローバルロケールを変更すると、グローバルロケールを
使っている他のすべてのインスタンスが影響を受けます。
L</Handling with embedded perls and threads> 直下の一覧にあるロケール関連の
関数のほとんどは、別のスレッドが実行を中断してロケールを変更した場合の
動作が定義されていません。
スレッドの下では、別のスレッドがまさにそれを行うことができます。

=begin original

But, on systems that have per-thread locales, starting with Perl v5.28,
perl uses them after initialization; the global locale is not used
except if XS code has called C<switch_to_global_locale()>.  Doing so
affects only the thread that called it.  If a maximum of one instance is
using the global locale, no other instances are affected, the locale of
concurrently executing functions in other threads is not changed, and
this becomes a non-issue.  The C preprocessor symbol
C<USE_THREAD_SAFE_LOCALE> will be defined if per-thread locales are
available and perl has been compiled to use them.  The implementation of
per-thread locales on some platforms, like most *BSD-based ones, is so
buggy that the perl hints files for them deliberately turn off the
possibility of using them.

=end original

しかし、Perl v5.28 以降のスレッドごとのロケールを持つシステムでは、perl は
初期化後にそれらを使います。
グローバルロケールは、XS コードが C<switch_to_global_locale()> を呼び出した
場合を除いて使いません。
これは、それを呼び出したスレッドにのみ影響します。
最大一つのインスタンスがグローバルロケールを使用している場合、他の
インスタンスは影響を受けず、他のスレッドで同時に実行されている関数の
ロケールは変更されず、これは問題になりません。
スレッドごとのロケールが使用可能で、それらを使用するようにperlが
コンパイルされている場合は、C プリプロセッサシンボル
C<USE_THREAD_SAFE_LOCALE> が定義されます。
ほとんどの *BSD ベースのプラットフォームのように、いくつかの
プラットフォームでのスレッドごとのロケールの実装は非常にバグが多いので、
perl ヒントファイルはそれらを使用する可能性を意図的にオフにしています。
(TBR)

=begin original

The converse is that on systems with only a global locale, having
different threads using different locales is not likely to work well;
and changing the locale is dangerous, often leading to crashes.

=end original

逆に、グローバルロケールしか持たないシステムでは、異なるロケールを
使う異なるスレッドを持つことはうまく機能しない可能性が高いです;
そしてロケールを変更することは危険であり、
しばしばクラッシュにつながります。

=begin original

Perl has extensive code to work as well as possible on both types of
systems.  You should always use C<Perl_setlocale()> to change and query
the locale, as it portably works across the range of possibilities.

=end original

Perl には、両方のタイプのシステムで可能な限りうまく動作するための
広範なコードがあります。
ロケールの変更と問い合わせには、常に C<Perl_setlocale()> を使うべきです;
C<Perl_setlocale()>は、さまざまな可能性に対して移植性を持って
動作するからです。


=head1 SEE ALSO

L<perlapi>, L<perlapio>, L<perlguts>, L<perlxs>

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: in progress

=end meta

