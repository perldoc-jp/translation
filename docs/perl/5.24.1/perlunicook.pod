
=encoding utf8

=head1 NAME

=begin original

perlunicook - cookbookish examples of handling Unicode in Perl

=end original

perlunicook - Perl ã§ Unicode ã‚’æ‰±ã†ãŸã‚ã®ã‚¯ãƒƒã‚¯ãƒ–ãƒƒã‚¯é¢¨ã®ä¾‹

=head1 DESCRIPTION

=begin original

This manpage contains short recipes demonstrating how to handle common Unicode
operations in Perl, plus one complete program at the end. Any undeclared
variables in individual recipes are assumed to have a previous appropriate
value in them.

=end original

ã“ã® man ãƒšãƒ¼ã‚¸ã«ã¯ã€Perl ã§ä¸€èˆ¬çš„ãª Unicode æ“ä½œã‚’æ‰±ã†æ–¹æ³•ã‚’èª¬æ˜ã™ã‚‹
çŸ­ã„ãƒ¬ã‚·ãƒ”ã¨ã€æœ€å¾Œã«ä¸€ã¤ã®å®Œå…¨ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
å€‹ã€…ã®ãƒ¬ã‚·ãƒ”å†…ã®å®£è¨€ã•ã‚Œã¦ã„ãªã„å¤‰æ•°ã¯ã€ãã‚Œä»¥å‰ã«é©åˆ‡ãªå€¤ãŒ
è¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã¾ã™ã€‚

=head1 EXAMPLES

=head2 â„ 0: Standard preamble

(â„ 0: æ¨™æº–ã®å‰æ)

=begin original

Unless otherwise notes, all examples below require this standard preamble
to work correctly, with the C<#!> adjusted to work on your system:

=end original

ç‰¹ã«æ³¨è¨˜ãŒãªã„é™ã‚Šã€ä»¥ä¸‹ã®ã™ã¹ã¦ã®ä¾‹ã§ã¯ã€ã“ã®æ¨™æº–ã®å‰æãŒæ­£ã—ãå‹•ä½œã—ã€
C<#!> ãŒã‚·ã‚¹ãƒ†ãƒ ä¸Šã§å‹•ä½œã™ã‚‹ã‚ˆã†ã«èª¿æ•´ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

 #!/usr/bin/env perl

=begin original

 use utf8;      # so literals and identifiers can be in UTF-8
 use v5.12;     # or later to get "unicode_strings" feature
 use strict;    # quote strings, declare variables
 use warnings;  # on by default
 use warnings  qw(FATAL utf8);    # fatalize encoding glitches
 use open      qw(:std :utf8);    # undeclared streams in UTF-8
 use charnames qw(:full :short);  # unneeded in v5.16

=end original

 use utf8;      # å¾“ã£ã¦ãƒªãƒ†ãƒ©ãƒ«ã¨è­˜åˆ¥å­ã§ UTF-8 ã‚’ä½¿ãˆã‚‹
 use v5.12;     # ã¾ãŸã¯ãã‚Œä»¥é™; "unicode_strings" æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«
 use strict;    # æ–‡å­—åˆ—ã‚’ã‚¯ã‚©ãƒ¼ãƒˆã€å¤‰æ•°ã‚’å®£è¨€
 use warnings;  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚ªãƒ³
 use warnings  qw(FATAL utf8);    # ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã‚’è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼ã«
 use open      qw(:std :utf8);    # æœªå®£è¨€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ UTF-8 ã«
 use charnames qw(:full :short);  # v5.16 ã§ã¯ä¸è¦

=begin original

This I<does> make even Unix programmers C<binmode> your binary streams,
or open them with C<:raw>, but that's the only way to get at them
portably anyway.

=end original

ã“ã‚Œã¯ Unix ãƒ—ãƒ­ã‚°ãƒ©ãƒã§ã•ãˆãƒã‚¤ãƒŠãƒªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ C<binmode> ã—ãŸã‚Šã€
C<:raw> ã§é–‹ã„ãŸã‚Š I<ã—ã¦ã„ã¾ã™> ãŒã€ãã‚ŒãŒã¨ã«ã‹ãã“ã‚Œã‚‰ã‚’
ç§»æ¤æ€§ã®ã‚ã‚‹ã‚‚ã®ã«ã™ã‚‹å”¯ä¸€ã®æ–¹æ³•ã§ã™ã€‚

=begin original

B<WARNING>: C<use autodie> (pre 2.26) and C<use open> do not get along with each
other.

=end original

B<è­¦å‘Š>: C<use autodie>(2.26 ã‚ˆã‚Šå‰)ã¨ C<use open> ã¯åŒæ™‚ã«ä½¿ãˆã¾ã›ã‚“ã€‚

=head2 â„ 1: Generic Unicode-savvy filter

(â„ 1: ä¸€èˆ¬çš„ãª Unicode ãŒä½¿ãˆã‚‹ãƒ•ã‚£ãƒ«ã‚¿)

=begin original

Always decompose on the way in, then recompose on the way out.

=end original

å¸¸ã«ã€å…¥ã‚Šå£ã§åˆ†è§£ã—ã€å‡ºå£ã§å†åˆæˆã—ã¾ã™ã€‚

 use Unicode::Normalize;

 while (<>) {
     $_ = NFD($_);   # decompose + reorder canonically
     ...
 } continue {
     print NFC($_);  # recompose (where possible) + reorder canonically
 }

=head2 â„ 2: Fine-tuning Unicode warnings

(â„ 2: Unicode è­¦å‘Šã®å¾®èª¿æ•´)

=begin original

As of v5.14, Perl distinguishes three subclasses of UTFâ€‘8 warnings.

=end original

v5.14 ã‹ã‚‰ã€Perl ã¯ UTF-8 è­¦å‘Šã®ä¸‰ã¤ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’åŒºåˆ¥ã—ã¦ã„ã¾ã™ã€‚

 use v5.14;                  # subwarnings unavailable any earlier
 no warnings "nonchar";      # the 66 forbidden non-characters
 no warnings "surrogate";    # UTF-16/CESU-8 nonsense
 no warnings "non_unicode";  # for codepoints over 0x10_FFFF

=head2 â„ 3: Declare source in utf8 for identifiers and literals

(â„ 3: è­˜åˆ¥å­ã¨ãƒªãƒ†ãƒ©ãƒ«ã®ãŸã‚ã«ã‚½ãƒ¼ã‚¹ãŒ utf8 ã§ã‚ã‚‹ã¨å®£è¨€ã™ã‚‹)

=begin original

Without the all-critical C<use utf8> declaration, putting UTFâ€‘8 in your
literals and identifiers wonâ€™t work right.  If you used the standard
preamble just given above, this already happened.  If you did, you can
do things like this:

=end original

æœ€ã‚‚é‡è¦ãª C<use utf8> å®£è¨€ãªã—ã®å ´åˆã€ãƒªãƒ†ãƒ©ãƒ«ã¨è­˜åˆ¥å­ã«
UTF-8 ã‚’å…¥ã‚Œã‚‹ã¨æ­£ã—ãå‹•ä½œã—ã¾ã›ã‚“ã€‚
å‰è¿°ã—ãŸæ¨™æº–ã®å‰æã‚’ä½¿ã£ãŸå ´åˆã€ã“ã‚Œã¯æ—¢ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ãã®å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ãªã“ã¨ãŒã§ãã¾ã™:

 use utf8;

 my $measure   = "Ã…ngstrÃ¶m";
 my @Î¼soft     = qw( cp852 cp1251 cp1252 );
 my @á½‘Ï€Î­ÏÎ¼ÎµÎ³Î±Ï‚ = qw( á½‘Ï€Î­Ï  Î¼ÎµÎ³Î±Ï‚ );
 my @é¯‰        = qw( koi8-f koi8-u koi8-r );
 my $motto     = "ğŸ‘ª ğŸ’— ğŸª"; # FAMILY, GROWING HEART, DROMEDARY CAMEL

=begin original

If you forget C<use utf8>, high bytes will be misunderstood as
separate characters, and nothing will work right.

=end original

C<use utf8> ã‚’å¿˜ã‚Œã‚‹ã¨ã€ä¸Šä½ãƒã‚¤ãƒˆã¯åˆ¥ã€…ã®æ–‡å­—ã¨ã—ã¦èª¤è§£ã•ã‚Œã€
ä½•ã‚‚æ­£ã—ãå‹•ä½œã—ã¾ã›ã‚“ã€‚

=head2 â„ 4: Characters and their numbers

(â„ 4: æ–‡å­—ã¨ãã®ç•ªå·)

=begin original

The C<ord> and C<chr> functions work transparently on all codepoints,
not just on ASCII alone â€” nor in fact, not even just on Unicode alone.

=end original

C<ord> é–¢æ•°ã¨ C<chr> é–¢æ•°ã¯ã€ã™ã¹ã¦ã®ç¬¦å·ä½ç½®ã§é€éçš„ã«å‹•ä½œã—ã¾ã™;
ASCII ã ã‘ã§ã¯ãªãã€å®Ÿéš›ã«ã¯ Unicode ã ã‘ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚

 # ASCII characters
 ord("A")
 chr(65)

 # characters from the Basic Multilingual Plane
 ord("Î£")
 chr(0x3A3)

 # beyond the BMP
 ord("ğ‘›")               # MATHEMATICAL ITALIC SMALL N
 chr(0x1D45B)

 # beyond Unicode! (up to MAXINT)
 ord("\x{20_0000}")
 chr(0x20_0000)

=head2 â„ 5: Unicode literals by character number

(â„ 5: æ–‡å­—ç•ªå·ã«ã‚ˆã‚‹ Unicode ãƒªãƒ†ãƒ©ãƒ«)

=begin original

In an interpolated literal, whether a double-quoted string or a
regex, you may specify a character by its number using the
C<\x{I<HHHHHH>}> escape.

=end original

å±•é–‹ãƒªãƒ†ãƒ©ãƒ«ã§ã¯ã€ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã¾ã‚ŒãŸæ–‡å­—åˆ—ã‹æ­£è¦è¡¨ç¾ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€
C<\x{I<HHHHHH>}> ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ã¦ç•ªå·ã§æ–‡å­—ã‚’æŒ‡å®šã§ãã¾ã™ã€‚

 String: "\x{3a3}"
 Regex:  /\x{3a3}/

 String: "\x{1d45b}"
 Regex:  /\x{1d45b}/

 # even non-BMP ranges in regex work fine
 /[\x{1D434}-\x{1D467}]/

=head2 â„ 6: Get character name by number

(â„ 6: ç•ªå·ã§æ–‡å­—åã‚’å–å¾—ã™ã‚‹)

 use charnames ();
 my $name = charnames::viacode(0x03A3);

=head2 â„ 7: Get character number by name

(â„ 7: åå‰ã§æ–‡å­—ç•ªå·ã‚’å–å¾—ã™ã‚‹)

 use charnames ();
 my $number = charnames::vianame("GREEK CAPITAL LETTER SIGMA");

=head2 â„ 8: Unicode named characters

(â„ 8: Unicode åã«ã‚ˆã‚‹æ–‡å­—)

=begin original

Use the C<< \N{I<charname>} >> notation to get the character
by that name for use in interpolated literals (double-quoted
strings and regexes).  In v5.16, there is an implicit

=end original

å±•é–‹ãƒªãƒ†ãƒ©ãƒ«(ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã¾ã‚ŒãŸæ–‡å­—åˆ—ã¨æ­£è¦è¡¨ç¾)ã§ç”¨ã„ã‚‹ã€
åå‰ã§æ–‡å­—ã‚’å¾—ã‚‹ãŸã‚ã« C<<\N{I<charname>}>> è¡¨è¨˜ã‚’ä½¿ã„ã¾ã™ã€‚
v5.16 ã§ã¯ã€ã“ã‚Œã¯æš—é»™ã«æŒ‡å®šã•ã‚Œã¾ã™:

 use charnames qw(:full :short);

=begin original

But prior to v5.16, you must be explicit about which set of charnames you
want.  The C<:full> names are the official Unicode character name, alias, or
sequence, which all share a namespace.

=end original

ã—ã‹ã—ã€v5.16 ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã©ã® charnames ã®é›†åˆã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚’
æ˜ç¤ºçš„ã«æŒ‡å®šã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚
C<:full> ã®åå‰ã¯ã€Unicode ã®æ­£å¼ãªæ–‡å­—åã€åˆ¥åã€ã¾ãŸã¯
ä¸¦ã³ã§ã‚ã‚Šã€ã™ã¹ã¦åå‰ç©ºé–“ã‚’å…±æœ‰ã—ã¾ã™ã€‚

 use charnames qw(:full :short latin greek);

 "\N{MATHEMATICAL ITALIC SMALL N}"      # :full
 "\N{GREEK CAPITAL LETTER SIGMA}"       # :full

=begin original

Anything else is a Perl-specific convenience abbreviation.  Specify one or
more scripts by names if you want short names that are script-specific.

=end original

ãã‚Œä»¥å¤–ã¯ã€Perl å›ºæœ‰ã®ä¾¿åˆ©ãªçœç•¥å½¢ã§ã™ã€‚
ç”¨å­—å›ºæœ‰ã®çŸ­ã„åå‰ãŒå¿…è¦ãªå ´åˆã¯ã€ä¸€ã¤ä»¥ä¸Šã®ç”¨å­—ã‚’åå‰ã§æŒ‡å®šã—ã¾ã™ã€‚

 "\N{Greek:Sigma}"                      # :short
 "\N{ae}"                               #  latin
 "\N{epsilon}"                          #  greek

=begin original

The v5.16 release also supports a C<:loose> import for loose matching of
character names, which works just like loose matching of property names:
that is, it disregards case, whitespace, and underscores:

=end original

v5.16 ãƒªãƒªãƒ¼ã‚¹ã§ã¯ã€æ–‡å­—åã®ç·©ã‚„ã‹ãªãƒãƒƒãƒãƒ³ã‚°ã®ãŸã‚ã®
C<:loose> ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ã‚‚å¯¾å¿œã—ã¦ã„ã¾ã™;
ã“ã‚Œã¯ç‰¹æ€§åã®ç·©ã‚„ã‹ãªãƒãƒƒãƒãƒ³ã‚°ã¨åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™:
ã¤ã¾ã‚Šã€å¤§æ–‡å­—å°æ–‡å­—ã€ç©ºç™½ã€ä¸‹ç·šã¯ç„¡è¦–ã•ã‚Œã¾ã™:

 "\N{euro sign}"                        # :loose (from v5.16)

=head2 â„ 9: Unicode named sequences

(â„ 9: Unicode åã«ã‚ˆã‚‹ä¸¦ã³)

=begin original

These look just like character names but return multiple codepoints.
Notice the C<%vx> vector-print functionality in C<printf>.

=end original

ã“ã‚Œã‚‰ã¯æ–‡å­—åã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€è¤‡æ•°ã®ç¬¦å·ä½ç½®ã‚’è¿”ã—ã¾ã™ã€‚
C<printf> ã® C<%vx> ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¤ºæ©Ÿèƒ½ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚

 use charnames qw(:full);
 my $seq = "\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}";
 printf "U+%v04X\n", $seq;
 U+0100.0300

=head2 â„ 10: Custom named characters

(â„ 10: ã‚«ã‚¹ã‚¿ãƒ åã«ã‚ˆã‚‹æ–‡å­—)

=begin original

Use C<:alias> to give your own lexically scoped nicknames to existing
characters, or even to give unnamed private-use characters useful names.

=end original

C<:alias> ã‚’ä½¿ç”¨ã—ã¦ã€æ—¢å­˜ã®æ–‡å­—ã«å¯¾ã—ã¦ãƒ¬ã‚­ã‚·ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®
ç‹¬è‡ªã®ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’ä»˜ã‘ãŸã‚Šã€ç„¡åã®ç§ç”¨æ–‡å­—ã«æœ‰ç”¨ãªåå‰ã‚’
ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

 use charnames ":full", ":alias" => {
     ecute => "LATIN SMALL LETTER E WITH ACUTE",
     "APPLE LOGO" => 0xF8FF, # private use character
 };

 "\N{ecute}"
 "\N{APPLE LOGO}"

=head2 â„ 11: Names of CJK codepoints

(â„ 11: CJK ç¬¦å·ä½ç½®ã®åå‰)

=begin original

Sinograms like â€œæ±äº¬â€ come back with character names of
C<CJK UNIFIED IDEOGRAPH-6771> and C<CJK UNIFIED IDEOGRAPH-4EAC>,
because their â€œnamesâ€ vary.  The CPAN C<Unicode::Unihan> module
has a large database for decoding these (and a whole lot more), provided you
know how to understand its output.

=end original

ã€Œæ±äº¬ã€ã®ã‚ˆã†ãªä¸­å›½æ¼¢å­—ã¯ã€ã€Œåå‰ã€ãŒç•°ãªã‚‹ãŸã‚ã€
C<CJK UNIFIED IDEOGRAPH-6771> ã¨
C<CJK UNIFIED IDEOGRAPH-4EAC> ã¨ã„ã†æ–‡å­—åã§æˆ»ã£ã¦ãã¾ã™ã€‚
CPAN ã® C<Unicode::Unihan> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ãã®å‡ºåŠ›ã‚’ç†è§£ã™ã‚‹æ–¹æ³•ã‚’
çŸ¥ã£ã¦ã„ã‚Œã°ã€ã“ã‚Œã‚‰(ãŠã‚ˆã³ã•ã‚‰ã«å¤šãã®)æ–‡å­—ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã®
å¤§è¦æ¨¡ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æŒã¡ã¾ã™ã€‚

 # cpan -i Unicode::Unihan
 use Unicode::Unihan;
 my $str = "æ±äº¬";
 my $unhan = Unicode::Unihan->new;
 for my $lang (qw(Mandarin Cantonese Korean JapaneseOn JapaneseKun)) {
     printf "CJK $str in %-12s is ", $lang;
     say $unhan->$lang($str);
 }

=begin original

prints:

=end original

ã“ã‚Œã¯æ¬¡ã®ã‚‚ã®ã‚’è¡¨ç¤ºã—ã¾ã™:

 CJK æ±äº¬ in Mandarin     is DONG1JING1
 CJK æ±äº¬ in Cantonese    is dung1ging1
 CJK æ±äº¬ in Korean       is TONGKYENG
 CJK æ±äº¬ in JapaneseOn   is TOUKYOU KEI KIN
 CJK æ±äº¬ in JapaneseKun  is HIGASHI AZUMAMIYAKO

=begin original

If you have a specific romanization scheme in mind,
use the specific module:

=end original

ç‰¹å®šã®ãƒ­ãƒ¼ãƒå­—åŒ–ã‚¹ã‚­ãƒ¼ãƒ ã‚’è€ƒãˆã¦ã„ã‚‹å ´åˆã¯ã€ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã„ã¾ã™:

 # cpan -i Lingua::JA::Romanize::Japanese
 use Lingua::JA::Romanize::Japanese;
 my $k2r = Lingua::JA::Romanize::Japanese->new;
 my $str = "æ±äº¬";
 say "Japanese for $str is ", $k2r->chars($str);

=begin original

prints

=end original

ã“ã‚Œã¯æ¬¡ã®ã‚‚ã®ã‚’è¡¨ç¤ºã—ã¾ã™:

 Japanese for æ±äº¬ is toukyou

=head2 â„ 12: Explicit encode/decode

(â„ 12: æ˜ç¤ºçš„ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰/ãƒ‡ã‚³ãƒ¼ãƒ‰)

=begin original

On rare occasion, such as a database read, you may be
given encoded text you need to decode.

=end original

ã¾ã‚Œã«ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èª­ã¿å–ã‚Šãªã©ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’å—ã‘å–ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

  use Encode qw(encode decode);

  my $chars = decode("shiftjis", $bytes, 1);
 # OR
  my $bytes = encode("MIME-Header-ISO_2022_JP", $chars, 1);

=begin original

For streams all in the same encoding, don't use encode/decode; instead
set the file encoding when you open the file or immediately after with
C<binmode> as described later below.

=end original

åŒã˜ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å¯¾ã—ã¦ã¯ã€encode/decode ã‚’
ä½¿ã‚ãªã„ã§ãã ã•ã„;
ä»£ã‚ã‚Šã«ã€å¾Œè¿°ã™ã‚‹ã‚ˆã†ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã¨ãã€ã¾ãŸã¯ãã®ç›´å¾Œã«
C<binmode> ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚

=head2 â„ 13: Decode program arguments as utf8

(â„ 13: ãƒ—ãƒ­ã‚°ãƒ©ãƒ å¼•æ•°ã‚’ utf8 ã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹)

     $ perl -CA ...
 or
     $ export PERL_UNICODE=A
 or
    use Encode qw(decode_utf8);
    @ARGV = map { decode_utf8($_, 1) } @ARGV;

=head2 â„ 14: Decode program arguments as locale encoding

(â„ 14: ãƒ—ãƒ­ã‚°ãƒ©ãƒ å¼•æ•°ã‚’ãƒ­ã‚±ãƒ¼ãƒ«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹)

    # cpan -i Encode::Locale
    use Encode qw(locale);
    use Encode::Locale;

    # use "locale" as an arg to encode/decode
    @ARGV = map { decode(locale => $_, 1) } @ARGV;

=head2 â„ 15: Declare STD{IN,OUT,ERR} to be utf8

(â„ 15: STD{IN,OUT,ERR} ã‚’ utf8 ã¨ã—ã¦å®£è¨€ã™ã‚‹)

=begin original

Use a command-line option, an environment variable, or else
call C<binmode> explicitly:

=end original

ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚„ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã†ã‹ã€æ˜ç¤ºçš„ã«
C<binmode> ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

     $ perl -CS ...
 or
     $ export PERL_UNICODE=S
 or
     use open qw(:std :utf8);
 or
     binmode(STDIN,  ":utf8");
     binmode(STDOUT, ":utf8");
     binmode(STDERR, ":utf8");

=head2 â„ 16: Declare STD{IN,OUT,ERR} to be in locale encoding

(â„ 15: STD{IN,OUT,ERR} ã‚’ãƒ­ã‚±ãƒ¼ãƒ«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã¨ã—ã¦å®£è¨€ã™ã‚‹)

    # cpan -i Encode::Locale
    use Encode;
    use Encode::Locale;

    # or as a stream for binmode or open
    binmode STDIN,  ":encoding(console_in)"  if -t STDIN;
    binmode STDOUT, ":encoding(console_out)" if -t STDOUT;
    binmode STDERR, ":encoding(console_out)" if -t STDERR;

=head2 â„ 17: Make file I/O default to utf8

(â„ 17: ãƒ•ã‚¡ã‚¤ãƒ« I/O ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ utf8 ã«ã™ã‚‹)

=begin original

Files opened without an encoding argument will be in UTF-8:

=end original

encoding å¼•æ•°ãªã—ã§é–‹ã‹ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ UTF-8 ã«ãªã‚Šã¾ã™:

     $ perl -CD ...
 or
     $ export PERL_UNICODE=D
 or
     use open qw(:utf8);

=head2 â„ 18: Make all I/O and args default to utf8

(â„ 18: å…¨ã¦ã® I/O ã¨å¼•æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ utf8 ã«ã™ã‚‹)

     $ perl -CSDA ...
 or
     $ export PERL_UNICODE=SDA
 or
     use open qw(:std :utf8);
     use Encode qw(decode_utf8);
     @ARGV = map { decode_utf8($_, 1) } @ARGV;

=head2 â„ 19: Open file with specific encoding

(â„ 19: ç‰¹å®šã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã)

=begin original

Specify stream encoding.  This is the normal way
to deal with encoded text, not by calling low-level
functions.

=end original

ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æŒ‡å®šã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€ä½ãƒ¬ãƒ™ãƒ«é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã®ã§ã¯ãªãã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’
å‡¦ç†ã™ã‚‹é€šå¸¸ã®æ–¹æ³•ã§ã™ã€‚

 # input file
     open(my $in_file, "< :encoding(UTF-16)", "wintext");
 OR
     open(my $in_file, "<", "wintext");
     binmode($in_file, ":encoding(UTF-16)");
 THEN
     my $line = <$in_file>;

 # output file
     open($out_file, "> :encoding(cp1252)", "wintext");
 OR
     open(my $out_file, ">", "wintext");
     binmode($out_file, ":encoding(cp1252)");
 THEN
     print $out_file "some text\n";

=begin original

More layers than just the encoding can be specified here. For example,
the incantation C<":raw :encoding(UTF-16LE) :crlf"> includes implicit
CRLF handling.

=end original

ã“ã“ã§æŒ‡å®šã§ãã‚‹ã®ã¯ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ä¾‹ãˆã°ã€å‘ªæ–‡ C<":raw :encoding(UTF-16LE) :crlf"> ã«ã¯
æš—é»™çš„ãª CRLF å‡¦ç†ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

=head2 â„ 20: Unicode casing

(â„ 20: Unicode ã®å¤§æ–‡å­—å°æ–‡å­—)

=begin original

Unicode casing is very different from ASCII casing.

=end original

Unicode ã®å¤§æ–‡å­—å°æ–‡å­—ã¯ ASCII ã®å¤§æ–‡å­—å°æ–‡å­—ã¨ã¯å¤§ããç•°ãªã‚Šã¾ã™ã€‚

 uc("henry â…·")  # "HENRY â…§"
 uc("tschÃ¼ÃŸ")   # "TSCHÃœSS"  notice ÃŸ => SS

 # both are true:
 "tschÃ¼ÃŸ"  =~ /TSCHÃœSS/i   # notice ÃŸ => SS
 "Î£Î¯ÏƒÏ…Ï†Î¿Ï‚" =~ /Î£ÎŠÎ£Î¥Î¦ÎŸÎ£/i   # notice Î£,Ïƒ,Ï‚ sameness

=head2 â„ 21: Unicode case-insensitive comparisons

(â„ 21: Unicode ã®å¤§æ–‡å­—å°æ–‡å­—ã‚’ç„¡è¦–ã—ãŸæ¯”è¼ƒ)

=begin original

Also available in the CPAN L<Unicode::CaseFold> module,
the new C<fc> â€œfoldcaseâ€ function from v5.16 grants
access to the same Unicode casefolding as the C</i>
pattern modifier has always used:

=end original

CPAN ã® L<Unicode::CaseFold> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã‚‚åˆ©ç”¨å¯èƒ½ãªã€v5.16 ã®æ–°ã—ã„
C<fc> "foldcase" é–¢æ•°ã¯ã€C</i> ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿®é£¾å­ãŒå¸¸ã«ä½¿ã£ã¦ããŸã®ã¨åŒã˜
Unicode å¤§æ–‡å­—å°æ–‡å­—ç•³ã¿è¾¼ã¿ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¸ãˆã¾ã™ã€‚

 use feature "fc"; # fc() function is from v5.16

 # sort case-insensitively
 my @sorted = sort { fc($a) cmp fc($b) } @list;

 # both are true:
 fc("tschÃ¼ÃŸ")  eq fc("TSCHÃœSS")
 fc("Î£Î¯ÏƒÏ…Ï†Î¿Ï‚") eq fc("Î£ÎŠÎ£Î¥Î¦ÎŸÎ£")

=head2 â„ 22: Match Unicode linebreak sequence in regex

(â„ 22: æ­£è¦è¡¨ç¾ä¸­ã® Unicode æ”¹è¡Œä¸¦ã³ã®ãƒãƒƒãƒãƒ³ã‚°)

=begin original

A Unicode linebreak matches the two-character CRLF
grapheme or any of seven vertical whitespace characters.
Good for dealing with textfiles coming from different
operating systems.

=end original

Unicode ã®æ”¹è¡Œã¯ã€2 æ–‡å­—ã® CRLF æ›¸è¨˜ç´ ã¾ãŸã¯ä¸ƒã¤ã®å‚ç›´ç©ºç™½æ–‡å­—ã®
ã„ãšã‚Œã‹ã«ãƒãƒƒãƒãƒ³ã‚°ã—ã¾ã™ã€‚
ç•°ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰é€ã‚‰ã‚Œã¦ãã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’
æ‰±ã†ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚

 \R

 s/\R/\n/g;  # normalize all linebreaks to \n

=head2 â„ 23: Get character category

(â„ 23: æ–‡å­—ã‚«ãƒ†ã‚´ãƒªã‚’å¾—ã‚‹)

=begin original

Find the general category of a numeric codepoint.

=end original

æ•°å€¤ç¬¦å·ä½ç½®ã®ä¸€èˆ¬ã‚«ãƒ†ã‚´ãƒªã‚’è¦‹ã¤ã‘ã¾ã™ã€‚

 use Unicode::UCD qw(charinfo);
 my $cat = charinfo(0x3A3)->{category};  # "Lu"

=head2 â„ 24: Disabling Unicode-awareness in builtin charclasses

(â„ 24: çµ„ã¿è¾¼ã¿æ–‡å­—ã‚¯ãƒ©ã‚¹ã§ Unicode åˆ¤å®šã‚’ç„¡åŠ¹ã«ã™ã‚‹)

=begin original

Disable C<\w>, C<\b>, C<\s>, C<\d>, and the POSIX
classes from working correctly on Unicode either in this
scope, or in just one regex.

=end original

ã“ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¾ãŸã¯ä¸€ã¤ã®æ­£è¦è¡¨ç¾ã§ã€C<\w>ã€C<\b>ã€C<\s>ã€C<\d>ã€
ãŠã‚ˆã³ POSIX ã‚¯ãƒ©ã‚¹ãŒ Unicode ã§æ­£ã—ãå‹•ä½œã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚

 use v5.14;
 use re "/a";

 # OR

 my($num) = $str =~ /(\d+)/a;

=begin original

Or use specific un-Unicode properties, like C<\p{ahex}>
and C<\p{POSIX_Digit>}.  Properties still work normally
no matter what charset modifiers (C</d /u /l /a /aa>)
should be effect.

=end original

ã¾ãŸã¯ã€C<\p{ahex}> ã‚„ C<\p{POSIX_Digit>} ãªã©ã®ç‰¹å®šã®é Unicode ç‰¹æ€§ã‚’
ä½¿ã„ã¾ã™ã€‚
ã©ã®æ–‡å­—é›†åˆä¿®é£¾å­ (C</d /u /l /a /aa>) ãŒæœ‰åŠ¹ã§ã‚ã£ã¦ã‚‚ã€
ç‰¹æ€§ã¯æ­£å¸¸ã«å‹•ä½œã—ã¾ã™ã€‚

=head2 â„ 25: Match Unicode properties in regex with \p, \P

(â„ 25: æ­£è¦è¡¨ç¾ä¸­ã« \p, \P ã‚’ä½¿ã£ã¦ Unicode ç‰¹æ€§ã«ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹)

=begin original

These all match a single codepoint with the given
property.  Use C<\P> in place of C<\p> to match
one codepoint lacking that property.

=end original

ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ã€æŒ‡å®šã•ã‚ŒãŸç‰¹æ€§ã‚’æŒã¤ä¸€ã¤ã®ç¬¦å·ä½ç½®ã«ãƒãƒƒãƒãƒ³ã‚°ã—ã¾ã™ã€‚
C<\p> ã®ä»£ã‚ã‚Šã« C<\P> ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãã®ç‰¹æ€§ã‚’æŒãŸãªã„ä¸€ã¤ã®ç¬¦å·ä½ç½®ã«
ãƒãƒƒãƒãƒ³ã‚°ã—ã¾ã™ã€‚

 \pL, \pN, \pS, \pP, \pM, \pZ, \pC
 \p{Sk}, \p{Ps}, \p{Lt}
 \p{alpha}, \p{upper}, \p{lower}
 \p{Latin}, \p{Greek}
 \p{script=Latin}, \p{script=Greek}
 \p{East_Asian_Width=Wide}, \p{EA=W}
 \p{Line_Break=Hyphen}, \p{LB=HY}
 \p{Numeric_Value=4}, \p{NV=4}

=head2 â„ 26: Custom character properties

(â„ 26: ã‚«ã‚¹ã‚¿ãƒ æ–‡å­—ç‰¹æ€§)

=begin original

Define at compile-time your own custom character
properties for use in regexes.

=end original

æ­£è¦è¡¨ç¾ã§ä½¿ç”¨ã™ã‚‹ç‹¬è‡ªã®ã‚«ã‚¹ã‚¿ãƒ æ–‡å­—ç‰¹æ€§ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å®šç¾©ã—ã¾ã™ã€‚

 # using private-use characters
 sub In_Tengwar { "E000\tE07F\n" }

 if (/\p{In_Tengwar}/) { ... }

 # blending existing properties
 sub Is_GraecoRoman_Title {<<'END_OF_SET'}
 +utf8::IsLatin
 +utf8::IsGreek
 &utf8::IsTitle
 END_OF_SET

 if (/\p{Is_GraecoRoman_Title}/ { ... }

=head2 â„ 27: Unicode normalization

(â„ 27: Unicode æ­£è¦åŒ–)

=begin original

Typically render into NFD on input and NFC on output. Using NFKC or NFKD
functions improves recall on searches, assuming you've already done to the
same text to be searched. Note that this is about much more than just pre-
combined compatibility glyphs; it also reorders marks according to their
canonical combining classes and weeds out singletons.

=end original

é€šå¸¸ã¯ã€å…¥åŠ›ã§ã¯ NFD ã«ã€å‡ºåŠ›ã§ã¯ NFC ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚
NFKC ã¾ãŸã¯ NFKD é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã§ã€æ¤œç´¢å¯¾è±¡ã®åŒã˜ãƒ†ã‚­ã‚¹ãƒˆã«å¯¾ã—ã¦
æ—¢ã«å®Ÿè¡Œã—ã¦ã„ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã€æ¤œç´¢æ™‚ã®å†å‘¼ã³å‡ºã—ãŒæ”¹å–„ã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã¯å˜ã«äº‹å‰çµåˆã•ã‚ŒãŸäº’æ›ã‚°ãƒªãƒ•ä»¥ä¸Šã®ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã«
æ³¨æ„ã—ã¦ãã ã•ã„;
æ­£æº–çµåˆã‚¯ãƒ©ã‚¹ã«å¾“ã£ã¦ãƒãƒ¼ã‚¯ã‚’ä¸¦ã³æ›¿ãˆã€ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚’å‰Šé™¤ã—ã¾ã™ã€‚

 use Unicode::Normalize;
 my $nfd  = NFD($orig);
 my $nfc  = NFC($orig);
 my $nfkd = NFKD($orig);
 my $nfkc = NFKC($orig);

=head2 â„ 28: Convert non-ASCII Unicode numerics

(â„ 28: é ASCII Unicode æ•°å­—ã‚’å¤‰æ›ã™ã‚‹)

=begin original

Unless youâ€™ve used C</a> or C</aa>, C<\d> matches more than
ASCII digits only, but Perlâ€™s implicit string-to-number
conversion does not current recognize these.  Hereâ€™s how to
convert such strings manually.

=end original

C</a> ã‚„ C</aa> ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„é™ã‚Šã€C<\d> ã¯ ASCII æ•°å­—ä»¥ä¸Šã®ã‚‚ã®ã«
ãƒãƒƒãƒãƒ³ã‚°ã—ã¾ã™ãŒã€
Perl ã®æš—é»™çš„ãªæ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤ã¸ã®å¤‰æ›ã§ã¯ã€ç¾åœ¨ã®ã¨ã“ã‚ã“ã‚Œã‚‰ã‚’
èªè­˜ã§ãã¾ã›ã‚“ã€‚
ã“ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’æ‰‹å‹•ã§å¤‰æ›ã™ã‚‹æ–¹æ³•ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚

 use v5.14;  # needed for num() function
 use Unicode::UCD qw(num);
 my $str = "got â…« and à¥ªà¥«à¥¬à¥­ and â… and here";
 my @nums = ();
 while ($str =~ /(\d+|\N)/g) {  # not just ASCII!
    push @nums, num($1);
 }
 say "@nums";   #     12      4567      0.875

 use charnames qw(:full);
 my $nv = num("\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}");

=head2 â„ 29: Match Unicode grapheme cluster in regex

(â„ 29: æ­£è¦è¡¨ç¾ä¸­ã® Unicode æ›¸è¨˜ç´ ã‚¯ãƒ©ã‚¹ã‚¿ã«ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹)

=begin original

Programmer-visible â€œcharactersâ€ are codepoints matched by C</./s>,
but user-visible â€œcharactersâ€ are graphemes matched by C</\X/>.

=end original

ãƒ—ãƒ­ã‚°ãƒ©ãƒã‹ã‚‰è¦‹ãˆã‚‹ã€Œæ–‡å­—ã€ã¯ã€C</./s> ãŒãƒãƒƒãƒã™ã‚‹ç¬¦å·ä½ç½®ã§ã™ãŒã€
ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰è¦‹ãˆã‚‹ã€Œæ–‡å­—ã€ã¯ã€C</\X/> ãŒãƒãƒƒãƒã™ã‚‹æ›¸è¨˜ç´ ã§ã™ã€‚

 # Find vowel *plus* any combining diacritics,underlining,etc.
 my $nfd = NFD($orig);
 $nfd =~ / (?=[aeiou]) \X /xi

=head2 â„ 30: Extract by grapheme instead of by codepoint (regex)

(â„ 30: ç¬¦å·ä½ç½®ã«ã‚ˆã£ã¦ã§ã¯ãªãã€æ›¸è¨˜ç´ ã«ã‚ˆã£ã¦å±•é–‹ã™ã‚‹ (æ­£è¦è¡¨ç¾))

 # match and grab five first graphemes
 my($first_five) = $str =~ /^ ( \X{5} ) /x;

=head2 â„ 31: Extract by grapheme instead of by codepoint (substr)

(â„ 31: ç¬¦å·ä½ç½®ã«ã‚ˆã£ã¦ã§ã¯ãªãã€æ›¸è¨˜ç´ ã«ã‚ˆã£ã¦å±•é–‹ã™ã‚‹ (substr))

 # cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString->new($str);
 my $first_five = $gcs->substr(0, 5);

=head2 â„ 32: Reverse string by grapheme

(â„ 32: æ–‡å­—åˆ—ã‚’æ›¸è¨˜ç´ å˜ä½ã§åè»¢ã™ã‚‹)

=begin original

Reversing by codepoint messes up diacritics, mistakenly converting
C<crÃ¨me brÃ»lÃ©e> into C<Ã©elÌ‚urb emÌ€erc> instead of into C<eÃ©lÃ»rb emÃ¨rc>;
so reverse by grapheme instead.  Both these approaches work
right no matter what normalization the string is in:

=end original

ç¬¦å·ä½ç½®ã«ã‚ˆã‚‹åè»¢ã¯ãƒ€ã‚¤ã‚¢ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒãƒ¼ã‚¯ã‚’æ··ä¹±ã•ã›ã€èª¤ã£ã¦
C<crÃ¨me brÃ¼lÃ©e> ã‚’ C<eÃ©lÃ»rb emÃ¨rc> ã§ã¯ãªã
C<Ã©elÌ‚urb emÌ€erc> ã«å¤‰æ›ã—ã¾ã™;
ãã“ã§ã€ä»£ã‚ã‚Šã«æ›¸è¨˜ç´ ã«ã‚ˆã‚‹åè»¢ã‚’è¡Œã„ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®æ‰‹æ³•ã¯ã©ã¡ã‚‰ã‚‚ã€æ–‡å­—åˆ—ã®æ­£è¦åŒ–ãŒã©ã®ã‚ˆã†ãªã‚‚ã®ã§ã‚ã£ã¦ã‚‚
æ­£ã—ãæ©Ÿèƒ½ã—ã¾ã™ã€‚

 $str = join("", reverse $str =~ /\X/g);

 # OR: cpan -i Unicode::GCString
 use Unicode::GCString;
 $str = reverse Unicode::GCString->new($str);

=head2 â„ 33: String length in graphemes

(â„ 33: æ›¸è¨˜ç´ ã§ã®æ–‡å­—åˆ—é•·)

=begin original

The string C<brÃ»lÃ©e> has six graphemes but up to eight codepoints.
This counts by grapheme, not by codepoint:

=end original

æ–‡å­—åˆ— C<brÃ¼lÃ©e> ã¯å…­ã¤ã®æ›¸è¨˜ç´ ã‚’æŒã¡ã¾ã™ãŒã€æœ€å¤§å…«ã¤ã®ç¬¦å·ä½ç½®ã‚’æŒã¡ã¾ã™ã€‚
ã“ã‚Œã¯ã€ç¬¦å·ä½ç½®ã§ã¯ãªãã€æ›¸è¨˜ç´ ã«ã‚ˆã£ã¦ã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¾ã™:

 my $str = "brÃ»lÃ©e";
 my $count = 0;
 while ($str =~ /\X/g) { $count++ }

  # OR: cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString->new($str);
 my $count = $gcs->length;

=head2 â„ 34: Unicode column-width for printing

(â„ 34: è¡¨ç¤ºã®ãŸã‚ã® Unicode æ¡å¹…)

=begin original

Perlâ€™s C<printf>, C<sprintf>, and C<format> think all
codepoints take up 1 print column, but many take 0 or 2.
Here to show that normalization makes no difference,
we print out both forms:

=end original

Perl ã® C<printf>ã€C<sprintf>ã€C<format> ã¯ã€ã™ã¹ã¦ã®ç¬¦å·ä½ç½®ãŒ
ä¸€ã¤ã®è¡¨ç¤ºæ¡ã‚’å æœ‰ã™ã‚‹ã¨è€ƒãˆã¦ã„ã¾ã™ãŒã€å¤šãã®ç¬¦å·ä½ç½®ã¯ 0 ã‹ã‚‰ 2 ã‚’
å æœ‰ã—ã¾ã™ã€‚
ã“ã“ã§ã¯ã€æ­£è¦åŒ–ã«é•ã„ãŒãªã„ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«ã€ä¸¡æ–¹ã®å½¢å¼ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚

 use Unicode::GCString;
 use Unicode::Normalize;

 my @words = qw/crÃ¨me brÃ»lÃ©e/;
 @words = map { NFC($_), NFD($_) } @words;

 for my $str (@words) {
     my $gcs = Unicode::GCString->new($str);
     my $cols = $gcs->columns;
     my $pad = " " x (10 - $cols);
     say str, $pad, " |";
 }

=begin original

generates this to show that it pads correctly no matter
the normalization:

=end original

ã“ã‚Œã¯ã€æ­£è¦åŒ–ã«é–¢ä¿‚ãªãæ­£ã—ããƒ‘ãƒƒãƒ‡ã‚£ãƒ³ã‚°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«
æ¬¡ã®ã‚ˆã†ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚

 crÃ¨me      |
 creÌ€me      |
 brÃ»lÃ©e     |
 bruÌ‚leÌe     |

=head2 â„ 35: Unicode collation

(â„ 35: Unicode ã®ç…§åˆé †åº)

=begin original

Text sorted by numeric codepoint follows no reasonable alphabetic order;
use the UCA for sorting text.

=end original

æ•°å€¤ç¬¦å·ä½ç½®ã§ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã¯ã€åˆç†çš„ãªã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †ã§ã¯ã‚ã‚Šã¾ã›ã‚“;
ãƒ†ã‚­ã‚¹ãƒˆã®ã‚½ãƒ¼ãƒˆã«ã¯ UCA ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚

 use Unicode::Collate;
 my $col = Unicode::Collate->new();
 my @list = $col->sort(@old_list);

=begin original

See the I<ucsort> program from the L<Unicode::Tussle> CPAN module
for a convenient command-line interface to this module.

=end original

ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®ä¾¿åˆ©ãªã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã«ã¤ã„ã¦ã¯ã€
L<Unicode::Tassil> CPAN ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® I<ucsort> ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

=head2 â„ 36: Case- I<and> accent-insensitive Unicode sort

(â„ 36: å¤§æ–‡å­—å°æ–‡å­— I<ãŠã‚ˆã³> ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’ç„¡è¦–ã—ãŸ Unicode ã®ã‚½ãƒ¼ãƒˆ)

=begin original

Specify a collation strength of level 1 to ignore case and
diacritics, only looking at the basic character.

=end original

ç…§åˆå¼·åº¦ãƒ¬ãƒ™ãƒ« 1 ã‚’æŒ‡å®šã—ã¦ã€å¤§æ–‡å­—å°æ–‡å­—ã¨ãƒ€ã‚¤ã‚¢ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒãƒ¼ã‚¯ã‚’
ç„¡è¦–ã—ã€åŸºæœ¬æ–‡å­—ã ã‘ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

 use Unicode::Collate;
 my $col = Unicode::Collate->new(level => 1);
 my @list = $col->sort(@old_list);

=head2 â„ 37: Unicode locale collation

(â„ 37: Unicode ãƒ­ã‚±ãƒ¼ãƒ«ã®ç…§åˆé †åº)

=begin original

Some locales have special sorting rules.

=end original

ä¸€éƒ¨ã®ãƒ­ã‚±ãƒ¼ãƒ«ã«ã¯ã€ç‰¹åˆ¥ãªã‚½ãƒ¼ãƒˆè¦å‰‡ãŒã‚ã‚Šã¾ã™ã€‚

 # either use v5.12, OR: cpan -i Unicode::Collate::Locale
 use Unicode::Collate::Locale;
 my $col = Unicode::Collate::Locale->new(locale => "de__phonebook");
 my @list = $col->sort(@old_list);

=begin original

The I<ucsort> program mentioned above accepts a C<--locale> parameter.

=end original

ä¸Šè¨˜ã® I<ucsort> ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€C<--locale> ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã¾ã™ã€‚

=head2 â„ 38: Making C<cmp> work on text instead of codepoints

(â„ 38: ç¬¦å·ä½ç½®ã§ã¯ãªããƒ†ã‚­ã‚¹ãƒˆã§g C<cmp> ãŒå‹•ä½œã™ã‚‹ã‚ˆã†ã«ã™ã‚‹)

=begin original

Instead of this:

=end original

æ¬¡ã®ã‚ˆã†ã«ã›ãšã«:

 @srecs = sort {
     $b->{AGE}   <=>  $a->{AGE}
                 ||
     $a->{NAME}  cmp  $b->{NAME}
 } @recs;

=begin original

Use this:

=end original

æ¬¡ã‚’ä½¿ã„ã¾ã™:

 my $coll = Unicode::Collate->new();
 for my $rec (@recs) {
     $rec->{NAME_key} = $coll->getSortKey( $rec->{NAME} );
 }
 @srecs = sort {
     $b->{AGE}       <=>  $a->{AGE}
                     ||
     $a->{NAME_key}  cmp  $b->{NAME_key}
 } @recs;

=head2 â„ 39: Case- I<and> accent-insensitive comparisons

(â„ 39: å¤§æ–‡å­—å°æ–‡å­— I<ãŠã‚ˆã³> ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’ç„¡è¦–ã—ãŸæ¯”è¼ƒ)

=begin original

Use a collator object to compare Unicode text by character
instead of by codepoint.

=end original

ç…§åˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦ã€Unicode ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¬¦å·ä½ç½®ã§ã¯ãªã
æ–‡å­—ã§æ¯”è¼ƒã—ã¾ã™ã€‚

 use Unicode::Collate;
 my $es = Unicode::Collate->new(
     level => 1,
     normalization => undef
 );

  # now both are true:
 $es->eq("GarcÃ­a",  "GARCIA" );
 $es->eq("MÃ¡rquez", "MARQUEZ");

=head2 â„ 40: Case- I<and> accent-insensitive locale comparisons

(â„ 40: å¤§æ–‡å­—å°æ–‡å­— I<ãŠã‚ˆã³> ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’ç„¡è¦–ã—ãŸãƒ­ã‚±ãƒ¼ãƒ«ã§ã®æ¯”è¼ƒ)

=begin original

Same, but in a specific locale.

=end original

åŒã˜ã§ã™ãŒã€ç‰¹å®šã®ãƒ­ã‚±ãƒ¼ãƒ«ã§ã™ã€‚

 my $de = Unicode::Collate::Locale->new(
            locale => "de__phonebook",
          );

 # now this is true:
 $de->eq("tschÃ¼ÃŸ", "TSCHUESS");  # notice Ã¼ => UE, ÃŸ => SS

=head2 â„ 41: Unicode linebreaking

(â„ 41: Unicode ã®æ”¹è¡Œ)

=begin original

Break up text into lines according to Unicode rules.

=end original

Unicode è¦å‰‡ã«å¾“ã£ã¦ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã«åˆ†å‰²ã—ã¾ã™ã€‚

 # cpan -i Unicode::LineBreak
 use Unicode::LineBreak;
 use charnames qw(:full);

 my $para = "This is a super\N{HYPHEN}long string. " x 20;
 my $fmt = Unicode::LineBreak->new;
 print $fmt->break($para), "\n";

=head2 â„ 42: Unicode text in DBM hashes, the tedious way

(â„ 42: DBM ãƒãƒƒã‚·ãƒ¥ã®ä¸­ã® Unicode ãƒ†ã‚­ã‚¹ãƒˆã€é€€å±ˆãªæ–¹æ³•)

=begin original

Using a regular Perl string as a key or value for a DBM
hash will trigger a wide character exception if any codepoints
wonâ€™t fit into a byte.  Hereâ€™s how to manually manage the translation:

=end original

DBM ãƒãƒƒã‚·ãƒ¥ã®ã‚­ãƒ¼ã¾ãŸã¯å€¤ã¨ã—ã¦é€šå¸¸ã® Perl æ–‡å­—åˆ—ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€
ç¬¦å·ä½ç½®ãŒ 1 ãƒã‚¤ãƒˆã«åã¾ã‚‰ãªã„å ´åˆã«ãƒ¯ã‚¤ãƒ‰æ–‡å­—ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã™ã€‚
æ¬¡ã«ã€æ‰‹å‹•ã§å¤‰æ›ã‚’ç®¡ç†ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™:

    use DB_File;
    use Encode qw(encode decode);
    tie %dbhash, "DB_File", "pathname";

 # STORE

    # assume $uni_key and $uni_value are abstract Unicode strings
    my $enc_key   = encode("UTF-8", $uni_key, 1);
    my $enc_value = encode("UTF-8", $uni_value, 1);
    $dbhash{$enc_key} = $enc_value;

 # FETCH

    # assume $uni_key holds a normal Perl string (abstract Unicode)
    my $enc_key   = encode("UTF-8", $uni_key, 1);
    my $enc_value = $dbhash{$enc_key};
    my $uni_value = decode("UTF-8", $enc_value, 1);

=head2 â„ 43: Unicode text in DBM hashes, the easy way

(â„ 43: DBM ãƒãƒƒã‚·ãƒ¥ã®ä¸­ã® Unicode ãƒ†ã‚­ã‚¹ãƒˆã€ç°¡å˜ãªæ–¹æ³•)

=begin original

Hereâ€™s how to implicitly manage the translation; all encoding
and decoding is done automatically, just as with streams that
have a particular encoding attached to them:

=end original

æ¬¡ã«ã€å¤‰æ›ã‚’æš—é»™çš„ã«ç®¡ç†ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™;
ã™ã¹ã¦ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã¨ãƒ‡ã‚³ãƒ¼ãƒ‰ã¯ã€ç‰¹å®šã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒä»˜åŠ ã•ã‚ŒãŸ
ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨åŒã˜ã‚ˆã†ã«è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã¾ã™:

    use DB_File;
    use DBM_Filter;

    my $dbobj = tie %dbhash, "DB_File", "pathname";
    $dbobj->Filter_Value("utf8");  # this is the magic bit

 # STORE

    # assume $uni_key and $uni_value are abstract Unicode strings
    $dbhash{$uni_key} = $uni_value;

  # FETCH

    # $uni_key holds a normal Perl string (abstract Unicode)
    my $uni_value = $dbhash{$uni_key};

=head2 â„ 44: PROGRAM: Demo of Unicode collation and printing

(â„ 44: ãƒ—ãƒ­ã‚°ãƒ©ãƒ : Unicode ã®ç…§åˆã¨è¡¨ç¤ºã®ãƒ‡ãƒ¢)

=begin original

Hereâ€™s a full program showing how to make use of locale-sensitive
sorting, Unicode casing, and managing print widths when some of the
characters take up zero or two columns, not just one column each time.
When run, the following program produces this nicely aligned output:

=end original

ä»¥ä¸‹ã®å®Œå…¨ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€ãƒ­ã‚±ãƒ¼ãƒ«ã‚’èªè­˜ã™ã‚‹ã‚½ãƒ¼ãƒˆã€
Unicode ã®å¤§æ–‡å­—å°æ–‡å­—ã€ãã—ã¦ã„ãã¤ã‹ã®æ–‡å­—ãŒ 1 æ¡ã§ã¯ãªã 0 ã¾ãŸã¯ 2 æ¡ã‚’
å ã‚ã‚‹å ´åˆã®å°åˆ·å¹…ã®ç®¡ç†ã‚’ã©ã®ã‚ˆã†ã«åˆ©ç”¨ã™ã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚
æ¬¡ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€æ¬¡ã®ã‚ˆã†ãªã†ã¾ãæ•´åˆ—ã—ãŸå‡ºåŠ›ãŒç”Ÿæˆã•ã‚Œã¾ã™:

    CrÃ¨me BrÃ»lÃ©e....... â‚¬2.00
    Ã‰clair............. â‚¬1.60
    FideuÃ ............. â‚¬4.20
    Hamburger.......... â‚¬6.00
    JamÃ³n Serrano...... â‚¬4.45
    LinguiÃ§a........... â‚¬7.00
    PÃ¢tÃ©............... â‚¬4.15
    Pears.............. â‚¬2.00
    PÃªches............. â‚¬2.25
    SmÃ¸rbrÃ¸d........... â‚¬5.75
    SpÃ¤tzle............ â‚¬5.50
    XoriÃ§o............. â‚¬3.00
    Î“ÏÏÎ¿Ï‚.............. â‚¬6.50
    ë§‰ê±¸ë¦¬............. â‚¬4.00
    ãŠã‚‚ã¡............. â‚¬2.65
    ãŠå¥½ã¿ç„¼ã......... â‚¬8.00
    ã‚·ãƒ¥ãƒ¼ã‚¯ãƒªãƒ¼ãƒ ..... â‚¬1.85
    å¯¿å¸............... â‚¬9.99
    åŒ…å­............... â‚¬7.50

=begin original

Here's that program; tested on v5.14.

=end original

ã“ã‚ŒãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™; v5.14 ã§ãƒ†ã‚¹ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚

 #!/usr/bin/env perl
 # umenu - demo sorting and printing of Unicode food
 #
 # (obligatory and increasingly long preamble)
 #
 use utf8;
 use v5.14;                       # for locale sorting
 use strict;
 use warnings;
 use warnings  qw(FATAL utf8);    # fatalize encoding faults
 use open      qw(:std :utf8);    # undeclared streams in UTF-8
 use charnames qw(:full :short);  # unneeded in v5.16

 # std modules
 use Unicode::Normalize;          # std perl distro as of v5.8
 use List::Util qw(max);          # std perl distro as of v5.10
 use Unicode::Collate::Locale;    # std perl distro as of v5.14

 # cpan modules
 use Unicode::GCString;           # from CPAN

 # forward defs
 sub pad($$$);
 sub colwidth(_);
 sub entitle(_);

 my %price = (
     "Î³ÏÏÎ¿Ï‚"             => 6.50, # gyros
     "pears"             => 2.00, # like um, pears
     "linguiÃ§a"          => 7.00, # spicy sausage, Portuguese
     "xoriÃ§o"            => 3.00, # chorizo sausage, Catalan
     "hamburger"         => 6.00, # burgermeister meisterburger
     "Ã©clair"            => 1.60, # dessert, French
     "smÃ¸rbrÃ¸d"          => 5.75, # sandwiches, Norwegian
     "spÃ¤tzle"           => 5.50, # Bayerisch noodles, little sparrows
     "åŒ…å­"              => 7.50, # bao1 zi5, steamed pork buns, Mandarin
     "jamÃ³n serrano"     => 4.45, # country ham, Spanish
     "pÃªches"            => 2.25, # peaches, French
     "ã‚·ãƒ¥ãƒ¼ã‚¯ãƒªãƒ¼ãƒ "    => 1.85, # cream-filled pastry like eclair
     "ë§‰ê±¸ë¦¬"            => 4.00, # makgeolli, Korean rice wine
     "å¯¿å¸"              => 9.99, # sushi, Japanese
     "ãŠã‚‚ã¡"            => 2.65, # omochi, rice cakes, Japanese
     "crÃ¨me brÃ»lÃ©e"      => 2.00, # crema catalana
     "fideuÃ "            => 4.20, # more noodles, Valencian
                                  # (Catalan=fideuada)
     "pÃ¢tÃ©"              => 4.15, # gooseliver paste, French
     "ãŠå¥½ã¿ç„¼ã"        => 8.00, # okonomiyaki, Japanese
 );

 my $width = 5 + max map { colwidth } keys %price;

 # So the Asian stuff comes out in an order that someone
 # who reads those scripts won't freak out over; the
 # CJK stuff will be in JIS X 0208 order that way.
 my $coll  = Unicode::Collate::Locale->new(locale => "ja");

 for my $item ($coll->sort(keys %price)) {
     print pad(entitle($item), $width, ".");
     printf " â‚¬%.2f\n", $price{$item};
 }

 sub pad($$$) {
     my($str, $width, $padchar) = @_;
     return $str . ($padchar x ($width - colwidth($str)));
 }

 sub colwidth(_) {
     my($str) = @_;
     return Unicode::GCString->new($str)->columns;
 }

 sub entitle(_) {
     my($str) = @_;
     $str =~ s{ (?=\pL)(\S)     (\S*) }
              { ucfirst($1) . lc($2)  }xge;
     return $str;
 }

=head1 SEE ALSO

=begin original

See these manpages, some of which are CPAN modules:
L<perlunicode>, L<perluniprops>,
L<perlre>, L<perlrecharclass>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>,
L<PerlIO>, L<DB_File>, L<DBM_Filter>, L<DBM_Filter::utf8>,
L<Encode>, L<Encode::Locale>,
L<Unicode::UCD>,
L<Unicode::Normalize>,
L<Unicode::GCString>, L<Unicode::LineBreak>,
L<Unicode::Collate>, L<Unicode::Collate::Locale>,
L<Unicode::Unihan>,
L<Unicode::CaseFold>,
L<Unicode::Tussle>,
L<Lingua::JA::Romanize::Japanese>,
L<Lingua::ZH::Romanize::Pinyin>,
L<Lingua::KO::Romanize::Hangul>.

=end original

ä»¥ä¸‹ã® man ãƒšãƒ¼ã‚¸; ä¸€éƒ¨ã¯ CPAN ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚‚ã®ã§ã™:
L<perlunicode>, L<perluniprops>,
L<perlre>, L<perlrecharclass>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>,
L<PerlIO>, L<DB_File>, L<DBM_Filter>, L<DBM_Filter::utf8>,
L<Encode>, L<Encode::Locale>,
L<Unicode::UCD>,
L<Unicode::Normalize>,
L<Unicode::GCString>, L<Unicode::LineBreak>,
L<Unicode::Collate>, L<Unicode::Collate::Locale>,
L<Unicode::Unihan>,
L<Unicode::CaseFold>,
L<Unicode::Tussle>,
L<Lingua::JA::Romanize::Japanese>,
L<Lingua::ZH::Romanize::Pinyin>,
L<Lingua::KO::Romanize::Hangul>.

=begin original

The L<Unicode::Tussle> CPAN module includes many programs
to help with working with Unicode, including
these programs to fully or partly replace standard utilities:
I<tcgrep> instead of I<egrep>,
I<uniquote> instead of I<cat -v> or I<hexdump>,
I<uniwc> instead of I<wc>,
I<unilook> instead of I<look>,
I<unifmt> instead of I<fmt>,
and
I<ucsort> instead of I<sort>.
For exploring Unicode character names and character properties,
see its I<uniprops>, I<unichars>, and I<uninames> programs.
It also supplies these programs, all of which are general filters that do Unicode-y things:
I<unititle> and I<unicaps>;
I<uniwide> and I<uninarrow>;
I<unisupers> and I<unisubs>;
I<nfd>, I<nfc>, I<nfkd>, and I<nfkc>;
and I<uc>, I<lc>, and I<tc>.

=end original

L<Unicode::Tussle> CPAN ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€Unicode ã‚’æ‰±ã†ãŸã‚ã®å¤šãã®
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå«ã¾ã‚Œã¦ã„ã¾ã™;
ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æ¨™æº–ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’å®Œå…¨ã«ã¾ãŸã¯éƒ¨åˆ†çš„ã«
ç½®ãæ›ãˆã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™:
I<egrep> ã®ä»£ã‚ã‚Šã« I<tcgrep>ã€
I<cat -v> ã¾ãŸã¯ I<hexdump> ã®ä»£ã‚ã‚Šã« I<uniquote>ã€
I<wc> ã®ä»£ã‚ã‚Šã« I<uniwc>ã€
I<look> ã®ä»£ã‚ã‚Šã« I<unilook>ã€
I<fmt> ã®ä»£ã‚ã‚Šã« I<unifmt>ã€
I<sort> ã®ä»£ã‚ã‚Šã« I<ucsort>ã€‚
Unicode æ–‡å­—åã¨æ–‡å­—ç‰¹æ€§ã‚’èª¿ã¹ã‚‹ã«ã¯ã€I<uniprops>ã€I<unichars>ã€
I<uninames> ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
ã¾ãŸã€ã“ã‚Œã‚‰ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚‚æä¾›ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã‚‰ã¯ã™ã¹ã¦ Unicode å¯¾å¿œã®ä¸€èˆ¬çš„ãªãƒ•ã‚£ãƒ«ã‚¿ã§ã™:
I<unititle> ã¨ I<unicaps>ã€
I<uniwide> ã¨ I<uninarrow>ã€
I<unisupers> ã¨ I<unisubs>ã€
I<nfd>ã€I<nfc>ã€I<nfkd>ã€I<nfkc>;
I<uc>ã€I<lc>ã€I<tc>ã€‚

=begin original

Finally, see the published Unicode Standard (page numbers are from version
6.0.0), including these specific annexes and technical reports:

=end original

æœ€å¾Œã«ã€ã“ã‚Œã‚‰ã®ç‰¹å®šã®ä»˜å±æ–‡æ›¸ãŠã‚ˆã³æŠ€è¡“å ±å‘Šæ›¸ã‚’å«ã‚€ã€å…¬é–‹ã•ã‚ŒãŸ
Unicode æ¨™æº–(ãƒšãƒ¼ã‚¸ç•ªå·ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³6.0.0 ã‹ã‚‰) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

=over

=item Â§3.13 Default Case Algorithms, page 113;
Â§4.2  Case, pages 120â€“122;
Case Mappings, page 166â€“172, especially Caseless Matching starting on page 170.

=item UAX #44: Unicode Character Database

=item UTS #18: Unicode Regular Expressions

=item UAX #15: Unicode Normalization Forms

=item UTS #10: Unicode Collation Algorithm

=item UAX #29: Unicode Text Segmentation

=item UAX #14: Unicode Line Breaking Algorithm

=item UAX #11: East Asian Width

=back

=head1 AUTHOR

=begin original

Tom Christiansen E<lt>tchrist@perl.comE<gt> wrote this, with occasional
kibbitzing from Larry Wall and Jeffrey Friedl in the background.

=end original

Tom Christiansen E<lt>tchrist@perl.comE<gt> ãŒã€
æ™‚ã€… Larry Wall ã¨ Jeffrey Friedl ã«å¾Œã‚ã‹ã‚‰å£å‡ºã—ã•ã‚ŒãªãŒã‚‰æ›¸ãã¾ã—ãŸã€‚

=head1 COPYRIGHT AND LICENCE

Copyright Â© 2012 Tom Christiansen.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=begin original

Most of these examples taken from the current edition of the â€œCamel Bookâ€;
that is, from the 4áµ—Ê° Edition of I<Programming Perl>, Copyright Â© 2012 Tom
Christiansen <et al.>, 2012-02-13 by Oâ€™Reilly Media.  The code itself is
freely redistributable, and you are encouraged to transplant, fold,
spindle, and mutilate any of the examples in this manpage however you please
for inclusion into your own programs without any encumbrance whatsoever.
Acknowledgement via code comment is polite but not required.

=end original

ã“ã‚Œã‚‰ã®ä¾‹ã®ã»ã¨ã‚“ã©ã¯ã€"Camel Book"ã®ç¾åœ¨ã®ç‰ˆã‹ã‚‰å¼•ç”¨ã•ã‚Œã¦ã„ã¾ã™:
ã™ãªã‚ã¡ã€4áµ—Ê°ç‰ˆI<Programming Perl>, Copyright Â© 2012 Tom
Christiansen <et al.>, 2012-02-13 by O'Reilly Mediaã€‚
ã‚³ãƒ¼ãƒ‰è‡ªä½“ã¯è‡ªç”±ã«å†é…å¸ƒå¯èƒ½ã§ã‚ã‚Šã€ã“ã® man ãƒšãƒ¼ã‚¸ã®ä¾‹ã‚’ç§»æ¤ã—ãŸã‚Šã€
æŠ˜ã‚ŠãŸãŸã‚“ã ã‚Šã€ç´¡éŒ˜å½¢ã«ã—ãŸã‚Šã€åˆ‡æ–­ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ãŒã€
ã‚ãªãŸè‡ªèº«ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å«ã‚ã‚‹ãŸã‚ã«ã¯ã€ä½•ã‚‚æ°—ã«ã›ãšã«è¡Œã£ã¦ãã ã•ã„ã€‚
ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆã«ã‚ˆã‚‹è¬è¾ã¯ä¸å¯§ã§ã™ãŒã€å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

=head1 REVISION HISTORY

=begin original

v1.0.0 â€“ first public release, 2012-02-27

=end original

v1.0.0 - æœ€åˆã®ä¸€èˆ¬å…¬é–‹ã€2012-02-27

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: completed

=end meta

