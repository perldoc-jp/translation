
=encoding utf8

=head1 NAME

=begin original

perlvar - Perl predefined variables

=end original

perlvar - Perl で定義済みの変数

=head1 DESCRIPTION

=head2 The Syntax of Variable Names

(変数名の文法)

=begin original

Variable names in Perl can have several formats.  Usually, they
must begin with a letter or underscore, in which case they can be
arbitrarily long (up to an internal limit of 251 characters) and
may contain letters, digits, underscores, or the special sequence
C<::> or C<'>.  In this case, the part before the last C<::> or
C<'> is taken to be a I<package qualifier>; see L<perlmod>.
A Unicode letter that is not ASCII is not considered to be a letter
unless S<C<"use utf8">> is in effect, and somewhat more complicated
rules apply; see L<perldata/Identifier parsing> for details.

=end original

Perl の変数名は様々な形があります。
通常、変数名は英文字か下線で始まらなければならず、
任意の長さ(内部制限の 251 文字まで)を取ることができ、
英文字、数字、下線、特別な文字列である C<::> と C<'> を含むことができます。
この場合、最後の C<::> または C<'> の前は I<パッケージ限定子> として
扱われます; L<perlmod> を参照して下さい。
ASCII ではない Unicode 文字は、S<C<"use utf8">> が有効でない限り
文字として扱われません; そしていくらかより複雑な規則が適用されます;
詳しくは L<perldata/Identifier parsing> を参照してください。

=begin original

Perl variable names may also be a sequence of digits, a single
punctuation character, or the two-character sequence: C<^> (caret or
CIRCUMFLEX ACCENT) followed by any one of the characters C<[][A-Z^_?\]>.
These names are all reserved for
special uses by Perl; for example, the all-digits names are used
to hold data captured by backreferences after a regular expression
match.

=end original

Perl の変数は、数字の列または一文字の句読点文字、2 文字並び(
C<^> (キャレット、CIRCUMFLEX ACCENT) に引き続いて C<[][A-Z^_?\]> の文字の一つ)
の場合もあります。
これらの名前は全て Perl によって特別な用途のために予約されています;
例えば、全て数字の名前は正規表現マッチの後の後方参照のデータを
保持するために用いられます。

=begin original

Since Perl v5.6.0, Perl variable names may also be alphanumeric strings
preceded by a caret.  These must all be written using the demarcated
variable form using curly braces such as C<${^Foo}>;
the braces are B<not> optional.  C<${^Foo}> denotes the scalar variable
whose name is considered to be a control-C<F> followed by two C<o>'s.
(See L<perldata/"Demarcated variable names using braces"> for more
information on this form of spelling a variable name or specifying
access to an element of an array or a hash).
These variables are
reserved for future special uses by Perl, except for the ones that
begin with C<^_> (caret-underscore).  No
name that begins with C<^_> will acquire a special
meaning in any future version of Perl; such names may therefore be
used safely in programs.  C<$^_> itself, however, I<is> reserved.

=end original

Perl v5.6.0 から、キャレットが前置された、英数字からなる文字列の変数名も
使えます。
これらは C<${^Foo}> のような中かっこを使った
区切り付き変数形式で書かれなければなりません;
括弧はオプション B<ではありません>。
C<${^Foo}> はコントロール-C<F> の後に二つ C<o> が続く名前を持つ
スカラ変数と考えられます。
(変数名をこの形式で書くことや配列やハッシュの要素へのアクセスを指定する
さらなる情報については
L<perldata/"Demarcated variable names using braces"> を参照してください。)
これらの変数は Perl によって特別な用途のために予約されていますが、
C<^_> (キャレット-下線)で始まるものは例外です。
C<^_> で始まる名前は Perl の将来のバージョンで特別な意味を
持つことはありません; 従ってこれらの名前はプログラム中で安全に使用できます。
但し、C<$^_> そのものは I<予約されます>。

=begin original

Note that you also B<must> use the demarcated form to access subscripts
of variables of this type when interpolating, for instance to access the
first element of the C<@{^CAPTURE}> variable inside of a double quoted
string you would write C<"${^CAPTURE[0]}"> and NOT C<"${^CAPTURE}[0]">
which would mean to reference a scalar variable named C<${^CAPTURE}> and
not index 0 of the magic C<@{^CAPTURE}> array which is populated by the
regex engine.

=end original

この種類の変数の添え字にアクセスするためにも境界を定める形式を
B<使わなければならない> ことに注意してください;
例えば、ダブルクォート文字列の中で
C<@{^CAPTURE}> 変数の最初の要素にアクセスするには、
C<"${^CAPTURE}[0]"> ではなく C<"${^CAPTURE[0]}"> と書きます;
前者は C<${^CAPTURE}> という名前のスカラ変数へのリファレンスで、
正規表現エンジンによって設定された C<@{^CAPTURE}> マジック配列の
インデックス 0 ではありません。

=begin original

Perl identifiers that begin with digits or
punctuation characters are exempt from the effects of the C<package>
declaration and are always forced to be in package C<main>; they are
also exempt from C<strict 'vars'> errors.  A few other names are also
exempt in these ways:

=end original

数字、句読点で始まる Perl の識別子は C<package> 宣言の
効果から逃れて、常に C<main> パッケージにあるものとして扱われます。
さらに以下のものも逃れます:

    ENV      STDIN
    INC      STDOUT
    ARGV     STDERR
    ARGVOUT
    SIG

=begin original

In particular, the special C<${^_XYZ}> variables are always taken
to be in package C<main>, regardless of any C<package> declarations
presently in scope.

=end original

特に、新しい特別な C<${^_XYZ}> 変数はスコープ内の C<package> 宣言に関わらず
常に C<main> パッケージとして扱われます。

=head1 SPECIAL VARIABLES

(特殊変数)

=begin original

The following names have special meaning to Perl.  Most punctuation
names have reasonable mnemonics, or analogs in the shells.
Nevertheless, if you wish to use long variable names, you need only say:

=end original

以下の名前は Perl では特別な意味を持ちます。
記号的な名前の多くは記憶法があるか、シェルでの類推が可能です。
それでも長い名前を使用したい場合には

    use English;

=begin original

at the top of your program.  This aliases all the short names to the long
names in the current package.  Some even have medium names, generally
borrowed from B<awk>.  For more info, please see L<English>.

=end original

とプログラムの最初に書いてください。
これは、すべての短い名前の別名として、
カレントパッケージで長い名前を付けるものです。
B<awk> から持ってきた中間的な名前を持っているものもあります。
さらなる情報については、どうか L<English> を参照してください。

=begin original

Before you continue, note the sort order for variables.  In general, we
first list the variables in case-insensitive, almost-lexicographical
order (ignoring the C<{> or C<^> preceding words, as in C<${^UNICODE}>
or C<$^T>), although C<$_> and C<@_> move up to the top of the pile.
For variables with the same identifier, we list it in order of scalar,
array, hash, and bareword.

=end original

先に進む前に、変数のソート順に注意してください。
一般的に、変数を大文字小文字を無視して、ほとんど辞書順に並んでいます
(C<${^UNICODE}> や C<$^T> のように、先頭についている C<{> や C<^> は
無視します)が、C<$_> と C<@_> は先頭に来ます。
同じ識別子を持つ変数については、スカラ、配列、ハッシュ、裸の単語の順に
並べています。

=head2 General Variables

(一般変数)

=over 8

=item $ARG

=item $_
X<$_> X<$ARG>

=begin original

The default input and pattern-searching space.  The following pairs are
equivalent:

=end original

デフォルトの入力とパターン検索のスペース。
以下の 2つは同値です:

=begin original

    while (<>) {...}    # equivalent only in while!
    while (defined($_ = <>)) {...}

=end original

    while (<>) {...}    # while の中でのみ等価!
    while (defined($_ = <>)) {...}

    /^Subject:/
    $_ =~ /^Subject:/

    tr/a-z/A-Z/
    $_ =~ tr/a-z/A-Z/

    chomp
    chomp($_)

=begin original

Here are the places where Perl will assume C<$_> even if you don't use it:

=end original

あなたが使いたくなくても Perl が C<$_> を仮定する場合がいくつかあります:

=over 3

=item *

=begin original

The following functions use C<$_> as a default argument:

=end original

以下の関数は C<$_> をデフォルト引数として使います:

=begin original

abs, alarm, chomp, chop, chr, chroot,
cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc,
lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf,
quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only),
rmdir, say, sin, split (for its second
argument), sqrt, stat, study, uc, ucfirst,
unlink, unpack.

=end original

abs, alarm, chomp, chop, chr, chroot,
cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc,
lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf,
quotemeta, readlink, readpipe, ref, require, reverse (スカラコンテキストのみ),
rmdir, say, sin, split (の 2 番目の引数),
sqrt, stat, study, uc, ucfirst,
unlink, unpack

=item *

=begin original

All file tests (C<-f>, C<-d>) except for C<-t>, which defaults to STDIN.
See L<perlfunc/-X>

=end original

デフォルトが STDIN である C<-t> を除く全てのファイルテスト(C<-f>, C<-d>)。
L<perlfunc/-X> を参照してください。

=item *

=begin original

The pattern matching operations C<m//>, C<s///> and C<tr///> (aka C<y///>)
when used without an C<=~> operator.

=end original

C<=~> 演算子なしで用いられたパターンマッチ演算 C<m//>, C<s///>, C<tr///>
(またの名を C<y///>)。

=item *

=begin original

The default iterator variable in a C<foreach> loop if no other
variable is supplied.

=end original

C<foreach> ループでの他の変数が補われなかった場合のデフォルトの繰り返し変数。

=item *

=begin original

The implicit iterator variable in the C<grep()> and C<map()> functions.

=end original

C<grep()> 関数と C<map()> 関数の暗黙の繰り返し変数。

=item *

=begin original

The implicit variable of C<given()>.

=end original

C<given()> の暗黙の変数。

=item *

=begin original

The default place to put the next value or input record
when a C<< <FH> >>, C<readline>, C<readdir> or C<each>
operation's result is tested by itself as the sole criterion of a C<while>
test.  Outside a C<while> test, this will not happen.

=end original

C<< <FH> >>, C<readline>, C<readdir>, C<each> が単独で C<while> テストで
テストされた場合の、次の値や入力レコードを入れるデフォルトの場所。
C<while> テスト以外ではこれは起こりません。

=back

=begin original

C<$_> is a global variable.

=end original

C<$_> はグローバル変数です。

=begin original

However, between perl v5.10.0 and v5.24.0, it could be used lexically by
writing C<my $_>.  Making C<$_> refer to the global C<$_> in the same scope
was then possible with C<our $_>.  This experimental feature was removed and is
now a fatal error, but you may encounter it in older code.

=end original

しかし、perl v5.10.0 から v5.24.0 の間、
C<my $_> と書くことでこれをレキシカルに使うことが出来ました。
同じスコープで C<$_> がグローバルな C<$_> を参照するのは
C<our $_> で可能になっていました。
この実験的機能は削除されて今では致命的エラーですが、
古いコードで見かけるかも知れません。

=begin original

Mnemonic: underline is understood in certain operations.

=end original

記憶法: 下線はある操作を覚えるためのもの。

=item @ARG

=item @_
X<@_> X<@ARG>

=begin original

Within a subroutine the array C<@_> contains the parameters passed to
that subroutine.  Inside a subroutine, C<@_> is the default array for
the array operators C<pop> and C<shift>.

=end original

サブルーチンに入るときには、配列 C<@_> はサブルーチンに渡された
パラメータです。
サブルーチンの内部では、C<@_> は配列演算子 C<push>, C<shift> の
デフォルト配列です。

=begin original

See L<perlsub>.

=end original

L<perlsub> を参照して下さい。

=item $LIST_SEPARATOR

=item $"
X<$"> X<$LIST_SEPARATOR>

=begin original

When an array or an array slice is interpolated into a double-quoted
string or a similar context such as C</.../>, its elements are
separated by this value.  Default is a space.  For example, this:

=end original

配列や配列スライスがダブルクォートされた文字列あるいは C</.../> のような
同様のコンテキスト展開されたとき、その要素はこの値で分割されます。
デフォルトは空白です。
例えば、以下のものは:

    print "The array is: @array\n";

=begin original

is equivalent to this:

=end original

以下と等価です:

    print "The array is: " . join($", @array) . "\n";

=begin original

Mnemonic: works in double-quoted context.

=end original

記憶法: ダブルクォートされた内容に対して動作します。

=item $PROCESS_ID

=item $PID

=item $$
X<$$> X<$PID> X<$PROCESS_ID>

=begin original

The process number of the Perl running this script.  Though you I<can> set
this variable, doing so is generally discouraged, although it can be
invaluable for some testing purposes.  It will be reset automatically
across C<fork()> calls.

=end original

このスクリプトを実行している Perl のプロセス番号です。
この変数に値を設定することは I<可能> ですが、そうすることは一般的に
非推奨です; しかしこれは一部のテストの目的には計り知れない価値があります。
C<fork()> 呼び出しがあると自動的にリセットされます。

=begin original

Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl
would emulate POSIX semantics on Linux systems using LinuxThreads, a
partial implementation of POSIX Threads that has since been superseded
by the Native POSIX Thread Library (NPTL).

=end original

Linux および Debian GNU/kFreeBSD ユーザーに対する注意: Perl v5.16.0 より
前では perl は LinuxThreads を使って Linux システムで POSIX の意味論を
エミュレートしていました; これは POSIX Threads の部分的な実装で、
Native POSIX Thread Library (NPTL) で置き換えられました。

=begin original

LinuxThreads is now obsolete on Linux, and caching C<getpid()>
like this made embedding perl unnecessarily complex (since you'd have
to manually update the value of $$), so now C<$$> and C<getppid()>
will always return the same values as the underlying C library.

=end original

LinuxThreads は Linux では古いもので、このように C<getpid()> を
キャッシュすると組み込み perl が不必要に複雑になります ($$ の値を手動で
更新する必要があるからです); それで今では C<$$> と C<getppid()> は常に
基礎となる C ライブラリと同じ値を返します。

=begin original

Debian GNU/kFreeBSD systems also used LinuxThreads up until and
including the 6.0 release, but after that moved to FreeBSD thread
semantics, which are POSIX-like.

=end original

Debian GNU/kFreeBSD システムは 6.0 リリースまで LinuxThreads を
使っていましたが、その後は POSIX 風の FreeBSD スレッドの意味論に
移行しました。

=begin original

To see if your system is affected by this discrepancy check if
C<getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL> returns a false
value.  NTPL threads preserve the POSIX semantics.

=end original

あなたのシステムがこの非一貫性の影響を受けるかどうかを調べるには、
C<getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL> が偽を返すかどうかを
チェックしてください。
NTPL スレッドは POSIX の意味論を保存します。

=begin original

Mnemonic: same as shells.

=end original

記憶法: シェルと同じ。

=item $PROGRAM_NAME

=item $0
X<$0> X<$PROGRAM_NAME>

=begin original

Contains the name of the program being executed.

=end original

実行されているプログラムの名前を示します。

=begin original

On some (but not all) operating systems assigning to C<$0> modifies
the argument area that the C<ps> program sees.  On some platforms you
may have to use special C<ps> options or a different C<ps> to see the
changes.  Modifying the C<$0> is more useful as a way of indicating the
current program state than it is for hiding the program you're
running.

=end original

一部の(しかし全てではありません)オペレーティングシステムでは
C<$0> に代入を行なうことで B<ps> プログラムが見る引数エリアを修正します。
プラットフォームによっては、この変更を見るために 特殊な C<ps> オプションや、
他の C<ps> を使う必要があるものもあります。
C<$0> の修正は、実行しているプログラムを隠すよりは、
実行中のプログラムの状態を表示するときに、使うとよいでしょう。

=begin original

Note that there are platform-specific limitations on the maximum
length of C<$0>.  In the most extreme case it may be limited to the
space occupied by the original C<$0>.

=end original

C<$0> の最大長にはプラットフォーム固有の制限があることに注意してください。
最も極端な場合では、元の C<$0> で占められているサイズに制限されます。

=begin original

In some platforms there may be arbitrary amount of padding, for
example space characters, after the modified name as shown by C<ps>.
In some platforms this padding may extend all the way to the original
length of the argument area, no matter what you do (this is the case
for example with Linux 2.2).

=end original

プラットフォームによっては、任意の量のパッディングがある場合があります;
例えば、C<ps> で見られる修正された名前の後の空白文字です。
プラットフォームによっては、このパッディングは、あなたが何をしたかに
関わらず、元の引数のエリア全体に拡張されるものもあります
(例えば、これは Linux 2.2 の場合です)。

=begin original

Note for BSD users: setting C<$0> does not completely remove "perl"
from the ps(1) output.  For example, setting C<$0> to C<"foobar"> may
result in C<"perl: foobar (perl)"> (whether both the C<"perl: "> prefix
and the " (perl)" suffix are shown depends on your exact BSD variant
and version).  This is an operating system feature, Perl cannot help it.

=end original

BSD ユーザーへの注意: C<$0> に値をセットしても、ps(1) の出力から
完全に "perl" の文字列は取り除かれません。
例えば、C<$0> に C<"foobar"> と設定すると、C<"perl: foobar (perl)"> という
結果になります
(C<"perl: "> 接頭辞と" (perl)" 接尾辞が表示されるかどうかは 、正確な
BSD の種類とバージョンに依存します)。
これはオペレーティングシステムの機能で、Perl は何もできません。

=begin original

In multithreaded scripts Perl coordinates the threads so that any
thread may modify its copy of the C<$0> and the change becomes visible
to ps(1) (assuming the operating system plays along).  Note that
the view of C<$0> the other threads have will not change since they
have their own copies of it.

=end original

マルチスレッドスクリプトでは、どのスレッドも自身の C<$0> のコピーを
変更できて、その変更が(OS が対応しているとして) ps(1) で見えるように、
Perl がスレッドを調整します。
他のスレッドが持っている C<$0> の見え方は(各自が自身のコピーを
持っているので)変わらないことに注意してください。

=begin original

If the program has been given to perl via the switches C<-e> or C<-E>,
C<$0> will contain the string C<"-e">.

=end original

プログラムが perl に C<-e> または C<-E> オプション経由で与えられた場合、
C<$0> には文字列 C<"-e"> を含みます。

=begin original

On Linux as of perl v5.14.0 the legacy process name will be set with
C<prctl(2)>, in addition to altering the POSIX name via C<argv[0]> as
perl has done since version 4.000.  Now system utilities that read the
legacy process name such as ps, top and killall will recognize the
name you set when assigning to C<$0>.  The string you supply will be
cut off at 16 bytes, this is a limitation imposed by Linux.

=end original

Linux では perl v5.14.0 以降、perl がバージョン 4.000 以降行っていた
C<argv[0]> 経由での POSIX 名の置き換えに加えて、
レガシープロセス名は C<prctl(2)> で設定されます。
今では ps, top, killall  のようにレガシープロセス名を読むユーティリティは
C<$0> に代入することに設定される名前を認識します。
指定した文字列は 16 バイトに切り詰められます; これは Linux による
制限です。

=begin original

Wide characters are invalid in C<$0> values. For historical reasons,
though, Perl accepts them and encodes them to UTF-8. When this
happens a wide-character warning is triggered.

=end original

ワイド文字は C<$0> の値としては不正です。
しかし、歴史的な理由により、Perl はこれを受け入れて、UTF-8 に
エンコードします。
これが起きると、wide-character 警告が引き起こされます。

=begin original

Mnemonic: same as B<sh> and B<ksh>.

=end original

記憶法: B<sh> や B<ksh> と同じ。

=item $REAL_GROUP_ID

=item $GID

=item $(
X<$(> X<$GID> X<$REAL_GROUP_ID>

=begin original

The real gid of this process.  If you are on a machine that supports
membership in multiple groups simultaneously, gives a space separated
list of groups you are in.  The first number is the one returned by
C<getgid()>, and the subsequent ones by C<getgroups()>, one of which may be
the same as the first number.

=end original

本プロセスの実 gid を示します。
同時に複数のグループに所属できるマシンでは、所属するグループをスペースで
区切ったリストが得られます。
最初の数値は、C<getgid()> で返されるものです; その後に C<getgroups()> が
返す値が続き、その中の 1 つは、最初の値と同じかもしれません。

=begin original

However, a value assigned to C<$(> must be a single number used to
set the real gid.  So the value given by C<$(> should I<not> be assigned
back to C<$(> without being forced numeric, such as by adding zero.  Note
that this is different to the effective gid (C<$)>) which does take a
list.

=end original

しかし、C<$(> に代入された値は実際の gid に設定された値の
一つでなければなりません。
従って、 C<$(> で与えられた値はゼロを足すことによって
数値化することなく C<$(> に書き戻すべきではありません。
これはリストが得られる実行 GID (C<$)>) とは違うことに注意してください。

=begin original

You can change both the real gid and the effective gid at the same
time by using C<POSIX::setgid()>.  Changes
to C<$(> require a check to C<$!>
to detect any possible errors after an attempted change.

=end original

C<POSIX::setgid()> を使って、実 GID と実効 GID の両方を同時に変更できます。
C<$(> を変更した場合は、変更しようとしたときに起こりうるエラーを検出するために
C<$!> をチェックする必要があります。

=begin original

Mnemonic: parentheses are used to I<group> things.  The real gid is the
group you I<left>, if you're running setgid.

=end original

記憶法: 括弧は、I<グループ化>に使われます。
setgid で実行中であれば、実 gid は I<left> した、つまり離れたグループです。

=item $EFFECTIVE_GROUP_ID

=item $EGID

=item $)
X<$)> X<$EGID> X<$EFFECTIVE_GROUP_ID>

=begin original

The effective gid of this process.  If you are on a machine that
supports membership in multiple groups simultaneously, gives a space
separated list of groups you are in.  The first number is the one
returned by C<getegid()>, and the subsequent ones by C<getgroups()>,
one of which may be the same as the first number.

=end original

本プロセスの実効 gid を示します。
同時に複数のグループに所属できるマシンでは、所属するグループをスペースで
区切ったリストが得られます。
最初の数値は、C<getegid()> で返されるものです; その後に C<getgroups()> が
返す値が続き、その中の 1 つは、最初の値と同じかもしれません。

=begin original

Similarly, a value assigned to C<$)> must also be a space-separated
list of numbers.  The first number sets the effective gid, and
the rest (if any) are passed to C<setgroups()>.  To get the effect of an
empty list for C<setgroups()>, just repeat the new effective gid; that is,
to force an effective gid of 5 and an effectively empty C<setgroups()>
list, say C< $) = "5 5" >.

=end original

同様に、C<$)> へ代入する値はスペースで区切られた数値の
リストでなければなりません。
最初の数値は実効 gid を設定し、残りの数値は(もしあれば) C<setgroups()> に
渡されます。
C<setgroups()> に空リストを渡したい場合は、単に新しい実効 gid を
繰り返してください; つまり、実効 gid を 5 にして、C<setgroups()> に空リストを
渡したい場合は、C< $) = "5 5" > としてください。

=begin original

You can change both the effective gid and the real gid at the same
time by using C<POSIX::setgid()> (use only a single numeric argument).
Changes to C<$)> require a check to C<$!> to detect any possible errors
after an attempted change.

=end original

C<POSIX::setgid()> を使って、実効 GID と実 GID を同時に変更できます
(1 つの数値引数だけが使えます)。
C<$)> を変更した場合は、変更時に起こりうるエラーを検出するために C<$!> の
チェックが必要です。

=begin original

C<< $< >>, C<< $> >>, C<$(> and C<$)> can be set only on
machines that support the corresponding I<set[re][ug]id()> routine.  C<$(>
and C<$)> can be swapped only on machines supporting C<setregid()>.

=end original

C<< $< >>, C<< $> >>, C<$(>, C<$)> は、実行するマシンで、
対応する I<set[re][ug]id()> ルーティンがサポートされているときにのみ
設定可能です。
C<$(> と C<$)> の交換は、
C<setregid()> がサポートされているマシンでのみ可能です。

=begin original

Mnemonic: parentheses are used to I<group> things.  The effective gid
is the group that's I<right> for you, if you're running setgid.

=end original

記憶法: 括弧は、I<グループ化>に使われます。
setgid で実行中であれば、実効 gid は right な、つまり正しいグループです。

=item $REAL_USER_ID

=item $UID

=item $<
X<< $< >> X<$UID> X<$REAL_USER_ID>

=begin original

The real uid of this process.  You can change both the real uid and the
effective uid at the same time by using C<POSIX::setuid()>.  Since
changes to C<< $< >> require a system call, check C<$!> after a change
attempt to detect any possible errors.

=end original

本プロセスの実 uid を示します。
C<POSIX::setuid()> を使って、実効 UID と実 UID を同時に変更できます。
C<< $< >> の変更にはシステムコールが必要なので、起こりうるエラーを
検出するために C<$!> のチェックが必要です。

=begin original

Mnemonic: it's the uid you came I<from>, if you're running setuid.

=end original

記憶法: setuid で実行中であれば、そこ「から」来た uid です。

=item $EFFECTIVE_USER_ID

=item $EUID

=item $>
X<< $> >> X<$EUID> X<$EFFECTIVE_USER_ID>

=begin original

The effective uid of this process.  For example:

=end original

本プロセスの実効 uid を示します。
例えば:

=begin original

    $< = $>;            # set real to effective uid
    ($<,$>) = ($>,$<);  # swap real and effective uids

=end original

    $< = $>;            # 実 uid に実効 uid を設定
    ($<,$>) = ($>,$<);  # 実 uid と実効 uid を交換

=begin original

You can change both the effective uid and the real uid at the same
time by using C<POSIX::setuid()>.  Changes to C<< $> >> require a check
to C<$!> to detect any possible errors after an attempted change.

=end original

C<POSIX::setuid()> を使って、実効 UID と実 UID を同時に変更できます。
C<< $> >> を変更した場合は、変更時に起こりうるエラーを検出するために
C<$!> のチェックが必要です。

=begin original

C<< $< >> and C<< $> >> can be swapped only on machines
supporting C<setreuid()>.

=end original

C<< $< >> と C<< $> >> の交換は、C<setreuid()> をサポートしている
マシンでのみ可能です。

=begin original

Mnemonic: it's the uid you went I<to>, if you're running setuid.

=end original

記憶法: setuid で実行中であれば、そこ I<へ> 行く uid です。

=item $SUBSCRIPT_SEPARATOR

=item $SUBSEP

=item $;
X<$;> X<$SUBSEP> X<SUBSCRIPT_SEPARATOR>

=begin original

The subscript separator for multidimensional array emulation.  If you
refer to a hash element as

=end original

多次元配列のエミュレートのための添え字の区切文字。
ハッシュの要素を

    $foo{$x,$y,$z}

=begin original

it really means

=end original

のようにして参照すると、実際には以下のようになります

    $foo{join($;, $x, $y, $z)}

=begin original

But don't put

=end original

しかし、以下のようにしてはいけません

=begin original

    @foo{$x,$y,$z}     # a slice--note the @

=end original

    @foo{$x,$y,$z}     # スライス -- @ に注意

=begin original

which means

=end original

これは以下の意味になります

    ($foo{$x},$foo{$y},$foo{$z})

=begin original

Default is "\034", the same as SUBSEP in B<awk>.  If your keys contain
binary data there might not be any safe value for C<$;>.

=end original

デフォルトは "\034" で、C<awk> の SUBSEP と同じです。
使おうとしている key の値がバイナリのデータを含むならば、
C<$;> に設定する安全な値などはないことになります。

=begin original

Consider using "real" multidimensional arrays as described
in L<perllol>.

=end original

L<perllol> で記述している「本物の」多次元配列を使うようにしてください。

=begin original

Mnemonic: comma (the syntactic subscript separator) is a semi-semicolon.

=end original

記憶法: コンマ (構文上の添え字区切り文字) はセミ－セミコロンなのです。

=item $a

=item $b
X<$a> X<$b>

=begin original

Special package variables when using C<sort()>, see L<perlfunc/sort>.
Because of this specialness C<$a> and C<$b> don't need to be declared
(using C<use vars>, or C<our()>) even when using the C<strict 'vars'>
pragma.  Don't lexicalize them with C<my $a> or C<my $b> if you want to
be able to use them in the C<sort()> comparison block or function.

=end original

C<sort()> を使うときの特殊パッケージ変数です; L<perlfunc/sort> を
参照してください。
この特殊性により、C<$a> と C<$b> は、たとえ C<strict 'vars'> プラグマを
使っているときでも (C<use vars> や C<our()> を使って) 宣言する必要が
ありません。
これを C<sort()> 比較ブロックや関数で使えるようにしたい場合は、
C<my $a> や C<my $b> としてレキシカル化しないでください。

=item %ENV
X<%ENV>

=begin original

The hash C<%ENV> contains your current environment.  Setting a
value in C<ENV> changes the environment for any child processes
you subsequently C<fork()> off.

=end original

ハッシュ C<%ENV> には、その時点の環境変数が設定されています。
C<ENV> に値を設定することで、
以後に C<fork()> した子プロセスの環境変数を変更します。

=begin original

As of v5.18.0, both keys and values stored in C<%ENV> are stringified.

=end original

v5.18.0 から、C<%ENV> に補完されたキーと値の両方は文字列化されます。

    my $foo = 1;
    $ENV{'bar'} = \$foo;
    if( ref $ENV{'bar'} ) {
        say "Pre 5.18.0 Behaviour";
    } else {
        say "Post 5.18.0 Behaviour";
    }

=begin original

Previously, only child processes received stringified values:

=end original

以前は、子プロセスのみが文字列化された値を受け取っていました:

    my $foo = 1;
    $ENV{'bar'} = \$foo;

    # Always printed 'non ref'
    system($^X, '-e',
           q/print ( ref $ENV{'bar'}  ? 'ref' : 'non ref' ) /);

=begin original

This happens because you can't really share arbitrary data structures with
foreign processes.

=end original

これは、外部プロセスと本当に任意のデータ構造を共有することができないために
起きます。

=item $OLD_PERL_VERSION

=item $]
X<$]> X<$OLD_PERL_VERSION>

=begin original

The revision, version, and subversion of the Perl interpreter, represented
as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY
is the subversion / 1e6.  For example, Perl v5.10.1 would be "5.010001".

=end original

5.XXXYYY 型式の小数で表現される Perl インタプリタの
revision, version, subversion
(XXX は version / 1e3、 YYY は subversion / 1e6)。
例えば、、Perl v5.10.1 は "5.010001" です。

=begin original

This variable can be used to determine whether the Perl interpreter
executing a script is in the right range of versions:

=end original

スクリプトの最初で、そのスクリプトを実行しているインタプリタのバージョンが
適切な範囲内にあるかを調べる、といったことができます:

    warn "No PerlIO!\n" if "$]" < 5.008;

=begin original

When comparing C<$]>, numeric comparison operators should be used, but the
variable should be stringified first to avoid issues where its original
numeric value is inaccurate.

=end original

C<$]> を比較するとき、数値比較演算子が使われるべきですが、
元の数値が不正確な場合の問題を避けるために、まず文字列化するべきです。

=begin original

See also the documentation of L<C<use VERSION>|perlfunc/use VERSION> and
C<require VERSION> for a convenient way to fail if the running Perl
interpreter is too old.

=end original

実行する Perl インタプリタが古すぎる場合に終了する便利な方法に
ついては L<C<use VERSION>|perlfunc/use VERSION> と
C<require VERSION> のドキュメントも
参照して下さい。

=begin original

See L</$^V> for a representation of the Perl version as a L<version>
object, which allows more flexible string comparisons.

=end original

より柔軟な文字列比較が可能な L<version> オブジェクトとしての
Perl バージョン表現については L</$^V> を参照してください。

=begin original

The main advantage of C<$]> over C<$^V> is that it works the same on any
version of Perl.  The disadvantages are that it can't easily be compared
to versions in other formats (e.g. literal v-strings, "v1.2.3" or
version objects) and numeric comparisons are subject to the binary
floating point representation; it's good for numeric literal version
checks and bad for comparing to a variable that hasn't been
sanity-checked.

=end original

C<$^V> に対する C<$]> の主な利点は、どのバージョンの Perl でも同様に
動作することです。
欠点は、他の型式のバージョン (例えばリテラルな v-文字列、"v1.2.3"、
バージョンオブジェクト) と簡単に比較できず、数値比較はバイナリ
浮動小数点表現になりがちです; 数値リテラルバージョンチェックとしては
良いですが、正気チェックをされていない変数と比較するには良くないです。

=begin original

The C<$OLD_PERL_VERSION> form was added in Perl v5.20.0 for historical
reasons but its use is discouraged. (If your reason to use C<$]> is to
run code on old perls then referring to it as C<$OLD_PERL_VERSION> would
be self-defeating.)

=end original

C<$OLD_PERL_VERSION> 型式は歴史的理由により Perl v5.20.0 に追加されましたが、
この使用は非推奨です。
(C<$]> を使う理由が古い perl でコードを実行することなら、これを
C<$OLD_PERL_VERSION> して参照すると自滅することになります。)

=begin original

Mnemonic: Is this version of perl in the right bracket?

=end original

記憶法: Perl のバージョンは、正しい範囲 (right bracket) にあるか。

=item $SYSTEM_FD_MAX

=item $^F
X<$^F> X<$SYSTEM_FD_MAX>

=begin original

The maximum system file descriptor, ordinarily 2.  System file
descriptors are passed to C<exec()>ed processes, while higher file
descriptors are not.  Also, during an
C<open()>, system file descriptors are
preserved even if the C<open()> fails (ordinary file descriptors are
closed before the C<open()> is attempted).  The close-on-exec
status of a file descriptor will be decided according to the value of
C<$^F> when the corresponding file, pipe, or socket was opened, not the
time of the C<exec()>.

=end original

システムが使用するファイル記述子の最大値を示し、通常は 2 です。
システムファイル記述子は、C<exec()> されたプロセスに渡されますが、
それ以降のファイル記述子は渡されません。
また、C<open()> の実行中は、システムファイル記述子は、
たとえ C<open()> が失敗しても、保存されます
(通常のファイル記述子は、C<open()> が実行される前にクローズされます)。
ファイル記述子の close-on-exec のステータスは、C<exec()> 時ではなく、
対応するファイル、パイプソケットの open 時の C<$^F> の値によって
決められます。

=item @F
X<@F>

=begin original

The array C<@F> contains the fields of each line read in when autosplit
mode is turned on.  See L<perlrun|perlrun/-a> for the B<-a> switch.  This
array is package-specific, and must be declared or given a full package
name if not in package main when running under C<strict 'vars'>.

=end original

自動 split モードが有効の場合、配列 C<@F> には読み込んだ行のフィールドを
含みます。
B<-a> オプションについては L<perlrun|perlrun/-a> を参照してください。
この配列はパッケージ固有であり、もし C<strict 'vars'> で実行していて
パッケージ main 以外の場合は完全なパッケージ名で定義したり与えたり
しなければなりません。

=item @INC
X<@INC>

=begin original

The array C<@INC> contains the list of places that the C<do EXPR>,
C<require>, or C<use> constructs look for their library files.  It
initially consists of the arguments to any B<-I> command-line
switches, followed by the default Perl library, probably
F</usr/local/lib/perl>.
Prior to Perl 5.26, C<.> -which represents the current directory, was included
in C<@INC>; it has been removed. This change in behavior is documented
in L<C<PERL_USE_UNSAFE_INC>|perlrun/PERL_USE_UNSAFE_INC> and it is
not recommended that C<.> be re-added to C<@INC>.
If you need to modify C<@INC> at runtime, you should use the C<use lib> pragma
to get the machine-dependent library properly loaded as well:

=end original

配列 C<@INC> には、C<do EXPR>, C<require>, C<use> によってライブラリファイルを
探すときに評価する場所のリストが納められています。
初期状態では、コマンドラインスイッチ B<-I> の引数とデフォルトの
Perl ライブラリディレクトリ (おそらく F</usr/local/lib/perl5>) を
順につなげたものです。
Perl 5.26 より前では、カレントディレクトリを表す C<.> 
が C<@INC> に含まれていました; これは削除されました。
この振る舞いの変更は
L<C<PERL_USE_UNSAFE_INC>|perlrun/PERL_USE_UNSAFE_INC> に文書化されていて、
C<@INC> に C<.> を再追加するのは推奨されません。
実行時に C<@INC> 変更する必要がある場合は、マシン依存のライブラリも正しく
読み込むために C<use lib> を使うべきです:

    use lib '/mypath/libdir/';
    use SomeMod;

=begin original

You can also insert hooks into the file inclusion system by putting Perl
code directly into C<@INC>.  Those hooks may be subroutine references,
array references or blessed objects.  See L<perlfunc/require> for details.

=end original

Perl のコードを直接 C<@INC> に入れることで、ファイルインクルード機構に
フックを挿入できます。
このフックはサブルーチンリファレンス、配列リファレンス、bless された
オブジェクトが可能です。
詳細については L<perlfunc/require> を参照してください。

=item %INC
X<%INC>

=begin original

The hash C<%INC> contains entries for each filename included via the
C<do>, C<require>, or C<use> operators.  The key is the filename
you specified (with module names converted to pathnames), and the
value is the location of the file found.  The C<require>
operator uses this hash to determine whether a particular file has
already been included.

=end original

ハッシュ C<%INC> は、C<do>, C<require>, C<use> 演算子によって
インクルードされた、個々のファイル名をエントリとして持っています。
key は指定したファイル名(モジュール名はパス名に変換されます)で、
value は見つかった場所となっています。
C<require> 演算子は、指定されたファイル名が既に
インクルードされているかを、このハッシュを使って調べます。

=begin original

If the file was loaded via a hook (e.g. a subroutine reference, see
L<perlfunc/require> for a description of these hooks), this hook is
by default inserted into C<%INC> in place of a filename.  Note, however,
that the hook may have set the C<%INC> entry by itself to provide some more
specific info.

=end original

ファイルがフック(つまりサブルーチンリファレンス; フックに関する
説明については L<perlfunc/require> を参照してください)経由で読み込まれた
場合、このフックはデフォルトではファイル名の代わりに C<%INC> に挿入されます。
しかし、フックはさらなる特定の情報を提供するために、自身で C<%INC> エントリを
セットするかもしれないことに注意してください。

=item $INC
X<$INC>

=begin original

As of 5.37.7 when an C<@INC> hook is executed the index of the C<@INC>
array that holds the hook will be localized into the C<$INC> variable.
When the hook returns the integer successor of its value will be used to
determine the next index in C<@INC> that will be checked, thus if it is
set to -1 (or C<undef>) the traversal over the C<@INC> array will be
restarted from its beginning.

=end original

5.37.7 から、C<@INC> フックが実行されるとき、フックを保持する
C<@INC> 配列のインデックスは C<$INC> 変数にローカル化されます。
フックが整数を返すとき、その値の継承はチェックされる C<@INC> の
次のインデックスを決定するために使われます;
従って、もしそれが -1 (または C<undef>)に設定されるなら、
C<@INC> 配列上の走査は最初から再開されます。

=begin original

Normally traversal through the C<@INC> array is from beginning to end
(C<0 .. $#INC>), and if the C<@INC> array is modified by the hook the
iterator may be left in a state where newly added entries are skipped.
Changing this value allows an C<@INC> hook to rewrite the C<@INC> array
and tell Perl where to continue afterwards. See L<perlfunc/require> for
details on C<@INC> hooks.

=end original

通常、C<@INC> 配列のトラバースは最初から最後まで
(C<0 .. $#INC>) であり、C<@INC> 配列がフックによって変更された場合、
反復子は新しく追加されたエントリが読み飛ばされる状態のままになる
可能性があります。
この値を変更すると、C<@INC> フックが C<@INC> 配列を書き換え、
後でどこに進むかを Perl に指示できます。
C<@INC> フックの詳細については L<perlfunc/require> を参照してください。

=item $INPLACE_EDIT

=item $^I
X<$^I> X<$INPLACE_EDIT>

=begin original

The current value of the inplace-edit extension.  Use C<undef> to disable
inplace editing.

=end original

置き換え編集の拡張子の値を示します。
置き換え編集を禁止するためには、C<undef> を設定します。

=begin original

Mnemonic: value of B<-i> switch.

=end original

記憶法: B<-i> スイッチの値。

=item @ISA
X<@ISA>

=begin original

Each package contains a special array called C<@ISA> which contains a list
of that class's parent classes, if any. This array is simply a list of
scalars, each of which is a string that corresponds to a package name. The
array is examined when Perl does method resolution, which is covered in
L<perlobj>.

=end original

それぞれのパッケージには C<@ISA> という名前の特殊配列があります;
これは (もしあれば) そのクラスの親クラスのリストです。
この変数は単なるスカラのリストで、それぞれはパッケージ名に対応する
文字列です。
この配列は Perl がメソッド解決を行うときにチェックされます; これは
L<perlobj> に記述しています。

=begin original

To load packages while adding them to C<@ISA>, see the L<parent> pragma. The
discouraged L<base> pragma does this as well, but should not be used except
when compatibility with the discouraged L<fields> pragma is required.

=end original

パッケージを読み込むために C<@ISA> に追加するには、L<parent> プラグマを
参照してください。
非推奨の L<base> プラグマは同じことをしますが、
非推奨の L<fields> プラグマとの互換性が必要な場合を除いて、
使うべきではありません。

=item $^M
X<$^M>

=begin original

By default, running out of memory is an untrappable, fatal error.
However, if suitably built, Perl can use the contents of C<$^M>
as an emergency memory pool after C<die()>ing.  Suppose that your Perl
were compiled with C<-DPERL_EMERGENCY_SBRK> and used Perl's malloc.
Then

=end original

デフォルトでは、メモリ不足はトラップできない致命的エラーとなります。
しかし、もし適切に構築されていれば、Perl は C<$^M> の中身を
C<die()> した後の緊急用メモリとして使えます。
Perl が C<-DPERL_EMERGENCY_SBRK> 付きでコンパイルされ、
Perl の malloc を使うと仮定します。そして、

    $^M = 'a' x (1 << 16);

=begin original

would allocate a 64K buffer for use in an emergency.  See the
F<INSTALL> file in the Perl distribution for information on how to
add custom C compilation flags when compiling perl.  To discourage casual
use of this advanced feature, there is no L<English|English> long name for
this variable.

=end original

とすると緊急用の 64K のバッファを割り当てます。
perl をコンパイルするときに独自の C コンパイルフラグを追加する
方法についての情報は、Perl 配布パッケージに含まれている
F<INSTALL> ファイルを参照して下さい。
この拡張機能を気軽に使えないようにするために、
この変数には L<English|English> の長い名前はありません。

=begin original

This variable was added in Perl 5.004.

=end original

この変数は Perl 5.004 で追加されました。

=item ${^MAX_NESTED_EVAL_BEGIN_BLOCKS}

=begin original

This variable determines the maximum number C<eval EXPR>/C<BEGIN> or
C<require>/C<BEGIN> block nesting that is allowed. This means it also
controls the maximum nesting of C<use> statements as well.

=end original

この変数は、C<eval EXPR>/C<BEGIN> や C<require>/C<BEGIN>
ブロックのネストの許される最大数を決定します。
つまり、C<use> 文のネストの最大数も制御します。

=begin original

The default of 1000 should be sufficiently large for normal working
purposes, and if you must raise it then you should be conservative
with your choice or you may encounter segfaults from exhaustion of
the C stack. It seems unlikely that real code has a use depth above
1000, but we have left this configurable just in case.

=end original

デフォルトの 1000 は、通常の作業目的に十分な大きさであるはずです;
値を大きくする必要がある場合は、慎重に選択する必要があります;
そうしないと、C スタックの枯渇によって segfault が発生する可能性があります。
実際のコードが 1000 を超える使用深度を持つ可能性は低いと思われますが、
念のためこれを設定できるようにしてあります。

=begin original

When set to C<0> then C<BEGIN> blocks inside of C<eval EXPR> or
C<require EXPR> are forbidden entirely and will trigger an exception
which will terminate the compilation and in the case of C<require>
will throw an exception, or in the case of C<eval> return the error in
C<$@> as usual.

=end original

C<0> に設定すると、C<eval EXPR> や C<require EXPR> 内の
C<BEGIN> ブロックは完全に禁止され、コンパイルを終了する
例外を引き起こします;
C<require> の場合は例外を投げ、C<eval> の場合は通常どおり
C<$@> にエラーを返します。

=begin original

Consider the code

=end original

次のコードを考えます:

 perl -le'sub f { eval "BEGIN { f() }"; } f()'

=begin original

each invocation of C<f()> will consume considerable C stack, and this
variable is used to cause code like this to die instead of exhausting
the C stack and triggering a segfault. Needless to say code like this is
unusual, it is unlikely you will actually need to raise the setting.
However it may be useful to set it to 0 for a limited time period to
prevent BEGIN{} blocks from being executed during an C<eval EXPR>.

=end original

C<f()> の各呼び出しはかなりの C スタックを消費し、この変数は、
このようなコードが C スタックを使い果たして segfault を
引き起こすのではなく、die させるために使われます。
このようなコードが普通ではないことは言うまでもありませんが、実際に
設定を上げる必要があることはあまりありません。
ただし、C<eval EXPR> 中に BEGIN{} ブロックが実行されないようにするために、
限られた時間だけ 0 に設定すると便利な場合があります。

=begin original

Note that setting this to 1 would NOT affect code like this:

=end original

これの 1 への設定は、次のようなコードには影響しません:

    BEGIN { $n += 1; BEGIN { $n += 2; BEGIN { $n += 4 } } }

=begin original

The reason is that BEGIN blocks are executed immediately after they are
completed, thus the innermost will execute before the ones which contain
it have even finished compiling, and the depth will not go above 1. In
fact the above code is equivalent to

=end original

その理由は、BEGIN ブロックは完了した直後に実行されるためです;
したがって、最も内側のブロックは、それを含むブロックがコンパイルを
完了する前に実行され、深さは 1 を超えません。
実際、前述のコードは次と等価です:

    BEGIN { $n+=4 }
    BEGIN { $n+=2 }
    BEGIN { $n+=1 }

=begin original

which makes it obvious why a ${^MAX_EVAL_BEGIN_DEPTH} of 1 would not
block this code.

=end original

これは、なぜ ${^MAX_EVAL_BEGIN_DEPTH} を 1 にすることが
このコードをブロックしないかを分かりやすくします。

=begin original

Only C<BEGIN>'s executed inside of an C<eval> or C<require> (possibly via
C<use>) are affected.

=end original

C<eval> または (C<use> 経由を含む) C<require> の内側で実行された
C<BEGIN> のみが影響を受けます。

=item $OSNAME

=item $^O
X<$^O> X<$OSNAME>

=begin original

The name of the operating system under which this copy of Perl was
built, as determined during the configuration process.  For examples
see L<perlport/PLATFORMS>.

=end original

この Perl が構築されたオペレーティングシステムの名前です;
これは設定プロセス中に決定されます。
例えば L<perlport/PLATFORMS> を参照してください。

=begin original

The value is identical to C<$Config{'osname'}>.  See also L<Config>
and the B<-V> command-line switch documented in L<perlrun|perlrun/-V>.

=end original

この値は C<$Config{'osname'}> と同じです。
L<Config> と、L<perlrun|perlrun/-V> で文書化されている
B<-V> コマンドラインスイッチも参照して下さい。

=begin original

In Windows platforms, C<$^O> is not very helpful: since it is always
C<MSWin32>, it doesn't tell the difference between
95/98/ME/NT/2000/XP/CE/.NET.  Use C<Win32::GetOSName()> or
Win32::GetOSVersion() (see L<Win32> and L<perlport>) to distinguish
between the variants.

=end original

Windows プラットフォームでは、C<$^O> はあまり役に立ちません: これは常に
C<MSWin32> となり、95/98/ME/NT/2000/XP/CE/.NET の違いを示していないからです。
これらを区別するためには、C<Win32::GetOSName()> や Win32::GetOSVersion() を
使ってください (L<Win32> と L<perlport> を参照してください)。

=begin original

This variable was added in Perl 5.003.

=end original

この変数は Perl 5.003 で追加されました。

=item %SIG
X<%SIG>

=begin original

The hash C<%SIG> contains signal handlers for signals.  For example:

=end original

ハッシュ C<%SIG> にはシグナルのためのシグナルハンドラが含まれています。
例えば:

=begin original

    sub handler {   # 1st argument is signal name
        my($sig) = @_;
        print "Caught a SIG$sig--shutting down\n";
        close(LOG);
        exit(0);
    }

=end original

    sub handler {   # 最初の引数はシグナル名
        my($sig) = @_;
        print "Caught a SIG$sig--shutting down\n";
        close(LOG);
        exit(0);
    }

=begin original

    $SIG{'INT'}  = \&handler;
    $SIG{'QUIT'} = \&handler;
    ...
    $SIG{'INT'}  = 'DEFAULT';   # restore default action
    $SIG{'QUIT'} = 'IGNORE';    # ignore SIGQUIT

=end original

    $SIG{'INT'}  = \&handler;
    $SIG{'QUIT'} = \&handler;
    ...
    $SIG{'INT'}  = 'DEFAULT';   # デフォルトの動作を復元
    $SIG{'QUIT'} = 'IGNORE';    # SIGQUIT を無視

=begin original

Using a value of C<'IGNORE'> usually has the effect of ignoring the
signal, except for the C<CHLD> signal.  See L<perlipc> for more about
this special case.  Using an empty string or C<undef> as the value has
the same effect as C<'DEFAULT'>.

=end original

C<'IGNORE'> という値は通常はシグナルの効果を無視するために使いますが、
C<CHLD> シグナルは例外です。
この特別な場合に関する詳細は L<perlipc> を参照して下さい。
値として空文字列や C<undef> を使うのは C<'DEFAULT'> と同じ効果です。

=begin original

Here are some other examples:

=end original

以下にその他の例を示します:

=begin original

    $SIG{"PIPE"} = "Plumber";   # assumes main::Plumber (not
                                # recommended)
    $SIG{"PIPE"} = \&Plumber;   # just fine; assume current
                                # Plumber
    $SIG{"PIPE"} = *Plumber;    # somewhat esoteric
    $SIG{"PIPE"} = Plumber();   # oops, what did Plumber()
                                # return??

=end original

    $SIG{"PIPE"} = "Plumber";   # main::Plumber を仮定します(非推奨)
    $SIG{"PIPE"} = \&Plumber;   # 問題なし; カレントの Plumber を仮定します
    $SIG{"PIPE"} = *Plumber;    # 少々難解
    $SIG{"PIPE"} = Plumber();   # げげ、Plumber() は何を返すの??

=begin original

Be sure not to use a bareword as the name of a signal handler,
lest you inadvertently call it.

=end original

裸の単語をシグナルハンドラの名前として使わないようにしてください;
不注意で呼び出すのを避けるためです。

=begin original

Using a string that doesn't correspond to any existing function or a
glob that doesn't contain a code slot is equivalent to C<'IGNORE'>,
but a warning is emitted when the handler is being called (the warning
is not emitted for the internal hooks described below).

=end original

既存の関数に対応しない文字列や、コードスロットを含んでいないグロブを
使うのは、C<'IGNORE'> と等価ですが、ハンドラが呼び出されると警告が
発生します(後述する内部フックでは警告は発生しません)。

=begin original

If your system has the C<sigaction()> function then signal handlers
are installed using it.  This means you get reliable signal handling.

=end original

システムに sigaction() 関数がある場合は、シグナルハンドラはそれを使って
インストールされます。
これにより、信頼性のあるシグナルハンドリングが可能になります。

=begin original

The default delivery policy of signals changed in Perl v5.8.0 from
immediate (also known as "unsafe") to deferred, also known as "safe
signals".  See L<perlipc> for more information.

=end original

デフォルトのシグナル配送ポリシーは Perl v5.8.0 に即時("unsafe"としても
知られます)から保留(「安全なシグナル」としても知られます)に変更されました。
さらなる情報については L<perlipc> を参照してください。

=begin original

Certain internal hooks can be also set using the C<%SIG> hash.  The
routine indicated by C<$SIG{__WARN__}> is called when a warning
message is about to be printed.  The warning message is passed as the
first argument.  The presence of a C<__WARN__> hook causes the
ordinary printing of warnings to C<STDERR> to be suppressed.  You can
use this to save warnings in a variable, or turn warnings into fatal
errors, like this:

=end original

ある種の内部フックも %SIG ハッシュを使ってセットされます。
警告メッセージを表示しようとするときに C<$SIG{__WARN__}> で
示されたルーチンが呼び出されます。
警告メッセージは最初の引数として渡されます。
C<__WARN__> フックがあると、通常の C<STDERR> への警告の出力は行われません。
これを使って、警告メッセージを変数にいれたり、
あるいは以下のようにして警告を致命的エラーに変えたり出来ます:

    local $SIG{__WARN__} = sub { die $_[0] };
    eval $proggie;

=begin original

As the C<'IGNORE'> hook is not supported by C<__WARN__>, its effect is
the same as using C<'DEFAULT'>.  You can disable warnings using the
empty subroutine:

=end original

C<__WARN__> では C<'IGNORE'> フックには対応していないので、
この効果は C<'DEFAULT'> を使うのと同じです。
空サブルーチンを使って警告を無効に出来ます:

    local $SIG{__WARN__} = sub {};

=begin original

The routine indicated by C<$SIG{__DIE__}> is called when a fatal
exception is about to be thrown.  The error message is passed as the
first argument.  When a C<__DIE__> hook routine returns, the exception
processing continues as it would have in the absence of the hook, unless
the hook routine itself throws an exception.  The C<__DIE__> handler is
explicitly disabled during the call, so that you can die from a
C<__DIE__> handler.  Similarly for C<__WARN__>.

=end original

C<$SIG{__DIE__}> で示されるルーチンは
致命的な例外がまさに投げられようとするときに呼び出されます。
エラーメッセージは最初の引数として渡されます。
C<__DIE__> フックから戻ると、例外処理はフックがなかったかのように
再開されますが、フックルーチン自体が例外を投げた場合を除きます。
C<__DIE__> ハンドラは呼び出し中は明示的に無効になりますので、
C<__DIE__> ハンドラから die できます。
C<__WARN__> も同様です。

=begin original

The C<$SIG{__DIE__}> hook is called even inside an C<eval()>. It was
never intended to happen this way, but an implementation glitch made
this possible. This used to be deprecated, as it allowed strange action
at a distance like rewriting a pending exception in C<$@>. Plans to
rectify this have been scrapped, as users found that rewriting a
pending exception is actually a useful feature, and not a bug.

=end original

C<$SIG{__DIE__}> は eval() の中でも呼び出されます。
これは決してこのようになることを意図したものではありませんでしたが、
実装上のミスでこれが可能になっていました。
これは以前廃止予定でした; C<$@> で保留されている例外を書き換えるといった
変わった行動を離れた場所でできるようにしていたからです。
これを修正する計画は破棄されました;
保留されている例外を書き換えるというのは実際有用な機能であることがわかり、
またバグではないからです。

=begin original

The C<$SIG{__DIE__}> hook doesn't support C<'IGNORE'>; it has the same
effect as C<'DEFAULT'>.

=end original

C<$SIG{__DIE__}> フックは C<'IGNORE'> に対応していません;
これは C<'DEFAULT'> と同じ効果です。

=begin original

C<__DIE__>/C<__WARN__> handlers are very special in one respect: they
may be called to report (probable) errors found by the parser.  In such
a case the parser may be in inconsistent state, so any attempt to
evaluate Perl code from such a handler will probably result in a
segfault.  This means that warnings or errors that result from parsing
Perl should be used with extreme caution, like this:

=end original

C<__DIE__> と C<__WARN__> のハンドラは一つの点で非常に特別です:
パーサによってエラー(であろうもの)を報告するために呼び出されることがある
ことです。
このような場合、パーサは不安定な状態になっているかもしれないので、
ハンドラから Perl コードを評価しようとするとセグメンテーションフォールトが
発生するかもしれません。
Perl のパース中の警告やエラーは、以下のように非常に注意して扱うべきです;

    require Carp if defined $^S;
    Carp::confess("Something wrong") if defined &Carp::confess;
    die "Something wrong, but could not load Carp to give "
      . "backtrace...\n\t"
      . "To see backtrace try starting Perl with -MCarp switch";

=begin original

Here the first line will load C<Carp> I<unless> it is the parser who
called the handler.  The second line will print backtrace and die if
C<Carp> was available.  The third line will be executed only if C<Carp> was
not available.

=end original

一行目は、パーサが C<ハンドラ> を I<呼び出したのでなければ> C<Carp> を
読み込みます。
C<二行目> は、C<Carp> が使えるならバックとレースを表示して die します。
三行目は C<Carp> が使えないときにのみ実行されます。

=begin original

Having to even think about the C<$^S> variable in your exception
handlers is simply wrong.  C<$SIG{__DIE__}> as currently implemented
invites grievous and difficult to track down errors.  Avoid it
and use an C<END{}> or CORE::GLOBAL::die override instead.

=end original

例外ハンドラの中で C<$^S> を使おうなどとは考えてもいけません。
現在の実装の C<$SIG{__DIE__}> は面倒を引き寄せ、エラーの追跡を困難にします。
これの代わりに C<END{}> を使うか、CORE::GLOBAL::die を
オーバーライドしてください。

=begin original

See L<perlfunc/die>, L<perlfunc/warn>, L<perlfunc/eval>, and
L<warnings> for additional information.

=end original

追加の情報については L<perlfunc/die>, L<perlfunc/warn>, L<perlfunc/eval>,
L<warnings> を参照して下さい。

=item %{^HOOK}
X<%{^HOOK}>

=begin original

This hash contains coderefs which are called when various perl keywords
which are hard or impossible to wrap are called. The keys of this hash
are named after the keyword that is being hooked, followed by two
underbars and then a phase term; either "before" or "after".

=end original

このハッシュには、ラップが困難または不可能なさまざまな
perl キーワードが呼び出されたときに呼び出される
コードリファレンスが含まれています。
このハッシュのキーは、フックされているキーワードにちなんで
名前が付けられ、その後に二つのアンダーバーとフェーズ用語
("before" または "after")が続きます。

=begin original

Perl will throw an error if you attempt to modify a key which is not
documented to exist, or if you attempt to store anything other than a
code reference or undef in the hash.  If you wish to use an object to
implement a hook you can use currying to embed the object into an
anonymous code reference.

=end original

存在することが文書化されていないキーを変更しようとしたり、
コードリファレンスや undef 以外のものをハッシュに
保存しようとしたりすると、Perl はエラーを投げます。
フックを実装するためにオブジェクトを使用したい場合は、カリー化を
使って、オブジェクトに匿名コードリファレンスを埋め込むことができます。

=begin original

Currently there is only one keyword which can be hooked, C<require>, but
it is expected that in future releases there will be additional keywords
with hook support.

=end original

現在、フック可能なキーワードは C<require> のみですが、将来のリリースでは
フックに対応するキーワードが追加される予定です。

=over 4

=item require__before

=begin original

The routine indicated by C<${^HOOK}{require__before}> is called by
C<require> B<before> it checks C<%INC>, looks up C<@INC>, calls INC
hooks, or compiles any code.  It is called with a single argument, the
filename for the item being required (package names are converted to
paths).  It may alter this filename to change what file is loaded.  If
the hook dies during execution then it will block the require from executing.

=end original

C<${^HOOK}{require__before}> で示されるルーチンは、
C<%INC> をチェックしたり、C<@INC> を検索したり、
INC フックを呼び出したり、任意のコードをコンパイルしたりする
B<前> に C<require> によって呼び出されます。
このルーチンは単一の引数で呼び出されます;
require されるアイテムのファイル名です (パッケージ名はパスに変換されます)。
このファイル名を変更して、ロードされるファイルを変更できます。
実行中にフックが die すると、require の実行がブロックされます。

=begin original

In order to make it easy to perform an action with shared state both
before and after the require keyword was executed the C<require__before>
hook may return a "post-action" coderef which will in turn be executed when
the C<require> completes.  This coderef will be executed regardless as to
whether the require completed successfully or threw an exception.  It will
be called with the filename that was required.  You can check %INC to
determine if the require was successful.  Any other return from the
C<require__before> hook will be silently ignored.

=end original

require キーワードが実行される前と後の両方で共有状態のアクションを
簡単に実行できるようにするために、C<require__before> フックは、
C<require> が完了したときに順番に実行される「アクション後」の
コードリファレンスを返すことができます。
このコードリファレンスは、require が正常に完了したか、
例外が投げられたかにかかわらず実行されます。
これは、require されたファイル名と共に呼び出されます。
%INC をチェックして、require が成功したかどうかを判断できます。
C<require__before> フックからのその他の戻り値は、暗黙に無視されます。

=begin original

C<require__before> hooks are called in FIFO order, and if the hook
returns a code reference those code references will be called in FILO
order.  In other words if A requires B requires C, then
C<require__before> will be called first for A, then B and then C, and
the post-action code reference will be executed first for C, then B and
then finally A.

=end original

C<require__before> フックは FIFO 順に呼び出され、フックが
コードリファレンスを返す場合、それらのコードリファレンスは
FILO 順に呼び出されます。
つまり、A が B を require し、B が C を require する場合、
C<require__before> が最初に A に対して呼び出され、次に B, C の順に
呼び出され、アクション後のコードリファレンスが最初に C に対して実行され、
次に B、最後に A の順に実行されます。

=begin original

Well behaved code should ensure that when setting up a
C<require__before> hook that any prior installed hook will be called,
and that their return value, if a code reference, will be called as
well.  See L<perlfunc/require> for an example implementation.

=end original

適切に動作するコードでは、C<require__before> フックを設定するときに、
以前にインストールされたフックが呼び出され、コードリファレンスの場合は
その戻り値も呼び出されるようにする必要があります。
実装例については、L<perlfunc/require> を参照してください。

=item require__after

=begin original

The routine indicated by C<${^HOOK}{require__after}> is called by
C<require> B<after> the require completes.  It is called with a single
argument, the filename for the item being required (package names are
converted to paths).  It is executed when the C<require> completes,
either via exception or via completion of the require statement, and you
can check C<%INC> to determine if the require was successful.

=end original

C<${^HOOK}{require__after}> で示されるルーチンは、require が完了した
B<後> に C<require> によって呼び出されます。
このルーチンは単一の引数で呼び出されます;
require されるアイテムのファイル名です (パッケージ名はパスに変換されます)。
このルーチンは、例外または require 文の完了によって
C<require> が完了したときに実行されます;
C<%INC> をチェックして、require が成功したかどうかを判断できます。

=begin original

The C<require__after> hook is called for each required file in FILO
order. In other words if A requires B requires C, then C<require__after>
will be called first for C, then B and then A.

=end original

C<require__after> フックは、require されたファイルごとに FILO 順で
呼び出されます。
つまり、A が B を require し、B が C を require する場合、
C<require__after> が最初に C に対して呼び出され、次に B、次に A に対して
呼び出されます。

=back

=item $BASETIME

=item $^T
X<$^T> X<$BASETIME>

=begin original

The time at which the program began running, in seconds since the
epoch (beginning of 1970).  The values returned by the B<-M>, B<-A>,
and B<-C> filetests are based on this value.

=end original

プログラムを実行開始した時刻を、紀元 (1970年の始め) からの秒数で
示したものです。
ファイルテスト B<-M>、B<-A>、B<-C> で返される値は、この値に基づいています。

=item $PERL_VERSION

=item $^V
X<$^V> X<$PERL_VERSION>

=for comment
These are documented in the generated file lib/Config.pod.  This looks
like as good a place as any to give notice that they are documented.

=begin original

The revision, version, and subversion of the Perl interpreter,
represented as a L<version> object.

=end original

L<version> オブジェクトとして表現される Perl インタプリタの
revision, version, subversion。

=begin original

This variable first appeared in perl v5.6.0; earlier versions of perl
will see an undefined value.  Before perl v5.10.0 C<$^V> was represented
as a v-string rather than a L<version> object.

=end original

この変数は perl v5.6.0 で最初に現れました; それより前のバージョンでは
未定義値となります。
perl v5.10.0 以前では C<$^V> は L<version> オブジェクトではなく
v-string 形式で表現されます。

=begin original

C<$^V> can be used to determine whether the Perl interpreter executing
a script is in the right range of versions.  For example:

=end original

C<$^V> はスクリプトを実行している Perl インタプリタのバージョンが
正しい範囲に入っているかを調べるのに使えます。
例えば:

    warn "Hashes not randomized!\n" if !$^V or $^V lt v5.8.1

=begin original

While version objects overload stringification, to portably convert
C<$^V> into its string representation, use C<sprintf()>'s C<"%vd">
conversion, which works for both v-strings or version objects:

=end original

移植性がある形で C<$^V> を文字列表現に変換するために、
バージョンオブジェクトは文字列化をオーバーロードしますが、
v-文字列とバージョンオブジェクトの療養で動作する
C<sprintf()> の C<"%vd"> 変換を使ってください。

=begin original

    printf "version is v%vd\n", $^V;  # Perl's version

=end original

    printf "version is v%vd\n", $^V;  # Perl のバージョン

=begin original

See the documentation of C<use VERSION> and C<require VERSION>
for a convenient way to fail if the running Perl interpreter is too old.

=end original

実行する Perl インタプリタが古すぎる場合に終了する便利な方法については
C<use VERSION> と C<require VERSION> のドキュメントを参照して下さい。

=begin original

See also C<L</$]>> for a decimal representation of the Perl version.

=end original

Perl バージョンの 10 進表現については C<L</$]>> も参照して下さい。

=begin original

The main advantage of C<$^V> over C<$]> is that, for Perl v5.10.0 or
later, it overloads operators, allowing easy comparison against other
version representations (e.g. decimal, literal v-string, "v1.2.3", or
objects).  The disadvantage is that prior to v5.10.0, it was only a
literal v-string, which can't be easily printed or compared, whereas
the behavior of C<$]> is unchanged on all versions of Perl.

=end original

Perl 5.10.0 以降での、C<$]> に対する C<$^V> の主な利点は、これは演算子を
オーバーロードするので、他のバージョン表現 (例えば 10 進数、
リテラルな v-文字列、"v1.2.3"、オブジェクト)との比較が簡単であることです。
v5.10.0 より前での欠点は、これは単なるリテラルな v-文字列であるため、
簡単に表示したり比較したり出来ないことです; 一方、
C<$]> の振る舞いは全てのバージョンの Perl で変化しません。

=begin original

Mnemonic: use ^V for a version object.

=end original

記憶法: ^V をバージョンオブジェクトに使います。

=item $EXECUTABLE_NAME

=item $^X
X<$^X> X<$EXECUTABLE_NAME>

=begin original

The name used to execute the current copy of Perl, from C's
C<argv[0]> or (where supported) F</proc/self/exe>.

=end original

Perl バイナリ自身が実行された時の名前を C の argv[0] または (対応していれば)
F</proc/self/exe> から持ってきたものです。

=begin original

Depending on the host operating system, the value of C<$^X> may be
a relative or absolute pathname of the perl program file, or may
be the string used to invoke perl but not the pathname of the
perl program file.  Also, most operating systems permit invoking
programs that are not in the PATH environment variable, so there
is no guarantee that the value of C<$^X> is in PATH.  For VMS, the
value may or may not include a version number.

=end original

ホスト OS に依存して、C<$^X> の値は perl プログラムファイルの絶対パスかも
しれませんし、相対パスかもしれませんし、perl を起動するために使われる
文字列ではありますが perl プログラムファイルのパス名ではないかもしれません。
また、ほとんどの OS は PATH 環境変数にない位置のプログラムを起動することを
許しているので、C<$^X> の値が PATH にある保証はありません。
VMS では、この値はバージョン番号を含む場合も含まない場合もあります。

=begin original

You usually can use the value of C<$^X> to re-invoke an independent
copy of the same perl that is currently running, e.g.,

=end original

通常は、現在実行中のものと同じ perl の独立したコピーを再起動するために
C<$^X> の値を使えます; つまり:

    @first_run = `$^X -le "print int rand 100 for 1..100"`;

=begin original

But recall that not all operating systems support forking or
capturing of the output of commands, so this complex statement
may not be portable.

=end original

しかし、全ての OS が fork やコマンドの出力の捕捉に対応しているわけでは
ないので、この複雑な文は移植性がないかもしれないことを忘れないでください。

=begin original

It is not safe to use the value of C<$^X> as a path name of a file,
as some operating systems that have a mandatory suffix on
executable files do not require use of the suffix when invoking
a command.  To convert the value of C<$^X> to a path name, use the
following statements:

=end original

C<$^X> の値をファイルのパス名として使うのは安全ではありません; 実行ファイルに
固定の接尾辞があり、コマンドの起動時には接尾辞が不要な OS もあるからです。
C<$^X> の値をパス名に変換するには、以下のコードを使ってください:

=begin original

    # Build up a set of file names (not command names).
    use Config;
    my $this_perl = $^X;
    if ($^O ne 'VMS') {
        $this_perl .= $Config{_exe}
        unless $this_perl =~ m/$Config{_exe}$/i;
    }

=end original

    # (コマンド名ではなく)ファイル名を構築する。
    use Config;
    my $this_perl = $^X;
    if ($^O ne 'VMS') {
        $this_perl .= $Config{_exe}
        unless $this_perl =~ m/$Config{_exe}$/i;
    }

=begin original

Because many operating systems permit anyone with read access to
the Perl program file to make a copy of it, patch the copy, and
then execute the copy, the security-conscious Perl programmer
should take care to invoke the installed copy of perl, not the
copy referenced by C<$^X>.  The following statements accomplish
this goal, and produce a pathname that can be invoked as a
command or referenced as a file.

=end original

多くの OS が Perl のプログラムファイルのコピーを作って、コピーにパッチを当て、
それを実行するための読み込み権限を全員に与えているので、セキュリティ
意識のある Perl プログラマは C<$^X> で参照されているコピーではなく、
インストールされている perl を起動するように気をつけるべきです。
以下のコードはこの目的を達成し、コマンドとして起動したりファイルとして
参照するためのパス名を作成します。

    use Config;
    my $secure_perl_path = $Config{perlpath};
    if ($^O ne 'VMS') {
        $secure_perl_path .= $Config{_exe}
        unless $secure_perl_path =~ m/$Config{_exe}$/i;
    }

=back

=head2 Variables related to regular expressions

(正規表現に関する変数)

=begin original

Most of the special variables related to regular expressions are side
effects. Perl sets these variables when it has completed a match
successfully, so you should check the match result before using them.
For instance:

=end original

正規表現に関連する特殊変数のほとんどは副作用です。
Perl はマッチングに成功したときにこれらの変数を設定するので、変数を
使う前にマッチングの結果をチェックするべきです。
例えば:

    if( /P(A)TT(ER)N/ ) {
        print "I found $1 and $2\n";
    }

=begin original

These variables are read-only and behave similarly to a dynamically
scoped variable, with only a few exceptions which are explicitly
documented as behaving otherwise.  See the following section for more
details.

=end original

これらの変数は、異なる振る舞いを明示的に記しているいくつかの例外を除いて、
読み込み専用で動的スコープを持つ変数と同様に振る舞います。

=head3 Scoping Rules of Regex Variables
X<Scoping Rules of Regex Variables>

(正規表現変数のスコープ規則)

=begin original

Regular expression variables allow the programmer to access the state of
the most recent I<successful> regex match in the current dynamic scope.

=end original

正規表現変数を使うと、プログラマは現在の動的スコープ内で最後に
I<成功した> 正規表現マッチングの状態にアクセスできます。

=begin original

The variables themselves are global and unscoped, but the data they
access is scoped similarly to dynamically scoped variables, in that
every successful match behaves as though it localizes a global state
object to the current block or file scope.
(See L<perlsyn/"Compound Statements"> for more details on dynamic
scoping and the C<local> keyword.)

=end original

変数自体はグローバルでスコープはありませんが、変数がアクセスする
データは動的スコープ変数と同様にスコープがあります;
つまり、マッチングが成功するたびに、グローバル状態オブジェクトが
現在のブロックまたはファイルスコープにローカル化されたかのように
動作します。
(動的スコープと C<local> キーワードの詳細については、
L<perlsyn/"Compound Statements"> を参照してください。)

=begin original

A I<successful match> includes any successful match performed by the
search and replace operator C<s///> as well as those performed by the
C<m//> operator.

=end original

I<成功したマッチング> には、C<m//> 演算子によって実行されたものに加えて、
検索および置換演算子 C<s///> によって実行されたすべての成功した
マッチングが含まれます。

=begin original

Consider the following code:

=end original

次のコードを考えます:

    my @state;
    sub matchit {
        push @state, $1;            # pushes "baz"
        my $str = shift;
        $str =~ /(zat)/;            # matches "zat"
        push @state, $1;            # pushes "zat"
    }

    {
        $str = "foo bar baz blorp zat";
        $str =~ /(foo)/;            # matches "foo"
        push @state, $1;            # pushes "foo"
        {
            $str =~ /(pizza)/;      # does NOT match
            push @state, $1;        # pushes "foo"
            $str =~ /(bar)/;        # matches "bar"
            push @state, $1;        # pushes "bar"
            $str =~ /(baz)/;        # matches "baz"
            matchit($str);          # see above
            push @state, $1;        # pushes "baz"
        }
        $str =~ s/noodles/rice/;    # does NOT match
        push @state, $1;            # pushes "foo"
        $str =~ s/(blorp)/zwoop/;   # matches "blorp"
        push @state, $1;            # pushes "blorp"
    }
    # the following prints "foo, foo, bar, baz, zat, baz, foo, blorp"
    print join ",", @state;

=begin original

Notice that each successful match in the exact same scope overrides the
match context of the previous successful match, but that unsuccessful
matches do not. Also note that in an inner nested scope the previous
state from an outer dynamic scope persists until it has been overridden
by another successful match, but that when the inner nested scope exits
whatever match context was in effect before the inner successful match
is restored when the scope concludes.

=end original

まったく同じスコープ内でマッチングが成功するたびに、以前の成功した
マッチングのマッチングコンテキストは上書きされますが、失敗したマッチングは
上書きされないことに注意してください。
また、内側のネストされたスコープでは、外側の動的スコープからの
以前の状態は、別の成功したマッチングによって上書きされるまで持続しますが、
内側のネストされたスコープが終了すると、内側の成功したマッチングが終了する
前に有効であったマッチングコンテキストが復元されます。

=begin original

It is a known issue that C<goto LABEL> may interact poorly with the
dynamically scoped match context. This may not be fixable, and is
considered to be one of many good reasons to avoid C<goto LABEL>.

=end original

C<goto LABEL> が動的スコープマッチングコンテキストとうまく
相互作用しない可能性があることは既知の問題です。
これは修正できない可能性があり、C<goto LABEL> を避ける多くの正当な
理由の一つと考えられています。

=head3 Performance issues

(性能問題)

=begin original

Traditionally in Perl, any use of any of the three variables  C<$`>, C<$&>
or C<$'> (or their C<use English> equivalents) anywhere in the code, caused
all subsequent successful pattern matches to make a copy of the matched
string, in case the code might subsequently access one of those variables.
This imposed a considerable performance penalty across the whole program,
so generally the use of these variables has been discouraged.

=end original

Perl では伝統的に、C<$`>, C<$&>, C<$'> (または C<use English> での
等価物) をコードのどこかで使うと、コードが引き続いてこれらの変数に
アクセスするかもしれないので、引き続くすべての成功したパターンマッチングで
マッチングした文字列のコピーを作ります。
これはプログラム全体に対してかなりの性能上の負荷を掛けるので、一般的に
これらの変数の使用は非推奨です。

=begin original

In Perl 5.6.0 the C<@-> and C<@+> dynamic arrays were introduced that
supply the indices of successful matches. So you could for example do
this:

=end original

Perl 5.6.0 では、マッチングに成功したインデックスを提供する C<@-> と
C<@+> 動的配列が導入されました。
それで、たとえばこのようにできます:

    $str =~ /pattern/;

    print $`, $&, $'; # bad: performance hit

    print             # good: no performance hit
    substr($str, 0,     $-[0]),
    substr($str, $-[0], $+[0]-$-[0]),
    substr($str, $+[0]);

=begin original

In Perl 5.10.0 the C</p> match operator flag and the C<${^PREMATCH}>,
C<${^MATCH}>, and C<${^POSTMATCH}> variables were introduced, that allowed
you to suffer the penalties only on patterns marked with C</p>.

=end original

Perl 5.10.0 で C</p> マッチング演算子フラグと C<${^PREMATCH}>,
C<${^MATCH}>, C<${^POSTMATCH}> 変数が導入され、C</p> でマークされた
パターンのみが負荷を被るようにできるようになりました。

=begin original

In Perl 5.18.0 onwards, perl started noting the presence of each of the
three variables separately, and only copied that part of the string
required; so in

=end original

Perl 5.18.0 以降では、perl は三つの変数の存在を別々に注意するようになり、
必要な部分文字列のみをコピーするようになりました; 従って、次の場合は

    $`; $&; "abcdefgh" =~ /d/

=begin original

perl would only copy the "abcd" part of the string. That could make a big
difference in something like

=end original

perl は文字列のうち "abcd" の部分のみをコピーします。
これは次のようなものとは大きな違いになります

    $str = 'x' x 1_000_000;
    $&; # whoops
    $str =~ /x/g # one char copied a million times, not a million chars

=begin original

In Perl 5.20.0 a new copy-on-write system was enabled by default, which
finally fixes most of the performance issues with these three variables, and
makes them safe to use anywhere.

=end original

Perl 5.20.0 では新しいコピーオンライトシステムがデフォルトで有効になり、
これらの変数に関するほとんどの性能問題は最終的に修正され、
これらをどこで使っても安全になりました。

=begin original

The C<Devel::NYTProf> and C<Devel::FindAmpersand> modules can help you
find uses of these problematic match variables in your code.

=end original

C<Devel::NYTProf> と C<Devel::FindAmpersand> のモジュールは、コード中に
これらの問題のあるマッチング変数の使用を探す助けになります。

=over 8

=item $<I<digits>> ($1, $2, ...)
X<$1> X<$2> X<$3> X<$I<digits>>

=begin original


Contains the subpattern from the corresponding set of capturing
parentheses from the last successful pattern match in the current
dynamic scope. (See L</Scoping Rules of Regex Variables>.)

=end original

現在の動的スコープで、最後に成功したパターンマッチングで対応する括弧の
サブパターンにマッチングした文字列が入っています。
(L</Scoping Rules of Regex Variables> を参照してください。)

=begin original

Note there is a distinction between a capture buffer which matches
the empty string a capture buffer which is optional. Eg, C<(x?)> and
C<(x)?> The latter may be undef, the former not.

=end original

空文字列にマッチングする捕捉バッファと、オプションの捕捉バッファの
違いに注意してください。
例えば、C<(x?)> と C<(x)?> では、後者は undef かもしれませんが、
前者は違います。

=begin original

These variables are read-only.

=end original

これらの変数はすべて読み込み専用です。

=begin original

Mnemonic: like \digits.

=end original

記憶法: \(数字) のようなもの。

=item @{^CAPTURE}
X<@{^CAPTURE}> X<@^CAPTURE>

=begin original

An array which exposes the contents of the capture buffers, if any, of
the last successful pattern match, not counting patterns matched
in nested blocks that have been exited already.

=end original

最後に成功したパターンマッチングの (もしあれば) 捕捉バッファの内容を
露出させた配列; 既に終了したネストしたブロックの中でマッチングしたパターンは
考慮しません。

=begin original

Note that the 0 index of C<@{^CAPTURE}> is equivalent to C<$1>, the 1 index
is equivalent to C<$2>, etc.

=end original

C<@{^CAPTURE}> の添え字 0 は C<$1> と等価、
添え字 1 は C<$2> と等価、などであることに注意してください。

    if ("foal"=~/(.)(.)(.)(.)/) {
        print join "-", @{^CAPTURE};
    }

=begin original

should output "f-o-a-l".

=end original

これは "f-o-a-l" を出力します。

=begin original

See also L<<< /$<I<digits>> ($1, $2, ...) >>>, L</%{^CAPTURE}> and
L</%{^CAPTURE_ALL}>.

=end original

L<<< /$<I<数字>> ($1, $2, ...) >>>, L</%{^CAPTURE}>,
L</%{^CAPTURE_ALL}> も参照してください。

=begin original

Note that unlike most other regex magic variables there is no single
letter equivalent to C<@{^CAPTURE}>. Also be aware that when
interpolating subscripts of this array you B<must> use the demarcated
variable form, for instance

=end original

その他のほとんどの正規表現マジカル変数と異なり、
C<@{^CAPTURE}> と等価な単一文字変数はないことに注意してください。
また、この配列の添え字を変数展開するときは、境界を定める変数形式を
B<使わなければならない> ことにも注意してください; 例えば:

    print "${^CAPTURE[0]}"

=begin original

see L<perldata/"Demarcated variable names using braces"> for more
information on this form and its uses.

=end original

この形式とその使用法に関するさらなる情報については
L<perldata/"Demarcated variable names using braces"> を参照してください。

=begin original

This variable was added in 5.25.7.

=end original

これは 5.25.7 で追加されました。

=begin original

If you need access to this functionality in older Perls you can use this
function immediately after your regexp.

=end original

古い Perl でこの機能にアクセスする必要がある場合は、
正規表現の直後にこの関数を使えます。

    sub get_captures {
        no strict 'refs';

        my $last_idx = scalar(@-) - 1;
        my @arr      = 1 .. $last_idx;
        my @ret      = map { $$_; } @arr;

        return @ret;
    }

=item $MATCH

=item $&
X<$&> X<$MATCH>

=begin original

The string matched by the last successful pattern match.
(See L</Scoping Rules of Regex Variables>.)

=end original

最後に成功したパターンマッチでマッチした文字列。
(L</Scoping Rules of Regex Variables> を参照してください。)

=begin original

See L</Performance issues> above for the serious performance implications
of using this variable (even once) in your code.

=end original

この変数を(一度でも)使うことによる重大な性能の問題については前述した
L</Performance issues> を参照してください。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

Mnemonic: like C<&> in some editors.

=end original

記憶法: あるエディタの C<&> ようなもの。

=item ${^MATCH}
X<${^MATCH}>

=begin original

It is only guaranteed to return a defined value when the pattern was
compiled or executed with the C</p> modifier.

=end original

パターンが C</p> 修飾子付きでコンパイルまたは実行された場合、
定義された値が返ることだけが保証されます。

=begin original

This is similar to C<$&> (C<$MATCH>) except that to use it you must
use the C</p> modifier when executing the pattern, and it does not incur
the performance penalty associated with that variable.

=end original

これは C<$&> (C<$MATCH>) と同様ですが、
パターンを実行するときに C</p> 修飾子を使わなければならず、
この変数と関連付けられた性能上のペナルティを被りません。

=begin original

See L</Performance issues> above.

=end original

前述した L</Performance issues> を参照してください。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=item $PREMATCH

=item $`
X<$`> X<$PREMATCH>

=begin original

The string preceding whatever was matched by the last successful
pattern match. (See L</Scoping Rules of Regex Variables>).

=end original

最後の成功したパターンマッチでマッチした部分の前の文字列。
(L</Scoping Rules of Regex Variables> を参照してください)。

=begin original

See L</Performance issues> above for the serious performance implications
of using this variable (even once) in your code.

=end original

この変数を(一度でも)使うことによる重大な性能の問題については前述した
L</Performance issues> を参照してください。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

Mnemonic: C<`> often precedes a quoted string.

=end original

記憶法: C<`> は多くの場合クォートされた文字列の前にある。

=item ${^PREMATCH}
X<${^PREMATCH}>

=begin original

It is only guaranteed to return a defined value when the pattern was
executed with the C</p> modifier.

=end original

パターンが C</p> 修飾子付きでコンパイルまたは実行された場合、
定義された値が返ることだけが保証されます。

=begin original

This is similar to C<$`> ($PREMATCH) except that to use it you must
use the C</p> modifier when executing the pattern, and it does not incur
the performance penalty associated with that variable.

=end original

これは C<$`> ($PREMATCH) と同様ですが、
パターンを実行するときに C</p> 修飾子を使わなければならず、
この変数と関連付けられた性能上のペナルティを被りません。

=begin original

See L</Performance issues> above.

=end original

前述した L</Performance issues> を参照してください。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=item $POSTMATCH

=item $'
X<$'> X<$POSTMATCH> X<@->

=begin original

The string following whatever was matched by the last successful
pattern match. (See L</Scoping Rules of Regex Variables>). Example:

=end original

最後の成功したパターンマッチでマッチした部分に続く文字列。
(L</Scoping Rules of Regex Variables> を参照してください)。
例:

=begin original

    local $_ = 'abcdefghi';
    /def/;
    print "$`:$&:$'\n";       # prints abc:def:ghi

=end original

    local $_ = 'abcdefghi';
    /def/;
    print "$`:$&:$'\n";       # abc:def:ghi を表示

=begin original

See L</Performance issues> above for the serious performance implications
of using this variable (even once) in your code.

=end original

この変数を(一度でも)使うことによる重大な性能の問題については前述した
L</Performance issues> を参照してください。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

Mnemonic: C<'> often follows a quoted string.

=end original

記憶法: C<'> は多くの場合クォートされた文字列の後にある。

=item ${^POSTMATCH}
X<${^POSTMATCH}>

=begin original

It is only guaranteed to return a defined value when the pattern was
compiled or executed with the C</p> modifier.

=end original

パターンが C</p> 修飾子付きでコンパイルまたは実行された場合、
定義された値が返ることだけが保証されます。

=begin original

This is similar to C<$'> (C<$POSTMATCH>) except that to use it you must
use the C</p> modifier when executing the pattern, and it does not incur
the performance penalty associated with that variable.

=end original

これは C<$'> (C<$POSTMATCH>) と同様ですが、
パターンを実行するときに C</p> 修飾子を使わなければならず、
この変数と関連付けられた性能上のペナルティを被りません。

=begin original

See L</Performance issues> above.

=end original

前述した L</Performance issues> を参照してください。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=item $LAST_PAREN_MATCH

=item $+
X<$+> X<$LAST_PAREN_MATCH>

=begin original

The text matched by the highest used capture group of the last
successful search pattern. (See L</Scoping Rules of Regex Variables>).
It is logically equivalent to the highest
numbered capture variable (C<$1>, C<$2>, ...) which has a defined value.


=end original

最後に検索されたパターンの最大の使われたの捕捉グループにマッチした文字列。
(L</Scoping Rules of Regex Variables> を参照してください)。
これは、定義されている最大の番号の捕捉変数
(C<$1>, C<$2>, ...) と論理的に等価です。

=begin original

This is useful if you don't know which one of a set of alternative patterns
matched.  For example:

=end original

わからないような場合に使うと便利です。
例えば:

    /Version: (.*)|Revision: (.*)/ && ($rev = $+);

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

Mnemonic: be positive and forward looking.

=end original

記憶法: ポジティブで前向き。

=item $LAST_SUBMATCH_RESULT

=item $^N
X<$^N> X<$LAST_SUBMATCH_RESULT>

=begin original

The text matched by the used group most-recently closed (i.e. the group
with the rightmost closing parenthesis) of the last successful match.
(See L</Scoping Rules of Regex Variables>).

=end original

最近のマッチングに成功した検索パターンのうち、一番最近に閉じられた使われた
グループ(つまり、一番右の閉じかっこのグループ)にマッチングしたテキスト。
(L</Scoping Rules of Regex Variables> を参照してください)。

=begin original

This is subtly different from C<$+>. For example in

=end original

これは C<$+> とわずかに異なります。
例えば次のものは

    "ab" =~ /^((.)(.))$/

=begin original

we have

=end original

次の結果になります

    $1,$^N   have the value "ab"
    $2       has  the value "a"
    $3,$+    have the value "b"

=begin original

This is primarily used inside C<(?{...})> blocks for examining text
recently matched.  For example, to effectively capture text to a variable
(in addition to C<$1>, C<$2>, etc.), replace C<(...)> with

=end original

これは主として最近マッチしたテキストを調べるために C<(?{...})> ブロックの
中で使われます。
例えば、(C<$1>, C<$2> などに加えて) テキストを変数に効率的に捕捉するには、
C<(...)> を以下で置き換えます:

    (?:(...)(?{ $var = $^N }))

=begin original

By setting and then using C<$var> in this way relieves you from having to
worry about exactly which numbered set of parentheses they are.

=end original

C<$var> をこの方法で設定してから使うことで、かっこの組の番号について
気にしなくてすむようになります。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

This variable was added in Perl v5.8.0.

=end original

この変数は Perl v5.8.0 で追加されました。

=begin original

Mnemonic: the (possibly) Nested parenthesis that most recently closed.

=end original

記憶法: もっとも最近閉じられた、(おそらく) ネストした (Nested) かっこ。

=item @LAST_MATCH_END

=item @+
X<@+> X<@LAST_MATCH_END>

=begin original

This array holds the offsets of the ends of the last successful
match and any matching capture buffers that the pattern contains.
(See L</Scoping Rules of Regex Variables>)

=end original

この配列は、最後に成功したマッチングの末尾へのオフセットと、
パターンが含むすべてのマッチング捕捉バッファを保持します。
(L</Scoping Rules of Regex Variables> を参照してください。)

=begin original

The number of elements it contains will be one more than the number
of capture buffers in the pattern, regardless of which capture buffers
actually matched. You can use this to determine how many capture
buffers there are in the pattern. (As opposed to C<@-> which may
have fewer elements.)

=end original

含まれる要素の数は、どの捕捉バッファが実際にマッチングしたかに関係なく、
パターン内の捕捉バッファの数よりも一つ多くなります。
これを使って、パターン内に捕捉バッファがいくつあるかを決定できます。
(要素の数が少なくなる C<@-> とは対照的です)。

=begin original

C<$+[0]> is the offset into the string of the end of the entire match.
This is the same value as what the C<pos> function returns when called
on the variable that was matched against. The I<n>th element of this
array holds the offset of the I<n>th submatch, so C<$+[1]> is the offset
past where C<$1> ends, C<$+[2]> the offset past where C<$2> ends, and so
on. You can use C<$#+> to determine how many subgroups were in the last
successful match. See the examples given for the C<@-> variable.

=end original

C<$+[0]> はマッチ全体の文字列の最後へのオフセットです。
これはマッチした変数に対して C<pos> 関数を呼び出したときの返り値と同じです。
この配列の I<n> 番目の要素は I<n> 番目のサブマッチのオフセットを
保持しているので、C<$+[1]> は過去の C<$1> の終わりのオフセット、C<$+[2]> は
C<$2> のオフセット、という形になります。
C<$#+> は最後に成功したマッチでいくつサブグループがあるかを決定するのに
使えます。
C<@-> 変数の例を参照して下さい。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

This variable was added in Perl v5.6.0.

=end original

この変数は Perl v5.6.0 で追加されました。

=item %{^CAPTURE}

=item %LAST_PAREN_MATCH

=item %+
X<%+> X<%LAST_PAREN_MATCH> X<%{^CAPTURE}>

=begin original

Similar to C<@+>, the C<%+> hash allows access to the named capture
buffers, should they exist, in the last successful match in the
currently active dynamic scope. (See L</Scoping Rules of Regex Variables>).

=end original

C<@+> と同様、C<%+> ハッシュは、現在アクティブな動的スコープで最後に成功した
マッチングの名前付き捕捉バッファ(存在すれば)へのアクセスを可能にします。
(L</Scoping Rules of Regex Variables> を参照してください)。

=begin original

For example, C<$+{foo}> is equivalent to C<$1> after the following match:

=end original

例えば、C<$+{foo}> は以下のマッチングの後の C<$1> と等価です:

    'foo' =~ /(?<foo>foo)/;

=begin original

The keys of the C<%+> hash list only the names of buffers that have
captured (and that are thus associated to defined values).

=end original

C<%+> ハッシュのキーは捕捉された(従って定義された値と結びついている)
バッファの名前のみの一覧です。

=begin original

If multiple distinct capture groups have the same name, then
C<$+{NAME}> will refer to the leftmost defined group in the match.

=end original

同じ名前の複数の異なる補足グループがある場合、
C<$+{NAME}> はマッチングの中で一番左側に定義されているグループを
参照します。

=begin original

The underlying behaviour of C<%+> is provided by the
L<Tie::Hash::NamedCapture> module.

=end original

C<%+> の基礎となる振る舞いは L<Tie::Hash::NamedCapture> モジュールで
提供されています。

=begin original

B<Note:> C<%-> and C<%+> are tied views into a common internal hash
associated with the last successful regular expression.  Therefore mixing
iterative access to them via C<each> may have unpredictable results.
Likewise, if the last successful match changes, then the results may be
surprising.

=end original

B<注意:> C<%-> and C<%+> は最後に成功した正規表現と関連付けられた共通の
内部ハッシュと tie されたビューです。
従って、C<each> 経由で混ざった反復アクセスを行うと、予測不能の結果となります。
同様に、最後に成功したマッチングを変更すると、結果は驚くべきものとなります。

=begin original

This variable was added in Perl v5.10.0. The C<%{^CAPTURE}> alias was
added in 5.25.7.

=end original

この変数は Perl v5.10.0 で追加されました。
C<%{^CAPTURE}> の別名は 5.25.7 で追加されました。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=item @LAST_MATCH_START

=item @-
X<@-> X<@LAST_MATCH_START>

=begin original

This array holds the offsets of the beginnings of the last successful
match and any capture buffers it contains.
(See L</Scoping Rules of Regex Variables>).

=end original

この配列は、最後に成功したマッチングの先頭へのオフセットと、
パターンが含むすべてのマッチング捕捉バッファを保持します。
(L</Scoping Rules of Regex Variables> を参照してください。)

=begin original

The number of elements it contains will be one more than the number of
the highest capture buffers (also called a subgroup) that actually
matched something. (As opposed to C<@+> which may have more elements.)

=end original

含まれる要素の数は、実際に何かにマッチングした最も高い捕捉バッファ
(サブグループとも呼ばれる)の数よりも一つ多くなります
(要素の数が多くなる C<@+> とは対照的です)。

=begin original

C<$-[0]> is the offset of the start of the last successful match.
C<$-[I<n>]> is the offset of the start of the substring matched by
I<n>-th subpattern, or undef if the subpattern did not match.

=end original

C<$-[0]> は最後に成功したマッチの先頭のオフセットです。
C<$-[I<n>]> は I<n> 番目のサブパターンにマッチした部分文字列の先頭の
オフセットです; サブパターンがマッチしなかった場合は undef です。

=begin original

Thus, after a match against C<$_>, C<$&> coincides with
C<substr $_, $-[0], $+[0] - $-[0]>.  Similarly, C<$I<n>> coincides
with C<substr $_, $-[n], $+[n] - $-[n]> if C<$-[n]> is defined, and
C<$+> coincides with C<substr $_, $-[$#-], $+[$#-] - $-[$#-]>.
One can use C<$#-> to find the last matched subgroup in the last
successful match.  Contrast with C<$#+>, the number of subgroups
in the regular expression.

=end original

従って C<$_> のマッチの後、C<$I<n>> は
C<substr $_, $-[0], $+[0] - $-[0]> と一致します。
同様に、$I<n> は、C<$-[n]> が定義されていれば
C<substr $_, $-[n], $+[n] - $-[n]> と一致し、
C<$+> は C<substr $_, $-[$#-], $+[$#-] - $-[$#-]> と一致します。
C<$#-> は直前に成功したマッチで最後のマッチしたサブグループを
探すのに使えます。
正規表現でのサブグループの数である C<$#+> と対照的です。

=begin original

C<$-[0]> is the offset into the string of the beginning of the
entire match.  The I<n>th element of this array holds the offset
of the I<n>th submatch, so C<$-[1]> is the offset where C<$1>
begins, C<$-[2]> the offset where C<$2> begins, and so on.

=end original

C<$-[0]> はマッチ全体の先頭の文字列へのオフセットです。
この配列の I<n> 番目の要素は I<n> 番目のサブマッチへの
オフセットを保持しますので、C<$-[1]> は C<$1> の先頭への
オフセット、C<$-[2]> は C<$2> の先頭へのオフセット、などとなります。

=begin original

After a match against some variable C<$var>:

=end original

ある変数 C<$var> でマッチした後、以下のようになります。

=over 5

=item C<$`> is the same as C<substr($var, 0, $-[0])>

(C<$`> は C<substr($var, 0, $-[0])> と同じです)

=item C<$&> is the same as C<substr($var, $-[0], $+[0] - $-[0])>

(C<$&> は C<substr($var, $-[0], $+[0] - $-[0])> と同じです)

=item C<$'> is the same as C<substr($var, $+[0])>

(C<$'> は C<substr($var, $+[0])> と同じです)

=item C<$1> is the same as C<substr($var, $-[1], $+[1] - $-[1])>

(C<$1> は C<substr($var, $-[1], $+[1] - $-[1])> と同じです)

=item C<$2> is the same as C<substr($var, $-[2], $+[2] - $-[2])>

(C<$2> は C<substr($var, $-[2], $+[2] - $-[2])> と同じです)

=item C<$3> is the same as C<substr($var, $-[3], $+[3] - $-[3])>

(C<$3> は C<substr $var, $-[3], $+[3] - $-[3])> と同じです)

=back

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=begin original

This variable was added in Perl v5.6.0.

=end original

この変数は Perl v5.6.0 で追加されました。

=item %{^CAPTURE_ALL}
X<%{^CAPTURE_ALL}>

=item %-
X<%->

=begin original

Similar to C<%+>, this variable allows access to the named capture
groups in the last successful match in the currently active dynamic
scope. (See L</Scoping Rules of Regex Variables>). To each capture group
name found in the regular expression, it associates a reference to an
array containing the list of values captured by all buffers with that
name (should there be several of them), in the order where they appear.

=end original

C<%+> と同様、この変数は現在アクティブな動的スコープで最後に成功した
マッチングの名前付き捕捉グループへのアクセスを可能にします。
(L</Scoping Rules of Regex Variables> を参照してください)。
正規表現中に捕捉グループ名が現れるごとに、その名前のグループ全てで
(複数あるでしょう)捕捉されている値のリストを出現順で含む配列への
リファレンスと関連付けられます。

=begin original

Here's an example:

=end original

以下は例です:

    if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
        foreach my $bufname (sort keys %-) {
            my $ary = $-{$bufname};
            foreach my $idx (0..$#$ary) {
                print "\$-{$bufname}[$idx] : ",
                      (defined($ary->[$idx])
                          ? "'$ary->[$idx]'"
                          : "undef"),
                      "\n";
            }
        }
    }

=begin original

would print out:

=end original

とすると、以下のものが表示されます:

    $-{A}[0] : '1'
    $-{A}[1] : '3'
    $-{B}[0] : '2'
    $-{B}[1] : '4'

=begin original

The keys of the C<%-> hash correspond to all buffer names found in
the regular expression.

=end original

C<%-> ハッシュのキーは正規表現で見つかった全てのバッファ名に対応します。

=begin original

The behaviour of C<%-> is implemented via the
L<Tie::Hash::NamedCapture> module.

=end original

C<%-> の振る舞いは L<Tie::Hash::NamedCapture> モジュールを使って
実装されています。

=begin original

B<Note:> C<%-> and C<%+> are tied views into a common internal hash
associated with the last successful regular expression.  Therefore mixing
iterative access to them via C<each> may have unpredictable results.
Likewise, if the last successful match changes, then the results may be
surprising. See L</Scoping Rules of Regex Variables>.

=end original

B<注意:> C<%-> and C<%+> は最後に成功した正規表現と関連付けられた共通の
内部ハッシュと tie されたビューです。
従って、C<each> 経由で混ざった反復アクセスを行うと、予測不能の結果となります。
同様に、最後に成功したマッチングを変更すると、結果は驚くべきものとなります。
L</Scoping Rules of Regex Variables> を参照してください。

=begin original

This variable was added in Perl v5.10.0. The C<%{^CAPTURE_ALL}> alias was
added in 5.25.7.

=end original

この変数は Perl v5.10.0 で追加されました。
C<%{^CAPTURE_ALL}> の別名は 5.25.7 で追加されました。

=begin original

This variable is read-only, and its value is dynamically scoped.

=end original

この変数は読み込み専用で、その値は動的スコープを持ちます。

=item ${^LAST_SUCCESSFUL_PATTERN}

=begin original

The last successful pattern that matched in the current scope.  The empty
pattern defaults to matching to this. For instance:

=end original

現在のスコープでマッチングした、最後に成功したパターン。
からパターンはこれにマッチングします。
例えば:

    if (m/foo/ || m/bar/) {
        s//BLAH/;
    }

=begin original

and

=end original

および

    if (m/foo/ || m/bar/) {
        s/${^LAST_SUCCESSFUL_PATTERN}/BLAH/;
    }

=begin original

are equivalent.

=end original

は等価です。

=begin original

You can use this to debug which pattern matched last, or to match with it again.

=end original

どのパターンが最後にマッチングしたかをデバッグしたり、
再び同じものでマッチングするためにこれを使えます。

=begin original

Added in Perl 5.37.10.

=end original

Perl 5.37.10 で追加されました。

=item $LAST_REGEXP_CODE_RESULT

=item $^R
X<$^R> X<$LAST_REGEXP_CODE_RESULT>

=begin original

The result of evaluation of the last successful C<(?{ code })>
regular expression assertion (see L<perlre>).

=end original

最後に成功した C<(?{ code })> 正規表現アサートの評価の結果です
(L<perlre> を参照して下さい)。

=begin original

This variable may be written to, and its value is scoped normally,
unlike most other regex variables.

=end original

この変数は、その他のほとんどの正規表現変数と異なり、
書き込み可能で、その値は通常のスコープを持ちます。

=begin original

This variable was added in Perl 5.005.

=end original

この変数は Perl 5.005 で追加されました。

=item ${^RE_COMPILE_RECURSION_LIMIT}
X<${^RE_COMPILE_RECURSION_LIMIT}>

=begin original

The current value giving the maximum number of open but unclosed
parenthetical groups there may be at any point during a regular
expression compilation.  The default is currently 1000 nested groups.
You may adjust it depending on your needs and the amount of memory
available.

=end original

正規表現コンパイル中の任意の時点での開いているけれども閉じていない
かっこグループの最大値として与えられている現在の値。
デフォルトは現在の所 1000 ネストグループです。
これは必要性と利用可能なメモリ量に合わせて調整できます。

=begin original

This variable was added in Perl v5.30.0.

=end original

この変数は Perl v5.30.0 で追加されました。

=item ${^RE_DEBUG_FLAGS}
X<${^RE_DEBUG_FLAGS}>

=begin original

The current value of the regex debugging flags.  Set to 0 for no debug output
even when the C<re 'debug'> module is loaded.  See L<re> for details.

=end original

正規表現デバッグフラグの現在の値です。
0 をセットすると、C<re 'debug'> モジュールが読み込まれていてもデバッグ出力を
行いません。
詳細については L<re> を参照してください。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=item ${^RE_TRIE_MAXBUF}
X<${^RE_TRIE_MAXBUF}>

=begin original

Controls how certain regex optimisations are applied and how much memory they
utilize.  This value by default is 65536 which corresponds to a 512kB
temporary cache.  Set this to a higher value to trade
memory for speed when matching large alternations.  Set
it to a lower value if you want the optimisations to
be as conservative of memory as possible but still occur, and set it to a
negative value to prevent the optimisation and conserve the most memory.
Under normal situations this variable should be of no interest to you.

=end original

どれくらい正規表現の最適化を行い、どれくらいのメモリを利用するかを制御します。
デフォルトではこの値は 65536 で、512kB の一時キャッシュに相当します。
この値を大きくすると、大きなものとマッチングするときに速度を重視して多くの
メモリを使います。
もしできるだけ保守的なメモリ消費をするけれども使うこともある、というように
最適化したい場合は小さい値を設定します; 負の値を設定すると最適化は行わず、
最大限メモリを節約します。
通常の状況では、この変数はあなたの興味を引くものではないでしょう。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=back

=head2 Variables related to filehandles

(ファイルハンドル関連の変数)

=begin original

Variables that depend on the currently selected filehandle may be set
by calling an appropriate object method on the C<IO::Handle> object,
although this is slightly less efficient than using the regular built-in
variables.  (Summary lines below for this contain the word HANDLE.)

=end original

現在選択されているファイルハンドルに依存する変数の場合には、代わりに
C<IO::Handle> オブジェクトに関するオブジェクトメソッドを呼び出して
設定できますが、通常の組み込み変数よりは効率が少し落ちます。
(以下の要約では HANDLE という語を含んでいます。)

=begin original

In Perl versions before v5.14.0, you had to say

=end original

バージョン v5.14.0 より前の Perl では、次のようにする必要がありました:

    use IO::Handle;

=begin original

before using

=end original

これを使う前にです:

    HANDLE->method(EXPR)

=begin original

Since Perl v5.14.0, you can use all filehandles as objects without manually
loading any modules first.

=end original

Perl v5.14.0 から、事前にモジュールを読み込むことなく、全てのファイルハンドルを
オブジェクトとして使えるようになりました。

=begin original

Each method returns the old value of the C<IO::Handle> attribute.  The
methods each take an optional EXPR, which, if supplied, specifies the
new value for the C<IO::Handle> attribute in question.  If not
supplied, most methods do nothing to the current value--except for
C<autoflush()>, which will assume a 1 for you, just to be different.

=end original

それぞれのメソッドは、C<IO::Handle> 属性の昔の値を返します。
メソッドはそれぞれ EXPR をとることができ、指定した場合には、問題の
C<IO::Handle> 属性の新しい値を指定することになります。
指定しない場合には、多くのメソッドでは現在の値に対して何もしませんが、
C<autoflush()> では 1 を指定されたものとします。

=begin original

A few of these variables are considered "read-only".  This means that
if you try to assign to this variable, either directly or indirectly
through a reference, you'll raise a run-time exception.

=end original

これらの変数のいくつかは「読み込み専用」と考えられます。
つまり、もしこの変数に対して直接またはリファレンスを通して間接に
代入しようとすると、、実行時エラーが発生します。

=begin original

You should be very careful when modifying the default values of most
special variables described in this document.  In most cases you want
to localize these variables before changing them, since if you don't,
the change may affect other modules which rely on the default values
of the special variables that you have changed.  This is one of the
correct ways to read the whole file at once:

=end original

この文書に記述されているほとんどの特殊変数のデフォルト値を変更するときには
とても慎重になるべきです。
ほとんどの場合、これらの変数を変更する前にこれらをローカル化したいでしょう;
さもなければ、あなたが変更した特殊変数のデフォルト値に依存している
その他のモジュールにも影響を与えるかもしれないからです。
これはファイル全体を一度に読み込む正しい方法の一つです:

=begin original

    open my $fh, "<", "foo" or die $!;
    local $/; # enable localized slurp mode
    my $content = <$fh>;
    close $fh;

=end original

    open my $fh, "<", "foo" or die $!;
    local $/; # ローカル化された吸い込みモードを有効にする
    my $content = <$fh>;
    close $fh;

=begin original

But the following code is quite bad:

=end original

しかし以下のコードは完全に悪いものです:

=begin original

    open my $fh, "<", "foo" or die $!;
    undef $/; # enable slurp mode
    my $content = <$fh>;
    close $fh;

=end original

    open my $fh, "<", "foo" or die $!;
    undef $/; # 吸い込みモードを有効にする
    my $content = <$fh>;
    close $fh;

=begin original

since some other module may want to read data from some file in the
default "line mode", so if the code we have just presented has been
executed, the global value of C<$/> is now changed for any other code
running inside the same Perl interpreter.

=end original

なぜなら、その他のモジュールでは、デフォルトの「行モード」でファイルを
読もうとするかも知れませんが、もし単に前述のコードを実行すると、
C<$/> のグローバルな値が、同じ Perl インタプリタ内で実行される
その他のコードに対しても変更されるからです。

=begin original

Usually when a variable is localized, you want to make sure that this
change affects the shortest scope possible.  So unless you are already
inside some short C<{}> block, you should create one yourself.  For
example:

=end original

通常、変数をローカル化するとき、この変更ができるだけ最短のスコープに
影響を与えることを確実にしたいでしょう。
従って、既に小さい C<{}> ブロックの内側であるのでない限り、それを
自身で作るべきです。
例えば:

    my $content = '';
    open my $fh, "<", "foo" or die $!;
    {
        local $/;
        $content = <$fh>;
    }
    close $fh;

=begin original

Here is an example of how your own code can go broken:

=end original

以下はどのように自分のコードが壊れるかの例です:

    for ( 1..3 ){
        $\ = "\r\n";
        nasty_break();
        print "$_";
    }

=begin original

    sub nasty_break {
        $\ = "\f";
        # do something with $_
    }

=end original

    sub nasty_break {
        $\ = "\f";
        # $_ で何かする
    }

=begin original

You probably expect this code to print the equivalent of

=end original

おそらくこのコードは以下のように表示されることを期待しています:

    "1\r\n2\r\n3\r\n"

=begin original

but instead you get:

=end original

しかし、以下のようになります:

    "1\f2\f3\f"

=begin original

Why? Because C<nasty_break()> modifies C<$\> without localizing it
first.  The value you set in  C<nasty_break()> is still there when you
return.  The fix is to add C<local()> so the value doesn't leak out of
C<nasty_break()>:

=end original

なぜでしょう? 
C<nasty_break()> は C<$_> をローカル化する前に変更するからです。
C<nasty_break()> で設定した値は戻ったときにまだそこにあります。
修正するには、C<local()> を追加して、値が C<nasty_break()> の外に
漏れないようにします:

    local $\ = "\f";

=begin original

It's easy to notice the problem in such a short example, but in more
complicated code you are looking for trouble if you don't localize
changes to the special variables.

=end original

このような短い例では問題に気付くのは簡単ですが、より複雑なコードでは、
もし特殊変数の変更をローカル化していないと問題を探すことになります。

=over 8

=item $ARGV
X<$ARGV>

=begin original

Contains the name of the current file when reading from C<< <> >>.

=end original

C<< <> >> から読込みを行なっているとき、その時点のファイル名を示します。

=item @ARGV
X<@ARGV>

=begin original

The array C<@ARGV> contains the command-line arguments intended for
the script.  C<$#ARGV> is generally the number of arguments minus
one, because C<$ARGV[0]> is the first argument, I<not> the program's
command name itself.  See L</$0> for the command name.

=end original

配列 C<@ARGV> は、コマンドラインからスクリプトに渡す引数が入れられます。
C<$ARGV[0]> がI<プログラムのコマンド名自身ではなく>、
最初の引数ですから、C<$#ARGV> は一般には、引数の個数 - 1 となります。
コマンド名については、L</$0> を参照してください。

=item ARGV
X<ARGV>

=begin original

The special filehandle that iterates over command-line filenames in
C<@ARGV>.  Usually written as the null filehandle in the diamond operator
C<< <> >>.  Note that currently C<ARGV> only has its magical effect
within the C<< <> >> operator; elsewhere it is just a plain filehandle
corresponding to the last file opened by C<< <> >>.  In particular,
passing C<\*ARGV> as a parameter to a function that expects a filehandle
may not cause your function to automatically read the contents of all the
files in C<@ARGV>.

=end original

C<@ARGV> にあるコマンドラインで指定されたファイル名に対して反復する
特殊ファイルハンドルです。
通常ダイヤモンド演算子 C<< <> >> の中で空ファイルハンドルとして書かれます。
現在のところ、C<ARGV> は C<< <> >> 演算子の中でのみ特別な効果があることに
注意してください; その他の場所では、C<< <> >> で開かれた最後のファイルに
対応する普通のファイルハンドルです。
特に、ファイルハンドルを想定している関数に C<\*ARGV> を引数として渡しても、
関数内で C<@ARGV> にある全てのファイルの内容を自動的に読み込むことには
なりません。

=item ARGVOUT
X<ARGVOUT>

=begin original

The special filehandle that points to the currently open output file
when doing edit-in-place processing with B<-i>.  Useful when you have
to do a lot of inserting and don't want to keep modifying C<$_>.  See
L<perlrun|perlrun/-i[extension]> for the B<-i> switch.

=end original

B<-i> を使ってその場修正を行っているときに、現在開いている出力ファイルを
示す特殊ファイルハンドルです。
たくさんの挿入をする必要があるときに C<$_> を修正し続けたくない場合に有用です。
B<-i> オプションについては L<perlrun|perlrun/-i[extension]> を
参照してください。

=item IO::Handle->output_field_separator( EXPR )

=item $OUTPUT_FIELD_SEPARATOR

=item $OFS

=item $,
X<$,> X<$OFS> X<$OUTPUT_FIELD_SEPARATOR>

=begin original

The output field separator for the print operator.  If defined, this
value is printed between each of print's arguments.  Default is C<undef>.

=end original

print 演算子のための出力フィールドセパレータ。
定義されると、この値がそれぞれの print の引数の間に表示されます。
デフォルトは C<undef> です。

=begin original

You cannot call C<output_field_separator()> on a handle, only as a
static method.  See L<IO::Handle|IO::Handle>.

=end original

ハンドルに対して C<output_field_separator()> を呼び出すことはできません;
静的メソッドしてのみです。
L<IO::Handle|IO::Handle> を参照してください。

=begin original

Mnemonic: what is printed when there is a "," in your print statement.

=end original

記憶法: print 文で "," を書いた場所に印字されるもの。

=item HANDLE->input_line_number( EXPR )

=item $INPUT_LINE_NUMBER

=item $NR

=item $.
X<$.> X<$NR> X<$INPUT_LINE_NUMBER> X<line number>

=begin original

Current line number for the last filehandle accessed.

=end original

最後にアクセスされたファイルハンドルの現在の行番号。

=begin original

Each filehandle in Perl counts the number of lines that have been read
from it.  (Depending on the value of C<$/>, Perl's idea of what
constitutes a line may not match yours.)  When a line is read from a
filehandle (via C<readline()> or C<< <> >>), or when C<tell()> or
C<seek()> is called on it, C<$.> becomes an alias to the line counter
for that filehandle.

=end original

Perl の各ファイルハンドルは、そこから読み込んだ行数を数えています。
(C<$/> の値に依存して、何が行を構成するかに関する Perl の考えはあなたの
考えと一致しないかもしれません。)
行が(C<readline()> や C<< <> >> を使って)ファイルハンドルから読み込まれたか、
C<tell()> や C<seek()> がファイルハンドルに対して呼び出された場合、
C<$.> はそのファイルハンドルの行カウンタへのエイリアスとなります。

=begin original

You can adjust the counter by assigning to C<$.>, but this will not
actually move the seek pointer.  I<Localizing C<$.> will not localize
the filehandle's line count>.  Instead, it will localize perl's notion
of which filehandle C<$.> is currently aliased to.

=end original

C<$.> へ代入することでカウンタの値を修正できますが、これは実際にシーク
ポインタを動かすことはありません。
I<C<$.> をローカル化してもファイルハンドルの行カウンタはローカル化されません>。
代わりに、現在 C<$.> がどのファイルハンドルへのエイリアスかという情報が
ローカル化されます。

=begin original

C<$.> is reset when the filehandle is closed, but B<not> when an open
filehandle is reopened without an intervening C<close()>.  For more
details, see L<perlop/"IE<sol>O Operators">.  Because C<< <> >> never does
an explicit close, line numbers increase across C<ARGV> files (but see
examples in L<perlfunc/eof>).

=end original

C<$.> はファイルハンドルがクローズされるとリセットされますが、
オープンしているファイルハンドルが C<close()> されることなく再オープンされた
場合にはリセット B<されません>。
さらなる詳細については、L<perlop/"IE<sol>O Operators"> を参照してください。
なぜなら、 C<< <> >> は決して明示的なクローズは行わず、行番号は C<ARGV> の
ファイル間で通算してカウントされるからです(但し L<perlfunc/eof> の例を
参照してください)。

=begin original

You can also use C<< HANDLE->input_line_number(EXPR) >> to access the
line counter for a given filehandle without having to worry about
which handle you last accessed.

=end original

また、C<< HANDLE->input_line_number(EXPR) >> とすることで、どのハンドルに
最後にアクセスしたかを気にすることなく行カウンタにアクセスできます。

=begin original

Mnemonic: many programs use "." to mean the current line number.

=end original

記憶法: 多くのプログラムで "." が現在行番号を示すように使われています。

=item IO::Handle->input_record_separator( EXPR )

=item $INPUT_RECORD_SEPARATOR

=item $RS

=item $/
X<$/> X<$RS> X<$INPUT_RECORD_SEPARATOR>

=begin original

The input record separator, newline by default.  This influences Perl's
idea of what a "line" is.  Works like B<awk>'s RS variable, including
treating empty lines as a terminator if set to the null string (an
empty line cannot contain any spaces or tabs).  You may set it to a
multi-character string to match a multi-character terminator, or to
C<undef> to read through the end of file.  Setting it to C<"\n\n">
means something slightly different than setting to C<"">, if the file
contains consecutive empty lines.  Setting to C<""> will treat two or
more consecutive empty lines as a single empty line.  Setting to
C<"\n\n"> will blindly assume that the next input character belongs to
the next paragraph, even if it's a newline.

=end original

入力レコードセパレータで、デフォルトでは改行文字。
これは Perl での「行」とは何か、ということに影響を与えます。
空文字列に設定されると、空行をセパレータとして扱うことを含めて、B<awk> の
変数 RS のように働きます(空行はスペースやタブを含んでいてはいけません)。
複数文字の区切文字を示すために、文字列を設定することもできます; また、
ファイルの最後まで読み込むために undef を指定することもできます。
この変数に C<"\n\n"> を設定すると、空行が続く場合において、
C<""> を設定した場合とわずかに違う動作をするようになります。
C<""> を設定した場合には、複数の空行も 1 つの空行であるかのように扱います。
C<"\n\n"> を設定した場合には、単純に次の文字が (たとえ改行文字であっても)
次の段落に含まれるものとして扱います。

=begin original

    local $/;           # enable "slurp" mode
    local $_ = <FH>;    # whole file now here
    s/\n[ \t]+/ /g;

=end original

    local $/;           # 「吸い込み」モードを有効にする
    local $_ = <FH>;    # ファイル全体が入る
    s/\n[ \t]+/ /g;

=begin original

Remember: the value of C<$/> is a string, not a regex.  B<awk> has to
be better for something. :-)

=end original

注意: C<$/> は文字列であり、正規表現ではありません。
B<awk> は何かもっとうまくやらなくてはいけません。:-)

=begin original

Setting C<$/> to an empty string -- the so-called I<paragraph mode> -- merits
special attention.  When C<$/> is set to C<""> and the entire file is read in
with that setting, any sequence of one or more consecutive newlines at the
beginning of the file is discarded.  With the exception of the final record in
the file, each sequence of characters ending in two or more newlines is
treated as one record and is read in to end in exactly two newlines.  If the
last record in the file ends in zero or one consecutive newlines, that record
is read in with that number of newlines.  If the last record ends in two or
more consecutive newlines, it is read in with two newlines like all preceding
records.

=end original

C<$/> に空文字列を設定すること -- I<段落モード> と呼ばれます -- には、
特に注意する価値があります。
C<$/> が C<""> に設定されて、ファイル全体がこの設定で読み込まれた場合、
ファイル先頭の一つ以上の連続する改行の並びは捨てられます。
ファイルの最後のレコードを例外として、
二つ以上の改行で終わるそれぞれの文字並びは一つのレコードとして扱われ、
正確に二つの改行で終わるように読み込まれます。
ファイルの最後のレコードが 0 または 1 の連続する改行で終わっている場合、
そのレコードはその数の改行と共に読み込まれます。
最後のレコードが二つ以上の連続する改行で終わっている場合、
全ての先行するレコードと同様、二つの改行と共に読み込まれます。

=begin original

Suppose we wrote the following string to a file:

=end original

次の文字列をファイルに書いたとします:

    my $string = "\n\n\n";
    $string .= "alpha beta\ngamma delta\n\n\n";
    $string .= "epsilon zeta eta\n\n";
    $string .= "theta\n";

    my $file = 'simple_file.txt';
    open my $OUT, '>', $file or die;
    print $OUT $string;
    close $OUT or die;

=begin original

Now we read that file in paragraph mode:

=end original

このファイルを段落モードで読み込みます:

    local $/ = ""; # paragraph mode
    open my $IN, '<', $file or die;
    my @records = <$IN>;
    close $IN or die;

=begin original

C<@records> will consist of these 3 strings:

=end original

C<@records> は三つの文字列からなります:

    (
      "alpha beta\ngamma delta\n\n",
      "epsilon zeta eta\n\n",
      "theta\n",
    )

=begin original

Setting C<$/> to a reference to an integer, scalar containing an
integer, or scalar that's convertible to an integer will attempt to
read records instead of lines, with the maximum record size being the
referenced integer number of characters.  So this:

=end original

C<$/> に整数、整数を含むスカラ、整数に変換できるスカラのいずれかへの
リファレンスをセットすると、行を読む代わりにレコードを読もうとします;
この場合、最大レコードサイズはリファレンス先の整数値の文字数となります。
つまり:

    local $/ = \32768; # or \"32768", or \$var_containing_32768
    open my $fh, "<", $myfile or die $!;
    local $_ = <$fh>;

=begin original

will read a record of no more than 32768 characters from $fh.  If you're
not reading from a record-oriented file (or your OS doesn't have
record-oriented files), then you'll likely get a full chunk of data
with every read.  If a record is larger than the record size you've
set, you'll get the record back in pieces.  Trying to set the record
size to zero or less is deprecated and will cause $/ to have the value
of "undef", which will cause reading in the (rest of the) whole file.

=end original

これは $fh から 32768 文字を超えないようにレコードを読み込みます。
もしレコード指向のファイルを読み込まない場合(あるいは OS がレコード指向
ファイルを持たない場合)、読み込み毎にデータのチャンク全部を取り込みます。
もしレコードがセットしたレコードサイズより大きい場合、
レコードの部分を取り込みます。
レコードサイズを 0 以下にセットしようとするのは廃止予定で、
$/ に値 "undef" が設定され、(残りの)ファイル全体を読み込むことになります。

=begin original

As of 5.19.9 setting C<$/> to any other form of reference will throw a
fatal exception. This is in preparation for supporting new ways to set
C<$/> in the future.

=end original

5.19.9 から、C<$/> にその他の形式のリファレンスを設定すると致命的エラーが
投げられます。
これは将来 C<$/> を設定する新しい方法に対応する準備です。

=begin original

On VMS only, record reads bypass PerlIO layers and any associated
buffering, so you must not mix record and non-record reads on the
same filehandle.  Record mode mixes with line mode only when the
same buffering layer is in use for both modes.

=end original

VMS だけでは、レコードは PerlIO 層とそれに関連するバッファリングを迂回して
読み込まれるので、同じファイルハンドルでレコード読み込みと
非レコード読み込みを混ぜてはいけません。
レコードモードは、同じバッファリング層を両方のモードで使う場合にのみ
ラインモードと混ざります。

=begin original

You cannot call C<input_record_separator()> on a handle, only as a
static method.  See L<IO::Handle|IO::Handle>.

=end original

ハンドルに対して C<input_record_separator()> を呼び出すことはできません;
静的メソッドしてのみです。
L<IO::Handle|IO::Handle> を参照してください。

=begin original

See also L<perlport/"Newlines">.  Also see L</$.>.

=end original

L<perlport/"Newlines"> を参照してください。
L</$.> も参照してください。

=begin original

Mnemonic: / delimits line boundaries when quoting poetry.

=end original

記憶法: /は、詩を引用するときに、行の区切りを示します。

=item IO::Handle->output_record_separator( EXPR )

=item $OUTPUT_RECORD_SEPARATOR

=item $ORS

=item $\
X<$\> X<$ORS> X<$OUTPUT_RECORD_SEPARATOR>

=begin original

The output record separator for the print operator.  If defined, this
value is printed after the last of print's arguments.  Default is C<undef>.

=end original

print 演算子のための出力レコードセパレータ。
もし定義されていると、print の最後の引数の最後にこの値が表示されます。
デフォルトは C<undef> です。

=begin original

You cannot call C<output_record_separator()> on a handle, only as a
static method.  See L<IO::Handle|IO::Handle>.

=end original

ハンドルに対して C<output_record_separator()> を呼び出すことはできません;
静的メソッドしてのみです。
L<IO::Handle|IO::Handle> を参照してください。

=begin original

Mnemonic: you set C<$\> instead of adding "\n" at the end of the print.
Also, it's just like C<$/>, but it's what you get "back" from Perl.

=end original

記憶法: print の最後に "\n" を付け加える代わりに C<$\> を設定する。
また、C<$/> に似通っているが、Perl から「バック」されるものです。

=item HANDLE->autoflush( EXPR )

=item $OUTPUT_AUTOFLUSH

=item $|
X<$|> X<autoflush> X<flush> X<$OUTPUT_AUTOFLUSH>

=begin original

If set to nonzero, forces a flush right away and after every write or
print on the currently selected output channel.  Default is 0
(regardless of whether the channel is really buffered by the system or
not; C<$|> tells you only whether you've asked Perl explicitly to
flush after each write).  STDOUT will typically be line buffered if
output is to the terminal and block buffered otherwise.  Setting this
variable is useful primarily when you are outputting to a pipe or
socket, such as when you are running a Perl program under B<rsh> and
want to see the output as it's happening.  This has no effect on input
buffering.  See L<perlfunc/getc> for that.  See L<perlfunc/select> on
how to select the output channel.  See also L<IO::Handle>.

=end original

0 以外に設定されると、その時点で選択されている出力チャネルを直ちにその場で
フラッシュし、さらに write や print を行なうごとに、強制的にフラッシュします。
デフォルトでは 0 となっています(チャンネルが実際にシステムによって
バッファリングされているかどうかは関知しません。
C<$|> は Perl が明示的に毎回書き込みの後にフラッシュするかどうかのみを
示します)。
STDOUT は通常では、端末への出力時には行バッファリング、
それ以外ではブロックバッファリングであることに注意してください。
これは、Perl のスクリプトを rsh 配下で実行して、実行状況を確認したい
場合のように、パイプやソケットに出力するときに特に便利でしょう。
これは入力バッファリングには何の影響も与えません。
出力チャネルの選択方法については L<perlfunc/select> を参照してください。
L<IO::Handle> も参照してください。

=begin original

Mnemonic: when you want your pipes to be piping hot.

=end original

記憶法: パイプをホットな状態にしておくために使う。

=item ${^LAST_FH}
X<${^LAST_FH}>

=begin original

This read-only variable contains a reference to the last-read filehandle.
This is set by C<< <HANDLE> >>, C<readline>, C<tell>, C<eof> and C<seek>.
This is the same handle that C<$.> and C<tell> and C<eof> without arguments
use.  It is also the handle used when Perl appends ", <STDIN> line 1" to
an error or warning message.

=end original

この読み込み専用変数は最後に読み込んだファイルハンドルへのリファレンスを
含んでいます。
これは C<< <HANDLE> >>, C<readline>, C<tell>, C<eof>, C<seek> で
設定されます。
これは C<$.> および、C<tell> と C<eof> が引数なしで使われたときと同じ
ハンドルです。
これはまた、Perl がエラーまたは警告メッセージに ", <STDIN> line 1" を追加する
ハンドルでもあります。

=begin original

This variable was added in Perl v5.18.0.

=end original

この変数は Perl v5.18.0 で追加されました。

=back

=head3 Variables related to formats

(フォーマット関連の変数)

=begin original

The special variables for formats are a subset of those for
filehandles.  See L<perlform> for more information about Perl's
formats.

=end original

フォーマットのための特殊変数はファイルハンドルのための物のサブセットです。
Perl のフォーマットに関するさらなる情報については L<perlform> を
参照してください。

=over 8

=item $ACCUMULATOR

=item $^A
X<$^A> X<$ACCUMULATOR>

=begin original

The current value of the C<write()> accumulator for C<format()> lines.
A format contains C<formline()> calls that put their result into
C<$^A>.  After calling its format, C<write()> prints out the contents
of C<$^A> and empties.  So you never really see the contents of C<$^A>
unless you call C<formline()> yourself and then look at it.  See
L<perlform> and L<perlfunc/"formline PICTURE,LIST">.

=end original

C<format()> 行のための、その時点での C<write()> アキュムレータの値。
format には、C<$^A> に結果を残す、C<formline()> 呼び出しが含まれます。
自分のフォーマットを呼び出した後で、
C<write()> は C<$^A> の内容を出力してから消去します。
したがって、自分で C<formline()> を呼び出すのでなければ、
C<$^A> の値が見えることはありません。
L<perlform> と L<perlfunc/"formline PICTURE,LIST"> を参照してください。

=item IO::Handle->format_formfeed(EXPR)

=item $FORMAT_FORMFEED

=item $^L
X<$^L> X<$FORMAT_FORMFEED>

=begin original

What formats output as a form feed.  The default is C<\f>.

=end original

フォーマット出力で、改ページのために出力されるもの。
デフォルトは C<\f>。

=begin original

You cannot call C<format_formfeed()> on a handle, only as a static
method.  See L<IO::Handle|IO::Handle>.

=end original

ハンドルに対して C<format_formfeed()> を呼び出すことはできません;
静的メソッドしてのみです。
L<IO::Handle|IO::Handle> を参照してください。

=item HANDLE->format_page_number(EXPR)

=item $FORMAT_PAGE_NUMBER

=item $%
X<$%> X<$FORMAT_PAGE_NUMBER>

=begin original

The current page number of the currently selected output channel.

=end original

その時点で選択されている出力チャネルの、その時点でのページ番号。

=begin original

Mnemonic: C<%> is page number in B<nroff>.

=end original

記憶法: C<%> は、B<nroff> でのページ番号です。

=item HANDLE->format_lines_left(EXPR)

=item $FORMAT_LINES_LEFT

=item $-
X<$-> X<$FORMAT_LINES_LEFT>

=begin original

The number of lines left on the page of the currently selected output
channel.

=end original

その時点で選択されている出力チャネルの、ページに残っている行数。

=begin original

Mnemonic: lines_on_page - lines_printed.

=end original

記憶法: "ページ行数" - "印字済み行数"

=item IO::Handle->format_line_break_characters EXPR

=item $FORMAT_LINE_BREAK_CHARACTERS

=item $:
X<$:> X<FORMAT_LINE_BREAK_CHARACTERS>

=begin original

The current set of characters after which a string may be broken to
fill continuation fields (starting with C<^>) in a format.  The default is
S<" \n-">, to break on a space, newline, or a hyphen.

=end original

フォーマットの充填継続フィールド (C<^> で始まるもの) への文字列で行分割を許す
文字集合。
デフォルトは S<" \n-"> で空白、改行、ハイフンの後で行分割が可能です。

=begin original

You cannot call C<format_line_break_characters()> on a handle, only as
a static method.  See L<IO::Handle|IO::Handle>.

=end original

ハンドルに対して C<format_line_break_characters()> を呼び出すことはできません;
静的メソッドしてのみです。
L<IO::Handle|IO::Handle> を参照してください。

=begin original

Mnemonic: a "colon" in poetry is a part of a line.

=end original

記憶法: 詩では「コロン」は、行の一部。

=item HANDLE->format_lines_per_page(EXPR)

=item $FORMAT_LINES_PER_PAGE

=item $=
X<$=> X<$FORMAT_LINES_PER_PAGE>

=begin original

The current page length (printable lines) of the currently selected
output channel.  The default is 60.

=end original

その時点で選択されている出力チャネルの、その時点でのページ長(印字可能行数)。
デフォルトは 60 です。

=begin original

Mnemonic: = has horizontal lines.

=end original

記憶法: = には複数の水平線 (行) が含まれます。

=item HANDLE->format_top_name(EXPR)

=item $FORMAT_TOP_NAME

=item $^
X<$^> X<$FORMAT_TOP_NAME>

=begin original

The name of the current top-of-page format for the currently selected
output channel.  The default is the name of the filehandle with C<_TOP>
appended.  For example, the default format top name for the C<STDOUT>
filehandle is C<STDOUT_TOP>.

=end original

その時点で選択されている出力チャネルの、その時点でのページ先頭フォーマット名。
デフォルトは、ファイルハンドル名に _TOP を続けたものです。
例えば、C<STDOUT> ファイルハンドルのデフォルトのページ先頭フォーマット名は
C<STDOUT_TOP> です。

=begin original

Mnemonic: points to top of page.

=end original

記憶法: ページの先頭へのポインタ。

=item HANDLE->format_name(EXPR)

=item $FORMAT_NAME

=item $~
X<$~> X<$FORMAT_NAME>

=begin original

The name of the current report format for the currently selected
output channel.  The default format name is the same as the filehandle
name.  For example, the default format name for the C<STDOUT>
filehandle is just C<STDOUT>.

=end original

その時点で選択されている出力チャネルの、その時点でのフォーマット名。
デフォルトは、ファイルハンドル名です。
例えば、C<STDOUT> ファイルハンドルのデフォルトフォーマット名は
単に C<STDOUT> です。

=begin original

Mnemonic: brother to C<$^>.

=end original

記憶法: C<$^> の兄弟。

=back

=head2 Error Variables
X<error> X<exception>

(エラー変数)

=begin original

The variables C<$@>, C<$!>, C<$^E>, and C<$?> contain information
about different types of error conditions that may appear during
execution of a Perl program.  The variables are shown ordered by
the "distance" between the subsystem which reported the error and
the Perl process.  They correspond to errors detected by the Perl
interpreter, C library, operating system, or an external program,
respectively.

=end original

変数 C<$@>, C<$!>, C<$^E>, C<$?> は Perl プログラムの実行中に
発生した、異なる種類のエラー情報を保持します。
変数はエラーを報告した副システムと Perl プロセスとの「距離」の順番に
並んでいます。
これらはそれぞれ、Perl インタプリタ、C ライブラリ、
オペレーティングシステム、外部プログラムによって検出された
エラーに対応しています。

=begin original

To illustrate the differences between these variables, consider the
following Perl expression, which uses a single-quoted string.  After
execution of this statement, perl may have set all four special error
variables:

=end original

これらの変数の違いを示すために、
以下のようなシングルクォートを用いた Perl 式を考えます。
この文の実行後、perl は四つ全ての特殊エラー変数をセットします:

    eval q{
        open my $pipe, "/cdrom/install |" or die $!;
        my @res = <$pipe>;
        close $pipe or die "bad pipe: $?, $!";
    };

=begin original

When perl executes the C<eval()> expression, it translates the
C<open()>, C<< <PIPE> >>, and C<close> calls in the C run-time library
and thence to the operating system kernel.  perl sets C<$!> to
the C library's C<errno> if one of these calls fails.

=end original

C<eval()> 式が実行されたとき、C<open()>, C<< <PIPE> >>, C<close> は
C ランタイムライブラリの呼び出しに変換され、それからオペレーティング
システムコールに変換されます。
C<$!> はこれらの呼び出しのどれかが失敗したとき、
C ライブラリの C<errno> の値がセットされます。

=begin original

C<$@> is set if the string to be C<eval>-ed did not compile (this may
happen if C<open> or C<close> were imported with bad prototypes), or
if Perl code executed during evaluation C<die()>d.  In these cases the
value of C<$@> is the compile error, or the argument to C<die> (which
will interpolate C<$!> and C<$?>).  (See also L<Fatal>, though.)

=end original

C<$@> は C<eval> された文字列がコンパイルされなかったとき(これは C<open> か
C<close> が正しくないプロトタイプでインポートされたときに起こり得ます)、
または評価中に実行している Perl コードが C<die()> したときにセットされます。
これらの場合には C<$@> の値はコンパイルエラー、または
C<die> への引数(これには C<$!> と C<$?> が差し挟まれます)です。
(しかし、L<Fatal> も参照して下さい。)

=begin original

Under a few operating systems, C<$^E> may contain a more verbose error
indicator, such as in this case, "CDROM tray not closed."  Systems that
do not support extended error messages leave C<$^E> the same as C<$!>.

=end original

いくつかのオペレーティングシステムでは、C<$^E> により詳細なエラー指示子が
入っているかもしれません; 今回の場合で言えば、
"CDROM tray not closed." などです。
追加のエラーメッセージに対応していないシステムでは、C<$^E> は C<$!> と同じ
値です。

=begin original

Finally, C<$?> may be set to a non-0 value if the external program
F</cdrom/install> fails.  The upper eight bits reflect specific error
conditions encountered by the program (the program's C<exit()> value).
The lower eight bits reflect mode of failure, like signal death and
core dump information.  See L<wait(2)> for details.  In contrast to
C<$!> and C<$^E>, which are set only if an error condition is detected,
the variable C<$?> is set on each C<wait> or pipe C<close>,
overwriting the old value.  This is more like C<$@>, which on every
C<eval()> is always set on failure and cleared on success.

=end original

最後に、C<$?> は外部プログラム F</cdrom/install> が失敗したときに
非 0 にセットされるかもしれません。
上位の 8 ビットはプログラムが遭遇した特定のエラー状況
(プログラムの C<exit()> の値)を反映します。
下位の 8 ビットは、シグナルの死亡やコアダンプ情報と言った失敗のモードを
反映します。
詳細については L<wait(2)> を参照して下さい。
C<$!> と C<$^E> はエラー状況が検出されたときにのみ設定されますが、
変数 C<$?> は C<wait> やパイプの C<close> の度に、前の値を上書きします。
これは、C<$@> が C<eval()> の実行毎に、エラーならセットされ、
成功ならクリアされるという動作と似ています。

=begin original

For more details, see the individual descriptions at C<$@>, C<$!>,
C<$^E>, and C<$?>.

=end original

より詳細については、C<$@>, C<$!>, C<$^E>, C<$?> それぞれの説明を
参照して下さい。

=over 8

=item ${^CHILD_ERROR_NATIVE}
X<$^CHILD_ERROR_NATIVE>

=begin original

The native status returned by the last pipe close, backtick (C<``>)
command, successful call to C<wait()> or C<waitpid()>, or from the
C<system()> operator.  On POSIX-like systems this value can be decoded
with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, and
WSTOPSIG functions provided by the L<POSIX> module.

=end original

最後のパイプクローズ、逆クォート (C<``>) コマンド、C<wait()> と
C<waitpid()> の成功した呼び出し、C<system()> 演算子から返された、
ネイティブなステータスです。
POSIX 風システムでは、この値は L<POSIX> モジュールで提供される
WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG 関数で
デコードできます。

=begin original

Under VMS this reflects the actual VMS exit status; i.e. it is the
same as C<$?> when the pragma C<use vmsish 'status'> is in effect.

=end original

VMS ではこれは実際の VMS の終了ステータスを反映します;
言い換えると、これは C<use vmsish 'status'> プラグマが有効なときの $? と
同じです。

=begin original

This variable was added in Perl v5.10.0.

=end original

この変数は Perl v5.10.0 で追加されました。

=item $EXTENDED_OS_ERROR

=item $^E
X<$^E> X<$EXTENDED_OS_ERROR>

=begin original

Error information specific to the current operating system.  At the
moment, this differs from C<L</$!>> under only VMS, OS/2, and Win32 (and
for MacPerl).  On all other platforms, C<$^E> is always just the same
as C<$!>.

=end original

現在のオペレーティングシステムに特化したエラー情報です。
現在のところ、VMS, OS/2, Win32 (と MacPerl) のみで
C<L</$!>> と異なる値をもちます。
その他のプラットフォームでは、C<$^E> はいつも C<$!> と同じです。

=begin original

Under VMS, C<$^E> provides the VMS status value from the last system
error.  This is more specific information about the last system error
than that provided by C<$!>.  This is particularly important when C<$!>
is set to B<EVMSERR>.

=end original

VMS では、C<$^E> は最後のシステムエラーの VMS ステータス値です。
これは、最後のシステムエラーについて C<$!> で提供されるものより
具体的な情報を示します。
これは特に C<$!> が B<EVMSERR> にセットされた場合に重要です。

=begin original

Under OS/2, C<$^E> is set to the error code of the last call to OS/2
API either via CRT, or directly from perl.

=end original

OS/2 では、C<$^E> は CRT 経由、または Perl から直接呼び出された
最後の OS/2 API のエラーコードがセットされます。

=begin original

Under Win32, C<$^E> always returns the last error information reported
by the Win32 call C<GetLastError()> which describes the last error
from within the Win32 API.  Most Win32-specific code will report errors
via C<$^E>.  ANSI C and Unix-like calls set C<errno> and so most
portable Perl code will report errors via C<$!>.

=end original

Win32 では、C<$^E> は Win32 API での最後のエラーの内容を返す
C<GetLastError()> Win32 呼び出しで報告される最新のエラー情報を
返します。
ほとんどの Win32 固有のコードはエラーを C<$^E> 経由で返します。
ANSI C と Unix 風の呼び出しは C<errno> をセットするので、
ほとんどの移植性のある Perl コードは C<$!> 経由で
エラーを報告します。

=begin original

Caveats mentioned in the description of C<L</$!>> generally apply to
C<$^E>, also.

=end original

C<L</$!>> の説明で触れた問題点は一般的に C<$^E> にも適用されます。

=begin original

This variable was added in Perl 5.003.

=end original

この変数は Perl 5.003 で追加されました。

=begin original

Mnemonic: Extra error explanation.

=end original

記憶法: 追加の(Extra)エラーの説明。

=item $EXCEPTIONS_BEING_CAUGHT

=item $^S
X<$^S> X<$EXCEPTIONS_BEING_CAUGHT>

=begin original

Current state of the interpreter.

=end original

現在のインタプリタの状態を示します。

=begin original

    $^S         State
    ---------   -------------------------------------
    undef       Parsing module, eval, or main program
    true (1)    Executing an eval or try block
    false (0)   Otherwise

=end original

    $^S         状態
    ---------   -------------------
    undef       モジュール、eval、メインプログラムのパース中
    真 (1)      eval または try ブロックの実行中
    偽 (0)      その他

=begin original

The first state may happen in C<$SIG{__DIE__}> and C<$SIG{__WARN__}>
handlers.

=end original

最初の状態は C<$SIG{__DIE__}> と C<$SIG{__WARN__}> のハンドラで起きる
可能性があります。

=begin original

The English name $EXCEPTIONS_BEING_CAUGHT is slightly misleading, because
the C<undef> value does not indicate whether exceptions are being caught,
since compilation of the main program does not catch exceptions.

=end original

英語名 $EXCEPTIONS_BEING_CAUGHT は少し誤解を招きます; C<undef> は例外が
捕捉されたかどうかを示しているわけではないからです; メインプログラムの
コンパイルは例外を捕捉しません。

=begin original

This variable was added in Perl 5.004.

=end original

この変数は Perl 5.004 で追加されました。

=item $WARNING

=item $^W
X<$^W> X<$WARNING>

=begin original

The current value of the warning switch, initially true if B<-w> was
used, false otherwise, but directly modifiable.

=end original

警告スイッチの値で、B<-w> スイッチが使われると内部的に真となり、
そうでない場合は直接変更可能です。

=begin original

See also L<warnings>.

=end original

L<warnings> も参照して下さい。

=begin original

Mnemonic: related to the B<-w> switch.

=end original

記憶法: B<-w> スイッチに関係します。

=item ${^WARNING_BITS}
X<${^WARNING_BITS}>

=begin original

The current set of warning checks enabled by the C<use warnings> pragma.
It has the same scoping as the C<$^H> and C<%^H> variables.  The exact
values are considered internal to the L<warnings> pragma and may change
between versions of Perl.

=end original

C<use warnings> プラグマで有効にされた、現在の警告チェックの集合です。
C<$^H> および C<%^H> 変数と同じスコープを持ちます。
正確な値は L<warnings> プラグマの内部の値と考えられ、Perl の
バージョンによって変更されるかもしれません。

=begin original

Each time a statement completes being compiled, the current value of
C<${^WARNING_BITS}> is stored with that statement, and can later be
retrieved via C<(caller($level))[9]>.

=end original

文のコンパイルが完了する毎に、C<${^WARNING_BITS}> の現在の値が文と共に
保管され、C<(caller($level))[9]> として後で取得できます。

=begin original

This variable was added in Perl v5.6.0.

=end original

この変数は Perl v5.6.0 で追加されました。

=item $OS_ERROR

=item $ERRNO

=item $!
X<$!> X<$ERRNO> X<$OS_ERROR>

=begin original

When referenced, C<$!> retrieves the current value
of the C C<errno> integer variable.
If C<$!> is assigned a numerical value, that value is stored in C<errno>.
When referenced as a string, C<$!> yields the system error string
corresponding to C<errno>.

=end original

参照されると、C<$!> は C の C<errno> 整数変数の現在の値を取得します。
C<$!> に数値が代入されると、その値は C<errno> に保管されます。
文字列として参照されると、C<$!> は C<errno> に対応するシステムエラー
文字列を返します。

=begin original

Many system or library calls set C<errno> if they fail,
to indicate the cause of failure.  They usually do B<not>
set C<errno> to zero if they succeed and may set C<errno> to a
non-zero value on success.  This means C<errno>, hence C<$!>, is
meaningful only I<immediately> after a B<failure>:

=end original

多くのシステムやライブラリ呼び出しは、失敗したときに、失敗の理由を示すために
C<errno> を設定します。
これらは普通は成功したときには C<errno> にゼロを設定 B<しません>;
成功時には C<errno> に非ゼロを設定するかもしれません。
これは、C<errno>、C<$!> は、B<失敗> の I<直後> でのみ意味が
あるということです:

=begin original

    if (open my $fh, "<", $filename) {
        # Here $! is meaningless.
        ...
    }
    else {
        # ONLY here is $! meaningful.
        ...
        # Already here $! might be meaningless.
    }
    # Since here we might have either success or failure,
    # $! is meaningless.

=end original

    if (open my $fh, "<", $filename) {
        # ここで $! は無意味。
        ...
    }
    else {
        # ここでだけ $! に意味がある。
        ...
        # ここで既に $! は無意味かもしれません。
    }
    # ここでは成功と失敗の両方の可能性があるので、
    # $! は無意味。

=begin original

Here, I<meaningless> means that C<$!> may be unrelated to the outcome
of the C<open()> operator.  Assignment to C<$!> is similarly ephemeral.
It can be used immediately before invoking the C<die()> operator,
to set the exit value, or to inspect the system error string
corresponding to error I<n>, or to restore C<$!> to a meaningful state.

=end original

ここで、I<無意味> というのは C<$!> は C<open()> 演算子の結果に
関係ないということです。
C<$!> への代入も同様に一時的なものです。
これは、終了値を設定したり、エラー I<n> に対応するシステムエラー文字列を
調べたり、C<$!> を意味のある状態に復元するために、C<die()> 演算子を
起動する直前で使えます。

=begin original

Perl itself may set C<errno> to a non-zero on failure even if no
system call is performed.

=end original

Perl 自身は、システムコールを実行しなくても失敗時には
C<errno> に非ゼロを設定するかもしれません。

=begin original

Mnemonic: What just went bang?

=end original

記憶法: 何が bang(!) したか。

=item %OS_ERROR

=item %ERRNO

=item %!
X<%!> X<%OS_ERROR> X<%ERRNO>

=begin original

Each element of C<%!> has a true value only if C<$!> is set to that
value.  For example, C<$!{ENOENT}> is true if and only if the current
value of C<$!> is C<ENOENT>; that is, if the most recent error was "No
such file or directory" (or its moral equivalent: not all operating
systems give that exact error, and certainly not all languages).  The
specific true value is not guaranteed, but in the past has generally
been the numeric value of C<$!>.  To check if a particular key is
meaningful on your system, use C<exists $!{the_key}>; for a list of legal
keys, use C<keys %!>.  See L<Errno> for more information, and also see
L</$!>.

=end original

C<%!> の各要素は、C<$!> がその値にセットされている場合にのみ真の値を持ちます。
例えば、C<$!{ENOENT}> は、現在の C<$!> の値が C<ENOENT> の場合にのみ
真となります; これは、最近のエラーが "No such file or directory" (あるいは
倫理的に等価なもの: 全ての OS が正確に同じエラーを出すわけではないですし、
全ての言語で出るわけでもありません) の場合です。
特定の真の値は保証されませんが、以前は一般的には C<$!> の数値でした。
あなたのシステムで特定のキーが意味があるかどうかを調べるには、
C<exists $!{the_key}> を使ってください; 有効なキーのリストを得るには、
C<keys %!> としてください。
さらなる情報に関しては L<Errno> と C</$!> を参照してください。

=begin original

This variable was added in Perl 5.005.

=end original

この変数は Perl 5.005 で追加されました。

=item $CHILD_ERROR

=item $?
X<$?> X<$CHILD_ERROR>

=begin original

The status returned by the last pipe close, backtick (C<``>) command,
successful call to C<wait()> or C<waitpid()>, or from the C<system()>
operator.  This is just the 16-bit status word returned by the
traditional Unix C<wait()> system call (or else is made up to look
like it).  Thus, the exit value of the subprocess is really (C<<< $? >>
8 >>>), and C<$? & 127> gives which signal, if any, the process died
from, and C<$? & 128> reports whether there was a core dump.

=end original

最後に close したパイプ、バッククォート (C<``>) コマンド、
成功した C<wait()> または waitpid() 呼び出し、C<system()> 演算子が返した
ステータス。
このステータスワードは伝統的な Unix の C<wait()> システムコールが返した
16 ビットのステータス(またはそのように見えるもの)です。
従ってサブプロセスの exit 値は、実際には (C<<< $? >> 8 >>>)
で、C<$? & 127> は、もしあれば、そのプロセスを止めたシグナルで、
C<$? & 128> はコアダンプがあるかどうかを示します。

=begin original

Additionally, if the C<h_errno> variable is supported in C, its value
is returned via C<$?> if any C<gethost*()> function fails.

=end original

さらに、C で C<h_errno> 変数に対応している場合は、
C<gethost*()> が失敗したときに C<$?> を通して返されます。

=begin original

If you have installed a signal handler for C<SIGCHLD>, the
value of C<$?> will usually be wrong outside that handler.

=end original

C<SIGCHLD> のシグナルハンドラを設定した場合、
C<$?> の値は通常ハンドラの外側では正しくない値となります。

=begin original

Inside an C<END> subroutine C<$?> contains the value that is going to be
given to C<exit()>.  You can modify C<$?> in an C<END> subroutine to
change the exit status of your program.  For example:

=end original

C<END> サブルーチンの内側では C<$?> には C<exit()> に渡されようとしている
値を含みます。
プログラムの終了ステータスを変更するために、C<END> サブルーチン 内で
C<$?> を変更できます。
例えば:

=begin original

    END {
        $? = 1 if $? == 255;  # die would make it 255
    }

=end original

    END {
        $? = 1 if $? == 255;  # die は 255
    }

=begin original

Under VMS, the pragma C<use vmsish 'status'> makes C<$?> reflect the
actual VMS exit status, instead of the default emulation of POSIX
status; see L<perlvms/$?> for details.

=end original

VMS では、C<use vmsish 'status'> を指定すると、
C<$?> はPOSIX ステータスをエミュレートしたものではなく、
実際の VMS 終了ステータスを反映します; 詳細は L<perlvms/$?> を
参照してください。

=begin original

Mnemonic: similar to B<sh> and B<ksh>.

=end original

記憶法: B<sh> や B<ksh> と同様。

=item $EVAL_ERROR

=item $@
X<$@> X<$EVAL_ERROR>

=begin original

The Perl error from the last C<eval> operator, i.e. the last exception that
was caught.  For C<eval BLOCK>, this is either a runtime error message or the
string or reference C<die> was called with.  The C<eval STRING> form also
catches syntax errors and other compile time exceptions.

=end original

最後の C<eval> 操作子による Perl のエラーです; つまり、最後に補足された
例外です。
C<eval BLOCK> の場合は、これは実行時エラーか、C<die> が呼び出されたときの
文字列かリファレンスです。
C<eval STRING> 型式は、文法エラーやその他のコンパイル時例外も捕捉します。

=begin original

If no error occurs, C<eval> sets C<$@> to the empty string.

=end original

エラーが起きなければ、C<eval> は C<$@> に空文字列を設定します。

=begin original

Warning messages are not collected in this variable.  You can, however,
set up a routine to process warnings by setting C<$SIG{__WARN__}> as
described in L</%SIG>.

=end original

警告メッセージはこの変数に入りません。
しかし、L</%SIG> に記述されている C<$SIG{__WARN__}> にセットすることで
警告を処理するルーチンを設定できます。

=begin original

Mnemonic: Where was the error "at"?

=end original

記憶法: どこで ("at") エラーが起ったか。

=back

=head2 Variables related to the interpreter state

(インタプリタの状態に関連する変数)

=begin original

These variables provide information about the current interpreter state.

=end original

これらの変数は現在のインタプリタの状態に関する情報を提供します。

=over 8

=item $COMPILING

=item $^C
X<$^C> X<$COMPILING>

=begin original

The current value of the flag associated with the B<-c> switch.
Mainly of use with B<-MO=...> to allow code to alter its behavior
when being compiled, such as for example to C<AUTOLOAD> at compile
time rather than normal, deferred loading.  Setting
C<$^C = 1> is similar to calling C<B::minus_c>.

=end original

B<-c> スイッチに関連付けられた現在の値です。
主に B<-MO=...> と共に用いられ、例えば C<AUTOLOAD> を通常の遅延ロードでは
なくコンパイル時に実行するといった、コンパイル時の振る舞いを
変えるために用います。
C<$^C = 1> に設定することは C<B::minus_c> を呼び出すのと似ています。

=begin original

This variable was added in Perl v5.6.0.

=end original

この変数は Perl v5.6.0 で追加されました。

=item $DEBUGGING

=item $^D
X<$^D> X<$DEBUGGING>

=begin original

The current value of the debugging flags.  May be read or set.  Like its
L<command-line equivalent|perlrun/B<-D>I<letters>>, you can use numeric
or symbolic values, e.g. C<$^D = 10> or C<$^D = "st">.  See
L<perlrun/B<-D>I<number>>.  The contents of this variable also affects the
debugger operation.  See L<perldebguts/Debugger Internals>.

=end original

デバッグフラグの現在の値を示します。
読み書き可能です。
L<コマンドラインによる等価な機能|perlrun/B<-D>I<letters>> と同様に、
数値とシンボル値が使えます
(例: C<$^D = 10> または C<$^D = "st">)。
L<perlrun/B<-D>I<number>> を参照してください。
この変数の内容はデバッガ操作にも影響されます。
L<perldebguts/Debugger Internals> を参照してください。

=begin original

Mnemonic: value of B<-D> switch.

=end original

記憶法: B<-D> スイッチの値。

=item ${^GLOBAL_PHASE}
X<${^GLOBAL_PHASE}>

=begin original

The current phase of the perl interpreter.

=end original

perl インタプリタの現在のフェーズ。

=begin original

Possible values are:

=end original

取り得る値は:

=over 8

=item CONSTRUCT

=begin original

The C<PerlInterpreter*> is being constructed via C<perl_construct>.  This
value is mostly there for completeness and for use via the
underlying C variable C<PL_phase>.  It's not really possible for Perl
code to be executed unless construction of the interpreter is
finished.

=end original

C<PerlInterpreter*> は C<perl_construct> で構築されます。
この変数はほとんど完全性のためと、基礎となっている C 変数
C<PL_phase> 経由での使用のために存在しています。
実際にはインタプリタの構築が完了しない限り Perl コードを
実行することはできません。

=item START

=begin original

This is the global compile-time.  That includes, basically, every
C<BEGIN> block executed directly or indirectly from during the
compile-time of the top-level program.

=end original

これはコンパイル時にグローバルです。
これは基本的に、直接実行されたり、トップレベルプログラムの
コンパイル時の間に間接的に実行される全ての C<BEGIN> です。

=begin original

This phase is not called "BEGIN" to avoid confusion with
C<BEGIN>-blocks, as those are executed during compile-time of any
compilation unit, not just the top-level program.  A new, localised
compile-time entered at run-time, for example by constructs as
C<eval "use SomeModule"> are not global interpreter phases, and
therefore aren't reflected by C<${^GLOBAL_PHASE}>.

=end original

C<BEGIN> ブロックとの混乱を避けるために、このフェーズの名前は "BEGIN" では
ありません; これらは単にトップレベルプログラムではなく、任意のコンパイル
ユニットのコンパイル中に実行されます。
例えば C<eval "use SomeModule"> のように、実行時に入った
新しいローカル化されたコンパイル時はグローバルなインタプリタフェーズではなく、
従って C<${^GLOBAL_PHASE}> に反映されません。

=item CHECK

=begin original

Execution of any C<CHECK> blocks.

=end original

C<CHECK> ブロックの実行。

=item INIT

=begin original

Similar to "CHECK", but for C<INIT>-blocks, not C<CHECK> blocks.

=end original

"CHECK" と似ていますが、C<CHECK> ブロックではなく C<INIT> ブロック。

=item RUN

=begin original

The main run-time, i.e. the execution of C<PL_main_root>.

=end original

メインの実行; つまり C<PL_main_root> の実行。

=item END

=begin original

Execution of any C<END> blocks.

=end original

C<END> ブロックの実行。

=item DESTRUCT

=begin original

Global destruction.

=end original

グローバルなデストラクタ。

=back

=begin original

Also note that there's no value for UNITCHECK-blocks.  That's because
those are run for each compilation unit individually, and therefore is
not a global interpreter phase.

=end original

また、UNITCHECK ブロックのための値はないことに注意してください。
なぜなら、これらはコンパイルユニット毎に独立に実行され、従って
グローバルなインタプリタフェーズではないからです。

=begin original

Not every program has to go through each of the possible phases, but
transition from one phase to another can only happen in the order
described in the above list.

=end original

全てのプログラムが可能な全てのフェーズを通らなければならないわけでは
ありませんが、あるフェーズから他のフェーズへの移行は上述の
順でのみ起こります。

=begin original

An example of all of the phases Perl code can see:

=end original

Perl コードの全てのフェーズを見る例です:

    BEGIN { print "compile-time: ${^GLOBAL_PHASE}\n" }

    INIT  { print "init-time: ${^GLOBAL_PHASE}\n" }

    CHECK { print "check-time: ${^GLOBAL_PHASE}\n" }

    {
        package Print::Phase;

        sub new {
            my ($class, $time) = @_;
            return bless \$time, $class;
        }

        sub DESTROY {
            my $self = shift;
            print "$$self: ${^GLOBAL_PHASE}\n";
        }
    }

    print "run-time: ${^GLOBAL_PHASE}\n";

    my $runtime = Print::Phase->new(
        "lexical variables are garbage collected before END"
    );

    END   { print "end-time: ${^GLOBAL_PHASE}\n" }

    our $destruct = Print::Phase->new(
        "package variables are garbage collected after END"
    );

=begin original

This will print out

=end original

これは以下のものを出力します:

    compile-time: START
    check-time: CHECK
    init-time: INIT
    run-time: RUN
    lexical variables are garbage collected before END: RUN
    end-time: END
    package variables are garbage collected after END: DESTRUCT

=begin original

This variable was added in Perl 5.14.0.

=end original

この変数は Perl 5.14.0 で追加されました。

=item $^H
X<$^H>

=begin original

WARNING: This variable is strictly for
internal use only.  Its availability,
behavior, and contents are subject to change without notice.

=end original

警告: この変数は厳密に内部使用に限定されます。
その可用性、挙動、内容は告知なく変更される可能性があります。

=begin original

This variable contains compile-time hints for the Perl interpreter.  At the
end of compilation of a BLOCK the value of this variable is restored to the
value when the interpreter started to compile the BLOCK.

=end original

この変数には Perl インタプリタのコンパイル時のヒントが入ります。
BLOCK のコンパイル終了時に、この変数の値は
インタプリタが BLOCK のコンパイルを開始した時の値に戻されます。

=begin original

Each time a statement completes being compiled, the current value of
C<$^H> is stored with that statement, and can later be retrieved via
C<(caller($level))[8]>.  See L<perlfunc/caller EXPR>.

=end original

文のコンパイルが完了する毎に、C<$^H> の現在の値が文と共に
保管され、C<(caller($level))[8]> として後で取得できます。
L<perlfunc/caller EXPR> を参照してください。

=begin original

When perl begins to parse any block construct that provides a lexical scope
(e.g., eval body, required file, subroutine body, loop body, or conditional
block), the existing value of C<$^H> is saved, but its value is left unchanged.
When the compilation of the block is completed, it regains the saved value.
Between the points where its value is saved and restored, code that
executes within BEGIN blocks is free to change the value of C<$^H>.

=end original

Perl がレキシカルスコープを持つブロック構造(eval の中身、required された
ファイル、サブルーチンの中身、loop の中身、条件付きブロック)の
パースを開始するとき、現在の C<$^H> の値は保存されますが、値は
変更されません。
ブロックのコンパイルが終わると、保存された値が戻されます。
値の保存と回復の間の地点で、BEGIN ブロックの中で実行されるコードは自由に
C<$^H> の値を変更できます。

=begin original

This behavior provides the semantic of lexical scoping, and is used in,
for instance, the C<use strict> pragma.

=end original

この振る舞いはレキシカルスコープを持ち、その中で使えます; 例としては
C<use strict> があります。

=begin original

The contents should be an integer; different bits of it are used for
different pragmatic flags.  Here's an example:

=end original

内容は整数であるべきです; ビット毎に異なるプラグマフラグとして使われます。
以下は例です:

    sub add_100 { $^H |= 0x100 }

    sub foo {
        BEGIN { add_100() }
        bar->baz($boon);
    }

=begin original

Consider what happens during execution of the BEGIN block.  At this point
the BEGIN block has already been compiled, but the body of C<foo()> is still
being compiled.  The new value of C<$^H>
will therefore be visible only while
the body of C<foo()> is being compiled.

=end original

BEGIN ブロックの実行中に起こることを考えてみます。
この時点で BEGIN ブロックは既にコンパイルされていますが、
C<foo()> の中身はまだコンパイル中です。
従って C<$^H> の新しい値は C<foo()> の中身がコンパイル中にのみ
見ることが出来ます。

=begin original

Substitution of C<BEGIN { add_100() }> block with:

=end original

C<BEGIN { add_100() }> ブロックを以下のように変更すると:

    BEGIN { require strict; strict->import('vars') }

=begin original

demonstrates how C<use strict 'vars'> is implemented.  Here's a conditional
version of the same lexical pragma:

=end original

どのように C<use strict 'vars'> が実装されているかがわかります。
以下は同じレキシカルプラグマの条件付き版です:

    BEGIN {
        require strict; strict->import('vars') if $condition
    }

=begin original

This variable was added in Perl 5.003.

=end original

この変数は Perl 5.003 で追加されました。

=item %^H
X<%^H>

=begin original

The C<%^H> hash provides the same scoping semantics as L<C<$^H>|/$^H>.  This
makes it useful for implementing lexically scoped pragmas.  See L<perlpragma>.
All the entries are stringified when accessed at runtime, so only simple values
can be accommodated.  This means no references to objects, for example.

=end original

C<%^H> ハッシュは L<C<$^H>|/$^H> と同じスコープの意味論を持ちます。
これはレキシカルスコープを持つプラグマを実装するのに便利です。
L<perlpragma> を参照してください。
実行時にアクセスされると全てのエントリは文字列化されるので、
単純な値のみに対応します。
これは、例えばオブジェクトへのリファレンスはないということです。

=begin original

Each time a statement completes being compiled, the current value of
C<%^H> is stored with that statement, and can later be retrieved via
C<(caller($level))[10]>.  See L<perlfunc/caller EXPR>.

=end original

文のコンパイルが完了する毎に、C<%^H> の現在の値が文と共に
保管され、C<(caller($level))[10]> として後で取得できます。
L<perlfunc/caller EXPR> を参照してください。

=begin original

When putting items into C<%^H>, in order to avoid conflicting with other
users of the hash there is a convention regarding which keys to use.
A module should use only keys that begin with the module's name (the
name of its main package) and a "/" character.  For example, a module
C<Foo::Bar> should use keys such as C<Foo::Bar/baz>.

=end original

C<%^H> に追加するとき、他のハッシュのユーザーとの衝突を回避するために、
キーの使い方に関する慣習があります。
モジュールはモジュールの名前(主なパッケージの名前)と "/" 文字で始まる
キーのみを使うべきです。
例えば、モジュール C<Foo::Bar> は C<Foo::Bar/baz> のようなキーを
使うべきです。

=begin original

This variable was added in Perl v5.6.0.

=end original

この変数は Perl v5.6.0 で追加されました。

=item ${^OPEN}
X<${^OPEN}>

=begin original

An internal variable used by L<PerlIO>.  A string in two parts, separated
by a C<\0> byte, the first part describes the input layers, the second
part describes the output layers.

=end original

L<PerlIO> で使われる内部変数です。
文字列は C<\0> で分割された二つの部分からなり、前半は入力層を、
後半は出力層を示します。

=begin original

This is the mechanism that applies the lexical effects of the L<open>
pragma, and the main program scope effects of the C<io> or C<D> options
for the L<-C command-line switch|perlrun/-C [I<numberE<sol>list>]> and
L<PERL_UNICODE environment variable|perlrun/PERL_UNICODE>.

=end original

これは L<open> プラグマおよび、C<io> や
L<-C コマンドラインオプション|perlrun/-C [I<numberE<sol>list>]> と
L<PERL_UNICODE 環境変数|perlrun/PERL_UNICODE> の C<D> オプションの
メインプログラムスコープにレキシカルな効果を適用するための機構です。

=begin original

The functions C<accept()>, C<open()>, C<pipe()>, C<readpipe()> (as well
as the related C<qx> and C<`STRING`> operators), C<socket()>,
C<socketpair()>, and C<sysopen()> are affected by the lexical value of
this variable.  The implicit L</ARGV> handle opened by C<readline()> (or
the related C<< <> >> (diamond) and C<<< <<>> >>> (double diamond)
operators) on passed filenames is
also affected (but not if it opens C<STDIN>).  If this variable is not
set, these functions will set the default layers as described in
L<PerlIO/Defaults and how to override them>.

=end original

C<accept()>, C<open()>, C<pipe()>, C<readpipe()> (および関連する
C<qx> と C<`STRING`> 演算子), C<socket()>,
C<socketpair()>, C<sysopen()> 関数は、この変数のレキシカルな値に
影響を受けます。
C<readline()> (や関連する C<< <> >> (ダイヤモンド)と C<<< <<>> >>>
(2 重ダイヤモンド)演算子) に
ファイル名を渡すことによって開かれた暗黙の L</ARGV> も影響を受けます
(しかし C<STDIN> を開いている場合は影響を受けません)。
この変数が設定されていない場合、これらの関数は
L<PerlIO/Defaults and how to override them> で記述されている
デフォルト層が設定されます。

=begin original

C<open()> ignores this variable (and the default layers) when called with
3 arguments and explicit layers are specified.  Indirect calls to these
functions via modules like L<IO::Handle> are not affected as they occur
in a different lexical scope.  Directory handles such as opened by
C<opendir()> are not currently affected.

=end original

C<open()> は、3 引数で呼び出され、明示的な層が指定された場合は
この変数(およびデフォルト層)を無視します。
L<IO::Handle> のようなモジュール経由でのこれらの関数の間接的な呼び出しは
影響を受けません; これらは異なったレキシカルスコープで起きるからです。
C<opendir()> で開かれたようなディレクトリハンドルは現在の所
影響を受けません。

=begin original

This variable was added in Perl v5.8.0.

=end original

この変数は Perl v5.8.0 で追加されました。

=item $PERLDB

=item $^P
X<$^P> X<$PERLDB>

=begin original

The internal variable for debugging support.  The meanings of the
various bits are subject to change, but currently indicate:

=end original

デバッグ機能のための内部変数です。
それぞれのビットの意味は変わるかもしれませんが、
現在のところは以下の通りです:

=over 6

=item 0x01

=begin original

Debug subroutine enter/exit.

=end original

サブルーチンの出入りをデバッグします。

=item 0x02

=begin original

Line-by-line debugging.  Causes C<DB::DB()> subroutine to be called for
each statement executed.  Also causes saving source code lines (like
0x400).

=end original

行毎にデバッグします。
各行を実行する毎に C<DB::DB()> サブルーチンを呼び出します。
さらに、(0x400 のように) ソースコードを保存します。

=item 0x04

=begin original

Switch off optimizations.

=end original

最適化を行いません。

=item 0x08

=begin original

Preserve more data for future interactive inspections.

=end original

将来の対話的な検査のためにより多くのデータを保存します。

=item 0x10

=begin original

Keep info about source lines on which a subroutine is defined.

=end original

サブルーチンが定義されたソース行に関する情報を保持します。

=item 0x20

=begin original

Start with single-step on.

=end original

シングルステップ実行で開始します。

=item 0x40

=begin original

Use subroutine address instead of name when reporting.

=end original

報告時にサブルーチン名でなくサブルーチンのアドレスを使います。

=item 0x80

=begin original

Report C<goto &subroutine> as well.

=end original

C<goto &subroutine> も同様に報告します。

=item 0x100

=begin original

Provide informative "file" names for evals based on the place they were compiled.

=end original

eval に対して、コンパイルされた位置を元にした「ファイル」名を提供します。

=item 0x200

=begin original

Provide informative names to anonymous subroutines based on the place they
were compiled.

=end original

無名サブルーチンに対して、
コンパイルされた位置を基にした参考名を提供します。

=item 0x400

=begin original

Save source code lines into C<@{"_<$filename"}>.

=end original

ソースコードの行数を C<@{"_<$filename"}> に保存します。

=item 0x800

=begin original

When saving source, include evals that generate no subroutines.

=end original

ソースを保存するときに、サブルーチンがない eval を含みます。

=item 0x1000

=begin original

When saving source, include source that did not compile.

=end original

ソースを保存するときに、コンパイルしていないソースを含みます。

=back

=begin original

Some bits may be relevant at compile-time only, some at
run-time only.  This is a new mechanism and the details may change.
See also L<perldebguts>.

=end original

一部のビットはコンパイル時にのみまたは実行時にのみ意味があります。
これは新しい機構であり、詳細は変更されるかもしれません。
L<perldebguts> も参照してください。

=item ${^TAINT}
X<${^TAINT}>

=begin original

Reflects if taint mode is on or off.  1 for on (the program was run with
B<-T>), 0 for off, -1 when only taint warnings are enabled (i.e. with
B<-t> or B<-TU>).

=end original

汚染検査モードのオン・オフを反映します。
1 はオン(プログラムは B<-T> 付きで実行されている)、0 はオフ、-1 は汚染
警告のみが有効になっている(つまり B<-t> か B<-TU>)ことを意味します。

=begin original

Note: if your perl was built without taint support (see L<perlsec>),
then C<${^TAINT}> will always be 0, even if the program was run with B<-T>).

=end original

注意: perl が汚染チェック対応 (L<perlsec> 参照) なしでビルドされている場合、
たとえプログラムが B<-T> 付きで実行されていても、
C<${^TAINT}> は常に 0 です。

=begin original

This variable is read-only.

=end original

この変数は読み込み専用です。

=begin original

This variable was added in Perl v5.8.0.

=end original

この変数は Perl v5.8.0 で追加されました。

=item ${^SAFE_LOCALES}
X<${^SAFE_LOCALES}>

=begin original

Reflects if safe locale operations are available to this perl (when the
value is 1) or not (the value is 0).  This variable is always 1 if the
perl has been compiled without threads.  It is also 1 if this perl is
using thread-safe locale operations.  Note that an individual thread may
choose to use the global locale (generally unsafe) by calling
L<perlapi/switch_to_global_locale>.  This variable currently is still
set to 1 in such threads.

=end original

この perl で安全なロケール操作が利用可能 (値が 1 の場合) かそうでない
(値が 0 の場合) かを反映します。
この変数は、perl がスレッドなしでコンパイルされている場合は常に 1 です。
また、perl がスレッドセーフなロケール操作を使っている場合は 1 です。
個々のスレッドは L<perlapi/switch_to_global_locale> を呼び出すことで
(一般的にはスレッドセーフでない) グローバルなロケールを使うことを
選ぶかも知れないことに注意してください。
この変数はそのようなスレッドでも 1 のままです。

=begin original

This variable is read-only.

=end original

この変数は読み込み専用です。

=begin original

This variable was added in Perl v5.28.0.

=end original

この変数は Perl v5.28.0 で追加されました。

=item ${^UNICODE}
X<${^UNICODE}>

=begin original

Reflects certain Unicode settings of Perl.  See
L<perlrun|perlrun/-C [numberE<sol>list]> documentation for the C<-C>
switch for more information about the possible values.

=end original

Perl のいくつかの Unicode 設定を反映します。
設定できる値に関するさらなる情報については
L<perlrun|perlrun/-C [numberE<sol>list]> の C<-C> オプションを
参照してください。

=begin original

This variable is set during Perl startup and is thereafter read-only.

=end original

この変数は Perl 起動時に設定され、その後は読み込み専用です。

=begin original

This variable was added in Perl v5.8.2.

=end original

この変数は Perl v5.8.2 で追加されました。

=item ${^UTF8CACHE}
X<${^UTF8CACHE}>

=begin original

This variable controls the state of the internal UTF-8 offset caching code.
1 for on (the default), 0 for off, -1 to debug the caching code by checking
all its results against linear scans, and panicking on any discrepancy.

=end original

この変数は内部 UTF-8 オフセットキャッシュコードの状態を制御します。
1 はオン(デフォルト)、0 はオフ、-1 は全ての結果を線形走査と比較して、
矛盾があれば異常終了する、という形でキャッシュコードをデバッグします。

=begin original

This variable was added in Perl v5.8.9.  It is subject to change or
removal without notice, but is currently used to avoid recalculating the
boundaries of multi-byte UTF-8-encoded characters.

=end original

この変数は Perl v5.8.9 で追加されました。
これは予告なく変更されたり削除されたりするかもしれませんが、現在のところ
複数バイト UTF-8 エンコード文字の境界の再計算を避けるために使われます。

=item ${^UTF8LOCALE}
X<${^UTF8LOCALE}>

=begin original

This variable indicates whether a UTF-8 locale was detected by perl at
startup.  This information is used by perl when it's in
adjust-utf8ness-to-locale mode (as when run with the C<-CL> command-line
switch); see L<perlrun|perlrun/-C [numberE<sol>list]> for more info on
this.

=end original

この変数は、起動時に perl によって UTF-8 ロケールが検出されたかどうかを
示します。
この情報は(C<-CL> コマンドラインスイッチで起動されることによって)
「utf8 性をロケールに合わせる」モードのときに perl によって使われます;
これに関するさらなる情報は 
L<perlrun|perlrun/-C [numberE<sol>list]> を参照してください。

=begin original

This variable was added in Perl v5.8.8.

=end original

この変数は Perl v5.8.8 で追加されました。

=back

=head2 Deprecated and removed variables

(非推奨および削除された変数)

=begin original

Deprecating a variable announces the intent of the perl maintainers to
eventually remove the variable from the language.  It may still be
available despite its status.  Using a deprecated variable triggers
a warning.

=end original

非推奨となった変数は、perl のメンテナが最終的にこの変数を
削除するということを意図して通知されます。
その状態にも関わらず、まだ利用可能です。
非推奨となった変数を使うと警告が出ます。

=begin original

Once a variable is removed, its use triggers an error telling you
the variable is unsupported.

=end original

変数が削除された後で変数を使うと、この変数が非対応となったことを
知らせるエラーが出ます。

=begin original

See L<perldiag> for details about error messages.

=end original

エラーメッセージの詳細については L<perldiag> を参照してください。

=over 8

=item $#
X<$#>

=begin original

C<$#> was a variable that could be used to format printed numbers.
After a deprecation cycle, its magic was removed in Perl v5.10.0 and
using it now triggers a compilation error: C<$# is no longer supported>.

=end original

C<$#> は、表示番号をフォーマットするために使われていました。
非推奨化の後、このマジックは Perl v5.10.0 で取り除かれ、
コンパイルエラーを引き起こします: C<$# is no longer supported>.

=begin original

This is not the sigil you use in front of an array name to get the
last index, like C<$#array>.  That's still how you get the last index
of an array in Perl.  (See L<perlintro/Arrays>.)
The two have nothing to do with each other.

=end original

これは C<$#array> のように最後のインデックスを得るために配列名の前に付ける
印ではありません。
これは今でも Perl で配列の最後のインデックスを得る方法です。
(L<perlintro/Arrays> 参照。)
これら二つには互いに何の関係もありません。

=begin original

Deprecated in Perl 5.

=end original

Perl 5 で非推奨となりました。

=begin original

Removed in Perl v5.10.0.

=end original

Perl v5.10.0 で削除されました。

=item $*
X<$*>

=begin original

C<$*> was a variable that you could use to enable multiline matching.
After a deprecation cycle, its magic was removed in Perl v5.10.0.
Using it now triggers a compilation error: C<$* is no longer supported>.
You should use the C</s> and C</m> regexp modifiers instead.

=end original

C<$*> は複数行マッチングを有効にするために使われていた変数です。
非推奨化の後、このマジックは Perl v5.10.0 で削除されました。
これを使うとコンパイルエラーを引き起こします: C<$* はもはや対応しません>。
代わりに C</s> と C</m> の正規表現修飾子を使うべきです。

=begin original

Deprecated in Perl 5.

=end original

Perl 5 で非推奨となりました。

=begin original

Removed in Perl v5.10.0.

=end original

Perl v5.10.0 で削除されました。

=item $[
X<$[>

=begin original

This variable stores the index of the first element in an array, and
of the first character in a substring.  The default is 0, but you could
theoretically set it to 1 to make Perl behave more like B<awk> (or Fortran)
when subscripting and when evaluating the index() and substr() functions.

=end original

この変数は配列の最初の要素や、文字列の最初の文字のインデックスを
保管します。
デフォルトは 0 ですが、理論的には、index() 関数や
substr() 関数を評価するときに、Perl の動作をより B<awk>
(や Fortran) に近づけるため、1 に設定することもできます。

=begin original

As of release 5 of Perl, assignment to C<$[> is treated as a compiler
directive, and cannot influence the behavior of any other file.
(That's why you can only assign compile-time constants to it.)
Its use is highly discouraged.

=end original

Perl 5 からは C<$[> への代入は、コンパイラ指示子として扱われ、
他のファイルの動作に影響を与えることがなくなりました。
(これが、コンパイル時定数しか代入できない理由です。)
この変数の使用は非推奨です。

=begin original

Prior to Perl v5.10.0, assignment to C<$[> could be seen from outer lexical
scopes in the same file, unlike other compile-time directives (such as
L<strict>).  Using local() on it would bind its value strictly to a lexical
block.  Now it is always lexically scoped.

=end original

Perl v5.10.0 より前では、C<$[> は(L<strict> のような)その他のコンパイル時
指示子と異なり、同じファイルのレキシカルスコープの外側から見ることが
出来ていました。
これに local() を使うとこの値を厳密にレキシカルスコープの内側に限定します。
今では常にレキシカルスコープを持ちます。

=begin original

As of Perl v5.16.0, it is implemented by the L<arybase> module.

=end original

Perl v5.16.0 から、これは L<arybase> モジュールで実装されています。

=begin original

As of Perl v5.30.0, or under C<use v5.16>, or C<no feature "array_base">,
C<$[> no longer has any effect, and always contains 0.
Assigning 0 to it is permitted, but any other value will produce an error.

=end original

Perl v5.30.0 以降か、C<use v5.16> または C<no feature "array_base"> の基では、
C<$[> はもはや何の効果もなく、常に 0 が入っています。
これに 0 を代入することは許されますが、それ以外の値はエラーを引き起こします。

=begin original

Mnemonic: [ begins subscripts.

=end original

記憶法: [ は添え字付けの始め。

=begin original

Deprecated in Perl v5.12.0.

=end original

Perl v5.12.0 で非推奨となりました。

=item ${^ENCODING}
X<${^ENCODING}>

=begin original

This variable is no longer supported.

=end original

この変数はもはや対応していません。

=begin original

It used to hold the I<object reference> to the C<Encode> object that was
used to convert the source code to Unicode.

=end original

これはソースコードを Unicode に変換するために使われる
C<Encode> オブジェクトへの I<オブジェクトリファレンス> を保持していました。

=begin original

Its purpose was to allow your non-ASCII Perl
scripts not to have to be written in UTF-8; this was
useful before editors that worked on UTF-8 encoded text were common, but
that was long ago.  It caused problems, such as affecting the operation
of other modules that weren't expecting it, causing general mayhem.

=end original

この目的は、非 ASCII Perl スクリプトを UTF-8 で書く必要をなくすためでした;
これは UTF-8 エンコードされたテキストで動作するエディタが一般的になる前は
有用でしたが、それはずっと前です。
これは、想定してない他のモジュールの操作に影響を与えるような問題を引き起こし、
一般的には破壊的です。

=begin original

If you need something like this functionality, it is recommended that use
you a simple source filter, such as L<Filter::Encoding>.

=end original

この機能のような何かが必要な場合は、L<Filter::Encoding> のような
単純なソースフィルタを使うことを勧めます。

=begin original

If you are coming here because code of yours is being adversely affected
by someone's use of this variable, you can usually work around it by
doing this:

=end original

あなたがここに来た理由が、誰かがこの変数を使うことであなたのコードが
意図せずに影響を受けたためなら、通常は次のようにして回避できます:

 local ${^ENCODING};

=begin original

near the beginning of the functions that are getting broken.  This
undefines the variable during the scope of execution of the including
function.

=end original

これを壊れてしまった関数の先頭付近に書きます。
これにより、この関数を含むスコープを実行する間この変数を未定義にします。

=begin original

This variable was added in Perl 5.8.2 and removed in 5.26.0.
Setting it to anything other than C<undef> was made fatal in Perl 5.28.0.

=end original

この変数は Perl 5.8.2 で追加され、5.26.0 で削除されました。
Perl 5.28.0 から、これに C<undef> 以外の値を設定すると致命的エラーになります。

=item ${^WIN32_SLOPPY_STAT}
X<${^WIN32_SLOPPY_STAT}> X<sitecustomize> X<sitecustomize.pl>

=begin original

This variable no longer has any function.

=end original

この変数はもはや何の機能もありません。

=begin original

This variable was added in Perl v5.10.0 and removed in Perl v5.34.0.

=end original

この変数は Perl v5.10.0 で追加され、Perl v5.34.0 で削除されました。

=back

=cut

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp> (5.000)
Update: Kentaro Shirakata <argrath@ub32.org> (5.6.1-)
Status: completed

=end meta

