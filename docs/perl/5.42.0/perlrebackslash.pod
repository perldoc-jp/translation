
=encoding utf8

=head1 NAME

=begin original

perlrebackslash - Perl Regular Expression Backslash Sequences and Escapes

=end original

perlrebackslash - Perl 正規表現逆スラッシュシーケンスとエスケープ

=head1 DESCRIPTION

=begin original

The top level documentation about Perl regular expressions
is found in L<perlre>.

=end original

Perl 正規表現に関する最上位文書は L<perlre> です。

=begin original

This document describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.

=end original

この文書は全ての逆スラッシュシーケンスとエスケープシーケンスについて
記述します。
逆スラッシュの役割について説明したあと、Perl 正規表現の中で特別な意味を持つ
全てのシーケンスを(アルファベット順に)示し、それぞれについて記述します。

=begin original

Most sequences are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.

=end original

ほとんどのシーケンスは他の文書に詳細に記述されています; この文書の主な目的は
全ての逆スラッシュシーケンスとエスケープシーケンスを記述した
クイックリファレンスガイドとなることです。

=head2 The backslash

(逆スラッシュ)

=begin original

In a regular expression, the backslash can perform one of two tasks:
it either takes away the special meaning of the character following it
(for instance, C<\|> matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.

=end original

正規表現において、逆スラッシュは二つのタスクのどちらかを行います:
引き続く文字の特殊な意味を取り除く(例えば、(C<\|> は代替ではなく、垂直バーに
マッチングします)か、逆スラッシュシーケンスまたはエスケープシーケンスの
開始となります。

=begin original

The rules determining what it is are quite simple: if the character
following the backslash is an ASCII punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.

=end original

これが何かを決定する規則はかなり単純です: 逆スラッシュに引き続く文字が
ASCII 句読点(非単語)文字(これは英字、数字、下線以外の全ての文字)なら、
逆スラッシュは引き続く文字の特別な意味を取り除きます。

=begin original

If the character following the backslash is an ASCII letter or an ASCII digit,
then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].

=end original

逆スラッシュに引き続く文字が ASCII 英字または ASCII 数字なら、この並びは
特別です; その場合、以下に示します。
いくつかの文字はまだ使われておらず、これを逆スラッシュでエスケープするのは
特別なものにはしません。
将来のバージョンの Perl はこれに特別な意味を割り当てるかもしれないので、
しかし、警告が有効なら、そのような並びを使うと Perl は警告を出力します。
[1]。

=begin original

It is however guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.

=end original

しかし、逆スラッシュシーケンスやエスケープシーケンスが逆スラッシュの後に
句読点文字がくることがないことは今だけではなく将来のバージョンの
Perl 5 でも保証されています。
従って、非単語文字の前に逆スラッシュを置くのは安全です。

=begin original

Note that the backslash itself is special; if you want to match a backslash,
you have to escape the backslash with a backslash: C</\\/> matches a single
backslash.

=end original

逆スラッシュ自体が特別であることに注意してください; 逆スラッシュと
マッチングしたいなら、逆スラッシュを逆スラッシュでエスケープする必要が
あります: C</\\/> は単一の逆スラッシュにマッチングします。

=over 4

=item [1]

=begin original

There is one exception. If you use an alphanumeric character as the
delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also L<perlop/Gory details of parsing
quoted constructs>.

=end original

一つの例外があります。
パターンの区切りとして英数字を使っている(おそらくこれは可読性の理由で
するべきではありません)場合、その文字にマッチングしたいなら区切り文字を
エスケープする必要があります。
Perl は警告を出しません。
L<perlop/Gory details of parsing quoted constructs> も参照してください。

=back

=head2 All the sequences and escapes

(全てのシーケンスとエスケープ)

=begin original

Those not usable within a bracketed character class (like C<[\da-z]>) are marked
as C<Not in [].>

=end original

(C<[\da-z]> のような) 大かっこ文字クラスで使えないものは
C<[] 内では使えない。> と記しています。

=begin original

 \000              Octal escape sequence.  See also \o{}.
 \1                Absolute backreference.  Not in [].
 \a                Alarm or bell.
 \A                Beginning of string.  Not in [].
 \b{}, \b          Boundary. (\b is a backspace in []).
 \B{}, \B          Not a boundary.  Not in [].
 \cX               Control-X.
 \d                Match any digit character.
 \D                Match any character that isn't a digit.
 \e                Escape character.
 \E                Turn off \Q, \L and \U processing.  Not in [].
 \f                Form feed.
 \F                Foldcase till \E.  Not in [].
 \g{}, \g1         Named, absolute or relative backreference.
                   Not in [].
 \G                Pos assertion.  Not in [].
 \h                Match any horizontal whitespace character.
 \H                Match any character that isn't horizontal whitespace.
 \k{}, \k<>, \k''  Named backreference.  Not in [].
 \K                Keep the stuff left of \K.  Not in [].
 \l                Lowercase next character.  Not in [].
 \L                Lowercase till \E.  Not in [].
 \n                (Logical) newline character.
 \N                Match any character but newline.  Not in [].
 \N{}              Named or numbered (Unicode) character or sequence.
 \o{}              Octal escape sequence.
 \p{}, \pP         Match any character with the given Unicode property.
 \P{}, \PP         Match any character without the given property.
 \Q                Quote (disable) pattern metacharacters till \E.  Not
                   (Also called "escape".)  Not in [].
 \r                Return character.
 \R                Generic new line.  Not in [].
 \s                Match any whitespace character.
 \S                Match any character that isn't a whitespace.
 \t                Tab character.
 \u                Titlecase next character.  Not in [].
 \U                Uppercase till \E.  Not in [].
 \v                Match any vertical whitespace character.
 \V                Match any character that isn't vertical whitespace
 \w                Match any word character.
 \W                Match any character that isn't a word character.
 \x{}, \x00        Hexadecimal escape sequence.
 \X                Unicode "extended grapheme cluster".  Not in [].
 \z                End of string.  Not in [].
 \Z                End of string.  Not in [].

=end original

 \000              8 進数エスケープシーケンス。\o{} も参照。
 \1                絶対後方参照。[] 内では使えない。
 \a                アラームまたはベル。
 \A                文字列の先頭。[] 内では使えない。
 \b{}, \b          境界。(\b は [] 内では後退)。
 \B{}, \B          境界でない。[] 内では使えない。
 \cX               Control-X。
 \d                数字にマッチング。
 \D                数字以外にマッチング。
 \e                エスケープ文字。
 \E                \Q, \L, \U の処理を終了する。[] 内では使えない。
 \f                書式送り。
 \F                \E まで畳み込み文字。[] 内では使えない。
 \g{}, \g1         名前付きの絶対または相対後方参照。[] 内では使えない。
 \G                位置表明。[] 内では使えない。
 \h                水平空白にマッチング。
 \H                水平空白以外にマッチング。
 \k{}, \k<>, \k''  名前付き後方参照。[] 内では使えない。
 \K                \K の左側を保持する。[] 内では使えない。
 \l                次の文字を小文字に。[] 内では使えない。
 \L                \E まで小文字に。[] 内では使えない。
 \n                (論理) 改行文字。
 \N                改行以外にマッチング。[] 内では使えない。
 \N{}              名前付きまたは番号 (Unicode) 文字または並び。
 \o{}              8 進数エスケープシーケンス。
 \p{}, \pP         指定された Unicode 特性を持つ文字にマッチング。
 \P{}, \PP         指定された Unicode 特性を持たない文字にマッチング。
 \Q                \E までパターンメタ文字をクォート(無効化)。
                   (「エスケープ」とも呼ばれる。) [] 内では使えない。
 \r                復帰文字。
 \R                一般的な改行。[] 内では使えない。
 \s                空白文字にマッチング。
 \S                空白文字以外にマッチング。
 \t                タブ文字。
 \u                辻の文字をタイトル文字に。[] 内では使えない。
 \U                \E まで大文字に。[] 内では使えない。
 \v                垂直空白にマッチング。
 \V                垂直空白以外にマッチング
 \w                単語文字にマッチング。
 \W                単語文字以外にマッチング。
 \x{}, \x00        16 進数エスケープシーケンス。
 \X                「拡張書記素クラスタ」。[] 内では使えない。
 \z                文字列の末尾。[] 内では使えない。
 \Z                文字列の末尾。[] 内では使えない。

=head2 Character Escapes

(文字エスケープ)

=head3  Fixed characters

(固定文字)

=begin original

A handful of characters have a dedicated I<character escape>. The following
table shows them, along with their ASCII code points (in decimal and hex),
their ASCII name, the control escape on ASCII platforms and a short
description.  (For EBCDIC platforms, see L<perlebcdic/OPERATOR DIFFERENCES>.)

=end original

一部の文字列は I<文字エスケープ> として動作します。
これらは、ASCII 符号位置 (10 進と 16 進)、ASCII の名前、ASCII
プラットフォームでの制御エスケープ、短い説明と共に、以下の表に示しています。
(EBCDIC プラットフォームについては、L<perlebcdic/OPERATOR DIFFERENCES> を
参照してください。)

=begin original

 Seq.  Code Point  ASCII   Cntrl   Description.
       Dec    Hex
  \a     7     07    BEL    \cG    alarm or bell
  \b     8     08     BS    \cH    backspace [1]
  \e    27     1B    ESC    \c[    escape character
  \f    12     0C     FF    \cL    form feed
  \n    10     0A     LF    \cJ    line feed [2]
  \r    13     0D     CR    \cM    carriage return
  \t     9     09    TAB    \cI    tab

=end original

 Seq.   符号位置   ASCII   Cntrl   説明。
      10 進  16 進
  \a     7     07    BEL    \cG    アラームまたはベル
  \b     8     08     BS    \cH    後退 [1]
  \e    27     1B    ESC    \c[    エスケープ文字
  \f    12     0C     FF    \cL    書式送り
  \n    10     0A     LF    \cJ    改行 [2]
  \r    13     0D     CR    \cM    復帰
  \t     9     09    TAB    \cI    タブ

=over 4

=item [1]

=begin original

C<\b> is the backspace character only inside a character class. Outside a
character class, C<\b> alone is a word-character/non-word-character
boundary, and C<\b{}> is some other type of boundary.

=end original

C<\b> は文字クラスの中でのみ復帰文字です。
文字クラスの外側では、C<\b> 単独はは単語文字/非単語文字境界で、
C<\b{}> は他の種類の境界です。

=item [2]

=begin original

C<\n> matches a logical newline. Perl converts between C<\n> and your
OS's native newline character when reading from or writing to text files.

=end original

C<\n> は論理改行にマッチングします。
Perl はテキストファイルの読み書きをする時には C<\n> OS ネイティブな
改行文字との間を変換します。

=back

=head4 Example

(例)

 $str =~ /\t/;   # Matches if $str contains a (horizontal) tab.

=head3 Control characters

(制御文字)

=begin original

C<\c> is used to denote a control character; the character following C<\c>
determines the value of the construct.  For example the value of C<\cA> is
C<chr(1)>, and the value of C<\cb> is C<chr(2)>, etc.
The gory details are in L<perlop/"Regexp Quote-Like Operators">.  A complete
list of what C<chr(1)>, etc. means for ASCII and EBCDIC platforms is in
L<perlebcdic/OPERATOR DIFFERENCES>.

=end original

C<\c> は制御文字を示すために使われます; C<\c> に引き続く文字は
構文の値を決定します。
例えば C<\cA> の値は C<chr(1)>、C<\cb> の値は C<chr(2)>、などです。
内部の詳細は L<perlop/"Regexp Quote-Like Operators"> にあります。
ASCII と EBCDIC プラットフォームで C<chr(1)> などが意味するものの完全な
一覧は L<perlebcdic/OPERATOR DIFFERENCES> にあります。

=begin original

Note that C<\c\> alone at the end of a regular expression (or doubled-quoted
string) is not valid.  The backslash must be followed by another character.
That is, C<\c\I<X>> means C<chr(28) . 'I<X>'> for all characters I<X>.

=end original

正規表現 (またはダブルクォートされた文字列) の末尾に単体で C<\c\> を置くのは
不正です。
逆スラッシュには他の文字が引き続かなければなりません。
つまり、全ての文字 I<X> に対して C<\c\I<X>> は C<chr(28) . 'I<X>' を意味する>
ということです。

=begin original

To write platform-independent code, you must use C<\N{I<NAME>}> instead, like
C<\N{ESCAPE}> or C<\N{U+001B}>, see L<charnames>.

=end original

プラットフォーム独立なコードを書くためには、代わりに C<\N{ESCAPE}> や
C<\N{U+001B}> のような C<\N{I<NAME>}> を使わなければなりません;
L<charnames> を参照してください。

=begin original

Mnemonic: I<c>ontrol character.

=end original

記憶法: 制御文字(I<c>ontrol character)。

=head4 Example

(例)

 $str =~ /\cK/;  # Matches if $str contains a vertical tab (control-K).

=head3 Named or numbered characters and character sequences

(名前付きまたは番号による文字および文字並び)

=begin original

Unicode characters have a Unicode name and numeric code point (ordinal)
value.  Use the
C<\N{}> construct to specify a character by either of these values.
Certain sequences of characters also have names.

=end original

Unicode 文字は Unicode 名と数値の符号位置(序数)を持ちます。
文字をそれらの値で指定するには C<\N{}> 構文を使います。
一部の文字並びにも名前があります。

=begin original

To specify by name, the name of the character or character sequence goes
between the curly braces.

=end original

名前を指定するには、文字や文字並びの名前は中かっこの間に書きます。

=begin original

To specify a character by Unicode code point, use the form C<\N{U+I<code
point>}>, where I<code point> is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus C<\N{U+0041}> means C<LATIN CAPITAL LETTER A>, and you will
rarely see it written without the two leading zeros.  C<\N{U+0041}> means
"A" even on EBCDIC machines (where the ordinal value of "A" is not 0x41).

=end original

文字を Unicode 符号位置で指定するには、C<\N{U+I<code point>}> 形式を使います;
ここで I<code point> は Unicode が目的の文字に割り当てている符号位置を
16 進数で指定します。
数値を 4 桁にパッディングするために先頭にゼロを付ける慣習がありますが、
必須ではありません。
従って C<\N{U+0041}> は C<LATIN CAPITAL LETTER A> を意味し、先頭の二つの
ゼロなしで書かれるのを見ることは稀でしょう。
C<\N{U+0041}> は ("A" の序数が 0x41 でない) EBCDIC マシンでも "A" を
意味します。

=begin original

Blanks may freely be inserted adjacent to but within the braces
enclosing the name or code point.  So S<C<\N{ U+0041 }>> is perfectly
legal.

=end original

名前や符号位置を囲む中かっこの内側隣接する部分には空白を自由に
挿入できます。
従って S<C<\N{ U+0041 }>> は完全に正当です。

=begin original

It is even possible to give your own names to characters and character
sequences by using the L<charnames> module.  These custom names are
lexically scoped, and so a given code point may have different names
in different scopes.  The name used is what is in effect at the time the
C<\N{}> is expanded.  For patterns in double-quotish context, that means
at the time the pattern is parsed.  But for patterns that are delimited
by single quotes, the expansion is deferred until pattern compilation
time, which may very well have a different C<charnames> translator in
effect.

=end original

L<charnames> モジュールを使って
文字や文字並びに独自の名前をつけることすら可能です。
これらのカスタム名はレキシカルスコープなので、
指定された符号位置は、異なるスコープでは異なる名前かも知れません。
使われる名前は、C<\N{}> が展開された時点で有効なものです。
ダブルクォート風コンテキストのパターンでは、
これはパターンがパースされた時点を意味します。
しかし、シングルクォートで区切られたパターンの場合、
展開はパターンのコンパイル島で遅延されるので、
異なった C<charnames> 変換器を持っているかもしれません。

=begin original

(There is an expanded internal form that you may see in debug output:
C<\N{U+I<code point>.I<code point>...}>.
The C<...> means any number of these I<code point>s separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)

=end original

(デバッグ出力で見るかも知れない拡張内部形式
C<\N{U+I<code point>.I<code point>...}> があります。
C<...> は任意の数の I<code point> をドットで区切ったものです。
これは文字によって形成される並びを表現します。
これは内部形式専用で、変更されるかも知れず、自分自身で
使おうとするべきではありません。)

=begin original

Mnemonic: I<N>amed character.

=end original

記憶法: 名前付き文字(I<N>amed character)。

=begin original

Note that a character or character sequence expressed as a named
or numbered character is considered a character without special
meaning by the regex engine, and will match "as is".

=end original

名前付きまたは番号による文字または文字並びで表現される文字は
正規表現エンジンにとって特別な意味を持たない文字として扱われ、
「そのまま」でマッチングすることに注意してください。

=head4 Example

(例)

 $str =~ /\N{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character

 use charnames 'Cyrillic';            # Loads Cyrillic names.
 $str =~ /\N{ZHE}\N{KA}/;             # Match "ZHE" followed by "KA".

=head3 Octal escapes

(8 進数エスケープ)

=begin original

There are two forms of octal escapes.  Each is used to specify a character by
its code point specified in base 8.

=end original

8 進数エスケープには二つの形式があります。
それぞれは 8 進数で指定された符号位置で文字を指定するために使われます。

=begin original

One form, available starting in Perl 5.14 looks like C<\o{...}>, where the dots
represent one or more octal digits.  It can be used for any Unicode character.

=end original

Perl 5.14 から利用可能になった一つ目の形式は C<\o{...}> のようなもので、
ドットは一つ以上の 8 進数を表現します。
これはどのような Unicode 文字にも使えます。

=begin original

It was introduced to avoid the potential problems with the other form,
available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
L</Disambiguation rules between old-style octal escapes and backreferences>
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \077 the largest code point specifiable.

=end original

これは全ての Perl で利用可能なもう一つの形式の潜在的な問題を避けるために
導入されました。
この形式は逆スラッシュに引き続いて 3 桁の 8 進数です。
この形式の問題の一つは、古い形式の後方参照とまったく同じように見えることです
(以下の
L</Disambiguation rules between old-style octal escapes and backreferences>
を参照してください。)
3 桁の数字の最初の文字を常にゼロにすることにこれを避けられますが、指定できる
最大の符号位置が \077 になります。

=begin original

In some contexts, a backslash followed by two or even one octal digits may be
interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See L</Absolute referencing> for more
discussion and examples of the snippet problem.

=end original

ある種のコンテキストでは、逆スラッシュに引き続いて二つや一つの 8 進数が
8 進エスケープとして解釈され、時々警告が出て、ある種のバグにより、時々
驚くような結果になります。
また、より小さいスニペットを結合して正規表現を作成して、3 桁より小さいものを
使うと、一つのスニペットの最初がその前のスニペットの終わりに追加された
数値と解釈されることがあります。
スニペット問題に関するさらなる議論と例については L</Absolute referencing> を
参照してください。

=begin original

Note that a character expressed as an octal escape is considered
a character without special meaning by the regex engine, and will match
"as is".

=end original

8 進エスケープで表現される文字は正規表現エンジンにとって特別な意味を持たない
文字として考えられ、「そのまま」でマッチングすることに注意してください。

=begin original

To summarize, the C<\o{}> form is always safe to use, and the other form is
safe to use for code points through \077 when you use exactly three digits to
specify them.

=end original

まとめると、C<\o{}> 形式は常に安全で、もう一つの形式は、指定するときに
正確に 3 桁を使う場合 \077 までの符号位置なら安全です。

=begin original

Mnemonic: I<0>ctal or I<o>ctal.

=end original

記憶法: 8 進数(I<0>ctal または I<o>ctal)。

=head4 Examples (assuming an ASCII platform)

(例(ASCII プラットフォームを仮定))

 $str = "Perl";
 $str =~ /\o{120}/;  # Match, "\120" is "P".
 $str =~ /\120/;     # Same.
 $str =~ /\o{120}+/; # Match, "\120" is "P",
                     # it's repeated at least once.
 $str =~ /\120+/;    # Same.
 $str =~ /P\053/;    # No match, "\053" is "+" and taken literally.
 /\o{23073}/         # Black foreground, white background smiling face.
 /\o{4801234567}/    # Raises a warning, and yields chr(4).
 /\o{ 400}/          # LATIN CAPITAL LETTER A WITH MACRON
 /\o{ 400 }/         # Same. These show blanks are allowed adjacent to
                     # the braces

=head4 Disambiguation rules between old-style octal escapes and backreferences

(古い形式の 8 進エスケープと後方参照との曖昧さをなくす規則)

=begin original

Octal escapes of the C<\000> form outside of bracketed character classes
potentially clash with old-style backreferences (see L</Absolute referencing>
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:

=end original

大かっこ文字クラスの外側での C<\000> 形式での 8 進エスケープは潜在的に
古い形式の後方参照を破壊します (後述の L</Absolute referencing> 参照)。
これらはどちらも逆スラッシュに引き続く数値で構成されます。
それで Perl は後方参照か 8 進エスケープかを決定するのに発見的手法を
使います。
Perl は曖昧さをなくすために以下の規則を使います:

=over 4

=item 1

=begin original

If the backslash is followed by a single digit, it's a backreference.

=end original

逆スラッシュに引き続くのが単一の数字なら、それは後方参照です。

=item 2

=begin original

If the first digit following the backslash is a 0, it's an octal escape.

=end original

逆スラッシュに引き続く文字が 0 なら、それは 8 進エスケープです。

=item 3

=begin original

If the number following the backslash is N (in decimal), and Perl already
has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.

=end original

逆スラッシュに引き続く数値が N (10 進) で、Perl がすでに N 個の
捕捉グループを見ているなら、Perl はこれを後方参照として扱います。
さもなければ、これは 8 進エスケープとして扱います。
N が 3 桁より長いなら、Perl は 8 進エスケープとして最初の 3 桁のみを
使います; 残りはそのままマッチングされます。

 my $pat  = "(" x 999;
    $pat .= "a";
    $pat .= ")" x 999;
 /^($pat)\1000$/;   #  Matches 'aa'; there are 1000 capture groups.
 /^$pat\1000$/;     #  Matches 'a@0'; there are 999 capture groups
                    #  and \1000 is seen as \100 (a '@') and a '0'.

=back

=begin original

You can force a backreference interpretation always by using the C<\g{...}>
form.  You can the force an octal interpretation always by using the C<\o{...}>
form, or for numbers up through \077 (= 63 decimal), by using three digits,
beginning with a "0".

=end original

常に C<\g{...}> 形式を使うことで後方参照に解釈するように強制できます。
常に C<\o{...}> 形式を使うか、\077 (= 10 進で 63) までの数値の場合は、
"0" を先頭に付けて常に 3 桁で使うことで 8 進数に解釈するように強制できます。

=head3 Hexadecimal escapes

(16 進数エスケープ)

=begin original

Like octal escapes, there are two forms of hexadecimal escapes, but both start
with the sequence C<\x>.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.

=end original

8 進エスケープと同様、16 進エスケープにも二つの形式がありますが、どちらも
並び C<\x> で始まります。
これに正確に 2 桁の数値を形成する 16 進数、あるいは中かっこで囲まれた
任意の桁の 16 進数が引き続きます。
16 進数は表現したい文字の符号位置です。

=begin original

Note that a character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and will match
"as is".

=end original

これらのエスケープの一つでで表現される文字は正規表現エンジンにとって特別な
意味を持たない文字として考えられ、「そのまま」でマッチングすることに
注意してください。

=begin original

Mnemonic: heI<x>adecimal.

=end original

記憶法: 16 進数(heI<x>adecimal)。

=head4 Examples (assuming an ASCII platform)

(例(ASCII プラットフォームを仮定))

 $str = "Perl";
 $str =~ /\x50/;    # Match, "\x50" is "P".
 $str =~ /\x50+/;   # Match, "\x50" is "P", it is repeated at least once
 $str =~ /P\x2B/;   # No match, "\x2B" is "+" and taken literally.

 /\x{2603}\x{2602}/ # Snowman with an umbrella.
                    # The Unicode character 2603 is a snowman,
                    # the Unicode character 2602 is an umbrella.
 /\x{263B}/         # Black smiling face.
 /\x{263b}/         # Same, the hex digits A - F are case insensitive.
 /\x{ 263b }/       # Same, showing optional blanks adjacent to the
                    # braces

=head2 Modifiers

(修飾子)

=begin original

A number of backslash sequences have to do with changing the character,
or characters following them. C<\l> will lowercase the character following
it, while C<\u> will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions C<lcfirst> and C<ucfirst>.

=end original

多くの逆スラッシュシーケンスは、引き続く文字を変更します。
C<\l> は引き続く文字を小文字に変えます; 一方C<\u> は引き続く文字を大文字(より
正確にはタイトル文字)にします。
これは関数 C<lcfirst> および C<ucfirst> と似たような機能を提供します。

=begin original

To uppercase or lowercase several characters, one might want to use
C<\L> or C<\U>, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
C<\E>, whichever comes first. They provide functionality similar to what
the functions C<lc> and C<uc> provide.

=end original

複数の文字を大文字または小文字にするのに、C<\L> または C<\U> を
使いたいかもしれません; これは、パターンの末尾または次に
C<\E> が現れるまでの全ての文字を小文字/大文字にします。
これらは関数 C<lc> および C<uc> と同じような機能を提供します。

=begin original

C<\Q> is used to quote or escape (disable) pattern metacharacters, up to
the next C<\E> or the end of the pattern. C<\Q> adds a backslash to any
character that could have special meaning to Perl.  In the ASCII range,
it quotes every character that isn't a letter, digit, or underscore.
See L<perlfunc/quotemeta> for details on what gets quoted for non-ASCII
code points.  Using this ensures that any character between C<\Q> and
C<\E> will be matched literally, not interpreted as a metacharacter by
the regex engine.

=end original

C<\Q> は引き続く文字列を、次の C<\E> またはパターンの最後まで
クォートまたはエスケープ(無効化)します。
C<\Q> は Perl で特殊な意味を持つ全ての文字に逆スラッシュを追加します。
ASCII の範囲では、英字、数字、下線でないものをクォートします。
非 ASCII 符号位置で何がクォートされるかに関する詳細については
L<perlfunc/quotemeta> を参照してください。
これにより C<\Q> と C<\E> の間の全ての文字はリテラルにマッチングし、
正規表現エンジンによってメタ文字として解釈されません。

=begin original

C<\F> can be used to casefold all characters following, up to the next C<\E>
or the end of the pattern. It provides the functionality similar to
the C<fc> function.

=end original

C<\F> は次の C<\E> またはパターンの最後まで畳み込み文字にします。
これは C<fc> 関数と似たような機能を提供します。

=begin original

Mnemonic: I<L>owercase, I<U>ppercase, I<F>old-case, I<Q>uotemeta, I<E>nd.

=end original

記憶法: 小文字(I<L>owercase)、大文字(I<U>ppercase)、畳み込み文字
(I<F>old-case)、クォート(I<Q>uotemeta)、終了(I<E>nd)。

=head4 Examples

(例)

 $sid     = "sid";
 $greg    = "GrEg";
 $miranda = "(Miranda)";
 $str     =~ /\u$sid/;        # Matches 'Sid'
 $str     =~ /\L$greg/;       # Matches 'greg'
 $str     =~ /\Q$miranda\E/;  # Matches '(Miranda)', as if the pattern
                              #   had been written as /\(Miranda\)/

=head2 Character classes

(文字クラス)

=begin original

Perl regular expressions have a large range of character classes. Some of
the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
L<perlrecharclass>.

=end original

Perl の正規表現は広い範囲の文字クラスを持っています。
文字クラスの一部は逆スラッシュシーケンスとして書かれます。
ここではそれらについて簡潔に議論します; 文字クラスに関する完全な詳細は
L<perlrecharclass> にあります。

=begin original

C<\w> is a character class that matches any single I<word> character
(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  C<\d> is a character class that matches any decimal
digit, while the character class C<\s> matches any whitespace character.
New in perl 5.10.0 are the classes C<\h> and C<\v> which match horizontal
and vertical whitespace characters.

=end original

C<\w> は単一の任意の I<単語> 文字 (英字、数字、Unicode マーク、
(下線のような)接続句読点) にマッチングする文字クラスです。
C<\d> は 10 進数字にマッチングする文字クラスです; 一方文字クラス C<\s> は
空白文字にマッチングします。
perl 5.10.0 から導入されたのは、それぞれ水平空白文字と垂直空白文字に
マッチングする C<\h> と C<\v> です。

=begin original

The exact set of characters matched by C<\d>, C<\s>, and C<\w> varies
depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the ASCII range by using the C</a>
regular expression modifier.  See L<perlrecharclass>.

=end original

C<\d>, C<\s>, C<\w> でマッチングする文字の正確な集合は様々なプラグマと
正規表現修飾子に依存して異なります。
C</a> 正規表現修飾子を使うことで ASCII の範囲にマッチングするように
制限できます。
L<perlrecharclass> を参照してください。

=begin original

The uppercase variants (C<\W>, C<\D>, C<\S>, C<\H>, and C<\V>) are
character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.

=end original

大文字の変種 (C<\W>, C<\D>, C<\S>, C<\H>, C<\V>) はそれぞれ単語文字、数字、
空白、水平空白、垂直空白ではない任意の文字にマッチングします。

=begin original

Mnemonics: I<w>ord, I<d>igit, I<s>pace, I<h>orizontal, I<v>ertical.

=end original

記憶法: 単語(I<w>ord)、数字(I<d>igit)、空白(I<s>pace)、水平(I<h>orizontal)、
垂直(I<v>ertical)。

=head3 Unicode classes

(Unicode クラス)

=begin original

C<\pP> (where C<P> is a single letter) and C<\p{Property}> are used to
match a character that matches the given Unicode property; properties
include things like "letter", or "thai character". Capitalizing the
sequence to C<\PP> and C<\P{Property}> make the sequence match a character
that doesn't match the given Unicode property. For more details, see
L<perlrecharclass/Backslash sequences> and
L<perlunicode/Unicode Character Properties>.

=end original

C<\pP> (ここで C<P> は単一の文字) と C<\p{Property}> は与えられた Unicode
特性にマッチングする文字にマッチングしていました; 特性には "letter" や
"thai character" のようなものが含まれます。
並びを C<\PP> と C<\P{Property}> のようにキャピタライズすると、与えられた
Unicode 特性にマッチングしない文字にマッチングするようになります。
さらなる詳細については、L<perlrecharclass/Backslash sequences> と
L<perlunicode/Unicode Character Properties> を参照してください。

=begin original

Mnemonic: I<p>roperty.

=end original

記憶法: 特性(I<p>roperty)。

=head2 Referencing

(参照)

=begin original

If capturing parenthesis are used in a regular expression, we can refer
to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such I<backreference>:
absolutely, relatively, and by name.

=end original

正規表現で捕捉かっこが使われると、マッチングしたソース文字列の一部を
参照したり、全く同じものにマッチングしたりできます。
このような I<後方参照> を参照するには三つの方法があります: 絶対、相対、
名前付きです。

=for later add link to perlrecapture

=head3 Absolute referencing

(絶対参照)

=begin original

Either C<\gI<N>> (starting in Perl 5.10.0), or C<\I<N>> (old-style) where I<N>
is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.

=end original

(Perl 5.10.0 に導入された) C<\gI<N>> または (古い形式の) C<\I<N>> で I<N> が
任意の長さの正の(符号なし)10 進数の場合、捕捉グループへの絶対参照です。

=begin original

I<N> refers to the Nth set of parentheses, so C<\gI<N>> refers to whatever has
been matched by that set of parentheses.  Thus C<\g1> refers to the first
capture group in the regex.

=end original

I<N> はかっこの N 番目の集合を参照するので、C<\gI<N>> はかっこのその集合に
マッチングするものを参照します。
従って、C<\g1> は正規表現中の最初の捕捉グループを参照してます。

=begin original

The C<\gI<N>> form can be equivalently written as C<\g{I<N>}>
which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex C<qr/$x$y/>, and C<$x> contained
C<"\g1">, and C<$y> contained C<"37">, you would get C</\g137/> which is
probably not what you intended.

=end original

C<\gI<N>> 形式は、より短い文字列を結合することにより正規表現を構築するときの
曖昧さを避けるために C<\g{I<N>}> と等価に書けます。
さもなければ、C<qr/$x$y/> という正規表現があって、C<$x> に C<"\g1"> が入り、
C<$y> に C<"37"> が入っていると、C</\g137/> を得ることになり、おそらく
望んでいないものでしょう。

=begin original

In the C<\I<N>> form, I<N> must not begin with a "0", and there must be at
least I<N> capturing groups, or else I<N> is considered an octal escape
(but something like C<\18> is the same as C<\0018>; that is, the octal escape
C<"\001"> followed by a literal digit C<"8">).

=end original

C<\I<N>> 形式で、I<N> は "0" で始まってはならず、少なくとも I<N> 個の
捕捉グループがなければなりません; さもなければ I<N> は 8 進エスケープと
考えられます (しかし C<\18> のようなものは C<\0018> と同じです; つまり、
8 進エスケープ C<"\001"> に引き続いてリテラルの数値 C<"8"> です)。

=begin original

Mnemonic: I<g>roup.

=end original

記憶法: グループ(I<g>roup)。

=head4 Examples

(例)

 /(\w+) \g1/;    # Finds a duplicated word, (e.g. "cat cat").
 /(\w+) \1/;     # Same thing; written old-style.
 /(\w+) \g{1}/;  # Same, using the safer braced notation
 /(\w+) \g{ 1 }/;# Same, showing optional blanks adjacent to the braces
 /(.)(.)\g2\g1/; # Match a four letter palindrome (e.g. "ABBA").

=head3 Relative referencing

(相対参照)

=begin original

C<\g-I<N>> (starting in Perl 5.10.0) is used for relative addressing.  (It can
be written as C<\g{-I<N>}>.)  It refers to the I<N>th group before the
C<\g{-I<N>}>.

=end original

(Perl 5.10.0 に導入された) C<\g-I<N>> は相対参照のために使われます。
(これは C<\g{-I<N>}> と書けます。)
C<\g{-N}> の N 個前のグループを参照します。

=begin original

The big advantage of this form is that it makes it much easier to write
patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.

=end original

この形式の大きな利点は、捕捉グループを含んでいるような大きなパターンに
展開されるような参照のパターンをより簡単に書けることです。

=head4 Examples

(例)

 /(A)        # Group 1
  (          # Group 2
    (B)      # Group 3
    \g{-1}   # Refers to group 3 (B)
    \g{-3}   # Refers to group 1 (A)
    \g{ -3 } # Same, showing optional blanks adjacent to the braces
  )
 /x;         # Matches "ABBA".

 my $qr = qr /(.)(.)\g{-2}\g{-1}/;  # Matches 'abab', 'cdcd', etc.
 /$qr$qr/                           # Matches 'ababcdcd'.

=head3 Named referencing

(名前付き参照)

=begin original

C<\g{I<name>}> (starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to think about capture
buffer positions.

=end original

(Perl 5.10.0 に導入された) C<\g{I<name>}> は名前付き捕捉グループへの
後方参照に使われ、捕捉バッファの位置について考える必要を完全になくします。

=begin original

To be compatible with .Net regular expressions, C<\g{name}> may also be
written as C<\k{name}>, C<< \k<name> >> or C<\k'name'>.

=end original

.Net 正規表現との互換性のために、C<\g{name}> は C<\k{name}>, C<< \k<name> >>,
C<\k'name'> とも書けます。

=begin original

To prevent any ambiguity, I<name> must not start with a digit nor contain a
hyphen.

=end original

曖昧さを避けるために、I<name> は数値で始まったりハイフンを含んだりしては
いけません。

=head4 Examples

(例)

 /(?<word>\w+) \g{word}/   # Finds duplicated word, (e.g. "cat cat")
 /(?<word>\w+) \k{word}/   # Same.
 /(?<word>\w+) \g{ word }/ # Same, showing optional blanks adjacent to
                           # the braces
 /(?<word>\w+) \k{ word }/ # Same.
 /(?<word>\w+) \k<word>/   # Same.  There are no braces, so no blanks
                           # are permitted
 /(?<letter1>.)(?<letter2>.)\g{letter2}\g{letter1}/
                           # Match a four letter palindrome (e.g.
                           # "ABBA")

=head2 Assertions

(表明)

=begin original

Assertions are conditions that have to be true; they don't actually
match parts of the substring. There are six assertions that are written as
backslash sequences.

=end original

表明は真である必要がある条件です; 実際に部分文字列の一部に
マッチングすることはありません。
逆スラッシュシーケンスとして書かれる六つの表明があります。

=over 4

=item \A

=begin original

C<\A> only matches at the beginning of the string. If the C</m> modifier
isn't used, then C</\A/> is equivalent to C</^/>. However, if the C</m>
modifier is used, then C</^/> matches internal newlines, but the meaning
of C</\A/> isn't changed by the C</m> modifier. C<\A> matches at the beginning
of the string regardless whether the C</m> modifier is used.

=end original

C<\A> は文字列の先頭にのみマッチングします。
C</m> 修飾子が使われていなければ、C</\A/> は C</^/> と等価です。
しかし、C</m> 修飾子が使われると、C</^/> は内部改行にマッチングしますが、
C</\A/> の意味は C</m> 修飾子によって変わりません。
C<\A> は、C</m> 修飾子が使われるかどうかに関わらず文字列の先頭に
マッチングします。

=item \z, \Z

=begin original

C<\z> and C<\Z> match at the end of the string. If the C</m> modifier isn't
used, then C</\Z/> is equivalent to C</$/>; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
C</m> modifier is used, then C</$/> matches at internal newlines, but the
meaning of C</\Z/> isn't changed by the C</m> modifier. C<\Z> matches at
the end of the string (or just before a trailing newline) regardless whether
the C</m> modifier is used.

=end original

C<\z> と C<\Z> は文字列の末尾にマッチングします。
C</m> 修飾子が使われていなければ、C</\Z/> は C</$/> と等価です; 文字列の
末尾か、文字列の末尾の改行の手前にマッチングします。
C</m> 修飾子が使われると、C</$/> は内部改行にマッチングしますが、
C</\Z/> の意味は C</m> 修飾子によって変わりません。
C<\Z> は、C</m> 修飾子が使われるかどうかに関わらず文字列の末尾(あるいは
末尾の改行の直前)にマッチングします。

=begin original

C<\z> is just like C<\Z>, except that it does not match before a trailing
newline. C<\z> matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.

=end original

C<\z> は C<\Z> と同様ですが、末尾の改行の手前ではマッチングしません。
C<\z> は文字列の末尾にのみマッチングします - 修飾子が使われるかや改行の
前かに関わりません。
これはアンカーがあらゆる条件の基で文字列の真の末尾にマッチングする方法です。

=item \G

=begin original

C<\G> is usually used only in combination with the C</g> modifier. If the
C</g> modifier is used and the match is done in scalar context, Perl
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.

=end original

C<\G> は普通は C</g> 修飾子との組み合わせでのみ使われます。
C</g> 修飾子が使われ、マッチングがスカラコンテキストで行われると、
Perl は最後のマッチングが終了したソース文字列の位置を覚えていて、次回の
マッチングでは、前回終わった位置からマッチングを開始します。

=begin original

C<\G> matches the point where the previous match on that string ended,
or the beginning of that string if there was no previous match.

=end original

C<\G> はその文字列で前回のマッチングが終了した位置、あるいは前回に
マッチングがなければ文字列の先頭にマッチングします。

=for later add link to perlremodifiers

=begin original

Mnemonic: I<G>lobal.

=end original

記憶法: グローバル(I<G>lobal)。

=item \b{}, \b, \B{}, \B

=begin original

C<\b{...}>, available starting in v5.22, matches a boundary (between two
characters, or before the first character of the string, or after the
final character of the string) based on the Unicode rules for the
boundary type specified inside the braces.  The boundary
types are given a few paragraphs below.  C<\B{...}> matches at any place
between characters where C<\b{...}> of the same type doesn't match.

=end original

v5.22 から利用可能である C<\b{...}> は、
中かっこの中で指定された境界タイプに関する Unicode の規則を基にして、
境界 (二つの文字の間、
文字列の最初の文字の前、文字列の最後の文字の後のいずれか) にマッチングします。
境界タイプは数段落後に述べます。
C<\B{...}> は、同じ種類の C<\b{...}> がマッチングしない全ての文字間に
マッチングします。

=begin original

C<\b> when not immediately followed by a C<"{"> is available in all
Perls.  It matches at any place
between a word (something matched by C<\w>) and a non-word character
(C<\W>); C<\B> when not immediately followed by a C<"{"> matches at any
place between characters where C<\b> doesn't match.  To get better
word matching of natural language text, see L</\b{wb}> below.

=end original

C<\b> の直後に C<"{"> が引き続かない場合は、全ての Perl で利用可能です。
これは単語文字 (C<\w> でマッチングするもの) と非単語文字 (C<\W>) の境界に
マッチングします;
C<\B> の直後に C<"{"> が引き続かない場合は、C<\b> が
マッチングしない任意の文字間にマッチングします。
よりよい自然言語テキストの単語マッチングのためには、
後述の L</\b{wb}> を参照してください。

=begin original

C<\b>
and C<\B> assume there's a non-word character before the beginning and after
the end of the source string; so C<\b> will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, C<\B> will match.

=end original

C<\b> と C<\B> は、ソース文字列の先頭の前と末尾の後ろに非単語文字があると
仮定します; 従って C<\b> は、ソース文字列が単語文字で始まっている(または
終わっている)場合はソース文字列の先頭(または末尾)にマッチングします。
さもなければ、C<\B> がマッチングします。

=begin original

Do not use something like C<\b=head\d\b> and expect it to match the
beginning of a line.  It can't, because for there to be a boundary before
the non-word "=", there must be a word character immediately previous.
All plain C<\b> and C<\B> boundary determinations look for word
characters alone, not for
non-word characters nor for string ends.  It may help to understand how
C<\b> and C<\B> work by equating them as follows:

=end original

C<\b=head\d\b> のようなものを使って行頭にマッチングすると
仮定しないでください。
これはできません; なぜなら非単語 "=" の前に境界があり、直前に単語文字が
なければならないからです。
全ての単なる C<\b> および C<\B> の境界決定は単語文字のみを探し、非単語文字や
文字列の末尾は探しません。
C<\b> と C<\B> がどのように動作するかは以下のように同等化することで
理解の助けになるでしょう:

    \b	really means	(?:(?<=\w)(?!\w)|(?<!\w)(?=\w))
    \B	really means	(?:(?<=\w)(?=\w)|(?<!\w)(?!\w))

=begin original

In contrast, C<\b{...}> and C<\B{...}> may or may not match at the
beginning and end of the line, depending on the boundary type.  These
implement the Unicode default boundaries, specified in
L<https://www.unicode.org/reports/tr14/> and
L<https://www.unicode.org/reports/tr29/>.
The boundary types are:

=end original

一方、C<\b{...}> と C<\B{...}> は、境界の種類に依存して、
行の先頭と末尾にマッチングしたりしなかったりします。
これらは L<https://www.unicode.org/reports/tr14/> と
L<https://www.unicode.org/reports/tr29/> で定義されている
Unicode のデフォルト境界を実装しています。
境界タイプは:

=over

=item C<\b{gcb}> or C<\b{g}>

=begin original

This matches a Unicode "Grapheme Cluster Boundary".  (Actually Perl
always uses the improved "extended" grapheme cluster").  These are
explained below under C<L</\X>>.  In fact, C<\X> is another way to get
the same functionality.  It is equivalent to C</.+?\b{gcb}/>.  Use
whichever is most convenient for your situation.

=end original

これは Unicode の「書記素境界」("Grapheme Cluster Boundary") に
マッチングします。
(実際には Perl は改良された「拡張書記素」("extended grapheme cluster") を
常に使います。)
これらは C<L</\X>> で後述します。
実際のところ、C<\X> は同じ機能を使うためのもう一つの方法です。
これは C</.+?\b{gcb}/> と等価です。
状況に応じて使いやすい方を使ってください。

=item C<\b{lb}>

=begin original

This matches according to the default Unicode Line Breaking Algorithm
(L<https://www.unicode.org/reports/tr14/>), as customized in that
document
(L<Example 7 of revision 35|https://www.unicode.org/reports/tr14/tr14-35.html#Example7>)
for better handling of numeric expressions.

=end original

これはデフォルトの Unicode Line Breaking Algorithm
(L<https://www.unicode.org/reports/tr14/>) に従ってマッチングしますが、
数値表現をより良く扱うために、
(L<Example 7 of revision 35|https://www.unicode.org/reports/tr14/tr14-35.html#Example7>)
文書でカスタマイズされています。

=begin original

This is suitable for many purposes, but the L<Unicode::LineBreak> module
is available on CPAN that provides many more features, including
customization.

=end original

これは多くの用途に使えますが、CPAN で利用可能な
L<Unicode::LineBreak> モジュールは、
カスタマイズを含むより多くの機能が利用可能です。

=item C<\b{sb}>

=begin original

This matches a Unicode "Sentence Boundary".  This is an aid to parsing
natural language sentences.  It gives good, but imperfect results.  For
example, it thinks that "Mr. Smith" is two sentences.  More details are
at L<https://www.unicode.org/reports/tr29/>.  Note also that it thinks
that anything matching L</\R> (except form feed and vertical tab) is a
sentence boundary.  C<\b{sb}> works with text designed for
word-processors which wrap lines
automatically for display, but hard-coded line boundaries are considered
to be essentially the ends of text blocks (paragraphs really), and hence
the ends of sentences.  C<\b{sb}> doesn't do well with text containing
embedded newlines, like the source text of the document you are reading.
Such text needs to be preprocessed to get rid of the line separators
before looking for sentence boundaries.  Some people view this as a bug
in the Unicode standard, and this behavior is quite subject to change in
future Perl versions.

=end original

これは Unicode の「文境界」("Sentence Boundary") にマッチングします。
これは自然言語文をパースする助けとなります。
この結果はよいけれども完璧ではないものです。
例えば、これは "Mr. Smith" を二つの文と考えます。
さらなる詳細は L<https://www.unicode.org/reports/tr29/> にあります。
また、(フォームフィードと垂直タブを除く) L</\R> にマッチングするものも
行境界と考えることに注意してください。
C<\b{sb}> は、表示用に自動的に行をラッピングするワードプロセッサ用に
デザインされたテキストに対して動作しますが、
ハードコーディングされた行境界は基本的にテキストブロック(実際には段落)の
終わりであり、従って分の終わりと考えられます。
C<\b{sb}> は、あなたが今読んでいる文書のソーステキストのような、
組み込みの改行を含むテキストに対しては上手く動作しません。
このようなテキストについては、文境界を探す前に行セパレータを取り除く
前処理が必要です。
これは Unicode 標準のバグであると考える人々もいて、
この振る舞いは将来の Perl バージョンで変更されるかもしれません。

=item C<\b{wb}>

=begin original

This matches a Unicode "Word Boundary", but tailored to Perl
expectations.  This gives better (though not
perfect) results for natural language processing than plain C<\b>
(without braces) does.  For example, it understands that apostrophes can
be in the middle of words and that parentheses aren't (see the examples
below).  More details are at L<https://www.unicode.org/reports/tr29/>.

=end original

これは Unicode の「単語境界」("Word Boundary") にマッチングしますが、
Perl に合わせて修正しています。
これは自然言語処理において単なる C<\b> (中かっこなし) よりも良い
(しかし完璧ではない)結果を返します。
例えば、アポストロフィは単語の途中にあってもよいけれども
かっこはあってはならないということを理解します
(後述する例を参照してください)。
さらなる詳細は L<https://www.unicode.org/reports/tr29/> にあります。

=begin original

The current Unicode definition of a Word Boundary matches between every
white space character.  Perl tailors this, starting in version 5.24, to
generally not break up spans of white space, just as plain C<\b> has
always functioned.  This allows C<\b{wb}> to be a drop-in replacement for
C<\b>, but with generally better results for natural language
processing.  (The exception to this tailoring is when a span of white
space is immediately followed by something like U+0303, COMBINING TILDE.
If the final space character in the span is a horizontal white space, it
is broken out so that it attaches instead to the combining character.
To be precise, if a span of white space that ends in a horizontal space
has the character immediately following it have any of the Word
Boundary property values "Extend", "Format" or "ZWJ", the boundary between the
final horizontal space character and the rest of the span matches
C<\b{wb}>.  In all other cases the boundary between two white space
characters matches C<\B{wb}>.)

=end original

単語境界について、現在の Unicode の定義としては全ての空白文字の間に
マッチングします。
Perl は 5.24 からこれを調整し、単なる C<\b> が常に機能するように、
一般的に空白の範囲を分割しないようにします。
これにより C<\b{wb}> を C<\b> の置き換えとして使えるだけでなく、
自然言語処理では一般的により良い結果になります。
(この調整の例外は、
ある範囲の空白の直後に U+0303, COMBINING TILDE のようなものが
引き続いている場合です。
その範囲の最後の空白文字が垂直空白文字の場合、結合文字に付くように
分割されます。
正確に言うと、垂直スペースで終わる空白の範囲の直後に
Word Boundary 特性の値が "Extend", "Format", "ZWJ" の文字が引き続く場合、
最後の垂直スペース文字とその範囲の残りの間の境界は C<\b{wb}> に
マッチングします。
それ以外の場合は、二つの空白文字の間の境界はC<\B{wb}> にマッチングします。)

=back

=begin original

It is important to realize when you use these Unicode boundaries,
that you are taking a risk that a future version of Perl which contains
a later version of the Unicode Standard will not work precisely the same
way as it did when your code was written.  These rules are not
considered stable and have been somewhat more subject to change than the
rest of the Standard.  Unicode reserves the right to change them at
will, and Perl reserves the right to update its implementation to
Unicode's new rules.  In the past, some changes have been because new
characters have been added to the Standard which have different
characteristics than all previous characters, so new rules are
formulated for handling them.  These should not cause any backward
compatibility issues.  But some changes have changed the treatment of
existing characters because the Unicode Technical Committee has decided
that the change is warranted for whatever reason.  This could be to fix
a bug, or because they think better results are obtained with the new
rule.

=end original

これらの Unicode 境界を使う場合、
後のバージョンの Unicode 標準を含む将来のバージョンの Perl では、
コードを書いた時点と正確に同じように動作しないかもしれないという
リスクを取ることになるということを認識することは重要です。
これらの規則は安定しているとは考えられておらず、標準の他の部分よりも
変更される可能性がより高いです。
Unicode は自分の意思でこれらを変更する権利を保持していて、
Perl はその実装を Unicode の新しい規則に更新する権利を保持しています。
過去には、以前の全ての文字と異なる性格を持つ新しい文字を標準に追加するために、
変更が行われたことがあります;
それらを扱うために新しい規則が策定されました。
これらは後方互換性問題は発生させないはずです。
しかし、Unicode Technical Committee が何らかの理由で変更が正当化されると
考えたことによって、既存の文字の扱いが変更されたことがあります。
これはバグを修正するためかもしれませんし、彼らが新しい規則によって
より良い結果を得られると考えるからかもしれません。

=begin original

It is also important to realize that these are default boundary
definitions, and that implementations may wish to tailor the results for
particular purposes and locales.  For example, some languages, such as
Japanese and Thai, require dictionary lookup to accurately determine
word boundaries.

=end original

また、これらはデフォルトの境界定義であり、実装は特定の目的やロケールのために
結果を調整する必要があることがあるということを認識することが重要です。
例えば、日本語やタイ語のような一部の言語では、単語境界の正確な決定には
辞書検索が必要です。

=begin original

Mnemonic: I<b>oundary.

=end original

記憶法: 境界(I<b>oundary)。

=back

=head4 Examples

(例)

  "cat"   =~ /\Acat/;     # Match.
  "cat"   =~ /cat\Z/;     # Match.
  "cat\n" =~ /cat\Z/;     # Match.
  "cat\n" =~ /cat\z/;     # No match.

  "cat"   =~ /\bcat\b/;   # Matches.
  "cats"  =~ /\bcat\b/;   # No match.
  "cat"   =~ /\bcat\B/;   # No match.
  "cats"  =~ /\bcat\B/;   # Match.

  while ("cat dog" =~ /(\w+)/g) {
      print $1;           # Prints 'catdog'
  }
  while ("cat dog" =~ /\G(\w+)/g) {
      print $1;           # Prints 'cat'
  }

  my $s = "He said, \"Is pi 3.14? (I'm not sure).\"";
  print join("|", $s =~ m/ ( .+? \b     ) /xg), "\n";
  print join("|", $s =~ m/ ( .+? \b{wb} ) /xg), "\n";
 prints
  He| |said|, "|Is| |pi| |3|.|14|? (|I|'|m| |not| |sure
  He| |said|,| |"|Is| |pi| |3.14|?| |(|I'm| |not| |sure|)|.|"

=head2 Misc

(その他)

=begin original

Here we document the backslash sequences that don't fall in one of the
categories above. These are:

=end original

ここでは上述のカテゴリの一つに当てはまらない逆スラッシュシーケンスについて
記述します。
それは:

=over 4

=item \K

=begin original

This appeared in perl 5.10.0. Anything matched left of C<\K> is
not included in C<$&>, and will not be replaced if the pattern is
used in a substitution. This lets you write C<s/PAT1 \K PAT2/REPL/x>
instead of C<s/(PAT1) PAT2/${1}REPL/x> or C<s/(?<=PAT1) PAT2/REPL/x>.

=end original

これは perl 5.10.0 から現れました。
C<\K> の左側でマッチングしたものは C<$&> に含まれまず、
パターンが置換で使われた場合は置き換えられません。
これにより、C<s/(PAT1) PAT2/${1}REPL/x> or C<s/(?<=PAT1) PAT2/REPL/x> の
代わりに C<s/PAT1 \K PAT2/REPL/x> と書けます。

=begin original

Mnemonic: I<K>eep.

=end original

Mnemonic: 保持(I<K>eep)。

=item \N

=begin original

This feature, available starting in v5.12,  matches any character
that is B<not> a newline.  It is a short-hand for writing C<[^\n]>, and is
identical to the C<.> metasymbol, except under the C</s> flag, which changes
the meaning of C<.>, but not C<\N>.

=end original

v5.12 から利用可能になったこの機能は、改行 B<でない> 任意の文字に
マッチングします。
これは C<[^\n]> の省略形で、C<.> メタ文字と同じですが、C<.> の意味を変える
C</s> フラグが付いていても C<\N> の意味は変わりません。

=begin original

Note that C<\N{...}> can mean a
L<named or numbered character
|/Named or numbered characters and character sequences>.

=end original

C<\N{...}> は L<名前または番号の文字
|/Named or numbered characters and character sequences> を
意味するかも知れないことに注意してください。

=begin original

Mnemonic: Complement of I<\n>.

=end original

記憶法: I<\n> の補数。

=item \R
X<\R>

=begin original

C<\R> matches a I<generic newline>; that is, anything considered a
linebreak sequence by Unicode. This includes all characters matched by
C<\v> (vertical whitespace), and the multi character sequence C<"\x0D\x0A">
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). C<\R> is equivalent to C<< (?>\x0D\x0A|\v) >>.  (The
reason it doesn't backtrack is that the sequence is considered
inseparable.  That means that

=end original

C<\R> は I<一般的な改行> にマッチングします; これは Unicode で改行並びとして
扱われるものです。
これには C<\v> (垂直空白) でマッチングする全ての文字、複数文字並び
C<"\x0D\x0A"> (復帰に引き続いて改行、時々ネットワーク改行と呼ばれるもの;
これは Microsoft テキストファイルをバイナリモードで開いた時に使われる
行末並びです) を含みます。
C<\R> は C<< (?>\x0D\x0A)|\v) >> と等価です。
(バックトラックしない理由は、並びは分割できないと考えられるからです。
つまり、

 "\x0D\x0A" =~ /^\R\x0A$/   # No match

=begin original

fails, because the C<\R> matches the entire string, and won't backtrack
to match just the C<"\x0D">.)  Since
C<\R> can match a sequence of more than one character, it cannot be put
inside a bracketed character class; C</[\R]/> is an error; use C<\v>
instead.  C<\R> was introduced in perl 5.10.0.

=end original

は失敗します; C<\R> は文字列全体にマッチングし、C<"\x0D"> だけを
マッチングするようにバックトラックしないからです。)
C<\R> は複数の文字の並びにマッチングするので、大かっこ文字クラスの内側には
使えません; C</[\R]/> はエラーです; 代わりに C<\v> を使ってください。
C<\R> は perl 5.10.0 で導入されました。

=begin original

Note that this does not respect any locale that might be in effect; it
matches according to the platform's native character set.

=end original

これは有効かもしれないロケールを認識しないことに注意してください; これは
プラットフォームのネイティブな文字集合に従ってマッチングします。

=begin original

Mnemonic: none really. C<\R> was picked because PCRE already uses C<\R>,
and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests C<\R> as its notation.

=end original

記憶法: 実際のところありません。
C<\R> が選ばれたのは、PCRE が既に C<\R> を使っていて、さらに重要なのは
Unicode がこのような正規表現メタ文字を勧めていて、記法として C<\R> を
提案しているからです。

=item \X
X<\X>

=begin original

This matches a Unicode I<extended grapheme cluster>.

=end original

これは Unicode の I<拡張書記素クラスタ> (extended grapheme cluster) に
マッチングします。

=begin original

C<\X> matches quite well what normal (non-Unicode-programmer) usage
would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode "COMBINING
UPWARDS ARROW BELOW", and would be displayed by Unicode-aware software as if it
were a single character.

=end original

C<\X> は普通の (非 Unicode プログラマの) 使い方で単一の文字と考えられるものに
かなりうまくマッチングします。
例えば、矢印のような、何らかのダイアクリティカルマーク付きの G を考えます。
Unicode にはそのような単一の文字はありませんが、G に引き続いて Unicode の
"COMBINING UPWARDS ARROW BELOW" を使うことで合成でき、Unicode を認識する
ソフトウェアに依って単一の文字であるかのように表示されます。

=begin original

The match is greedy and non-backtracking, so that the cluster is never
broken up into smaller components.

=end original

マッチングは貪欲でバックトラッキングしないので、クラスタは決してより
小さい要素に分解されません。

=begin original

See also L<C<\b{gcb}>|/\b{}, \b, \B{}, \B>.

=end original

L<C<\b{gcb}>|/\b{}, \b, \B{}, \B> も参照してください。

=begin original

Mnemonic: eI<X>tended Unicode character.

=end original

記憶法: 拡張 Unicode 文字(eI<X>tended Unicode character)。

=back

=head4 Examples

(例)

 $str =~ s/foo\Kbar/baz/g; # Change any 'bar' following a 'foo' to 'baz'
 $str =~ s/(.)\K\g1//g;    # Delete duplicated characters.

 "\n"   =~ /^\R$/;         # Match, \n   is a generic newline.
 "\r"   =~ /^\R$/;         # Match, \r   is a generic newline.
 "\r\n" =~ /^\R$/;         # Match, \r\n is a generic newline.

 "P\x{307}" =~ /^\X$/     # \X matches a P with a dot above.

=cut

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org> (5.10.1-)
Status: completed

=end meta

