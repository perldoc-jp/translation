
=encoding utf8

=head1 NAME

=begin original

perldeprecation - list Perl deprecations

=end original

perldeprecation - Perl の廃止予定の一覧

=head1 DESCRIPTION

=begin original

The purpose of this document is to document what has been deprecated
in Perl, and by which version the deprecated feature will disappear,
or, for already removed features, when it was removed.

=end original

この文書の目的は、Perl で何が廃止予定になったか、どのバージョンで
廃止予定の機能が消滅したか、あるいは既に削除された機能については、
いつ削除されたかを文書化することです。

=begin original

This document will try to discuss what alternatives for the deprecated
features are available.

=end original

この文書は、廃止予定の機能についてどんな代替案が利用可能かについて
議論しようとしています。

=begin original

The deprecated features will be grouped by the version of Perl in
which they will be removed.

=end original

廃止予定の機能は、削除される予定の Perl のバージョン毎に
グループ分けされています。

=head2 Unscheduled Deprecations

(予定の決まっていない廃止予定)

=head3 Unicode Delimiter Will be Paired

(Unicode 区切り文字は組になります)

=begin original

Some Unicode delimiters used to be allowed as single characters, but
in the future will be part of a balanced pair. This deprecation category
is used to mark the ones that will change from being unpaired to paired.

=end original

いくつかの Unicode 区切り文字は、単一の文字として認められていましたが、
将来バランスした組の一部になります。
この廃止予定カテゴリは、組ではないものから組になるものに変更されるものを
マークするために使われます。

=begin original

Category: "deprecated::delimiter_will_be_paired"

=end original

カテゴリ: "deprecated::delimiter_will_be_paired"

=head3 Dot In Inc

(INC の中のドット)

=begin original

The current working directory C<.> used to be automatically included in
C<@INC>, but in Perl 5.26 this was removed for security reasons. Ever
since then we have produced a warning when a user uses C<do EXPR> and
C<EXPR> does not include a path, and the file was not found in any
directory in C<@INC> but I<was> located in C<.>. The file will not be loaded
but a deprecated warning will be generated.

=end original

現在の作業ディレクトリ C<.> は自動的に C<@INC> に含まれていましたが、
これはセキュリティ上の理由により Perl 5.26 で削除されました。
それ以降、パスが含まれていない C<do EXPR> and C<EXPR> を使っていて、
ファイルが C<@INC> のディレクトリになく、C<.> にある場合に、 
警告が出力されています。
ファイルは読み込まれませんが廃止予定警告が生成されます。

=begin original

Category: "deprecated::dot_in_inc"

=end original

カテゴリ: "deprecated::dot_in_inc"

=head3 Unicode Property Name

(Unicode 特性名)

=begin original

Various types of Unicode property name will generate deprecated warnings
when used in a regex pattern. For instance surrogate characters will result
in deprecation warnings.

=end original

様々な種類の Unicode 特性名は、正規表現パターン内で使われると
廃止予定警告が生成されます。
例えば、代用文字は廃止予定警告が出ます。

=begin original

Category: "deprecated::unicode_property_name"

=end original

カテゴリ: "deprecated::unicode_property_name"

=head2 Perl 5.44

=head3 Calling a missing C<import()> or C<unimport()> method with an argument

(引数付きでの存在しない C<import()> や C<unimport()> メソッドの呼び出し)

=begin original

Historically calling C<import()> or C<unimport()> on any class which did
not define such a method would be silently ignored. Effectively Perl
behaved as though there was an empty method defined in the C<UNIVERSAL>
package (even when there was no such method actually defined). As of
Perl version 5.39.2 calling such a method I<with> an argument will
trigger a warning, and in Perl version 5.44 this warning will be
upgraded to an error. (Calling such a method with no arguments at all
will always be safe.)

=end original

歴史的には、そのようなメソッドを定義していないクラスで C<import()> または
C<unimport()> を呼び出すと、黙って無視されていました。
事実上、Perl は C<UNIVERSAL> パッケージに空のメソッドが
定義されているかのように動作しました
(そのようなメソッドが実際に定義されていない場合でも)。
Perl バージョン 5.39.2 では、I<引数付きで> そのようなメソッドを呼び出すと、
警告が発生します;
Perl バージョン 5.44 では、この警告はエラーに昇格します。
(そのようなメソッドを引数なしで呼び出すことは常に安全です。)

Category: "deprecated::missing_import_called_with_args"

=head3 Changing C<use VERSION> while another C<use VERSION> is in scope

(スコープ内に別の C<use VERSION> がすでに存在している状態での C<use VERSION> の変更)

=begin original

A C<use VERSION> declaration has many implicit effects on the surrounding
scope, such as L<strict> and L<feature> flags, or importing L<builtin>
functions. Once you have a C<use VERSION> statement in scope, another
C<use VERSION> statement with a different version is now deprecated since
Perl 5.39.8, due to the increasing complexity of swapping from one
prevailing version to another.

=end original

C<use VERSION> 宣言は、L<strict> フラグや L<feature> フラグ、L<builtin> 関数の
インポートなど、周囲のスコープに対して多くの暗黙的な影響を与えます。
Perl 5.39.8 以降、一旦スコープ内に C<use VERSION> 文があると、別のバージョンを
持つもう一つの C<use VERSION> 文は廃止予定になりました;
これは、ある一般的なバージョンから別のバージョンへの交換が
複雑になったためです。

Category: "deprecated::subsequent_use_version"

=head2 Perl 5.42

=head3 Goto Block Construct

(goto ブロック構文)

=begin original

C<goto LABEL;> will produce a deprecated warning when jumping into the body
of a loop or other block construct from outside. For instance

=end original

C<goto LABEL;> は、ループの本体や他のブロックの外側から内側に
ジャンプしようとすると、廃止予定警告が出力されます。
例えば:

    while (should_loop($x)) {
        LABEL:
            do_stuff();
    }
    goto LABEL;

=begin original

will produce a warning that this behavior is deprecated. In general you should
just avoid doing this; the people that maintain your code will be grateful for
your restraint.

=end original

この振る舞いは廃止予定なので警告が出力されます。
一般的に、こうすることは単に避けるべきです;
あなたのコードを保守する人々は、あなたの節制に感謝するでしょう。

=begin original

Category: "deprecated::goto_construct"

=end original

カテゴリ: "deprecated::goto_construct"

=head2 Perl 5.40

=head3 Downgrading a C<use VERSION> to below v5.11

(C<use VERSION> の v5.11 より以前への降格)

=begin original

Once Perl has seen a C<use VERSION> declaration that requests a version
C<v5.11> or above, a subsequent second declaration that requests an earlier
version will print a deprecation warning. For example,

=end original

一度 Perl が C<v5.11> 以降を要求する C<use VERSION> 宣言を見ると、
引き続いてより前のバージョンを要求する 2 番目の宣言があったときに、
廃止予定警告を表示します。
例えば:

    use v5.14;
    say "We can use v5.14's features here";

    use v5.10;        # This prints a warning

=begin original

This was deprecated in Perl 5.36 and is now fatal.

=end original

これは Perl 5.36 で廃止予定になり、今回致命的エラーになりました。

=begin original

This is because of an intended related change to the interaction between
C<use VERSION> and C<use strict>. If you specify a version >= 5.11, strict is
enabled implicitly. If you request a version < 5.11, strict will become
disabled I<even if you had previously written> C<use strict>. This was not
the previous behaviour of C<use VERSION>, which at present will track
explicitly-enabled strictness flags independently.

=end original

これは、C<use VERSION> と C<use strict> の相互作用に関する意図した
変更のためです。
バージョンに >= 5.11 を指定すると、strict が暗黙に有効になります。
バージョンに < 5.11 を要求すると、
C<use strict> I<がたとえその前に書かれていても> 無効になります。
これは C<use VERSION> の以前の振る舞いと異なります; 現在の所
明示的に有効にされた strict フラグは独立に追跡しています。

=begin original

Category: "deprecated::version_downgrade"

=end original

カテゴリ: "deprecated::version_downgrade"

=head2 Perl 5.38

=head3 Pod::Html utility functions

(Pod::Html ユーティリティ関数)

=begin original

The definition and documentation of three utility functions previously
importable from L<Pod::Html> were moved to new package L<Pod::Html::Util> in
Perl 5.36.  While they remained importable from L<Pod::Html> in Perl 5.36, as
of Perl 5.38 they are only importable, on request, from L<Pod::Html::Util>.

=end original

以前は L<Pod::Html> からインポート可能だった三つのユーティリティ関数の
定義と文書は、Perl 5.36 から新しいパッケージ L<Pod::Html::Util> に
移動しました。
Perl 5.36 ではまだ L<Pod::Html> からインポート可能ですが、
Perl 5.38 から、L<Pod::Html::Util> からのみ要求に応じてインポート可能です。

=head2 Perl 5.34

=begin original

There were no deprecations or fatalizations in Perl 5.34.

=end original

Perl 5.34 での廃止予定や致命的エラー化はありませんでした。

=head2 Perl 5.32

=head3 Constants from lexical variables potentially modified elsewhere

(レキシカル変数からの定数が潜在的にどこからでも変更可能)

=begin original

You wrote something like

=end original

次のように書きました:

    my $var;
    $sub = sub () { $var };

=begin original

but C<$var> is referenced elsewhere and could be modified after the C<sub>
expression is evaluated.  Either it is explicitly modified elsewhere
(C<$var = 3>) or it is passed to a subroutine or to an operator like
C<printf> or C<map>, which may or may not modify the variable.

=end original

しかし C<$var> はどこかで参照されていて、
C<sub> 式が評価された後に変更されるかもしれません。
これは、明示的に他の場所から変更されたり (C<$var = 3>)、
変数を変更するかもしれないしされないかもしれない
C<printf> や C<map> のような演算子やサブルーチンに
渡されることによります。

=begin original

Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.

=end original

伝統的に、Perl はこの時点で変数の値を捕捉して、
サブルーチンをインライン化可能な定数に変えます。
変数が他の場所で変更できる場合、これはクロージャの振る舞いを壊します;
サブルーチンはその値ではなく変数そのものを捕捉するからです;
従って、将来の変数への変更はサブルーチンの返り値に反映されます。

=begin original

If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:

=end original

サブルーチンをインライン化可能にすることを意図している場合は、
おそらくコピーすることによって、変数がどこからも
参照されていないようにしてください:

    my $var2 = $var;
    $sub = sub () { $var2 };

=begin original

If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit C<return>:

=end original

このサブルーチンを、閉じた変数の将来の変更を反映するクロージャにしたい場合は、
明示的な C<return> を追加してください:

    my $var;
    $sub = sub () { return $var };

=begin original

This usage was deprecated and as of Perl 5.32 is no longer allowed.

=end original

この使用法は廃止予定で、Perl 5.32 以降ではもはや許されません。

=head3 Use of strings with code points over 0xFF as arguments to C<vec>

(C<vec> の引数として 0xFF を超える符号位置の文字列の使用)

=begin original

C<vec> views its string argument as a sequence of bits.  A string
containing a code point over 0xFF is nonsensical.  This usage is
deprecated in Perl 5.28, and was removed in Perl 5.32.

=end original

C<vec> はその文字列引数をビット列として見ます。
0xFF を超える符号位置を含む文字列は意味がありません。
この使用法は Perl 5.28 で廃止予定になり、
Perl 5.32 で削除されました。

=head3 Use of code points over 0xFF in string bitwise operators

(ビット単位文字列演算子での 0xFF を超える符号位置の使用)

=begin original

The string bitwise operators, C<&>, C<|>, C<^>, and C<~>, treat their
operands as strings of bytes. As such, values above 0xFF are
nonsensical. Some instances of these have been deprecated since Perl
5.24, and were made fatal in 5.28, but it turns out that in cases where
the wide characters did not affect the end result, no deprecation
notice was raised, and so remain legal.  Now, all occurrences either are
fatal or raise a deprecation warning, so that the remaining legal
occurrences became fatal in 5.32.

=end original

ビット単位文字列演算子 C<&>, C<|>, C<^>, C<~> は、そのオペランドを
バイト文字列として扱います。
従って、0xFF を超える値は意味がありません。
これらの恥部は Perl 5.24 から廃止予定で、5.28 で致命的エラーになりましたが、
ワイド文字が最終結果に影響を与えない場合、
廃止予定警告は出力されず、従って正当なまま残っていることが分かりました。
今回、こえらの全ては致命的エラーか廃止予定警告が出るようになり、
残っている正当な場合は 5.32 で致命的エラーになりました。

=begin original

An example of this is

=end original

この例は:

 "" & "\x{100}"

=begin original

The wide character is not used in the C<&> operation because the left
operand is shorter.  This now throws an exception.

=end original

ワイド文字は C<&> 演算では使われません;
左オペランドはより短いからです。
どちらにしろこれは例外を投げるようになりました。

=head3 hostname() doesn't accept any arguments

(hostname() は引数を取りません)

=begin original

The function C<hostname()> in the L<Sys::Hostname> module has always
been documented to be called with no arguments.  Historically it has not
enforced this, and has actually accepted and ignored any arguments.  As a
result, some users have got the mistaken impression that an argument does
something useful.  To avoid these bugs, the function is being made strict.
Passing arguments was deprecated in Perl 5.28 and became fatal in Perl 5.32.

=end original

L<Sys::Hostname> モジュールの C<hostname()> 関数は、
引数なしで呼び出されると常に文書化されていました。
歴史的にはこれは強制されておらず、実際に引数を受け付けて、
全て無視していました。
結果として、引数が何か有用であるという間違った印象を
一部のユーザーに与えていました。
これらのバグを避けるために、この関数はより厳密になりました。
引数を渡すのは Perl 5.28 で廃止予定になり、
Perl 5.32 で致命的エラーになりました。

=head3 Unescaped left braces in regular expressions

(正規表現中のエスケープされない左中かっこ)

=begin original

The simple rule to remember, if you want to match a literal C<{>
character (U+007B C<LEFT CURLY BRACKET>) in a regular expression
pattern, is to escape each literal instance of it in some way.
Generally easiest is to precede it with a backslash, like C<\{>
or enclose it in square brackets (C<[{]>).  If the pattern
delimiters are also braces, any matching right brace (C<}>) should
also be escaped to avoid confusing the parser, for example,

=end original

正規表現パターン中でリテラルな
C<{> 文字 (U+007B C<LEFT CURLY BRACKET>) にマッチングしたい場合、
覚えるべき単純な規則は、何らかの形でそれぞれのリテラルな実体を
エスケープすることです。
一般的に最も簡単な方法は、C<\{> のように逆スラッシュを前置するか、
大かっこで囲む (C<[{]>) ことです。
パターン区切り文字も中かっこなら、例えばパーサの混乱を避けるために、
マッチングする右中かっこ (C<}>) もエスケープするべきです。

 qr{abc\{def\}ghi}

=begin original

Forcing literal C<{> characters to be escaped will enable the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use of C<{> as a literal.  A non-deprecation
warning that the left brace is being taken literally is raised in
contexts where there could be confusion about it.

=end original

リテラルな C<{> 文字のエスケープの強制は、
Perl 言語が将来のリリースで様々な方法で拡張できるようにするためにします。
既存のコードを不必要に壊すのを避けるために、この制限は、
C<{> をリテラルとして使うことと衝突する拡張がなさそうな部分では
強制されません。
左中かっこがリテラルに取られているときの非廃止予定警告は、
それが混乱するかも知れない文脈で発生します。

=begin original

Literal uses of C<{> were deprecated in Perl 5.20, and some uses of it
started to give deprecation warnings since. These cases were made fatal
in Perl 5.26. Due to an oversight, not all cases of a use of a literal
C<{> got a deprecation warning.  Some cases started warning in Perl 5.26,
and were made fatal in Perl 5.30.  Other cases started in Perl 5.28,
and were made fatal in 5.32.

=end original

C<{> のリテラルな使用は Perl 5.20 に廃止予定になり、
一部の使用についてはその時から廃止予定警告が出始めています。
これらの場合は Perl 5.26 で致命的エラーになりました。
見過ごしにより、全てのリテラルな C<{> の使用に対して廃止予定警告を
出していませんでした。
一部の場合は Perl 5.26 で警告を始め、Perl 5.30 で致命的エラーになりました。
その他の場合は Perl 5.28 で始め、5.32 で致命的エラーになりました。

=head3 In XS code, use of various macros dealing with UTF-8

(XS コードで、UTF-8 を扱う様々なマクロの使用)

=begin original

The macros below now require an extra parameter compared to versions prior
to Perl 5.32.  The final parameter in each one is a pointer into the
string supplied by the first parameter beyond which the input will not
be read.  This prevents potential reading beyond the end of the buffer.
C<isALPHANUMERIC_utf8>,
C<isASCII_utf8>,
C<isBLANK_utf8>,
C<isCNTRL_utf8>,
C<isDIGIT_utf8>,
C<isIDFIRST_utf8>,
C<isPSXSPC_utf8>,
C<isSPACE_utf8>,
C<isVERTWS_utf8>,
C<isWORDCHAR_utf8>,
C<isXDIGIT_utf8>,
C<isALPHANUMERIC_LC_utf8>,
C<isALPHA_LC_utf8>,
C<isASCII_LC_utf8>,
C<isBLANK_LC_utf8>,
C<isCNTRL_LC_utf8>,
C<isDIGIT_LC_utf8>,
C<isGRAPH_LC_utf8>,
C<isIDCONT_LC_utf8>,
C<isIDFIRST_LC_utf8>,
C<isLOWER_LC_utf8>,
C<isPRINT_LC_utf8>,
C<isPSXSPC_LC_utf8>,
C<isPUNCT_LC_utf8>,
C<isSPACE_LC_utf8>,
C<isUPPER_LC_utf8>,
C<isWORDCHAR_LC_utf8>,
C<isXDIGIT_LC_utf8>,
C<toFOLD_utf8>,
C<toLOWER_utf8>,
C<toTITLE_utf8>,
and
C<toUPPER_utf8>.

=end original

これらのマクロは Perl 5.32 以前と比べて一つ追加の引数が必要になりました。
それぞれの最後の引数は、これを超えて入力が読み込まれない、最初の引数で
指定された文字列へのポインタです。
これはバッファの末尾を超えて読み込む可能性を防ぎます。
C<isALPHANUMERIC_utf8>,
C<isASCII_utf8>,
C<isBLANK_utf8>,
C<isCNTRL_utf8>,
C<isDIGIT_utf8>,
C<isIDFIRST_utf8>,
C<isPSXSPC_utf8>,
C<isSPACE_utf8>,
C<isVERTWS_utf8>,
C<isWORDCHAR_utf8>,
C<isXDIGIT_utf8>,
C<isALPHANUMERIC_LC_utf8>,
C<isALPHA_LC_utf8>,
C<isASCII_LC_utf8>,
C<isBLANK_LC_utf8>,
C<isCNTRL_LC_utf8>,
C<isDIGIT_LC_utf8>,
C<isGRAPH_LC_utf8>,
C<isIDCONT_LC_utf8>,
C<isIDFIRST_LC_utf8>,
C<isLOWER_LC_utf8>,
C<isPRINT_LC_utf8>,
C<isPSXSPC_LC_utf8>,
C<isPUNCT_LC_utf8>,
C<isSPACE_LC_utf8>,
C<isUPPER_LC_utf8>,
C<isWORDCHAR_LC_utf8>,
C<isXDIGIT_LC_utf8>,
C<toFOLD_utf8>,
C<toLOWER_utf8>,
C<toTITLE_utf8>,
C<toUPPER_utf8>.

=begin original

Since Perl 5.26, this functionality with the extra parameter has been
available by using a corresponding macro to each one of these, and whose
name is formed by appending C<_safe> to the base name.  There is no
change to the functionality of those.  For example, C<isDIGIT_utf8_safe>
corresponds to C<isDIGIT_utf8>, and both now behave identically.  All
are documented in L<perlapi/Character case changing> and
L<perlapi/Character classification>.

=end original

Perl 5.26 から、追加の引数の機能は、
これらのそれぞれに対応するベース名に C<_safe> を追加した形の名前のマクロを
使うことによって利用可能です。
これらの機能に変更はありません。
例えば、C<isDIGIT_utf8_safe> は C<isDIGIT_utf8> に対応し、
これらは同様に振る舞うようになりました。
これら全ては L<perlapi/Character case changing> と
L<perlapi/Character classification> に文書化されています。

=begin original

This change was originally scheduled for 5.30, but was delayed until
5.32.

=end original

この変更は本来 5.30 に計画されていましたが、5.32 まで延期されました。

=head3 C<< File::Glob::glob() >> was removed

(C<< File::Glob::glob() >> は削除されました)

=begin original

C<< File::Glob >> had a function called C<< glob >>, which just called
C<< bsd_glob >>.

=end original

C<< File::Glob >> には C<< glob >> という関数があり、
これは単に C<< bsd_glob >> を呼び出していました。

=begin original

C<< File::Glob::glob() >> was deprecated in Perl 5.8. A deprecation
message was issued from Perl 5.26 onwards, the function became fatal
in Perl 5.30, and was removed entirely in Perl 5.32.

=end original

C<< File::Glob::glob() >> は Perl 5.8 で廃止予定になりました。
廃止予定メッセージは Perl 5.26 から出力されていて、
この関数は Perl 5.30 で致命的エラーになり、
Perl 5.32 で完全に取り除かれました。

=begin original

Code using C<< File::Glob::glob() >> should call
C<< File::Glob::bsd_glob() >> instead.

=end original

C<< File::Glob::glob() >> を使っているコードは代わりに
C<< File::Glob::bsd_glob() >> を呼び出すべきです。

=head2 Perl 5.30

=head3 C<< $* >> is no longer supported

(C<< $* >> はもはや対応しません)

=begin original

Before Perl 5.10, setting C<< $* >> to a true value globally enabled
multi-line matching within a string. This relic from the past lost
its special meaning in 5.10. Use of this variable became a fatal error
in Perl 5.30, freeing the variable up for a future special meaning.

=end original

Perl 5.10 より前では、C<< $* >> に真の値を設定すると、
一つの文字列中の複数行マッチングをグローバルに有効にします。
この過去からの遺物は 5.10 で特別な意味を失いました。
将来の特別な意味のために変数を空けるために、
この変数の使用は Perl 5.30 で致命的エラーになりました。

=begin original

To enable multiline matching one should use the C<< /m >> regexp
modifier (possibly in combination with C<< /s >>). This can be set
on a per match basis, or can be enabled per lexical scope (including
a whole file) with C<< use re '/m' >>.

=end original

複数行マッチングを有効にするためには、
(おそらく C<< /s >> と組み合わせて) C<< /m >> 正規表現修飾子を使うべきです。
これはマッチング毎で設定したり、C<< use re '/m' >> で (ファイル全体を含む)
レキシカルスコープ毎に設定したり出来ます。

=head3 C<< $# >> is no longer supported

(C<< $# >> はもはや対応しません)

=begin original

This variable used to have a special meaning -- it could be used
to control how numbers were formatted when printed. This seldom
used functionality was removed in Perl 5.10. In order to free up
the variable for a future special meaning, its use became a fatal
error in Perl 5.30.

=end original

この変数は特別な意味を持っていました -- 
print したときにいくつフォーマットするかを制御するために使われていました。
このほとんど使われない機能は Perl 5.10 で削除されました。
将来の特別な意味のために変数を空けるために、
この使用は Perl 5.30 で致命的エラーになりました。

=begin original

To specify how numbers are formatted when printed, one is advised
to use C<< printf >> or C<< sprintf >> instead.

=end original

print したときにいくつフォーマットされるかを指定するには、
代わりに C<< printf >> や C<< sprintf >> を使うことを勧めます。

=head3 Assigning non-zero to C<< $[ >> is fatal

(C<< $[ >> への非 0 の代入は致命的エラーになります)

=begin original

This variable (and the corresponding C<array_base> feature and
L<arybase> module) allowed changing the base for array and string
indexing operations.

=end original

この変数 (および対応する C<array_base> 機能と L<arybase> モジュール) は
配列と文字列の添え字操作の底を変更することができました。

=begin original

Setting this to a non-zero value has been deprecated since Perl 5.12 and
throws a fatal error as of Perl 5.30.

=end original

これに非 0 の値を設定するのは Perl 5.12 から廃止予定になり、
Perl 5.30 から致命的エラーを投げます。

=head3 Unqualified C<dump()>

(修飾されない C<dump()>)

=begin original

Use of C<dump()> instead of C<CORE::dump()> was deprecated in Perl 5.8,
and an unqualified C<dump()> is no longer available as of Perl 5.30.

=end original

C<CORE::dump()> の代わりの C<dump()> の使用は Perl 5.8 で廃止予定になり、
修飾されない C<dump()> は Perl 5.30 からは利用できません。

=begin original

See L<perlfunc/dump>.

=end original

L<perlfunc/dump> を参照してください。

=head3 Using my() in false conditional

(偽の条件で my() を使う)

=begin original

There has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  To allow us to fix this bug, people should not be
relying on this behavior.

=end original

Perl には、宣言が偽の条件を含んでいる場合、スコープを出るときに
レキシカル変数がクリアされないという長年のバグがあります。
一部の人々はある種の静的変数を達成するためにこのバグを悪用していました。
私たちがこのバグを修正できるように、人々はこの振る舞いに
依存しないべきです。

=begin original

Instead, it's recommended one uses C<state> variables to achieve the
same effect:

=end original

代わりに、同じ効果を達成するために C<state> 変数を使うことを勧めます:

    use 5.10.0;
    sub count {state $counter; return ++ $counter}
    say count ();    # Prints 1
    say count ();    # Prints 2

=begin original

C<state> variables were introduced in Perl 5.10.

=end original

C<state> 変数は Perl 5.10 で導入されました。

=begin original

Alternatively, you can achieve a similar static effect by
declaring the variable in a separate block outside the function, e.g.,

=end original

あるいは、関数の外側の別のブロックの中で変数を宣言することで
似たような静的な効果を得られます:

    sub f { my $x if 0; return $x++ }

=begin original

becomes

=end original

これは次のようになります:

    { my $x; sub f { return $x++ } }

=begin original

The use of C<my()> in a false conditional has been deprecated in
Perl 5.10, and became a fatal error in Perl 5.30.

=end original

偽の条件での C<my()> の使用は Perl 5.10 で廃止予定になり、
Perl 5.30 で致命的エラーになりました。

=head3 Reading/writing bytes from/to :utf8 handles

(:utf8 ハンドルに対するバイト読み書き)

=begin original

The sysread(), recv(), syswrite() and send() operators are
deprecated on handles that have the C<:utf8> layer, either explicitly, or
implicitly, eg., with the C<:encoding(UTF-16LE)> layer.

=end original

(明示的あるいは C<:encoding(UTF-16LE)> 層のように暗黙的どちらでも)
C<:utf8> 層を持つハンドルに対する
sysread(), recv(), syswrite(), send() 演算子は廃止予定です。

=begin original

Both sysread() and recv() currently use only the C<:utf8> flag for the stream,
ignoring the actual layers.  Since sysread() and recv() do no UTF-8
validation they can end up creating invalidly encoded scalars.

=end original

sysread() と recv() の両方は今のところ C<:utf8> フラグを
ストリームのためだけに使い、実際の層は無視します。
sysread() と recv() は UTF-8 検証を行わないので、
不正にエンコードされたスカラを作ることになるかも知れません。

=begin original

Similarly, syswrite() and send() use only the C<:utf8> flag, otherwise ignoring
any layers.  If the flag is set, both write the value UTF-8 encoded, even if
the layer is some different encoding, such as the UTF-16LE example above.

=end original

同様に、syswrite() と send() は C<:utf8> フラグのみを使い、
その他の層は無視します。
フラグが設定されていると、これらは、たとえ層が前述の UTF-16LE の例のように
異なったエンコーディングの場合でも、UTF-8 エンコードされた値を書き込みます。

=begin original

Ideally, all of these operators would completely ignore the C<:utf8> state,
working only with bytes, but this would result in silently breaking existing
code.  To avoid this a future version of perl will throw an exception when
any of sysread(), recv(), syswrite() or send() are called on handles with the
C<:utf8> layer.

=end original

理想的には、これらの演算子全ては完全に C<:utf8> の状態を無視して、
バイトに対してのみ動作したいですが、
これは既存のコードを暗黙に壊すことになります。
これを避けるために、将来のバージョンの Perl では
sysread(), recv(), syswrite(), send() が C<:utf8> 層を持った
ハンドルで呼び出されると例外を投げる予定です。

=begin original

As of Perl 5.30, it is no longer possible to use sysread(), recv(),
syswrite() or send() to read or send bytes from/to C<:utf8> handles.

=end original

Perl 5.30 から、C<:utf8> ハンドルでバイトを読み書きするために
sysread(), recv(), syswrite(), send() を使うことはもはやできません。

=head3 Use of unassigned code point or non-standalone grapheme for a delimiter

(区切り文字として未割当符号位置や非独立書記素の使用)

=begin original

A grapheme is what appears to a native speaker of a language to be a
character.  In Unicode (and hence Perl) a grapheme may actually be
several adjacent characters that together form a complete grapheme.  For
example, there can be a base character, like "R" and an accent, like a
circumflex "^", that appear to be a single character when displayed,
with the circumflex hovering over the "R".

=end original

書記素は、言語のネイティブスピーカーにとって文字のように見えるものです。
Unicode (従って Perl) では、
書記素は実際には互いに完全な書記素を形成するいくつかの隣接する
文字かもしれません。
例えば、"R" のような基底文字と曲折アクセント "^" のような
アクセントかもしれません; これは表示されるときには
"R" の上に曲折アクセントがある単一の文字となります。

=begin original

As of Perl 5.30, use of delimiters which are non-standalone graphemes is
fatal, in order to move the language to be able to accept
multi-character graphemes as delimiters.

=end original

Perl 5.30 から、非独立書記素の区切り文字としての使用は致命的エラーです;
これは複数文字書記素を区切り文字として受け入れられるように言語を
動かすためです。

=begin original

Also, as of Perl 5.30, delimiters which are unassigned code points
but that may someday become assigned are prohibited.  Otherwise, code
that works today would fail to compile if the currently unassigned
delimiter ends up being something that isn't a stand-alone grapheme.
Because Unicode is never going to assign L<non-character code
points|perlunicode/Noncharacter code points>, nor L<code points that are
above the legal Unicode maximum|perlunicode/Beyond Unicode code
points>, those can be delimiters.

=end original

また、Perl 5.30 から、いつか割り当てられるかも知れない
非割り当て符号位置の区切り文字も禁止されます。
さもなければ、もし現在割り当てられていない書記素が単体の書記素でないものに
なった場合、今日動作しているコードがコンパイルに失敗することになります。
Unicode は決して
L<非文字符号位置|perlunicode/Noncharacter code points> や
L<正当な Unicode の最大値より大きな符号位置|
perlunicode/Beyond Unicode code points> を割り当てないので、
これらは区切り文字になることができます。

=head2 Perl 5.28

=head3 Attributes C<< :locked >> and C<< :unique >>

(属性 C<< :locked >> と C<< :unique >>)

=begin original

The attributes C<< :locked >> (on code references) and C<< :unique >>
(on array, hash and scalar references) have had no effect since 
Perl 5.005 and Perl 5.8.8 respectively. Their use has been deprecated
since.

=end original

属性 (コードリファレンスに対する) C<< :locked >> および 
(配列、ハッシュ、スカラリファレンスに対する) C<< :unique >> は
それぞれ Perl Perl 5.005 と Perl 5.8.8 から何もしなくなっていました。
これらの使用はその時から廃止予定でした。

=begin original

As of Perl 5.28, these attributes are syntax errors. Since the
attributes do not do anything, removing them from your code fixes
the syntax error; and removing them will not influence the behaviour
of your code.

=end original

Perl 5.28 から、これらの属性は文法エラーとなります。
これらの属性は何もしないので、コードからこれらを削除すれば
文法エラーを修正でき、削除することによってコードの振る舞いには
影響ありません。

=head3 Bare here-document terminators

(空のヒヤドキュメント終端子)

=begin original

Perl has allowed you to use a bare here-document terminator C<<< << >>> to
have the here-document end at the first empty line. This practise was
deprecated in Perl 5.000; as of Perl 5.28, using a bare here-document
terminator throws a fatal error.

=end original

Perl は、最初の空行をヒヤドキュメントの末尾とするために空の
ヒヤドキュメント終端子 C<<< << >>> を使うことを許していました。
この慣習は Perl 5.000 で廃止予定になりました;
Perl 5.28 から、裸のヒヤドキュメント終端子の使用は
致命的エラーを投げます。

=begin original

You are encouraged to use the explicitly quoted form if you wish to
use an empty line as the terminator of the here-document:

=end original

ヒヤドキュメントの終端子として空行を使いたい場合は、
明示的にクォートした形式を使うことが推奨されます:

  print <<"";
    Print this line.

  # Previous blank line ends the here-document.

=head3 Setting $/ to a reference to a non-positive integer

($/ への非正整数へのリファレンスの設定)

=begin original

You assigned a reference to a scalar to C<$/> where the
referenced item is not a positive integer.  In older perls this B<appeared>
to work the same as setting it to C<undef> but was in fact internally
different, less efficient and with very bad luck could have resulted in
your file being split by a stringified form of the reference.

=end original

リファレンスが差しているのが非正整数のときにそのリファレンスを
C<$/> に代入しました。
より古い Perl では、これは C<undef> を設定するのと同じ
B<ように見えます> が、実際内部では異なり、
より効率が悪く、とても運が悪いとファイルがリファレンスの文字列化形式で
分割されることになります。

=begin original

In Perl 5.20.0 this was changed so that it would be B<exactly> the same as
setting C<$/> to C<undef>, with the exception that this warning would be
thrown.

=end original

Perl 5.20.0 では、これは例外が投げられることを除けば、
B<正確に> C<$/> に C<undef> を設定するのと同じです。

=begin original

As of Perl 5.28, setting C<$/> to a reference to a non-positive
integer throws a fatal error.

=end original

Perl 5.28 から、C<$/> に非正整数へのリファレンスを設定すると
致命的エラーを投げます。

=begin original

You are recommended to change your code to set C<$/> to C<undef> explicitly
if you wish to slurp the file.

=end original

ファイルを吸い込みたい場合、明示的に C<$/> に C<undef> を設定するように
コードを変更することを薦めます。

=head3 Limit on the value of Unicode code points

(Unicode 符号位置の値の制限)

=begin original

Unicode only allows code points up to 0x10FFFF, but Perl allows
much larger ones. Up till Perl 5.28, it was allowed to use code
points exceeding the maximum value of an integer (C<IV_MAX>).
However, that did break the perl interpreter in some constructs,
including causing it to hang in a few cases.  The known problem
areas were in C<tr///>, regular expression pattern matching using
quantifiers, as quote delimiters in C<qI<X>...I<X>> (where I<X> is
the C<chr()> of a large code point), and as the upper limits in
loops.

=end original

Unicode は 0x10FFFF までの符号位置だけを許していますが、
Perl はもっと大きなものも許しています。
Perl 5.28 まで、整数の最大値 (C<IV_MAX>) を超える符号位置を許していました。
しかし、これは一部の構文でperl インタプリタを壊すことがあり、
一部の場合はハングアップを引き起こします。
問題があることが知られている分野は
C<tr///>、量指定子を使った正規表現パターンマッチング
C<qI<X>...I<X>> の中でのクォート区切り文字
(I<X> は大きな符号位置の C<chr()>)、ループの上限でした。

=begin original

The use of out-of-range code points was deprecated in Perl 5.24; as of
Perl 5.28 using a code point exceeding C<IV_MAX> throws a fatal error.

=end original

範囲外の符号位置の使用は Perl 5.24 で廃止予定になりました;
Perl 5.28 から、C<IV_MAX> を超える符号位置の使用は致命的エラーを投げます。

=begin original

If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform. It is much larger on 64-bit word sizes
than 32-bit ones. For 32-bit integers, C<IV_MAX> equals C<0x7FFFFFFF>;
for 64-bit integers, C<IV_MAX> equals C<0x7FFFFFFFFFFFFFFF>.

=end original

あなたのコードを様々なプラットフォームで実行するためには、
上限はプラットフォームに依存することを覚えておいてください。
これは 64 ビットワードサイズでは 32 ビットのものより遙かに大きいです。
32 ビット整数では C<IV_MAX> は C<0x7FFFFFFF> です;
64 ビット整数では C<IV_MAX> は C<0x7FFFFFFFFFFFFFFF> です。

=head3 Use of comma-less variable list in formats

(フォーマットでのカンマなしの変数リストの使用)

=begin original

It was allowed to use a list of variables in a format, without
separating them with commas. This usage has been deprecated
for a long time, and as of Perl 5.28, this throws a fatal error.

=end original

フォーマットで、分割するカンマなしの変数のリストを使うことが
許されていました。
この使用法は長い間廃止予定で、Perl 5.28 からこれは致命的エラーを投げます。

=head3 Use of C<\N{}>

(C<\N{}> の使用)

=begin original

Use of C<\N{}> with nothing between the braces was deprecated in
Perl 5.24, and throws a fatal error as of Perl 5.28.

=end original

中かっこの中に何もない C<\N{}> の使用は Perl 5.24 で廃止予定になり、
Perl 5.28 から致命的エラーを投げます。

=begin original

Since such a construct is equivalent to using an empty string,
you are recommended to remove such C<\N{}> constructs.

=end original

このような構文は空文字列を使うのと等価なので、
このような C<\N{}> 構文を削除することを勧めます。

=head3 Using the same symbol to open a filehandle and a dirhandle

(ファイルハンドルとディレクトリハンドルで同じシンボルを使う)

=begin original

It used to be legal to use C<open()> to associate both a
filehandle and a dirhandle to the same symbol (glob or scalar).
This idiom is likely to be confusing, and it was deprecated in
Perl 5.10.

=end original

ファイルハンドルとディレクトリハンドルに同じシンボル
(グロブまたはスカラ) を代入するのに C<open()> を使うのは、
以前は正当でした。
この慣用句は混乱を起こしやすく、Perl 5.10 で廃止予定になりました。

=begin original

Using the same symbol to C<open()> a filehandle and a dirhandle
throws a fatal error as of Perl 5.28.

=end original

ファイルハンドルとディレクトリハンドルを C<open()> するのに
同じシンボルを使うのは Perl 5.28 から致命的エラーを投げます。

=begin original

You should be using two different symbols instead.

=end original

代わりに二つの異なったシンボルを使うようにしてください。

=head3 ${^ENCODING} is no longer supported

(${^ENCODING} はもはや対応しません)

=begin original

The special variable C<${^ENCODING}> was used to implement
the C<encoding> pragma. Setting this variable to anything other
than C<undef> was deprecated in Perl 5.22. Full deprecation
of the variable happened in Perl 5.25.3.

=end original

特殊変数 C<${^ENCODING}> は C<encoding> プラグマを実装するために
使われていました。
この変数を C<undef> 以外の値に設定するのは Perl 5.22 で廃止予定になりました。
この変数の完全な廃止予定は Perl 5.25.3 で起こりました。

=begin original

Setting this variable to anything other than an undefined value
throws a fatal error as of Perl 5.28.

=end original

この変数に未定義値以外のものを設定するのは
Perl 5.28 から致命的エラーを投げます。

=head3 C<< B::OP::terse >>

=begin original

This method, which just calls C<< B::Concise::b_terse >>, has been
deprecated, and disappeared in Perl 5.28. Please use 
L<B::Concise> instead.

=end original

単に C<< B::Concise::b_terse >> を呼び出すこのメソッドは廃止予定で、
Perl 5.28 で消滅しました。
代わりに L<B::Concise> を使ってください。

=head3 Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed

(非メソッド %s() のための継承された AUTOLOAD はもはや許されません)

=begin original

As an (ahem) accidental feature, C<AUTOLOAD> subroutines were looked
up as methods (using the C<@ISA> hierarchy) even when the subroutines
to be autoloaded were called as plain functions (e.g. C<Foo::bar()>),
not as methods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).

=end original

ある (ゴホン) 偶発的な機能として、C<AUTOLOAD> サブルーチンは、
たとえ autoload されるサブルーチンが
(C<< Foo->bar() >> や C<< $obj->bar() >> のように)メソッドとしてではなく
(C<Foo::bar()> のように)普通の関数として呼び出されても、
(C<@ISA> 階層を使って) メソッドして検索されていました。

=begin original

This bug was deprecated in Perl 5.004 and has been rectified in Perl 5.28
by using method lookup only for methods' C<AUTOLOAD>s.

=end original

このバグは Perl 5.004 で廃止予定になり、
Perl 5.28 でメソッドの C<AUTOLOAD> のみでメソッド検索するように
修正されました。

=begin original

The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting C<AUTOLOAD> for non-methods from a base class
named C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during
startup.

=end original

単純な規則は: 継承は非メソッドを autoload された時には動作しません。
古いコードのための簡単な修正方法は: 
C<BaseClass> という名前のベースクラスから非メソッドの
C<AUTOLOAD> を継承することに依存しているそれぞれのモジュールで、
起動時に C<*AUTOLOAD = \&BaseClass::AUTOLOAD> を実行します。

=begin original

In code that currently says C<use AutoLoader; @ISA = qw(AutoLoader);>
you should remove AutoLoader from C<@ISA> and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.

=end original

現在 C<use AutoLoader; @ISA = qw(AutoLoader);> としているコードは、
C<@ISA> から AutoLoader を削除して、
C<use AutoLoader;> を C<use AutoLoader 'AUTOLOAD';> に変更するべきです。

=head3 In XS code, use of C<to_utf8_case()>

(XS コード内での C<to_utf8_case()> の使用)

=begin original

This function has been removed as of Perl 5.28; instead convert to call
the appropriate one of:
L<C<toFOLD_utf8_safe>|perlapi/toFOLD_utf8_safe>.
L<C<toLOWER_utf8_safe>|perlapi/toLOWER_utf8_safe>,
L<C<toTITLE_utf8_safe>|perlapi/toTITLE_utf8_safe>,
or
L<C<toUPPER_utf8_safe>|perlapi/toUPPER_utf8_safe>.

=end original

この関数は Perl 5.28 で削除されました;
代わりに以下のうち適切なものを呼び出すように変換してください:
L<C<toFOLD_utf8_safe>|perlapi/toFOLD_utf8_safe>.
L<C<toLOWER_utf8_safe>|perlapi/toLOWER_utf8_safe>,
L<C<toTITLE_utf8_safe>|perlapi/toTITLE_utf8_safe>,
L<C<toUPPER_utf8_safe>|perlapi/toUPPER_utf8_safe>.

=head2 Perl 5.26

=head3 C<< --libpods >> in C<< Pod::Html >>

(C<< Pod::Html >> での C<< --libpods >>)

=begin original

Since Perl 5.18, the option C<< --libpods >> has been deprecated, and
using this option did not do anything other than producing a warning.

=end original

Perl 5.18 から、C<< --libpods >> は廃止予定で、
このオプションは警告を出力する以外に何もしていませんでした。

=begin original

The C<< --libpods >> option is no longer recognized as of Perl 5.26.

=end original

C<< --libpods >> オプションは Perl 5.26 からはや認識しなくなりました。

=head3 The utilities C<< c2ph >> and C<< pstruct >>

(ユーティリティ C<< c2ph >> と C<< pstruct >>)

=begin original

These old, perl3-era utilities have been deprecated in favour of
C<< h2xs >> for a long time. As of Perl 5.26, they have been removed.

=end original

これらの古い、perl3 時代のユーティリティは、C<< h2xs >> に置き換えられて
長い間廃止予定でした。
Perl 5.26 から、これらは削除されました。

=head3 Trapping C<< $SIG{__DIE__} >> other than during program exit

(プログラム終了中以外での C<< $SIG{__DIE__} >> のトラップ)

=begin original

The C<$SIG{__DIE__}> hook is called even inside an C<eval()>. It was
never intended to happen this way, but an implementation glitch made
this possible. This used to be deprecated, as it allowed strange action
at a distance like rewriting a pending exception in C<$@>. Plans to
rectify this have been scrapped, as users found that rewriting a
pending exception is actually a useful feature, and not a bug.

=end original

C<$SIG{__DIE__}> フックは C<eval()> の内側でも呼び出されます。
これが起きることは決して意図されていませんでしたが、
実装上の問題によりこれが可能になっていました。
これは廃止予定にされていました; なぜなら
C<$@> の中の保留されている例外を書き換えるというような、
離れた場所でおかしな動作が可能になるからです。
これを修正する計画は却下されました;
ユーザーが、保留している計画を書き換えるのは実際には有用な機能で
バグではないと発見したからです。

=begin original

Perl never issued a deprecation warning for this; the deprecation
was by documentation policy only. But this deprecation has been 
lifted as of Perl 5.26.

=end original

Perl はこれに関する廃止予定警告を出したことはありません;
廃止予定は文書分署ポリシーによるものだけです。
しかし廃止予定は Perl 5.26 で実行されました。

=head3 Malformed UTF-8 string in "%s"

("%s" での不正な UTF-8 文字列)

=begin original

This message indicates a bug either in the Perl core or in XS
code. Such code was trying to find out if a character, allegedly
stored internally encoded as UTF-8, was of a given type, such as
being punctuation or a digit.  But the character was not encoded
in legal UTF-8.  The C<%s> is replaced by a string that can be used
by knowledgeable people to determine what the type being checked
against was.

=end original

このメッセージは、Perl コアまたは XS コードのバグを示しています。
このようなコードは、内部で UTF-8 でエンコードされて保管されたと
されている文字が、句読点や数字のような特定の種類かどうかを
調べようとしています。
しかしこの文字は正当な UTF-8 でエンコードされていません。
C<%s> は、知識のある人々がどのような種類をチェックしようとしたかを
決定するのに使われる文字列で置き換えられます。

=begin original

Passing malformed strings was deprecated in Perl 5.18, and
became fatal in Perl 5.26.

=end original

不正な文字列を渡すのは Perl 5.18 で廃止予定になり、
Perl 5.26 で致命的エラーになりました。

=head2 Perl 5.24

=head3 Use of C<< *glob{FILEHANDLE} >>

(C<< *glob{FILEHANDLE} >> の使用)

=begin original

The use of C<< *glob{FILEHANDLE} >> was deprecated in Perl 5.8.
The intention was to use C<< *glob{IO} >> instead, for which 
C<< *glob{FILEHANDLE} >> is an alias.

=end original

C<< *glob{FILEHANDLE} >> の使用は Perl 5.8 で廃止予定になりました。
その意図は、C<< *glob{FILEHANDLE} >> が別名である
C<< *glob{IO} >> を代わりに使うことでした。

=begin original

However, this feature was undeprecated in Perl 5.24.

=end original

しかし、この機能は Perl 5.24 で廃止予定でなくなりました。

=head3 Calling POSIX::%s() is deprecated

(POSIX::%s() の呼び出しは廃止予定です)

=begin original

The following functions in the C<POSIX> module are no longer available:
C<isalnum>, C<isalpha>, C<iscntrl>, C<isdigit>, C<isgraph>, C<islower>,  
C<isprint>, C<ispunct>, C<isspace>, C<isupper>, and C<isxdigit>.  The 
functions are buggy and don't work on UTF-8 encoded strings.  See their
entries in L<POSIX> for more information.

=end original

C<POSIX> モジュールの以下の関数はもはや利用できません:
C<isalnum>, C<isalpha>, C<iscntrl>, C<isdigit>, C<isgraph>, C<islower>,  
C<isprint>, C<ispunct>, C<isspace>, C<isupper>, C<isxdigit>。
これらの関数はバグっぽく、UTF-8 エンコードされた文字列で動作しません。
さらなる情報については L<POSIX> のそれぞれの項目を参照してください。

=begin original

The functions were deprecated in Perl 5.20, and removed in Perl 5.24.

=end original

これらの関数は Perl 5.20 で廃止予定になり、Perl 5.24 で削除されました。

=head2 Perl 5.16

=head3 Use of %s on a handle without * is deprecated

(* なしでのハンドルでの %s は廃止予定です)

=begin original

It used to be possible to use C<tie>, C<tied> or C<untie> on a scalar
while the scalar holds a typeglob. This caused its filehandle to be
tied. It left no way to tie the scalar itself when it held a typeglob,
and no way to untie a scalar that had had a typeglob assigned to it.

=end original

スカラが型グロブを保持しているときにスカラに対して
C<tie>, C<tied>, C<untie> を使うことが可能でした。
これはそのファイルハンドルが tie されていました。
型グロブを保持しているときにスカラ自身を tie したり、
型グロブが代入されているスカラを untie する方法はありませんでした。

=begin original

This was deprecated in Perl 5.14, and the bug was fixed in Perl 5.16.

=end original

これは Perl 5.14 で廃止予定になり、バグは Perl 5.16 で修正されました。

=begin original

So now C<tie $scalar> will always tie the scalar, not the handle it holds.
To tie the handle, use C<tie *$scalar> (with an explicit asterisk).  The same
applies to C<tied *$scalar> and C<untie *$scalar>.

=end original

今では C<tie $scalar> は保持しているハンドルではなく、常にスカラを
tie します。
ハンドルを tie するためには、(明示的なアスタリスク付きの)
C<tie *$scalar> を使ってください。
同じことは C<tied *$scalar> と C<untie *$scalar> にも適用されます。

=head1 SEE ALSO

L<warnings>, L<diagnostics>.

=begin meta

Translate: Kentaro Shirakata <argrath@ub32.org>
Status: completed

=end meta

=cut

