
=encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlootut.pod

=head1 NAME

=begin original

perlootut - Object-Oriented Programming in Perl Tutorial

=end original

perlootut - Perl でのオブジェクト指向プログラミングのチュートリアル

=head1 DATE

=begin original

This document was created in February, 2011, and the last major
revision was in February, 2013.

=end original

この文書は 2011 年 2 月に作成され、最後に大きく見直されたのは 2013 年
2 月です。

=begin original

If you are reading this in the future then it's possible that the state
of the art has changed. We recommend you start by reading the perlootut
document in the latest stable release of Perl, rather than this
version.

=end original

もし将来これを読んでいる場合、最新版は変更されている可能性があります。
このバージョンではなく、Perl の最新安定リリースの perlootut 文書を
読むことから始めることを勧めます。

=head1 DESCRIPTION

=begin original

This document provides an introduction to object-oriented programming
in Perl. It begins with a brief overview of the concepts behind object
oriented design. Then it introduces several different OO systems from
L<CPAN|https://www.cpan.org> which build on top of what Perl
provides.

=end original

この文書は Perl でのオブジェクト指向プログラミングを紹介します。
これはオブジェクト指向設計の背後にあるコンセプトの概説から始めます。
それから Perl が提供するものの上に構築されている、
L<CPAN|https://www.cpan.org> にあるいくつかの OO システムを紹介します。

=begin original

By default, Perl's built-in OO system is very minimal, leaving you to
do most of the work. This minimalism made a lot of sense in 1994, but
in the years since Perl 5.0 we've seen a number of common patterns
emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich
ecosystem of Perl OO systems to flourish.

=end original

デフォルトでは、Perl の組み込みの OO システムはとても最小限です; ほとんどの
作業を自分でする必要があります。
この最小限主義は 1994 年には十分意味のあるものでしたが、Perl 5.0 から
時が経つにつれて、Perl OO に多くの共通のパターンが見られるようになりました。
幸い、Perl の柔軟性により、Perl OO システムの豊かなエコシステムが
発展しました。

=begin original

If you want to know how Perl OO works under the hood, the L<perlobj>
document explains the nitty gritty details.

=end original

裏で Perl OO がどのように動作するのかを知りたい場合は、L<perlobj> 文書が
本質的な詳細について説明しています。

=begin original

This document assumes that you already understand the basics of Perl
syntax, variable types, operators, and subroutine calls. If you don't
understand these concepts yet, please read L<perlintro> first. You
should also read the L<perlsyn>, L<perlop>, and L<perlsub> documents.

=end original

この文書は、Perl の文法、変数型、演算子、サブルーチン呼び出しの基本について
既に理解していると仮定しています。
まだこれらのコンセプトについてまだ理解していないなら、まず L<perlintro> を
読んでください。
L<perlsyn>, L<perlop>, L<perlsub> 文書も読むべきでしょう。

=head1 OBJECT-ORIENTED FUNDAMENTALS

(オブジェクト指向の基本)

=begin original

Most object systems share a number of common concepts. You've probably
heard terms like "class", "object, "method", and "attribute" before.
Understanding the concepts will make it much easier to read and write
object-oriented code. If you're already familiar with these terms, you
should still skim this section, since it explains each concept in terms
of Perl's OO implementation.

=end original

ほとんどのオブジェクトシステムは多くの共通の概念を共有しています。
おそらく以前に「クラス」、「オブジェクト」、「メソッド」、属性といった
用語について聞いたことがあるでしょう。
概念の理解は、オブジェクト指向のコードを読み書きするよりも遥かに容易です。
既にこれらの用語に親しんでいても、この章に目を通すべきです; なぜなら
Perl の OO 実装の用語でそれぞれの概念を説明しているからです。

=begin original

Perl's OO system is class-based. Class-based OO is fairly common. It's
used by Java, C++, C#, Python, Ruby, and many other languages. There
are other object orientation paradigms as well. JavaScript is the most
popular language to use another paradigm. JavaScript's OO system is
prototype-based.

=end original

Perl の OO システムはクラスベースです。
クラスベース OO はかなり一般的です。
これは Java, C++, C#, Python, Ruby およびその他の多くの言語で使われています。
その他のオブジェクト指向パラダイムもあります。
JavaScript は、その他のパラダイムを使っている最も有名な言語です。
JavaScript の OO システムはプロトタイプベースです。

=head2 Object

(オブジェクト)

=begin original

An B<object> is a data structure that bundles together data and
subroutines which operate on that data. An object's data is called
B<attributes>, and its subroutines are called B<methods>. An object can
be thought of as a noun (a person, a web service, a computer).

=end original

B<オブジェクト> は、データと、そのデータを操作するサブルーチンを一つに
まとめたデータ構造です。
オブジェクトのデータは B<属性> と呼ばれ、サブルーチンは B<メソッド> と
呼ばれます。
オブジェクトは名詞と考えることができます (人、web サービス、
コンピュータなど)。

=begin original

An object represents a single discrete thing. For example, an object
might represent a file. The attributes for a file object might include
its path, content, and last modification time. If we created an object
to represent F</etc/hostname> on a machine named "foo.example.com",
that object's path would be "/etc/hostname", its content would be
"foo\n", and it's last modification time would be 1304974868 seconds
since the beginning of the epoch.

=end original

オブジェクトは単一のものを表現します。
たとえば、あるオブジェクトがファイルを表現しているとします。
ファイルオブジェクトの属性はパス、内容、最終更新時刻といったものになります。
オブジェクトのパスが "/etc/hostname" になるような、
"foo.example.com" という名前のマシンの F</etc/hostname> を表現する
オブジェクトを作る場合、その内容は "foo\n" で、最終更新時刻は紀元から
1304974868 秒といったものになります。

=begin original

The methods associated with a file might include C<rename()> and
C<write()>.

=end original

ファイルに結びつけられたメソッドは C<rename()> や C<write()> と
いったものになります。

=begin original

In Perl most objects are hashes, but the OO systems we recommend keep
you from having to worry about this. In practice, it's best to consider
an object's internal data structure opaque.

=end original

Perl ではほとんどのオブジェクトはハッシュですが、推奨する OO システムは
これについて気にする必要がないようにします。
実際には、オブジェクトの内部構造は不透明であると考えるのが最良です。

=head2 Class

(クラス)

=begin original

A B<class> defines the behavior of a category of objects. A class is a
name for a category (like "File"), and a class also defines the
behavior of objects in that category.

=end original

B<クラス> はあるカテゴリのオブジェクトの振る舞いを定義します。
クラスは("File" のような)カテゴリを表す名前です; またクラスは
そのカテゴリのオブジェクトの振る舞いを定義します。

=begin original

All objects belong to a specific class. For example, our
F</etc/hostname> object belongs to the C<File> class. When we want to
create a specific object, we start with its class, and B<construct> or
B<instantiate> an object. A specific object is often referred to as an
B<instance> of a class.

=end original

全てのオブジェクトは何らかのクラスに属します。
例えば、F</etc/hostname> オブジェクトは C<File> クラスに属します。
特定のオブジェクトを作りたい場合、そのクラスから始めて、オブジェクトを
B<構築>(construct) または B<インスタンス化> (instantiate) します。
特定のオブジェクトはしばしばクラスの B<インスタンス> (instance) と
呼ばれます。

=begin original

In Perl, any package can be a class. The difference between a package
which is a class and one which isn't is based on how the package is
used. Here's our "class declaration" for the C<File> class:

=end original

Perl では、どのパッケージもクラスになれます。
クラスであるパッケージとそうでないパッケージの違いは、パッケージがどのように
使われるかによります。
以下は C<File> クラスのための「クラス宣言」です:

  package File;

=begin original

In Perl, there is no special keyword for constructing an object.
However, most OO modules on CPAN use a method named C<new()> to
construct a new object:

=end original

Perl では、オブジェクトの構築のための特別なキーワードはありません。
しかし、CPAN のほとんどの OO モジュールは、新しいオブジェクトの構築に
C<new()> という名前のメソッドを使います:

  my $hostname = File->new(
      path          => '/etc/hostname',
      content       => "foo\n",
      last_mod_time => 1304974868,
  );

=begin original

(Don't worry about that C<< -> >> operator, it will be explained
later.)

=end original

(C<< -> >> 演算子について心配しないでください; 後で説明します。)

=head3 Blessing

(bless)

=begin original

As we said earlier, most Perl objects are hashes, but an object can be
an instance of any Perl data type (scalar, array, etc.). Turning a
plain data structure into an object is done by B<blessing> that data
structure using Perl's C<bless> function.

=end original

既に述べたように、ほとんどの Perl オブジェクトはハッシュですが、
オブジェクトはどの Perl データ型 (スカラ、配列など)のインスタンスも可能です。
普通のデータ構造のオブジェクトへの変換は、データ構造に Perl の C<bless> 関数を
使うことによる B<bless> によって行われます。

=begin original

While we strongly suggest you don't build your objects from scratch,
you should know the term B<bless>. A B<blessed> data structure (aka "a
referent") is an object. We sometimes say that an object has been
"blessed into a class".

=end original

一からオブジェクトを構築しないことを強く勧めますが、B<bless> という
用語は知っておくべきです。
B<bless された> データ構造 (またの名を「リファレンス先」)はオブジェクトです。
時々、オブジェクトは「クラスに bless された」と表現します。

=begin original

Once a referent has been blessed, the C<blessed> function from the
L<Scalar::Util> core module can tell us its class name. This subroutine
returns an object's class when passed an object, and false otherwise.

=end original

一旦リファレンス先が bless されると、L<Scalar::Util> コアモジュールの
C<blessed> 関数はそのクラス名を返します。
このサブルーチンは、オブジェクトが和されるとオブジェクトのクラスを返し、
さもなければ偽を返します。

  use Scalar::Util 'blessed';

  print blessed($hash);      # undef
  print blessed($hostname);  # File

=head3 Constructor

(コンストラクタ)

=begin original

A B<constructor> creates a new object. In Perl, a class's constructor
is just another method, unlike some other languages, which provide
syntax for constructors. Most Perl classes use C<new> as the name for
their constructor:

=end original

B<コンストラクタ> は新しいオブジェクトを作成します。
コンストラクタのための文法を提供しているその他の言語と異なり、Perl では
クラスのコンストラクタは単なるメソッドです。
ほとんどの Perl クラスはコンストラクタの名前として C<new> を使います:

  my $file = File->new(...);

=head2 Methods

(メソッド)

=begin original

You already learned that a B<method> is a subroutine that operates on
an object. You can think of a method as the things that an object can
I<do>. If an object is a noun, then methods are its verbs (save, print,
open).

=end original

オブジェクトを操作するサブルーチンが B<メソッド> であるということは
既に学んでいます。
メソッドはオブジェクトが I<する> ことと考えることができます。
オブジェクトが名詞なら、メソッドは動詞 (保存する、表示する、開く) です。

=begin original

In Perl, methods are simply subroutines that live in a class's package.
Methods are always written to receive the object as their first
argument:

=end original

Perl では、メソッドは単にクラスのパッケージにあるサブルーチンです。
メソッドは常に最初の引数としてオブジェクトを受け取るように書かれます:

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

  $file->print_info;
  # The file is at /etc/hostname

=begin original

What makes a method special is I<how it's called>. The arrow operator
(C<< -> >>) tells Perl that we are calling a method.

=end original

メソッドを特別なものにしているのは、I<どのように呼び出されるか> です。
矢印演算子 (C<< -> >>) は、メソッドとして呼び出していることを Perl に
知らせます。

=begin original

When we make a method call, Perl arranges for the method's B<invocant>
to be passed as the first argument. B<Invocant> is a fancy name for the
thing on the left side of the arrow. The invocant can either be a class
name or an object. We can also pass additional arguments to the method:

=end original

メソッド呼び出しをするとき、Perl はメソッドの B<呼び出し元> (invocant) を
最初の引数として渡すように用意します。
B<呼び出し元> とは矢印の左側にあるものの名前です。
呼び出し元はクラス名とオブジェクトのどちらかです。
また、メソッドに追加の引数も渡せます:

  sub print_info {
      my $self   = shift;
      my $prefix = shift // "This file is at ";

      print $prefix, ", ", $self->path, "\n";
  }

  $file->print_info("The file is located at ");
  # The file is located at /etc/hostname

=head2 Attributes

(属性)

=begin original

Each class can define its B<attributes>. When we instantiate an object,
we assign values to those attributes. For example, every C<File> object
has a path. Attributes are sometimes called B<properties>.

=end original

各クラスは B<属性> を定義します。
オブジェクトをインスタンス化するとき、これらの属性に値を代入します。
例えば、各 C<File> オブジェクトはパスを持ちます。
属性は時々 B<プロパティ> (properties) と呼ばれます。

=begin original

Perl has no special syntax for attributes. Under the hood, attributes
are often stored as keys in the object's underlying hash, but don't
worry about this.

=end original

Perl には属性のための特別な文法はありません。
内部では、属性はしばしばオブジェクトの基となっているハッシュのキーとして
保管されますが、これについて気にすることはありません。

=begin original

We recommend that you only access attributes via B<accessor> methods.
These are methods that can get or set the value of each attribute. We
saw this earlier in the C<print_info()> example, which calls C<<
$self->path >>.

=end original

属性には B<アクセサ> (accessor) メソッドを経由してのみアクセスすることを
勧めます。
これはそれぞれの属性の値を取得または設定するメソッドです。
既に、前述した C<print_info()> の例で、C<< $self->path >> を
呼び出しているのを見ています。

=begin original

You might also see the terms B<getter> and B<setter>. These are two
types of accessors. A getter gets the attribute's value, while a setter
sets it. Another term for a setter is B<mutator>

=end original

B<ゲッター> (getter) と B<セッター> (setter) という用語も見るかも知れません。
これらはアクセサの種類です。
ゲッターは属性の値を取得し、セッターは設定します。
セッターに関する別名は B<ミューテータ> (mutator) です。

=begin original

Attributes are typically defined as read-only or read-write. Read-only
attributes can only be set when the object is first created, while
read-write attributes can be altered at any time.

=end original

属性は典型的には読み込み専用または読み書き可能として定義されます。
読み込み専用属性はオブジェクトが最初に作成されるときにのみ設定でき、
読み書き可能属性はいつでも変更できます。

=begin original

The value of an attribute may itself be another object. For example,
instead of returning its last mod time as a number, the C<File> class
could return a L<DateTime> object representing that value.

=end original

属性の値それ自身が他のオブジェクトかも知れません。
例えば、最終更新時刻を数値として返す代わりに、C<File> クラスはその値を
表現する L<DateTime> オブジェクトを返すかも知れません。

=begin original

It's possible to have a class that does not expose any publicly
settable attributes. Not every class has attributes and methods.

=end original

設定可能な属性が一切公開されていないクラスも可能です。
全てのクラスが属性とメソッドを持っているというわけではありません。

=head2 Polymorphism

(多態性)

=begin original

B<Polymorphism> is a fancy way of saying that objects from two
different classes share an API. For example, we could have C<File> and
C<WebPage> classes which both have a C<print_content()> method. This
method might produce different output for each class, but they share a
common interface.

=end original

B<多態性> (polymorphism) は二つの異なるクラスが API を共有しているということを
示す変わった方法です。
例えば、どちらも C<print_content()> メソッドを持つ、C<File> クラスと
C<WebPage> クラスを持てます。
このメソッドはクラスごとに異なった出力を生成するかも知れませんが、共通の
インターフェースを共有します。

=begin original

While the two classes may differ in many ways, when it comes to the
C<print_content()> method, they are the same. This means that we can
try to call the C<print_content()> method on an object of either class,
and B<we don't have to know what class the object belongs to!>

=end original

二つのクラスはいろいろな意味で異なっているかも知れませんが、
C<print_content()> メソッドを呼び出すときには、これらは同じです。
これは、どちらのクラスのオブジェクトに対しても C<print_content()> を
呼び出そうとすることができて、B<オブジェクトがどのクラスに属しているかを
知る必要がないと言うことです!>

=begin original

Polymorphism is one of the key concepts of object-oriented design.

=end original

多態性はオブジェクト指向設計の鍵となる概念の一つです。

=head2 Inheritance

(継承)

=begin original

B<Inheritance> lets you create a specialized version of an existing
class. Inheritance lets the new class reuse the methods and attributes
of another class.

=end original

B<継承> は既にあるクラスの特殊版を作成できるようにします。
継承は他のクラスのメソッドと属性を再利用して新しいクラスを
作成できるようにします。

=begin original

For example, we could create a C<File::MP3> class which B<inherits>
from C<File>. A C<File::MP3> B<is-a> I<more specific> type of C<File>.
All mp3 files are files, but not all files are mp3 files.

=end original

例えば、C<File> から B<継承> した C<File::MP3> クラスを作成できます。
C<File::MP3> B<は> (is-a) C<File> の I<より特殊な> 型です。
全ての mp3 ファイルはファイルですが、全てのファイルが
mp3 ファイルというわけではありません。.

=begin original

We often refer to inheritance relationships as B<parent-child> or
C<superclass>/C<subclass> relationships. Sometimes we say that the
child has an B<is-a> relationship with its parent class.

=end original

継承関係はしばしば B<親-子> または C<スーパークラス>/C<サブクラス> 関係として
参照されます。
子は親クラスとの B<is-a> 関係を持つと表現することがあります。

=begin original

C<File> is a B<superclass> of C<File::MP3>, and C<File::MP3> is a
B<subclass> of C<File>.

=end original

C<File> は C<File::MP3> の B<スーパークラス> で、C<File::MP3> は C<File> の
B<サブクラス> です。

  package File::MP3;

  use parent 'File';

=begin original

The L<parent> module is one of several ways that Perl lets you define
inheritance relationships.

=end original

L<parent> モジュールは、Perl で継承関係を定義するいくつかの方法のひとつです。

=begin original

Perl allows multiple inheritance, which means that a class can inherit
from multiple parents. While this is possible, we strongly recommend
against it. Generally, you can use B<roles> to do everything you can do
with multiple inheritance, but in a cleaner way.

=end original

Perl は多重継承を認めています; つまり、クラスは複数の親から継承できます。
これは可能ですが、行わないように強く勧めます。
一般的に、多重継承で行えることは全て、B<ロール> を使うことでより
きれいな形で行えます。

=begin original

Note that there's nothing wrong with defining multiple subclasses of a
given class. This is both common and safe. For example, we might define
C<File::MP3::FixedBitrate> and C<File::MP3::VariableBitrate> classes to
distinguish between different types of mp3 file.

=end original

あるクラスに対して複数のサブクラスを定義することは何も悪くないことに
注意してください。
これは一般的でかつ安全です。
例えば、mp3 ファイルの異なった種類を区別するために、
C<File::MP3::FixedBitrate> クラスと C<File::MP3::VariableBitrate> クラスを
定義できます。

=head3 Overriding methods and method resolution

(メソッドのオーバーライドとメソッド解決)

=begin original

Inheritance allows two classes to share code. By default, every method
in the parent class is also available in the child. The child can
explicitly B<override> a parent's method to provide its own
implementation. For example, if we have a C<File::MP3> object, it has
the C<print_info()> method from C<File>:

=end original

継承は二つのクラスでコードを共有できるようにします。
デフォルトでは、親クラスの全てのメソッドは子でも利用可能です。
子は、独自の実装を提供することで親のメソッドを明示的に B<オーバーライド>
(override) できます。
例えば、C<File::MP3> オブジェクトがあれば、C<File> からの
C<print_info()> メソッドがあります:

  my $cage = File::MP3->new(
      path          => 'mp3s/My-Body-Is-a-Cage.mp3',
      content       => $mp3_data,
      last_mod_time => 1304974868,
      title         => 'My Body Is a Cage',
  );

  $cage->print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3

=begin original

If we wanted to include the mp3's title in the greeting, we could
override the method:

=end original

返り値に mp3 のタイトルを含めたい場合、メソッドをオーバーライドできます:

  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
      print "Its title is ", $self->title, "\n";
  }

  $cage->print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3
  # Its title is My Body Is a Cage

=begin original

The process of determining what method should be used is called
B<method resolution>. What Perl does is look at the object's class
first (C<File::MP3> in this case). If that class defines the method,
then that class's version of the method is called. If not, Perl looks
at each parent class in turn. For C<File::MP3>, its only parent is
C<File>. If C<File::MP3> does not define the method, but C<File> does,
then Perl calls the method in C<File>.

=end original

どのメソッドが使われるべきかを決定する処理は、B<メソッド解決>
(method resolution) と呼ばれます。
Perl が行うことは、まずオブジェクトのクラス (この場合は C<File::MP3>) を
見ます。
このクラスにメソッドが定義されていれば、そのクラスのメソッドが呼び出されます。
さもなければ、Perl は順番に親クラスを見ます。
C<File::MP3> の場合、唯一の親は C<File> です。
C<File::MP3> がメソッドを定義しておらず、C<File> が定義しているなら、
Perl は C<File> のメソッドを呼び出します。

=begin original

If C<File> inherited from C<DataSource>, which inherited from C<Thing>,
then Perl would keep looking "up the chain" if necessary.

=end original

C<File> が C<DataSource> から継承され、これが C<Thing> から継承されていれば、
Perl はもし必要なら「チェーンをたどって」探し続けます。

=begin original

It is possible to explicitly call a parent method from a child:

=end original

子から親メソッドを明示的に呼び出すことは可能です:

  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      $self->SUPER::print_info();
      print "Its title is ", $self->title, "\n";
  }

=begin original

The C<SUPER::> bit tells Perl to look for the C<print_info()> in the
C<File::MP3> class's inheritance chain. When it finds the parent class
that implements this method, the method is called.

=end original

C<SUPER::> は、C<File::MP3> クラスの継承チェーンから C<print_info()> を
探すように Perl に伝えます。
このメソッドを実装している親クラスが見つかると、そのメソッドが
呼び出されます。

=begin original

We mentioned multiple inheritance earlier. The main problem with
multiple inheritance is that it greatly complicates method resolution.
See L<perlobj> for more details.

=end original

以前に多重継承について述べました。
多重継承の主な問題は、メソッド解決が非常に込み入っているということです。
さらなる詳細については L<perlobj> を参照してください。

=head2 Encapsulation

(カプセル化)

=begin original

B<Encapsulation> is the idea that an object is opaque. When another
developer uses your class, they don't need to know I<how> it is
implemented, they just need to know I<what> it does.

=end original

B<カプセル化> は、オブジェクトを不透明にする考え方です。
他の開発者があなたのクラスを使うとき、I<どのように> 実装されているかを
知る必要はなく、単に I<何を> するかを知る必要があるだけです。

=begin original

Encapsulation is important for several reasons. First, it allows you to
separate the public API from the private implementation. This means you
can change that implementation without breaking the API.

=end original

カプセル化はいくつかの理由で重要です。
まず、これにより公的な API を内部の実装から分離できます。
これにより、API を壊すことなく実装を変更できます。

=begin original

Second, when classes are well encapsulated, they become easier to
subclass. Ideally, a subclass uses the same APIs to access object data
that its parent class uses. In reality, subclassing sometimes involves
violating encapsulation, but a good API can minimize the need to do
this.

=end original

次に、クラスが十分にカプセル化されていれば、サブクラス化が容易になります。
理想的には、サブクラスは親クラスが使っているオブジェクトデータに
アクセスするのに同じ API を使います。
実際には、サブクラス化は時々カプセル化に違反しますが、よい API は
その必要性を最小限にします。

=begin original

We mentioned earlier that most Perl objects are implemented as hashes
under the hood. The principle of encapsulation tells us that we should
not rely on this. Instead, we should use accessor methods to access the
data in that hash. The object systems that we recommend below all
automate the generation of accessor methods. If you use one of them,
you should never have to access the object as a hash directly.

=end original

既に、ほとんどの Perl オブジェクトは内部ではハッシュとして実装されていると
述べました。
カプセル化の原則は、このことに依存するべきではないと伝えています。
代わりに、ハッシュのデータにアクセスするためにアクセサメソッドを使います。
後に推奨するオブジェクトシステムは全てアクセサメソッドの生成を自動化します。
これらの一つを使うなら、オブジェクトをハッシュとして直接アクセスする必要は
ないはずです。

=head2 Composition

(包含)

=begin original

In object-oriented code, we often find that one object references
another object. This is called B<composition>, or a B<has-a>
relationship.

=end original

オブジェクト指向のコードでは、しばしばあるオブジェクトが他のオブジェクトを
参照しています。
これは B<包含> (composition)、または B<has-a> 関係と呼ばれます。

=begin original

Earlier, we mentioned that the C<File> class's C<last_mod_time>
accessor could return a L<DateTime> object. This is a perfect example
of composition. We could go even further, and make the C<path> and
C<content> accessors return objects as well. The C<File> class would
then be B<composed> of several other objects.

=end original

既に、C<File> クラスの C<last_mod_time> アクセサが L<DateTime> オブジェクトを
返すかも知れないことに触れました。
これは包含の完璧な例です。
さらに進めて、C<path> と C<content> アクセサもオブジェクトを返すようにも
できます。
そして C<File> クラスはいくつかのその他のオブジェクトの B<包含> になります。

=head2 Roles

(ロール)

=begin original

B<Roles> are something that a class I<does>, rather than something that
it I<is>. Roles are relatively new to Perl, but have become rather
popular. Roles are B<applied> to classes. Sometimes we say that classes
B<consume> roles.

=end original

B<ロール> は、クラスが I<何か> ではなく、クラスが I<何をするか> です。
ロールは Perl では比較的新しいですが、かなり人気になってきています。
ロールはクラスに B<適用> されます。
クラスがロールを B<消費> (consume) するということもあります。

=begin original

Roles are an alternative to inheritance for providing polymorphism.
Let's assume we have two classes, C<Radio> and C<Computer>. Both of
these things have on/off switches. We want to model that in our class
definitions.

=end original

ロールは多態性を提供するための継承の代替策です。
二つのクラス C<Radio> と C<Computer> があると考えます。
どちらもオン/オフするスイッチがあります。
これをクラス定義でモデル化したいとします。

=begin original

We could have both classes inherit from a common parent, like
C<Machine>, but not all machines have on/off switches. We could create
a parent class called C<HasOnOffSwitch>, but that is very artificial.
Radios and computers are not specializations of this parent. This
parent is really a rather ridiculous creation.

=end original

C<Machine> のように、共通の親から両方のクラスを継承することもできますが、
全ての機械にオン/オフスイッチがあるわけではありません。
C<HasOnOffSwitch> と呼ばれる親クラスを作ることもできますが、とても
不自然です。
ラジオとコンピュータはこの親の特殊化ではありません。
この親は実際にはかなりおかしなものです。

=begin original

This is where roles come in. It makes a lot of sense to create a
C<HasOnOffSwitch> role and apply it to both classes. This role would
define a known API like providing C<turn_on()> and C<turn_off()>
methods.

=end original

これはロールの出番です。
C<HasOnOffSwitch> ロールを作って両方のクラスに適用することは
とても合理的です。
このロールは C<turn_on()> と C<turn_off()> メソッドを提供するような
既知の API を定義します。

=begin original

Perl does not have any built-in way to express roles. In the past,
people just bit the bullet and used multiple inheritance. Nowadays,
there are several good choices on CPAN for using roles.

=end original

Perl にはロールを記述する組み込みの方法はありません。
以前は、人々は我慢して多重継承を使っていました。
最近は、ロールを使うためのいくつかの良い選択肢が CPAN にあります。

=head2 When to Use OO

(いつ OO を使うか)

=begin original

Object Orientation is not the best solution to every problem. In I<Perl
Best Practices> (copyright 2004, Published by O'Reilly Media, Inc.),
Damian Conway provides a list of criteria to use when deciding if OO is
the right fit for your problem:

=end original

オブジェクト指向は全ての問題に対する最良の解法というわけではありません。
I<Perl Best Practices> (copyright 2004, Published by O'Reilly Media, Inc.)
において、Damian Conway は OO が問題に正しく適応するかどうかを決定するときに
使う基準の一覧を提供しています:

=over 4

=item *

=begin original

The system being designed is large, or is likely to become large.

=end original

設計しているシステムが大きいか、大きくなりそう。

=item *

=begin original

The data can be aggregated into obvious structures, especially if
there's a large amount of data in each aggregate.

=end original

データが明らかな構造に集合できる; 特にそれぞれの集合が大量のデータを持つ。

=item *

=begin original

The various types of data aggregate form a natural hierarchy that
facilitates the use of inheritance and polymorphism.

=end original

様々な型のデータ集合が、継承と多態性を使うことが容易な自然な階層を形成する。

=item *

=begin original

You have a piece of data on which many different operations are
applied.

=end original

多くの異なった操作を適用するデータがある。

=item *

=begin original

You need to perform the same general operations on related types of
data, but with slight variations depending on the specific type of data
the operations are applied to.

=end original

データの種類に関係する同じ一般的な操作をする必要があるが、操作を適用する
データの特定の種類に依存して少しずつ変化がある。

=item *

=begin original

It's likely you'll have to add new data types later.

=end original

後で新しいデータ型を追加する必要がありそう。

=item *

=begin original

The typical interactions between pieces of data are best represented by
operators.

=end original

データ間の典型的な相互作用は演算子によって最もよく表現される。

=item *

=begin original

The implementation of individual components of the system is likely to
change over time.

=end original

システムの独立した要素の実装が時間につれて変化しそう。

=item *

=begin original

The system design is already object-oriented.

=end original

システムの設計が既にオブジェクト指向である。

=item *

=begin original

Large numbers of other programmers will be using your code modules.

=end original

多くのプログラマがこのコードモジュールを使う。

=back

=head1 PERL OO SYSTEMS

(Perl の OO システム)

=begin original

As we mentioned before, Perl's built-in OO system is very minimal, but
also quite flexible. Over the years, many people have developed systems
which build on top of Perl's built-in system to provide more features
and convenience.

=end original

前述したように、Perl の組み込みの OO システムは非常に最小限ですが、
一方とても柔軟です。
年を重ねるにつれて、多くの人々がより多くの機能と利便性を提供するために
Perl の組み込みのシステムの上に構築されたシステムを開発しました。

=begin original

We strongly recommend that you use one of these systems. Even the most
minimal of them eliminates a lot of repetitive boilerplate. There's
really no good reason to write your classes from scratch in Perl.

=end original

私たちはこれらのシステムの一つを使うことを強く勧めます。
それらの中の最小限のものでも多くの繰り返される定型文を排除できます。
Perl でクラスを一から書く本当にいい理由というものはありません。

=begin original

If you are interested in the guts underlying these systems, check out
L<perlobj>.

=end original

これらのシステムの基礎となる内部に興味があるなら、 L<perlobj> を
調べてください。

=head2 Moose

=begin original

L<Moose> bills itself as a "postmodern object system for Perl 5". Don't
be scared, the "postmodern" label is a callback to Larry's description
of Perl as "the first postmodern computer language".

=end original

L<Moose> は自分自身を「Perl 5 のためのポストモダンオブジェクトシステム」と
宣伝しています。
怖がらなくても大丈夫です; 「ポストモダン」というのはラリーが Perl のことを
「最初のポストモダンコンピュータ言語」と説明したことにちなんでいます。

=begin original

C<Moose> provides a complete, modern OO system. Its biggest influence
is the Common Lisp Object System, but it also borrows ideas from
Smalltalk and several other languages. C<Moose> was created by Stevan
Little, and draws heavily from his work on the Raku OO design.

=end original

C<Moose> は完全でモダンな OO システムを提供します。
その最大の影響元は Common Lisp Object System ですが、Smalltalk およびその他の
いくつかの言語からもアイデアを借りています。
C<Moose> は Stevan Little によって作成され、彼の Raku OO 設計に関する
作業から多くを引いています。

=begin original

Here is our C<File> class using C<Moose>:

=end original

以下は C<Moose> を使った C<File> クラスです:

  package File;
  use Moose;

  has path          => ( is => 'ro' );
  has content       => ( is => 'ro' );
  has last_mod_time => ( is => 'ro' );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

=begin original

C<Moose> provides a number of features:

=end original

C<Moose> は多くの機能を提供します:

=over 4

=item * Declarative sugar

(構文糖)

=begin original

C<Moose> provides a layer of declarative "sugar" for defining classes.
That sugar is just a set of exported functions that make declaring how
your class works simpler and more palatable.  This lets you describe
I<what> your class is, rather than having to tell Perl I<how> to
implement your class.

=end original

C<Moose> はクラスを定義するために、宣言的な「糖」の層を提供します。
この糖は、クラスがより簡単に、使いやすくなるようにするための単に
エクスポートされた関数の集合です。
これは Perl が I<どのように> クラスを実装するのかを教えるように
するのではなく、クラスが I<何を> するかを表現するようにします。

=begin original

The C<has()> subroutine declares an attribute, and C<Moose>
automatically creates accessors for these attributes. It also takes
care of creating a C<new()> method for you. This constructor knows
about the attributes you declared, so you can set them when creating a
new C<File>.

=end original

C<has()> サブルーチンは属性を定義し、C<Moose> は自動的にそれらの属性のための
アクセサを作成します。
また、C<new()> メソッドの面倒も見ます。
このコンストラクタは宣言された属性について知っているので、
新しい C<File> を作成するときにそれを設定できます。

=item * Roles built-in

(組み込みのロール)

=begin original

C<Moose> lets you define roles the same way you define classes:

=end original

C<Moose> はクラスを定義するのと同じようにロールを定義できます:

  package HasOnOffSwitch;
  use Moose::Role;

  has is_on => (
      is  => 'rw',
      isa => 'Bool',
  );

  sub turn_on {
      my $self = shift;
      $self->is_on(1);
  }

  sub turn_off {
      my $self = shift;
      $self->is_on(0);
  }

=item * A miniature type system

(小型の型システム)

=begin original

In the example above, you can see that we passed C<< isa => 'Bool' >>
to C<has()> when creating our C<is_on> attribute. This tells C<Moose>
that this attribute must be a boolean value. If we try to set it to an
invalid value, our code will throw an error.

=end original

前述の例では、C<is_on> 属性を作成するときに C<has()> に
C<< isa => 'Bool' >> を渡します。
これは C<Moose> に、この属性は真偽値でなければならないということを示します。
これに不正な値を設定しようとすると、エラーを投げます。

=item * Full introspection and manipulation

(完全なイントロスペクションと操作)

=begin original

Perl's built-in introspection features are fairly minimal. C<Moose>
builds on top of them and creates a full introspection layer for your
classes. This lets you ask questions like "what methods does the File
class implement?" It also lets you modify your classes
programmatically.

=end original

Perl の組み込みのイントロスペクション機能はかなり最低限です。
C<Moose> はこれらの上に構築され、クラスのための完全なイントロスペクション
層を作成します。
これにより、「File クラスに実装されているメソッドは何?」といった問い合わせが
できます。
また、クラスをプログラムで修正できます。

=item * Self-hosted and extensible

(セルフホスティングと拡張性)

=begin original

C<Moose> describes itself using its own introspection API. Besides
being a cool trick, this means that you can extend C<Moose> using
C<Moose> itself.

=end original

C<Moose> は自分自身を自身のイントロスペクション API を使って記述しています。
かっこいい技という以外に、これは C<Moose> 自身を使って C<Moose> を
拡張できるということです。

=item * Rich ecosystem

(豊かなエコシステム)

=begin original

There is a rich ecosystem of C<Moose> extensions on CPAN under the
L<MooseX|https://metacpan.org/search?q=MooseX>
namespace. In addition, many modules on CPAN already use C<Moose>,
providing you with lots of examples to learn from.

=end original

CPAN の L<MooseX|https://metacpan.org/search?q=MooseX>
名前空間に、C<Moose> 拡張の豊かなエコシステムがあります。
さらに、CPAN の多くのモジュールは既に C<Moose> を使っていて、そこから学べる
多くの例を提供しています。

=item * Many more features

(さらに多くの機能)

=begin original

C<Moose> is a very powerful tool, and we can't cover all of its
features here. We encourage you to learn more by reading the C<Moose>
documentation, starting with
L<Moose::Manual|https://metacpan.org/pod/Moose::Manual>.

=end original

C<Moose> はとても強力なツールで、その機能の全てについてここで触れることは
できません。
さらに学ぶために、C<Moose> の文書を
L<Moose::Manual|https://metacpan.org/pod/Moose::Manual> から
読むことを勧めます。

=back

=begin original

Of course, C<Moose> isn't perfect.

=end original

もちろん、C<Moose> は完璧ではありません。

=begin original

C<Moose> can make your code slower to load. C<Moose> itself is not
small, and it does a I<lot> of code generation when you define your
class. This code generation means that your runtime code is as fast as
it can be, but you pay for this when your modules are first loaded.

=end original

C<Moose> によってコードの読み込みが遅くなることがあります。
C<Moose> 自身が小さくなく、またクラスを定義するときに I<大量> の
コードを生成します。
このコード生成は、実行時コードは可能な限り高速であることを意味しますが、
このためにモジュールが最初に読み込まれるときにコストを支払うことになります。

=begin original

This load time hit can be a problem when startup speed is important,
such as with a command-line script or a "plain vanilla" CGI script that
must be loaded each time it is executed.

=end original

この読み込み時間は、実行時に毎回読み込みしなければならない
コマンドラインスクリプトや「何の変哲もない」CGIスクリプトのように、
起動速度が重要な場合には問題になり得ます。

=begin original

Before you panic, know that many people do use C<Moose> for
command-line tools and other startup-sensitive code. We encourage you
to try C<Moose> out first before worrying about startup speed.

=end original

うろたえる前に、多くの人々がコマンドラインツールやその他の起動時間が重要な
コードに C<Moose> を使っていることを知ってください。
起動速度について気にする前にまず C<Moose> を試してみることを勧めます。

=begin original

C<Moose> also has several dependencies on other modules. Most of these
are small stand-alone modules, a number of which have been spun off
from C<Moose>. C<Moose> itself, and some of its dependencies, require a
compiler. If you need to install your software on a system without a
compiler, or if having I<any> dependencies is a problem, then C<Moose>
may not be right for you.

=end original

C<Moose> はまた他のモジュールに対していくつかの依存があります。
それらのほとんどは小さいスタンドアロンのモジュールで、いくつかは
C<Moose> から切り離されたものです。
C<Moose> 自身と、その依存のいくつかは、コンパイラを必要とします。
コンパイラのないシステムにインストールする必要があったり、I<どんな>
依存があっても問題がある場合は、C<Moose> は適切ではないかも知れません。

=head3 Moo

=begin original

If you try C<Moose> and find that one of these issues is preventing you
from using C<Moose>, we encourage you to consider L<Moo> next. C<Moo>
implements a subset of C<Moose>'s functionality in a simpler package.
For most features that it does implement, the end-user API is
I<identical> to C<Moose>, meaning you can switch from C<Moo> to
C<Moose> quite easily.

=end original

C<Moose> を試してみて、これらの理由の一つが C<Moose> を使うのを
妨げているなら、次に L<Moo> を考慮するのを勧めます。
C<Moo> は C<Moose> の機能のサブセットをより単純なパッケージで実装しています。
実装されているほとんどの機能について、エンドユーザー API は C<Moose> と
I<同一> です; つまり C<Moo> から C<Moose> にとても簡単に
切り替えられるということです。

=begin original

C<Moo> does not implement most of C<Moose>'s introspection API, so it's
often faster when loading your modules. Additionally, none of its
dependencies require XS, so it can be installed on machines without a
compiler.

=end original

C<Moo> は C<Moose> のイントロスペクション API を実装しておらず、従って
モジュールを読み込むときはしばしばより速いです。
さらに、XS が必要な依存はないので、コンパイラのないマシンでも
インストールできます。

=begin original

One of C<Moo>'s most compelling features is its interoperability with
C<Moose>. When someone tries to use C<Moose>'s introspection API on a
C<Moo> class or role, it is transparently inflated into a C<Moose>
class or role. This makes it easier to incorporate C<Moo>-using code
into a C<Moose> code base and vice versa.

=end original

C<Moo> の最も切実な機能は C<Moose> との相互運用性です。
C<Moose> のイントロスペクション API を C<Moo> のクラスやロールで使おうと
した場合、透過的に C<Moose> のクラスやロールに変換されます。
これにより、C<Moo> を使ったコードと C<Moose> を使ったコードベースに組み込む、
またはその逆を行うことがより容易になります。

=begin original

For example, a C<Moose> class can subclass a C<Moo> class using
C<extends> or consume a C<Moo> role using C<with>.

=end original

例えば、ある C<Moose> のクラスは、C<extends> を使った C<Moo> のクラスの
サブクラスになったり、C<with> を使った C<Moo> のロールを消費したりできます。

=begin original

The C<Moose> authors hope that one day C<Moo> can be made obsolete by
improving C<Moose> enough, but for now it provides a worthwhile
alternative to C<Moose>.

=end original

C<Moose> の作者は、いつの日か C<Moose> が十分改良されることによって
C<Moo> が古いものになることを望んでいますが、今のところは C<Moose> に対する
価値のある代替を提供します。

=head2 Class::Accessor

=begin original

L<Class::Accessor> is the polar opposite of C<Moose>. It provides very
few features, nor is it self-hosting.

=end original

L<Class::Accessor> は C<Moose> の対極です。
非常に少ない機能しか提供しませんし、セルフホスティングでもありません。

=begin original

It is, however, very simple, pure Perl, and it has no non-core
dependencies. It also provides a "Moose-like" API on demand for the
features it supports.

=end original

しかし、とても単純で、ピュア Perl で、非コア依存はありません。
また、対応している機能に対する「Moose 風」 API も提供しています。

=begin original

Even though it doesn't do much, it is still preferable to writing your
own classes from scratch.

=end original

多くのことはしませんが、それでもクラスを一から書くよりは望ましいです。

=begin original

Here's our C<File> class with C<Class::Accessor>:

=end original

以下に C<Class::Accessor> を使った C<File> クラスを示します:

  package File;
  use Class::Accessor 'antlers';

  has path          => ( is => 'ro' );
  has content       => ( is => 'ro' );
  has last_mod_time => ( is => 'ro' );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

=begin original

The C<antlers> import flag tells C<Class::Accessor> that you want to
define your attributes using C<Moose>-like syntax. The only parameter
that you can pass to C<has> is C<is>. We recommend that you use this
Moose-like syntax if you choose C<Class::Accessor> since it means you
will have a smoother upgrade path if you later decide to move to
C<Moose>.

=end original

C<antlers> インポートフラグは、属性を C<Moose> 風の文法で定義したいことを
C<Class::Accessor> に伝えます。
C<has> に渡せる唯一の引数は C<is> です。
C<Class::Accessor> を選択した場合は、この Moose 風の文法を使うことを勧めます;
なぜなら後に C<Moose> に移行しようと決めたときによりスムーズに
アップグレードできるからです。

=begin original

Like C<Moose>, C<Class::Accessor> generates accessor methods and a
constructor for your class.

=end original

C<Moose> と同様、C<Class::Accessor> はアクセサメソッドとコンストラクタを
生成します。

=head2 Class::Tiny

=begin original

Finally, we have L<Class::Tiny>. This module truly lives up to its
name. It has an incredibly minimal API and absolutely no dependencies
on any recent Perl. Still, we think it's a lot easier to use than
writing your own OO code from scratch.

=end original

最後に、L<Class::Tiny> があります。
このモジュールはまさにその名前通りです。
これは非常に最小限の API のみを持ち、最近の Perl では全く依存はありません。
それでも、一から独自の OO コードを書くよりも遙かに簡単に使えます。

=begin original

Here's our C<File> class once more:

=end original

以下に C<File> クラスをもう一度示します:

  package File;
  use Class::Tiny qw( path content last_mod_time );

  sub print_info {
      my $self = shift;

      print "This file is at ", $self->path, "\n";
  }

=begin original

That's it!

=end original

これだけです!

=begin original

With C<Class::Tiny>, all accessors are read-write. It generates a
constructor for you, as well as the accessors you define.

=end original

C<Class::Tiny> では、全てのアクセサは読み書き可能です。
コンストラクタと、定義したアクセサを生成します。

=begin original

You can also use L<Class::Tiny::Antlers> for C<Moose>-like syntax.

=end original

C<Moose> 風の文法の L<Class::Tiny::Antlers> も使えます。

=head2 Role::Tiny

=begin original

As we mentioned before, roles provide an alternative to inheritance,
but Perl does not have any built-in role support. If you choose to use
Moose, it comes with a full-fledged role implementation. However, if
you use one of our other recommended OO modules, you can still use
roles with L<Role::Tiny>.

=end original

前述したように、ロールは継承の代替策を提供しますが、Perl には組み込みの
ロール対応はありません。
Moose を使うことを選んだ場合、完全なロール実装が同梱されています。
しかし、その他の推奨 OO モジュールを使う場合、L<Role::Tiny> で
ロールを使えます。

=begin original

C<Role::Tiny> provides some of the same features as Moose's role
system, but in a much smaller package. Most notably, it doesn't support
any sort of attribute declaration, so you have to do that by hand.
Still, it's useful, and works well with C<Class::Accessor> and
C<Class::Tiny>.

=end original

C<Role::Tiny> は Moose のロールシステムと同じような機能を提供しますが、
パッケージは遙かに小さいです。
特に、属性宣言には対応していないので、手動で行う必要があります。
それでも、これは有用で、C<Class::Accessor> および C<Class::Tiny> と
うまく動作します。

=head2 OO System Summary

(OO システムの要約)

=begin original

Here's a brief recap of the options we covered:

=end original

以下はここで取り上げた選択肢の簡潔なまとめです:

=over 4

=item * L<Moose>

=begin original

C<Moose> is the maximal option. It has a lot of features, a big
ecosystem, and a thriving user base. We also covered L<Moo> briefly.
C<Moo> is C<Moose> lite, and a reasonable alternative when Moose
doesn't work for your application.

=end original

C<Moose> は最大限のオプションです。
多くの機能、大きなエコシステム、繁栄しているユーザーベースがあります。
また、L<Moo> も簡単に取り上げました。
C<Moo> は C<Moose> の簡略版で、Moose があなたのアプリケーションで
動作しないときの妥当な代替案です。

=item * L<Class::Accessor>

=begin original

C<Class::Accessor> does a lot less than C<Moose>, and is a nice
alternative if you find C<Moose> overwhelming. It's been around a long
time and is well battle-tested. It also has a minimal C<Moose>
compatibility mode which makes moving from C<Class::Accessor> to
C<Moose> easy.

=end original

C<Class::Accessor> がすることは C<Moose> よりもとても少なく、C<Moose> が
おおげさな時にはよい選択肢です。
長い間存在し、よくテストされています。
C<Class::Accessor> から C<Moose> への以降を容易にするための最小限の
C<Moose> 互換モードもあります。

=item * L<Class::Tiny>

=begin original

C<Class::Tiny> is the absolute minimal option. It has no dependencies,
and almost no syntax to learn. It's a good option for a super minimal
environment and for throwing something together quickly without having
to worry about details.

=end original

C<Class::Tiny> は明らかに最小限のオプションです。
依存はなく、学ぶ必要のある文法もほとんどありません。
超最小限環境の場合や詳細について心配することなく素早く何かを作るときには
よいオプションです。

=item * L<Role::Tiny>

=begin original

Use C<Role::Tiny> with C<Class::Accessor> or C<Class::Tiny> if you find
yourself considering multiple inheritance. If you go with C<Moose>, it
comes with its own role implementation.

=end original

多重継承について考えているなら C<Class::Accessor> または C<Class::Tiny> と
共に C<Role::Tiny> を使ってください。
C<Moose> を使っているなら、独自のロール実装が同梱されています。

=back

=head2 Other OO Systems

(その他の OO システム)

=begin original

There are literally dozens of other OO-related modules on CPAN besides
those covered here, and you're likely to run across one or more of them
if you work with other people's code.

=end original

ここで扱ったものの他に、CPAN には文字通り数十のその他の OO 関連の
モジュールがあり、他の人のコードを動かすときにはおそらく
それらのいくつかを使っているでしょう。

=begin original

In addition, plenty of code in the wild does all of its OO "by hand",
using just the Perl built-in OO features. If you need to maintain such
code, you should read L<perlobj> to understand exactly how Perl's
built-in OO works.

=end original

さらに、世の中の多くのコードは全ての OO を「手動で」、単に Perl 組み込みの
OO 機能を使って行っています。
もしそのようなコードを保守する必要があるなら、Perl の組み込みの OO が
どのように動作するのかを正確に理解するためにL<perlobj> を読むべきです。

=head1 CONCLUSION

(まとめ)

=begin original

As we said before, Perl's minimal OO system has led to a profusion of
OO systems on CPAN. While you can still drop down to the bare metal and
write your classes by hand, there's really no reason to do that with
modern Perl.

=end original

既に述べたように、Perl の最小限の OO システムは CPAN での豊富な OO システムを
生み出しました。
今でもこの地金まで降りていってクラスを手で書くこともできる一方、
モダン Perl においてそうする理由は本当はありません。

=begin original

For small systems, L<Class::Tiny> and L<Class::Accessor> both provide
minimal object systems that take care of basic boilerplate for you.

=end original

小さいシステムなら、L<Class::Tiny> と L<Class::Accessor> の両方は
基本的な定型文の面倒を見る最小限のオブジェクトシステムを提供します。

=begin original

For bigger projects, L<Moose> provides a rich set of features that will
let you focus on implementing your business logic. L<Moo> provides a
nice alternative to L<Moose> when you want a lot of features but need
faster compile time or to avoid XS.

=end original

より大きいプロジェクトなら、L<Moose> はあなたがビジネスロジックの実装に
集中できるような豊富な機能セットを提供します。
多くの機能が必要だけれどもより早いコンパイル時間が必要だったり
XS を避けたい場合、L<Moo> は L<Moose> のよい代替案です。

=begin original

We encourage you to play with and evaluate L<Moose>, L<Moo>,
L<Class::Accessor>, and L<Class::Tiny> to see which OO system is right
for you.

=end original

どの OO システムが適しているかを見るために、L<Moose>, L<Moo>,
L<Class::Accessor>, L<Class::Tiny> を試して評価することをお勧めします。

=cut

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org> (5.16.1-)
Status: completed

=end meta

