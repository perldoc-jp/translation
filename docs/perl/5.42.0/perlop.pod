
=encoding utf8

=head1 NAME
X<operator>

=begin original

perlop - Perl expressions: operators, precedence, string literals

=end original

perlop - Perl の式: 演算子、優先順位、文字列リテラル

=head1 DESCRIPTION

=begin original

In Perl, the operator determines what operation is performed,
independent of the type of the operands.  For example S<C<$x + $y>>
is always a numeric addition, and if C<$x> or C<$y> do not contain
numbers, an attempt is made to convert them to numbers first.

=end original

Perl では、演算子はどんな演算を行うかをオペランドの型と独立して決定します。
例えば S<C<$x + $y>> は常に数値加算で、C<$x> や C<$y> に数値でないものが
含まれている場合、まずそれらを数値に変換しようとします。

=begin original

This is in contrast to many other dynamic languages, where the
operation is determined by the type of the first argument.  It also
means that Perl has two versions of some operators, one for numeric
and one for string comparison.  For example S<C<$x == $y>> compares
two numbers for equality, and S<C<$x eq $y>> compares two strings.

=end original

これは、最初の引数の型によって演算が決定されるその他の多くの動的言語と
対照的です。
これはまた、数値比較用と文字列比較用の 2 種類の演算子があるということです。
例えば S<C<$x == $y>> は二つの数値の等価性を比較し、S<C<$x eq $y>> は二つの
文字列を比較します。

=begin original

There are a few exceptions though: The operator C<x> can be either string
repetition or list repetition, depending on the type of the left
operand, and C<&>, C<|>, C<^> and C<~> can be either string or numeric bit
operations.

=end original

しかし、いくつかの例外があります: 演算子 C<x> は左オペランドの型によって、
文字列の繰り返しの場合とリストの繰り返しの場合があります; また
C<&>, C<|>, C<^>, C<~> は文字列としてのビット演算と数値としてのビット演算の
場合があります。

=head2 Operator Precedence and Associativity
X<operator, precedence> X<precedence> X<associativity>

(演算子の優先順位と結合性)

=begin original

Operator precedence and associativity work in Perl more or less like
they do in mathematics.

=end original

Perl での演算子の優先順位と結合性は多かれ少なかれ数学のものと似ています。

=begin original

I<Operator precedence> means some operators group more tightly than others.
For example, in C<2 + 4 * 5>, the multiplication has higher precedence, so C<4
* 5> is grouped together as the right-hand operand of the addition, rather
than C<2 + 4> being grouped together as the left-hand operand of the
multiplication. It is as if the expression were written C<2 + (4 * 5)>, not
C<(2 + 4) * 5>. So the expression yields C<2 + 20 == 22>, rather than
C<6 * 5 == 30>.

=end original

I<演算子の優先順位> とは、他の演算子グループよりもしっかりと
結びついている演算子グループがあるということです。
例えば、C<2 + 4 * 5> の場合、乗算が高い優先順位を持っているので、
C<2 + 4> が乗算の左オペランドとしてまとめられるのではなく、
C<4 * 5> が加法の右オペランドとしてまとめられます。
これは、C<(2 + 4) * 5> ではなく、C<2 + (4 * 5)> と
書かれたかのようなものです。
従って、この式は C<6 * 5 == 30> ではなく C<2 + 20 == 22> になります。

=begin original

I<Operator associativity> defines what happens if a sequence of the same
operators is used one after another:
usually that they will be grouped at the left
or the right. For example, in C<9 - 3 - 2>, subtraction is left associative,
so C<9 - 3> is grouped together as the left-hand operand of the second
subtraction, rather than C<3 - 2> being grouped together as the right-hand
operand of the first subtraction. It is as if the expression were written
C<(9 - 3) - 2>, not C<9 - (3 - 2)>. So the expression yields C<6 - 2 == 4>,
rather than C<9 - 1 == 8>.

=end original

I<演算子の結合性> は、同じ演算子が連続して現れた場合に何が起こるかを
定義します: 通常はそれらが左側と結びつくか右側と結びつくかです。
例えば C<9 - 3 - 2>で、減法は左結合なので、
C<3 - 2> が最初の減法の右オペランドとしてまとめられるのではなく、
C<9 - 3> が 2 番目の減法の左オペランドとしてまとめられます。
これは、C<9 - (3 - 2)> ではなく C<(9 - 3) - 2> と書かれたかのようなものです。
従って、この式は C<9 - 1 == 8> ではなく C<6 - 2 == 4> になります。

=begin original

For simple operators that evaluate all their operands and then combine the
values in some way, precedence and associativity (and parentheses) imply some
ordering requirements on those combining operations. For example, in C<2 + 4 *
5>, the grouping implied by precedence means that the multiplication of 4 and
5 must be performed before the addition of 2 and 20, simply because the result
of that multiplication is required as one of the operands of the addition. But
the order of operations is not fully determined by this: in C<2 * 2 + 4 * 5>
both multiplications must be performed before the addition, but the grouping
does not say anything about the order in which the two multiplications are
performed. In fact Perl has a general rule that the operands of an operator
are evaluated in left-to-right order. A few operators such as C<&&=> have
special evaluation rules that can result in an operand not being evaluated at
all; in general, the top-level operator in an expression has control of
operand evaluation.

=end original

全てのオペランドを評価してから何らかの形で値を結合する
単純な演算子の場合、優先順位と結合性(とかっこ)はそれらの結合操作で
ある種の順序要求を暗示します。
例えば C<2 + 4 * 5> では、
優先順位が暗示するグループ化によって、
4 と 5 の乗算は
2 と 20 の加算の前に行われる必要があります;
単にこの乗法の結果が加法のオペランドの一つとして必要だからです。
しかし、演算の順序はこれによって完全に決定されるわけではありません:
C<2 * 2 + 4 * 5> では、両方の乗算は加算の前に行われなければなりませんが、
グループ化は二つの乗算が行われる順序については何も言っていません。
実際の所、Perl には、演算子のオペランドは左から右の順で
評価されるという一般的な規則があります。
C<&&=> のようないくつかの演算子は、
全く評価されないオペランドとなる特別な評価規則を持ちます;
一般的に、式の中の最上位の演算子がオペランド評価を制御します。

=begin original

Some comparison operators, as their associativity, I<chain> with some
operators of the same precedence (but never with operators of different
precedence).  This chaining means that each comparison is performed
on the two arguments surrounding it, with each interior argument taking
part in two comparisons, and the comparison results are implicitly ANDed.
Thus S<C<"$x E<lt> $y E<lt>= $z">> behaves exactly like S<C<"$x E<lt>
$y && $y E<lt>= $z">>, assuming that C<"$y"> is as simple a scalar as
it looks.  The ANDing short-circuits just like C<"&&"> does, stopping
the sequence of comparisons as soon as one yields false.

=end original

一部の比較演算子は、それらの優先順位と、
同じ優先順位を持つ一部の演算子と I<連鎖> させることができます
(異なる優先順位を持つ演算子とはできません)。
連鎖というのは、それぞれの比較はそれらの周りの二つの引数に対して
行われ、それぞれの内部引数は二つの比較の一部となり、比較結果は
暗黙に AND されるということです。
従って S<C<"$x E<lt> $y E<lt>= $z">> は、C<"$y"> が見た目単純な
スカラだと仮定すると、
S<C<"$x E<lt> $y && $y E<lt>= $z">> と正確に同じように振る舞います。
AND の短絡は C<"&&"> と同様に行われ、一つが偽となった時点で一連の連鎖は
停止します。

=begin original

In a chained comparison, each argument expression is evaluated at most
once, even if it takes part in two comparisons, but the result of the
evaluation is fetched for each comparison.  (It is not evaluated
at all if the short-circuiting means that it's not required for any
comparisons.)  This matters if the computation of an interior argument
is expensive or non-deterministic.  For example,

=end original

連鎖比較において、それぞれの引数式は、例え二つの比較の一部となったとしても、
評価されるのは最大 1 回ですが、評価の結果はそれぞれの比較毎に取得されます。
(短絡によって比較が必要でない場合は、まったく評価されません。)
これは、内側の引数の計算が高価だったり非決定的だったりする場合に
問題になります。
例えば:

    if ($x < expensive_sub() <= $z) { ...

=begin original

is not entirely like

=end original

これは全体的に次のようなものではなく:

    if ($x < expensive_sub() && expensive_sub() <= $z) { ...

=begin original

but instead closer to

=end original

しかし次のものに近いです:

    my $tmp = expensive_sub();
    if ($x < $tmp && $tmp <= $z) { ...

=begin original

in that the subroutine is only called once.  However, it's not exactly
like this latter code either, because the chained comparison doesn't
actually involve any temporary variable (named or otherwise): there is
no assignment.  This doesn't make much difference where the expression
is a call to an ordinary subroutine, but matters more with an lvalue
subroutine, or if the argument expression yields some unusual kind of
scalar by other means.  For example, if the argument expression yields
a tied scalar, then the expression is evaluated to produce that scalar
at most once, but the value of that scalar may be fetched up to twice,
once for each comparison in which it is actually used.

=end original

ここでサブルーチンは 1 回だけ呼び出されます。
しかし、正確に後者のコードのようなものでもありません; なぜなら
連鎖比較は実際には(名前付きかどうかにかかわらず)一時変数を使わないからです;
代入はありません。
これは、式が通常のサブルーチンとして呼び出されるときにはあまり違いは
ありませんが、左辺値サブルーチンの呼び出しの場合や、引数式が
他の手段によって何らかの普通でない種類のスカラになった場合には
より問題になります。
例えば、引数式が tie されたスカラになった場合、式はスカラを作るために
最大 1 回評価されますが、スカラの値は、実際に使われる比較毎に 1 回、
合計 2 回読み込まれます。

=begin original

In this example, the expression is evaluated only once, and the tied
scalar (the result of the expression) is fetched for each comparison that
uses it.

=end original

この例で、式は 1 回だけ評価され、tie されたスカラ (式の結果) は、
これら使われる比較毎に取得されます。

    if ($x < $tied_scalar < $z) { ...

=begin original

In the next example, the expression is evaluated only once, and the tied
scalar is fetched once as part of the operation within the expression.
The result of that operation is fetched for each comparison, which
normally doesn't matter unless that expression result is also magical due
to operator overloading.

=end original

次の例では、式は 1 回だけ評価され、 tie されたスカラは式の中の演算の
一部として 1 回だけ取得されます。
この演算の結果は比較毎に取得されます;
通常これは、式の結果も演算子オーバーロードによってマジカルでない限り、
関係ありません。

    if ($x < $tied_scalar + 42 < $z) { ...

=begin original

Some operators are instead non-associative, meaning that it is a syntax
error to use a sequence of those operators of the same precedence.
For example, S<C<"$x .. $y .. $z">> is an error.

=end original

一部の演算子は非結合です; 同じ優先順位の演算子の並びを使うと
文法エラーになります。
例えば、S<C<"$x .. $y .. $z">> はエラーです。

=begin original

Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.  Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.  (This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.

=end original

Perl の演算子には、以下のような結合性と優先順位 (高い優先順位から
低いものへ並べている) があります。
C から持ってきた演算子の優先順位は、C での優先順位が多少おかしくても、
そのままにしてあります。
(これによって、C を使っている方が Perl に移りやすくなっています。)
ごく僅かな例外を別として、全ての演算子はスカラ値のみを持ち、
配列値を持ちません。

=begin original

    left        terms and list operators (leftward)
    left        ->
    nonassoc    ++ --
    right       **
    right       ! ~ ~. \ and unary + and -
    left        =~ !~
    left        * / % x
    left        + - .
    left        << >>
    nonassoc    named unary operators
    nonassoc    isa
    chained     < > <= >= lt gt le ge
    chain/na    == != eq ne <=> cmp ~~
    left        & &.
    left        | |. ^ ^.
    left        &&
    left        || ^^ //
    nonassoc    ..  ...
    right       ?:
    right       = += -= *= etc. goto last next redo dump
    left        , =>
    nonassoc    list operators (rightward)
    right       not
    left        and
    left        or xor

=end original

    左結合      項  リスト演算子 (左方向に対して)
    左結合      ->
    非結合      ++ --
    右結合      **
    右結合      ! ~ ~. \ 単項の+ 単項の-
    左結合      =~ !~
    左結合      * / % x
    左結合      + - .
    左結合      << >>
    非結合      名前付き単項演算子
    連鎖        < > <= >= lt gt le ge
    連鎖/なし   == != eq ne <=> cmp ~~
    非結合      isa
    左結合      & &.
    左結合      | |. ^ ^.
    左結合      &&
    左結合      || ^^ //
    非結合      .. ...
    右結合      ?:
    右結合      = += -= *= など; goto last next redo dump
    左結合      , =>
    非結合      リスト演算子 (右方向に対して)
    右結合      not
    左結合      and
    左結合      or xor

=begin original

The following sections cover these operators in detail.  Each section
covers all the operators for a single precedence level.  The sections
are ordered highest precedence first, same as in the table above.

=end original

以下の章では、これらの演算子に関して詳述します。
それぞれの節は、一つの優先順位レベルの全ての演算子を取り上げています。
節は前述の表と同様、最も高い優先順位を持つものが最初に来ています。

=begin original

Many operators can be overloaded for objects.  See L<overload>.

=end original

多くの演算子はオブジェクトでオーバーロードできます。
L<overload> を参照して下さい。

=head2 Terms and List Operators (Leftward)
X<list operator> X<operator, list> X<term>

(項とリスト演算子 (左方向))

=begin original

A TERM has the highest precedence in Perl.  They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in L<perlfunc>.

=end original

「項」は Perl でもっとも優先順位が高いものです。
これには、変数、クォートとクォート的な演算子、括弧で括った任意の式、
引数を括弧で括った任意の関数が含まれます。
実際には、この意味では本当の関数はなく、リスト演算子と関数のように働く
単項演算子が、引数を括弧で括るためそのように見えます。
これらはすべて L<perlfunc> に記述しています。

=begin original

If any list operator (C<print()>, etc.) or any unary operator (C<chdir()>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

=end original

リスト演算子 (C<print()> など) や単項演算子 (C<chdir()> など) は、
すべて次のトークンとして開き括弧が続くと、その演算子と括弧内の引数は、
通常の関数呼び出しのようにもっとも高い優先順位として扱われます。

=begin original

In the absence of parentheses, the precedence of list operators such as
C<print>, C<sort>, or C<chmod> is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.
For example, in

=end original

括弧が無い場合には、C<print>、C<sort>、C<chmod> のようなリスト演算子の
優先順位は、演算子の左側をからすると非常に高く、右側からすると
非常に低く見えます。たとえば、

    @ary = (1, 3, sort 4, 2);
    print @ary;         # prints 1324

=begin original

the commas on the right of the C<sort> are evaluated before the C<sort>,
but the commas on the left are evaluated after.  In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.
Be careful with parentheses:

=end original

では、C<sort> の右のコンマは C<sort> よりも前に評価されますが、左側のコンマは
後から評価されます。
言い方を変えると、リスト演算子は自分の後にある引数をすべて使って処理を行ない、
その結果を自分の前の式に対する「項」であるかのように見せるということです。
ただし、括弧には気を付けないといけません:

=begin original

    # These evaluate exit before doing the print:
    print($foo, exit);  # Obviously not what you want.
    print $foo, exit;   # Nor is this.

=end original

    # 以下は print を行なう前に exit を評価します:
    print($foo, exit);  # 明らかにやりたいことではないでしょう。
    print $foo, exit;   # これでもない。

=begin original

    # These do the print before evaluating exit:
    (print $foo), exit; # This is what you want.
    print($foo), exit;  # Or this.
    print ($foo), exit; # Or even this.

=end original

    # 以下は exit を評価する前に print を行ないます:
    (print $foo), exit; # これがしたかった。
    print($foo), exit;  # これでもいい。
    print ($foo), exit; # これも OK。

=begin original

Also note that

=end original

また、

    print ($foo & 255) + 1, "\n";

=begin original

probably doesn't do what you expect at first glance.  The parentheses
enclose the argument list for C<print> which is evaluated (printing
the result of S<C<$foo & 255>>).  Then one is added to the return value
of C<print> (usually 1).  The result is something like this:

=end original

の動作を一目見ただけで判断するのは、難しいでしょう。
かっこは C<print> のために評価される引数リストを囲っています
(S<C<$foo & 255>> の結果が表示されます)。
それから C<print> の返り値 (通常は 1) に 1 が加えられます。
結果は以下のようになります:

=begin original

    1 + 1, "\n";    # Obviously not what you meant.

=end original

    1 + 1, "\n";    # 明らかにやりたいことではないでしょう。

=begin original

To do what you meant properly, you must write:

=end original

意味したいことを適切に行うには、以下のように書く必要があります:

    print(($foo & 255) + 1, "\n");

=begin original

See L</Named Unary Operators> for more discussion of this.

=end original

詳しくは、L</Named Unary Operators> を参照してください。

=begin original

Also parsed as terms are the S<C<do {}>> and S<C<eval {}>> constructs, as
well as subroutine and method calls, and the anonymous
constructors C<[]> and C<{}>.

=end original

この他に「項」として解析されるものには、S<C<do {}>> や S<C<eval {}>> の
構成、サブルーティンやメソッドの呼び出し、無名のコンストラクタ
C<[]> と C<{}> があります。

=begin original

See also L</Quote and Quote-like Operators> below,
as well as L</"I/O Operators">.

=end original

後述する L</Quote and Quote-like Operators> や
L</"I/O Operators"> も参照してください。

=head2 The Arrow Operator
X<arrow> X<dereference> X<< -> >>

(矢印演算子)

=begin original

"C<< -> >>" is an infix dereference operator, just as it is in C
and C++.  If the right side is one of a C<[...]>, C<{...}>, or a
C<(...)> subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.
(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L<perlreftut> and L<perlref>.

=end original

C や C++ と同じように "C<< -> >>" は中置の被参照演算子です。
右側が C<[...]>, C<{...}>, C<(...)> の一つの形の添字であれば、左側は配列、
ハッシュ、サブルーチンへのハードリファレンスか
シンボリックリファレンスでなければなりません。
(あるいは技術的には、配列またはハードリファレンスが代入可能であれば
ハードリファレンスを保持できる場所です。)
L<perlreftut> と L<perlref> を参照してください。

=begin original

Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and (if it is a method name) the left side must be either an object (a
blessed reference) or a class name (that is, a package name).  See
L<perlobj>.

=end original

そうでなければ、右側はメソッド名かサブルーチンのリファレンスを持った
単純スカラ変数で、
(メソッド名なら) 左側はオブジェクト (bless されたリファレンス) か
クラス名でなければなりません。
L<perlobj> を参照してください。

=begin original

The right side may also be the name of a subroutine, prefixed with the C<&>
sigil.  This creates what looks like a lexical method invocation, where the
method subroutine is resolved lexically instead of by name by a search within
the packages of the object's class.  This resolution happens entirely at
compile-time, and performs the same as a regular subroutine call at runtime.

=end original

The right side may also be the name of a subroutine, prefixed with the C<&>
sigil.  This creates what looks like a lexical method invocation, where the
method subroutine is resolved lexically instead of by name by a search within
the packages of the object's class.  This resolution happens entirely at
compile-time, and performs the same as a regular subroutine call at runtime.
(TBT)

=begin original

The dereferencing cases (as opposed to method-calling cases) are
somewhat extended by the C<postderef> feature.  For the
details of that feature, consult L<perlref/Postfix Dereference Syntax>.

=end original

(メソッド呼び出しの場合ではなく) デリファレンスの場合、
C<後置デリファレンス> (postderef) 機能によっていくらか拡張されます。
この機能の詳細については、L<perlref/Postfix Dereference Syntax> を
参照してください。

=head2 Auto-increment and Auto-decrement
X<increment> X<auto-increment> X<++> X<decrement> X<auto-decrement> X<-->

(インクリメントとデクリメント)

=begin original

C<"++"> and C<"--"> work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.

=end original

C<"++"> と C<"--"> は、C の場合と同じように動作します。
つまり、変数の前に置かれれば、値を返す前に変数を 1 インクリメントまたは
デクリメントし、後に置かれれば、値を返した後で変数を
インクリメントまたはデクリメントします。

    $i = 0;  $j = 0;
    print $i++;  # prints 0
    print ++$j;  # prints 1

=begin original

Note that just as in C, Perl doesn't define B<when> the variable is
incremented or decremented.  You just know it will be done sometime
before or after the value is returned.  This also means that modifying
a variable twice in the same statement will lead to undefined behavior.
Avoid statements like:

=end original

C と同様、Perl は B<いつ> 変数がインクリメントまたはデクリメントされるかは
定義されません。
値が返される前か後のどこかで行われる、ということだけがわかります。
これは、同じ文である変数を 2 回修正すると、振る舞いが未定義になることを
意味します。
以下のような文は避けてください:

    $i = $i ++;
    print ++ $i + $i ++;

=begin original

Perl will not guarantee what the result of the above statements is.

=end original

Perl は上記の文の結果について保障しません。

=begin original

The auto-increment operator has a little extra builtin magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C</^[a-zA-Z]*[0-9]*\z/>, the increment is done as a string, preserving each
character within its range, with carry:

=end original

インクリメント演算子には、ちょっと風変わりな機能が組み込まれています。
数値が入った変数や、数値の文脈で使われてきた変数を
インクリメントする場合には、通常のインクリメントとして動作します。
しかし、その変数が設定されてからずっと文字列の文脈でしか使われていなくて、
空文字列でなく、 C</^[a-zA-Z]*[0-9]*\z/> にマッチする値を持っているときには、
個々の文字の範囲を保ちながら桁あげを行なって、文字列としてインクリメントが
行なわれます (マジカルインクリメントと呼ばれます):

    print ++($foo = "99");      # prints "100"
    print ++($foo = "a0");      # prints "a1"
    print ++($foo = "Az");      # prints "Ba"
    print ++($foo = "zz");      # prints "aaa"

=begin original

C<undef> is always treated as numeric, and in particular is changed
to C<0> before incrementing (so that a post-increment of an undef value
will return C<0> rather than C<undef>).

=end original

C<undef> は常に数値として扱われ、特にインクリメントされる前には C<0> に
変換されます(従って、undef のポストインクリメント値は C<undef> ではなく
C<0> になります)。

=begin original

The auto-decrement operator is not magical.

=end original

デクリメント演算子には、マジカルなものはありません。

=head2 Exponentiation
X<**> X<exponentiation> X<power>

(指数演算子)

=begin original

Binary C<"**"> is the exponentiation operator.  It binds even more
tightly than unary minus, so C<-2**4> is C<-(2**4)>, not C<(-2)**4>.
(This is
implemented using C's C<pow(3)> function, which actually works on doubles
internally.)

=end original

二項演算子の C<"**"> は指数演算子です。
この演算子は、単項のマイナスよりも結合が強い演算子で、
C<-2**4> は C<(-2)**4> ではなく、C<-(2**4)> と解釈されます。
(これは C の C<pow(3)> を使って実装されていますので、
内部的には double で動作します。)

=begin original

Note that certain exponentiation expressions are ill-defined:
these include C<0**0>, C<1**Inf>, and C<Inf**0>.  Do not expect
any particular results from these special cases, the results
are platform-dependent.

=end original

一部の指数表現は明確に定義されていません:
これは C<0**0>, C<1**Inf>, C<Inf**0> などです。
これらの特殊な場合に関して特定の結果を想定しないでください;
結果はプラットフォーム依存です。

=head2 Symbolic Unary Operators
X<unary operator> X<operator, unary>

(単項演算子)

=begin original

Unary C<"!"> performs logical negation, that is, "not".  See also
L<C<not>|/Logical Not> for a lower precedence version of this.
X<!>

=end original

単項演算子の C<"!"> は論理否定を行ないます; つまり「not」ということです。
この演算子の優先順位を低くしたものとして、
L<C<not>|/Logical Not> が用意されています。
X<!>

=begin original

Unary C<"-"> performs arithmetic negation if the operand is numeric,
including any string that looks like a number.  If the operand is
an identifier, a string consisting of a minus sign concatenated
with the identifier is returned.  Otherwise, if the string starts
with a plus or minus, a string starting with the opposite sign is
returned.  One effect of these rules is that C<-bareword> is equivalent
to the string C<"-bareword">.  If, however, the string begins with a
non-alphabetic character (excluding C<"+"> or C<"-">), Perl will attempt
to convert
the string to a numeric, and the arithmetic negation is performed.  If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B<Argument "the string" isn't numeric in negation (-) at ...>.
X<-> X<negation, arithmetic>

=end original

単項演算子の C<"-"> は被演算子が数値または数値に見える文字列であれば、
算術否定を行ないます。
被演算子が識別子ならば、マイナス記号にその識別子をつなげた文字列が返されます。
これ以外で被演算子の最初の文字がプラスかマイナスのときには、
その記号を逆のものに置き換えた文字列を返します。
この規則の結果、C<-bareword> が文字列 C<"-bareword"> に等価となります。
しかし、文字列が英字以外(C<"+"> と C<"-"> を除く)で始まっていると、
Perl は文字列を数値に変換しようとし、それから算術否定が実行されます。
もし文字列が明確に数値に変換できない場合、Perl は
B<Argument "the string" isn't numeric in negation (-) at ...> という
警告を出します。
X<-> X<negation, arithmetic>

=begin original

Unary C<"~"> performs bitwise negation, that is, 1's complement.  For
example, S<C<0666 & ~027>> is 0640.  (See also L</Integer Arithmetic> and
L</Bitwise String Operators>.)  Note that the width of the result is
platform-dependent: C<~0> is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the C<"&"> operator to mask off the excess bits.
X<~> X<negation, binary>

=end original

単項演算子の C<"~"> はビットごとの否定を行ないます; つまり、1 の補数を返します。
例えば、S<C<0666 & ~027>> は 0640 です。
(L</Integer Arithmetic> と L</Bitwise String Operators> も参照して下さい。)
結果の幅はプラットホーム依存であることに注意してください: C<~0> は
32 ビットプラットホームでは 32 ビット幅ですが、64 ビットプラットホームでは
64 ビット幅なので、特定のビット幅を仮定する場合は、
余分なビットをマスクするために C<"&"> 演算子を使うことを忘れないでください。
X<~> X<negation, binary>

=begin original

Starting in Perl 5.28, it is a fatal error to try to complement a string
containing a character with an ordinal value above 255.

=end original

Perl 5.28 から、値が 255 を超える文字を含む文字列の
補数を求めようとすると致命的エラーになります。

=begin original

If the "bitwise" feature is enabled via S<C<use
feature 'bitwise'>> or C<use v5.28>, then unary
C<"~"> always treats its argument as a number, and an
alternate form of the operator, C<"~.">, always treats its argument as a
string.  So C<~0> and C<~"0"> will both give 2**32-1 on 32-bit platforms,
whereas C<~.0> and C<~."0"> will both yield C<"\xff">.  Until Perl 5.28,
this feature produced a warning in the C<"experimental::bitwise"> category.

=end original

"bitwise" 機能が S<C<use feature 'bitwise'>> か C<use v5.28> で有効にされると、
単項の C<"~"> は常にその引数を数値として扱い、その代替形式である
C<"~."> はその引数を常に文字列として扱います。
従って 32 ビットプラットフォームでは C<~0> と C<~"0"> はどちらも
2**32-1 を意味しますが、C<~.0> と C<~."0"> はどちらも C<"\xff"> になります。
Perl 5.28 まで、この機能は C<"experimental::bitwise"> カテゴリの警告を
発生させていました。

=begin original

Unary C<"+"> has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under L</Terms and List Operators (Leftward)>.)
X<+>

=end original

単項演算子の C<"+"> は、たとえ文字列に対して用いられた場合にも、何もしません。
関数名に続けて括弧付きの式を書く場合に、関数の引数リストと
解釈されないようにするために用いることができます。
(下記 L</Terms and List Operators (Leftward)> の例を参照してください。)
X<+>

=begin original

Unary C<"\"> creates references.  If its operand is a single sigilled
thing, it creates a reference to that object.  If its operand is a
parenthesised list, then it creates references to the things mentioned
in the list.  Otherwise it puts its operand in list context, and creates
a list of references to the scalars in the list provided by the operand.
See L<perlreftut>
and L<perlref>.  Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.
X<\> X<reference> X<backslash>

=end original

単項演算子の C<"\"> はリファレンスを生成します。
オペランドが一つの印付きのものの場合、それへのリファレンスを作ります。
オペランドがかっこでくくられたリストの場合、
リストで言及されているものへのリファレンスを作ります。
さもなければオペランドをリストコンテキストとし、
オペランドによって提供されたリストのスカラへのリファレンスのリストを作ります。
L<perlreftut> と L<perlref> を参照してください。
この用法も文字列中のバックスラッシュも、後に続くものが展開されるのを
防ぐことになりますが、動作を混同しないでください。
X<\> X<reference> X<backslash>

=head2 Binding Operators
X<binding> X<operator, binding> X<=~> X<!~>

(拘束演算子)

=begin original

Binary C<"=~"> binds a scalar expression to a pattern match.  Certain operations
search or modify the string C<$_> by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or transliteration.  The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
C<$_>.  When used in scalar context, the return value generally indicates the
success of the operation.  The exceptions are substitution (C<s///>)
and transliteration (C<y///>) with the C</r> (non-destructive) option,
which cause the B<r>eturn value to be the result of the substitution.
Behavior in list context depends on the particular operator.
See L</"Regexp Quote-Like Operators"> for details and L<perlretut> for
examples using these operators.

=end original

二項演算子の C<"=~"> は、スカラ式をパターンマッチに拘束します。
デフォルトで C<$_> の文字列を検索したり、変更したりする演算があります。
この演算子は、そのような演算を他の文字列に対して行なわせるようにするものです。
右引数は、検索パターン、置換、文字変換のいずれかです。
左引数は、デフォルトの C<$_> の代わりに検索、置換、文字変換の
対象となるものです。
スカラコンテキストで使うと、返り値は一般的に演算の結果が成功したか否かです。
例外は、C</r> (非破壊) オプション付きの置換 (C<s///>) と
文字変換 (C<y///>) です; この場合は変換した結果を返します。
リストコンテキストでの振る舞いは演算子に依存します。
詳しくは L</"Regexp Quote-Like Operators"> を、これらの演算子を使った
例については L<perlretut> を参照して下さい。

=begin original

If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time.  Note that this means that its
contents will be interpolated twice, so

=end original

右引数が検索パターン、置換、文字変換ではなく、式であれば、
それは実行時に決まる検索パターンと解釈されます。
これは、内容が 2 回展開されることを意味することに注意してください;
つまり:

    '\\' =~ q'\\';

=begin original

is not ok, as the regex engine will end up trying to compile the
pattern C<\>, which it will consider a syntax error.

=end original

は正しくありません; 正規表現エンジンは最終的にパターン C<\> を
コンパイルしようとして、これは文法エラーと考えるからです。

=begin original

Binary C<"!~"> is just like C<"=~"> except the return value is negated in
the logical sense.

=end original

二項演算子の C<"!~"> は、返される値が論理否定されることを除いて
C<"=~"> と同じです。

=begin original

Binary C<"!~"> with a non-destructive substitution (C<s///r>) or transliteration
(C<y///r>) is a syntax error.

=end original

二項演算子の C<"!~"> を非破壊置換 (C<s///r>) や変換 (C<y///r>) で使うと
文法エラーとなります。

=head2 Multiplicative Operators
X<operator, multiplicative>

(乗法演算子)

=begin original

Binary C<"*"> multiplies two numbers.
X<*>

=end original

二項演算子の C<"*"> は 2 つの数値の積を返します。
X<*>

=begin original

Binary C<"/"> divides two numbers.
X</> X<slash>

=end original

二項演算子の C<"/"> は 2 つの数値の商を返します。
X</> X<slash>

=begin original

Binary C<"%"> is the modulo operator, which computes the division
remainder of its first argument with respect to its second argument.
Given integer
operands C<$m> and C<$n>: If C<$n> is positive, then S<C<$m % $n>> is
C<$m> minus the largest multiple of C<$n> less than or equal to
C<$m>.  If C<$n> is negative, then S<C<$m % $n>> is C<$m> minus the
smallest multiple of C<$n> that is not less than C<$m> (that is, the
result will be less than or equal to zero).  If the operands
C<$m> and C<$n> are floating point values and the absolute value of
C<$n> (that is C<abs($n)>) is less than S<C<(UV_MAX + 1)>>, only
the integer portion of C<$m> and C<$n> will be used in the operation
(Note: here C<UV_MAX> means the maximum of the unsigned integer type).
If the absolute value of the right operand (C<abs($n)>) is greater than
or equal to S<C<(UV_MAX + 1)>>, C<"%"> computes the floating-point remainder
C<$r> in the equation S<C<($r = $m - $i*$n)>> where C<$i> is a certain
integer that makes C<$r> have the same sign as the right operand
C<$n> (B<not> as the left operand C<$m> like C function C<fmod()>)
and the absolute value less than that of C<$n>.
Note that when S<C<use integer>> is in scope, C<"%"> gives you direct access
to the modulo operator as implemented by your C compiler.  This
operator is not as well defined for negative operands, but it will
execute faster.
X<%> X<remainder> X<modulo> X<mod>

=end original

二項演算子の C<"%"> は剰余演算子で、一つ目の引数を二つ目の引数で割ったときの
余りを返します。
C<$m> と C<$n> の二つの整数の被演算子を取ったとすると:
C<$n> が正の場合、S<C<$m % $n>> は、C<$m> から C<$m> 以下の最大の
C<$n> の倍数を引いた値です。
C<$n> が負の場合、S<C<$m % $n>> は、C<$m> から C<$m> を下回らない
最小の C<$n> の倍数を引いた値です(従って結果はゼロ以下になります)。
オペランド C<$m> と C<$n> が浮動小数点数で、C<$n> の絶対値
(つまり C<abs($n)>) が S<C<(UV_MAX + 1)>> より小さい場合、
C<$m> と C<$n> の整数部のみが操作で使われます
(注意: ここで C<UV_MAX> は符号なし整数の最大値を意味します)。
右オペランドの絶対値 (C<abs($n)>) が S<C<(UV_MAX + 1)>> 以上の場合、
C<"%"> は、S<C<($r = $m - $i*$n)>> となる浮動小数点剰余 C<$r> を計算します;
ここで C<$i> は、C<$r> が右オペランド C<$n> と同じ符号 (C の
関数 C<fmod()> のように左オペランド C<$m> B<ではありません>) で、
絶対値が C<$n> より小さいものになるような、ある整数です。
S<C<use integer>> がスコープ内にある場合、
C<"%"> は C コンパイラで実装された剰余演算子を使います。
この演算子は被演算子が負の場合の挙動が不確実ですが、
より高速です。
X<%> X<remainder> X<modulo> X<mod>

=begin original

Binary C<x> is the repetition operator.  In scalar context, or if the
left operand is neither enclosed in parentheses nor a C<qw//> list,
it performs a string repetition.  In that case it supplies scalar
context to the left operand, and returns a string consisting of the
left operand string repeated the number of times specified by the right
operand.  If the C<x> is in list context, and the left operand is either
enclosed in parentheses or a C<qw//> list, it performs a list repetition.
In that case it supplies list context to the left operand, and returns
a list consisting of the left operand list repeated the number of times
specified by the right operand.
If the right operand is zero or negative (raising a warning on
negative), it returns an empty string
or an empty list, depending on the context.
X<x>

=end original

二項演算子の C<"x"> は繰り返し演算子です。
スカラコンテキストまたは左辺値がかっこで囲まれたり
C<qw//> リストであったりしない場合は、文字列の繰り返しを実行します。
この場合、左オペランドにスカラコンテキストを提供し、
右オペランドによって指定された回数繰り返された左オペランド文字列からなる
文字列を返します。
C<x> がリストコンテキストで、
左オペランドがかっこでくくられているか
C<qw//> リストの場合、
リスト繰り返しを実行します。
この場合、これは左オペランドへリストコンテキストを提供し、
右オペランドによって指定された回数繰り返された
左オペランドのリストからなるリストを返します。
右オペランドが 0 か負数の場合(負数の場合は警告が出ます)、
コンテキストによって空文字列か空リストを返します。
X<x>

    print '-' x 80;             # print row of dashes

    print "\t" x ($tab/8), ' ' x ($tab%8);      # tab over

    @ones = (1) x 80;           # a list of 80 1's
    @ones = (5) x @ones;        # set all elements to 5

=head2 Additive Operators
X<operator, additive>

(加法演算子)

=begin original

Binary C<"+"> returns the sum of two numbers.
X<+>

=end original

二項演算子の C<"+"> は 2 つの数値の和を返します。
X<+>

=begin original

Binary C<"-"> returns the difference of two numbers.
X<->

=end original

二項演算子の C<"-"> は 2 つの数値の差を返します。
X<->

=begin original

Binary C<"."> concatenates two strings.
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=end original

二項演算子の C<"."> は 2 つの文字列を連結します。
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=head2 Shift Operators
X<shift operator> X<operator, shift> X<<< << >>>
X<<< >> >>> X<right shift> X<left shift> X<bitwise shift>
X<shl> X<shr> X<shift, right> X<shift, left>

(シフト演算子)

=begin original

Binary C<<< "<<" >>> returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also L</Integer Arithmetic>.)

=end original

二項演算子の C<<< "<<" >>> は左引数の値を、右引数で示すビット数だけ、
左にシフトした値を返します。
引数は整数でなければなりません。
(L</Integer Arithmetic> も参照して下さい。)

=begin original

Binary C<<< ">>" >>> returns the value of its left argument shifted right by
the number of bits specified by the right argument.  Arguments should
be integers.  (See also L</Integer Arithmetic>.)

=end original

二項演算子の C<<< ">>" >>> は左引数の値を、右引数で示すビット数だけ、
右にシフトした値を返します。
引数は整数でなければなりません。
(L</Integer Arithmetic> も参照して下さい。)

=begin original

If S<C<use integer>> (see L</Integer Arithmetic>) is in force then
signed C integers are used (I<arithmetic shift>), otherwise unsigned C
integers are used (I<logical shift>), even for negative shiftees.
In arithmetic right shift the sign bit is replicated on the left,
in logical shift zero bits come in from the left.

=end original

S<C<use integer>> (L</Integer Arithmetic> を参照してください)が有効な場合、
C の符号付き整数が使われ(I<算術シフト>)、そうでない場合は(例え負のシフトでも)
C の符号なし整数が使われます(I<論理シフト>)。
算術右シフトでは符号ビットは左側に複製され、論理シフトでは 0 ビットが
左側から来ます。

=begin original

Either way, the implementation isn't going to generate results larger
than the size of the integer type Perl was built with (32 bits or 64 bits).

=end original

どちらの場合も、この実装は Perl がビルドされた整数型のサイズ(32 ビットか
64 ビット)よりも大きい結果を生成することはありません。

=begin original

Shifting by a negative number of bits means the reverse shift: left
shift becomes right shift, right shift becomes left shift.  This is
unlike in C, where negative shift is undefined.

=end original

負数のビットシフトは逆シフトを意味します: 左シフトは右シフトに鳴り、
右シフトは左シフトになります。
これは、負のシフトが未定義である C とは異なります。

=begin original

Shifting by a value greater than or equal to integer size (in bits)
results in zero (all bits fall off), except that under S<C<use integer>>
right shifting a negative value by such an amount results in -1.
This is unlike in C, where shifting by too many bits is undefined.

=end original

(ビット数での) 整数のサイズ以上の価でののシフトは、0 (全てのビットが落ちる)
になりますが、例外として、S<C<use integer>> の下で、そのような量の負の値を
シフトすると -1 になります。
これは、多すぎるビット数のシフトは未定義である C とは異なります。

=begin original

If you get tired of being subject to your platform's native integers,
the S<C<use bigint>> pragma neatly sidesteps the issue altogether:

=end original

プラットフォームのネイティブな整数の影響に疲れたなら、S<C<use bigint>>
プラグマは問題を完全にうまく回避します:

    print 20 << 20;  # 20971520
    print 20 << 32;  # 0 with 32-bit integer,
                     # 85899345920 with 64-bit integer
    use bigint;
    print 20 << 100; # 25353012004564588029934064107520

=head2 Named Unary Operators
X<operator, named unary>

(名前付き単項演算子)

=begin original

The various named unary operators are treated as functions with one
argument, with optional parentheses.

=end original

さまざまな名前付き単項演算子が、引数を 1 つ持ち、括弧が省略可能な、
関数として扱われます。

=begin original

If any list operator (C<print()>, etc.) or any unary operator (C<chdir()>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  For example,
because named unary operators are higher precedence than C<||>:

=end original

リスト演算子 (C<print()> など) や単項演算子 (C<chdir()> など) は、
すべて次のトークンとして開き括弧が続くと、その演算子と括弧内の引数は、
通常の関数呼び出しのようにもっとも高い優先順位として扱われます。
たとえば、名前つき単項演算子は C<||> より優先順位が高いので、
以下のようになります:

    chdir $foo    || die;       # (chdir $foo) || die
    chdir($foo)   || die;       # (chdir $foo) || die
    chdir ($foo)  || die;       # (chdir $foo) || die
    chdir +($foo) || die;       # (chdir $foo) || die

=begin original

but, because C<"*"> is higher precedence than named operators:

=end original

しかし C<"*"> は名前つき演算子より優先順位が高いので、以下のようになります:

    chdir $foo * 20;    # chdir ($foo * 20)
    chdir($foo) * 20;   # (chdir $foo) * 20
    chdir ($foo) * 20;  # (chdir $foo) * 20
    chdir +($foo) * 20; # chdir ($foo * 20)

    rand 10 * 20;       # rand (10 * 20)
    rand(10) * 20;      # (rand 10) * 20
    rand (10) * 20;     # (rand 10) * 20
    rand +(10) * 20;    # rand (10 * 20)

=begin original

Regarding precedence, the filetest operators, like C<-f>, C<-M>, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.  That means, for example, that C<-f($file).".bak"> is
equivalent to S<C<-f "$file.bak">>.
X<-X> X<filetest> X<operator, filetest>

=end original

優先順位に関して、C<-f> や C<-M> のようなファイルテスト演算子は、名前付き
単項演算子として扱われますが、この関数のかっこルールは適用されません。
これは、例えば C<-f($file).".bak"> は S<C<-f "$file.bak">> と等価であることを
意味します。
X<-X> X<filetest> X<operator, filetest>

=begin original

See also L</"Terms and List Operators (Leftward)">.

=end original

L</"Terms and List Operators (Leftward)"> も参照して下さい。

=head2 Class Instance Operator
X<isa operator>

(クラスインスタンス演算子)

=begin original

Binary C<isa> evaluates to true when the left argument is an object instance of
the class (or a subclass derived from that class) given by the right argument.
If the left argument is not defined, not a blessed object instance, and does
not derive from the class given by the right argument, the operator evaluates
as false. The right argument may give the class either as a bareword or a
scalar expression that yields a string class name:

=end original

二項演算子の C<isa> は、左側の引数が右側の引数で与えられた
クラス(またはこのクラスから派生した下位クラス)の
オブジェクトインスタンスである場合に真と評価されます。
左側の引数が、未定義、bless されたオブジェクトインスタンスではない、
右側の引数で与えられたクラスから派生していない、のいずれかの場合、
この演算子は偽として評価されます。
右側の引数は、裸の単語か、クラス名の文字列となるスカラ式を与えます:

    if ( $obj isa Some::Class ) { ... }

    if ( $obj isa "Different::Class" ) { ... }
    if ( $obj isa $name_of_class ) { ... }

=begin original

This feature is available from Perl 5.31.6 onwards when enabled by
C<use feature 'isa'>. This feature is enabled automatically by a
C<use v5.36> (or higher) declaration in the current scope.

=end original

これは Perl 5.31.6 からの機能で、C<use feature 'isa'> によって
有効化されると利用可能になります。
この機能は、現在のスコープで C<use v5.36> (またはそれ以上の) 宣言をすることで
自動的に有効になります。

=head2 Relational Operators
X<relational operator> X<operator, relational>

(比較演算子)

=begin original

Perl operators that return true or false generally return values
that can be safely used as numbers.  For example, the relational
operators in this section and the equality operators in the next
one return C<1> for true and a special version of the defined empty
string, C<"">, which counts as a zero but is exempt from warnings
about improper numeric conversions, just as S<C<"0 but true">> is.

=end original

真か偽の値を返す Perl 演算子は一般的に安全に数値として使える値を返します。
例えば、この節の関係演算子と次の節の等価演算子は、真および、
S<C<"0 but true">> と同様、ゼロとカウントされるけれども不適切な数値変換に
関する警告の出ない、定義された空文字列 C<""> の特別版に対して C<1> を
返します。

=begin original

Binary C<< "<" >> returns true if the left argument is numerically less than
the right argument.
X<< < >>

=end original

二項演算子の C<< "<" >> は左引数が数値的に右引数よりも小さければ、
真を返します。
X<< < >>

=begin original

Binary C<< ">" >> returns true if the left argument is numerically greater
than the right argument.
X<< > >>

=end original

二項演算子の C<< ">" >> は左引数が数値的に右引数よりも大きければ、
真を返します。
X<< > >>

=begin original

Binary C<< "<=" >> returns true if the left argument is numerically less than
or equal to the right argument.
X<< <= >>

=end original

二項演算子の C<< "<=" >> は左引数が数値的に右引数よりも小さいか等しければ、
真を返します。
X<< <= >>

=begin original

Binary C<< ">=" >> returns true if the left argument is numerically greater
than or equal to the right argument.
X<< >= >>

=end original

二項演算子の C<< ">=" >> は左引数が数値的に右引数よりも大きいか等しければ、
真を返します。
X<< >= >>

=begin original

Binary C<"lt"> returns true if the left argument is stringwise less than
the right argument.
X<< lt >>

=end original

二項演算子の C<"lt"> は左引数が文字列的に右引数よりも小さければ、真を返します。
X<< lt >>

=begin original

Binary C<"gt"> returns true if the left argument is stringwise greater
than the right argument.
X<< gt >>

=end original

二項演算子の C<"gt"> は左引数が文字列的に右引数よりも大きければ、真を返します。
X<< gt >>

=begin original

Binary C<"le"> returns true if the left argument is stringwise less than
or equal to the right argument.
X<< le >>

=end original

二項演算子の C<"le"> は左引数が文字列的に右引数よりも小さいか等しければ、
真を返します。
X<< le >>

=begin original

Binary C<"ge"> returns true if the left argument is stringwise greater
than or equal to the right argument.
X<< ge >>

=end original

二項演算子の C<"ge"> は左引数が文字列的に右引数よりも大きいか等しければ、
真を返します。
X<< ge >>

=begin original

A sequence of relational operators, such as S<C<"$x E<lt> $y E<lt>=
$z">>, performs chained comparisons, in the manner described above in
the section L</"Operator Precedence and Associativity">.
Beware that they do not chain with equality operators, which have lower
precedence.

=end original

S<C<"$x E<lt> $y E<lt>= $z">> のような比較演算子の並びは、
L</"Operator Precedence and Associativity"> 節で述べたような形で
連鎖比較を実行します。
より低い優先順位を持つ等価演算子とは連鎖しないことに注意してください。

=begin original

C<"lt">, C<"le">, C<"ge">, C<"gt">, and C<"cmp"> (this last is described
in the L<next section|/Equality Operators>) use the collation (sort)
order specified by the current C<LC_COLLATE> locale if a S<C<use
locale>> form that includes collation is in effect.  See L<perllocale>.
Depending on the capabilities of the platform, these can give reasonable
results with Unicode, but the standard C<L<Unicode::Collate>> and
C<L<Unicode::Collate::Locale>> modules offer much more powerful
solutions to collation issues.

=end original

C<"lt">, C<"le">, C<"ge">, C<"gt">, C<"cmp"> 
(最後のものは L<次の節|/Equality Operators> で記述) 
は、照合を含むS<C<use locale>> 型式が有効な場合は、
現在の C<LC_COLLATE> ロケールで指定された照合(ソート)順が使われます。
L<perllocale> を参照して下さい。
プラットフォームの能力によって、Unicode で妥当な結果が
得られるかもしれませんが、
標準の C<L<Unicode::Collate>> と C<L<Unicode::Collate::Locale>> モジュールは、
照合問題に関する遥かに強力な解決法を提供します。

=begin original

For case-insensitive comparisons, look at the L<perlfunc/fc> case-folding
function, available in Perl v5.16 or later:

=end original

大文字小文字を無視した比較に関しては、Perl v5.16 以降で利用可能な
L<perlfunc/fc> 大文字小文字畳み込み関数を参照してください:

    if ( fc($x) eq fc($y) ) { ... }

=head2 Equality Operators
X<equality> X<equal> X<equals> X<operator, equality>

(等価演算子)

=begin original

Binary C<< "==" >> returns true if the left argument is numerically equal to
the right argument.
X<==>

=end original

二項演算子の C<< "==" >> は左引数が数値的に右引数と等しければ、真を返します。
X<==>

=begin original

Binary C<< "!=" >> returns true if the left argument is numerically not equal
to the right argument.
X<!=>

=end original

二項演算子の C<< "!=" >> は左引数が数値的に右引数と等しくなければ、真を
返します。
X<!=>

=begin original

Binary C<"eq"> returns true if the left argument is stringwise equal to
the right argument.
X<eq>

=end original

二項演算子の C<"eq"> は左引数が文字列的に右引数と等しければ、真を返します。
X<eq>

=begin original

Binary C<"ne"> returns true if the left argument is stringwise not equal
to the right argument.
X<ne>

=end original

二項演算子の C<"ne"> は左引数が文字列的に右引数と等しくなければ、真を
返します。
X<ne>

=begin original

A sequence of the above equality operators, such as S<C<"$x == $y ==
$z">>, performs chained comparisons, in the manner described above in
the section L</"Operator Precedence and Associativity">.
Beware that they do not chain with relational operators, which have
higher precedence.

=end original

S<C<"$x == $y == $z">> のような上述の等価演算子の並びは、
L</"Operator Precedence and Associativity"> 節で述べたような形で
連鎖比較を実行します。
より高い優先順位を持つ比較演算子とは連鎖しないことに注意してください。

=begin original

Binary C<< "<=>" >> returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.  If your platform supports C<NaN>'s (not-a-numbers) as numeric
values, using them with C<< "<=>" >> returns undef.  C<NaN> is not
C<< "<" >>, C<< "==" >>, C<< ">" >>, C<< "<=" >> or C<< ">=" >> anything
(even C<NaN>), so those 5 return false.  S<C<< NaN != NaN >>> returns
true, as does S<C<NaN !=> I<anything else>>.  If your platform doesn't
support C<NaN>'s then C<NaN> is just a string with numeric value 0.
X<< <=> >>
X<spaceship>

=end original

二項演算子の C<< "<=>" >> は左引数が数値的に右引数より小さいか、等しいか、
大きいかに従って、-1, 0, 1 を返します。
数値として C<NaN> (非数) に対応しているプラットフォームでは、
それに対して C<< "<=>" >> を使うと undef を返します。
C<NaN> はどの値に対しても(C<NaN> に対してでさえも) C<< "<" >>, C<< "==" >>,
C<< ">" >>, C<< "<=" >>, C<< ">=" >> のいずれも成立しないので、これらは全て
偽となります。
S<C<< NaN != NaN >>> は真を返しますが、
S<C<NaN !=> I<その他のどの値でも>> です。
C<NaN> に対応していないプラットフォームでは、C<NaN> は単に数としての値 0 を
持つ文字列です。
X<< <=> >> X<spaceship>

    $ perl -le '$x = "NaN"; print "No NaN support here" if $x == $x'
    $ perl -le '$x = "NaN"; print "NaN support here" if $x != $x'

=begin original

(Note that the L<bigint>, L<bigrat>, and L<bignum> pragmas all
support C<"NaN">.)

=end original

(L<bigint>, L<bigrat>, L<bignum> プラグマは全て C<"NaN"> に対応していることに
注意してください。)

=begin original

Binary C<"cmp"> returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.

=end original

二項演算子の C<"cmp"> は左引数が文字列的に右引数より小さいか、
等しいか、大きいかに従って、-1, 0, 1 を返します。

=begin original

Here we can see the difference between C<< <=> >> and C<cmp>,

=end original

ここで、C<< <=> >> と C<cmp> の違いを示します:

    print 10 <=> 2 #prints 1
    print 10 cmp 2 #prints -1

=begin original

X<cmp>
(likewise between the relational operators that were described in the
L<previous section|/Relational Operators>: C<gt> and C<< > >>, C<lt> and
C<< < >>, I<etc>.)

=end original

X<cmp>
(likewise between the relational operators that were described in the
L<previous section|/Relational Operators>: C<gt> and C<< > >>, C<lt> and
C<< < >>, I<etc>.)
(TBT)

=begin original

Binary C<"~~"> does a smartmatch between its arguments.  Smart matching
is complicated enough to warrant
L<two subsections|/Smartmatch Operator>, starting just below.
X<~~>

=end original

二項演算子の C<"~~"> はその引数に対してスマートマッチングを行います。
スマートマッチングは次から始まる
L<二つの節|/Smartmatch Operator> が必要なぐらい複雑です。
X<~~>

=begin original

The two-sided ordering operators C<"E<lt>=E<gt>"> and C<"cmp">, and the
smartmatch operator C<"~~">, are non-associative with respect to each
other and with respect to the equality operators of the same precedence.

=end original

両面順序演算子 C<"E<lt>=E<gt>">, C<"cmp"> および、
スマートマッチング演算子 C<"~~"> は、互いに、および同じ優先順位の
演算子に対しては非結合です。

=head3 Smartmatch Operator

(スマートマッチング演算子)

=begin original

The C<smartmatch> feature is discouraged for new code and retained for
backward compatibility.

=end original

The C<smartmatch> feature is discouraged for new code and retained for
backward compatibility.
(TBT)

=begin original

The smartmatch operator was introduced in 5.10.0 had significant
changes in 5.10.1.  It is enabled by default and in all feature
bundles up to 5.40.  To use smartmatch with a later feature bundle you
will need enable it explicitly:

=end original

The smartmatch operator was introduced in 5.10.0 had significant
changes in 5.10.1.  It is enabled by default and in all feature
bundles up to 5.40.  To use smartmatch with a later feature bundle you
will need enable it explicitly:
(TBT)

  use v5.42;
  use feature "smartmatch";

=begin original

Binary C<~~> does a "smartmatch" between its arguments.  This is mostly
used implicitly in the C<when> construct described in L<perlsyn>, although
not all C<when> clauses call the smartmatch operator.  Unique among all of
Perl's operators, the smartmatch operator can recurse.

=end original

2 項 C<~~> は引数に対する「スマートマッチング」を行います。
これはほとんど L<perlsyn> で記述されている C<when> 構文で暗黙に使われますが、
C<when> 節だけがスマートマッチング演算子を呼び出すわけではありません。
全ての Perl の演算子の中で唯一、スマートマッチング演算子は再帰できます。

=begin original

It is also unique in that all other Perl operators impose a context
(usually string or numeric context) on their operands, autoconverting
those operands to those imposed contexts.  In contrast, smartmatch
I<infers> contexts from the actual types of its operands and uses that
type information to select a suitable comparison mechanism.

=end original

また、その他全ての Perl 演算子はそのオペランドにコンテキスト(通常は
文字列または数値コンテキスト)を割り当てて、オペランドを割り当てた
コンテキストに自動変換します。
一方、スマートマッチングはそのオペランドの実際の型からコンテキストを
I<推論> して、適切な比較機構を選択するためにその型情報を使います。

=begin original

The C<~~> operator compares its operands "polymorphically", determining how
to compare them according to their actual types (numeric, string, array,
hash, etc.).  Like the equality operators with which it shares the same
precedence, C<~~> returns 1 for true and C<""> for false.  It is often best
read aloud as "in", "inside of", or "is contained in", because the left
operand is often looked for I<inside> the right operand.  That makes the
order of the operands to the smartmatch operand often opposite that of
the regular match operator.  In other words, the "smaller" thing is usually
placed in the left operand and the larger one in the right.

=end original

C<~~> 演算子はオペランドを「多態的に」比較します; どのように比較するかの
決定は、実際の型 (数値、文字列、配列、ハッシュなど) に基づきます。
同じ優先順位を共有する等価演算子のように、
C<~~> は真では 1 を、偽では C<""> を返します。
これはしばしば "in", "inside of", "is contained in" と呼ぶのが最良です;
なぜなら左オペランドはしばしば右オペランドの I<内側> を探すからです。
これにより、スマートマッチングオペランドへのオペランドの順序はしばしば
正規表現演算子のものと逆になります。
言い換えると、「より小さい」ものが普通は左オペランドに置かれ、より
大きいものが右側に置かれます。

=begin original

The behavior of a smartmatch depends on what type of things its arguments
are, as determined by the following table.  The first row of the table
whose types apply determines the smartmatch behavior.  Because what
actually happens is mostly determined by the type of the second operand,
the table is sorted on the right operand instead of on the left.

=end original

スマートマッチングの振る舞いは、次の表で決定されるように、引数がどんな
型かに依存します。
型が適用される表の最初の行は、スマートマッチングの振る舞いを決定します。
実際に何が起こるかはほとんどの場合 2 番目のオペランドの型で決定されるので、
表は左ではなく右オペランドでソートされています。

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 Any       undef      check whether Any is undefined
                like: !defined Any

=end original

 左        右         説明と擬似コード
 ===============================================================
 Any       undef      Any が未定義かどうか調べる
                like: !defined Any

=begin original

 Any       Object     invoke ~~ overloading on Object, or die

=end original

 Any       Object     Object に対する ~~ オーバーロードを起動するか die

=begin original

 Right operand is an ARRAY:

=end original

 右被演算子が 配列:

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY1    ARRAY2     recurse on paired elements of ARRAY1 and ARRAY2[2]
                like: (ARRAY1[0] ~~ ARRAY2[0])
                        && (ARRAY1[1] ~~ ARRAY2[1]) && ...
 HASH      ARRAY      any ARRAY elements exist as HASH keys
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    ARRAY      any ARRAY elements pattern match Regexp
                like: grep { /Regexp/ } ARRAY
 undef     ARRAY      undef in ARRAY
                like: grep { !defined } ARRAY
 Any       ARRAY      smartmatch each ARRAY element[3]
                like: grep { Any ~~ $_ } ARRAY

=end original

 左        右         説明と擬似コード
 ===============================================================
 ARRAY1    ARRAY2     ARRAY1 と ARRAY2 の組の要素に対して再帰 [2]
                like: (ARRAY1[0] ~~ ARRAY2[0])
                        && (ARRAY1[1] ~~ ARRAY2[1]) && ...
 HASH      ARRAY      いずれかの ARRAY 要素が HASH キーに存在するか
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    ARRAY      いずれかの ARRAY 要素が Regexp でマッチングするか
                like: grep { /Regexp/ } ARRAY
 undef     ARRAY      ARRAY 内の undef
                like: grep { !defined } ARRAY
 Any       ARRAY      それぞれの ARRAY 要素に対してスマートマッチング [3]
                like: grep { Any ~~ $_ } ARRAY

=begin original

 Right operand is a HASH:

=end original

 右被演算子がハッシュ:

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 HASH1     HASH2      all same keys in both HASHes
                like: keys HASH1 ==
                         grep { exists HASH2->{$_} } keys HASH1
 ARRAY     HASH       any ARRAY elements exist as HASH keys
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    HASH       any HASH keys pattern match Regexp
                like: grep { /Regexp/ } keys HASH
 undef     HASH       always false (undef cannot be a key)
                like: 0 == 1
 Any       HASH       HASH key existence
                like: exists HASH->{Any}

=end original

 左        右         説明と擬似コード
 ===============================================================
 HASH1     HASH2      HASH1 と HASH2 両方が全て同じキー
                like: keys HASH1 ==
                         grep { exists HASH2->{$_} } keys HASH1
 ARRAY     HASH       いずれかの ARRAY 要素が HASH キーに存在するか
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    HASH       いずれかの HASH キーが Regexp でマッチングするか
                like: grep { /Regexp/ } keys HASH
 undef     HASH       常に偽 (undef はキーになれない)
                like: 0 == 1
 Any       HASH       HASH キーが存在するか
                like: exists HASH->{Any}

=begin original

 Right operand is CODE:

=end original

 右被演算子がコードリファレンス:

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY     CODE       sub returns true on all ARRAY elements[1]
                like: !grep { !CODE->($_) } ARRAY
 HASH      CODE       sub returns true on all HASH keys[1]
                like: !grep { !CODE->($_) } keys HASH
 Any       CODE       sub passed Any returns true
                like: CODE->(Any)

=end original

 左        右         説明と擬似コード
 ===============================================================
 ARRAY     CODE       全ての ARRAY 要素に対してサブルーチンが真を返す [1]
                like: !grep { !CODE->($_) } ARRAY
 HASH      CODE       全ての HASH キーに対してサブルーチンが真を返す [1]
                like: !grep { !CODE->($_) } keys HASH
 Any       CODE       サブルーチンに Any を渡して真を返す
                like: CODE->(Any)

=begin original

 Right operand is a Regexp:

=end original

 右被演算子が正規表現:

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY     Regexp     any ARRAY elements match Regexp
                like: grep { /Regexp/ } ARRAY
 HASH      Regexp     any HASH keys match Regexp
                like: grep { /Regexp/ } keys HASH
 Any       Regexp     pattern match
                like: Any =~ /Regexp/

=end original

 左        右         説明と擬似コード
 ===============================================================
 ARRAY     Regexp     いずれかの ARRAY 要素が Regexp にマッチングするか
                like: grep { /Regexp/ } ARRAY
 HASH      Regexp     いずれかの HASH キーが Regexp にマッチングするか
                like: grep { /Regexp/ } keys HASH
 Any       Regexp     パターンマッチング
                like: Any =~ /Regexp/

=begin original

 Other:

=end original

 その他:

=begin original

 Left      Right      Description and pseudocode
 ===============================================================
 Object    Any        invoke ~~ overloading on Object,
                      or fall back to...

=end original

 左        右         説明と擬似コード
 ===============================================================
 Object    Any        Object に対して ~~ のオーバーロードを起動、
                      あるいは次にフォールバック…

=begin original

 Any       Num        numeric equality
                 like: Any == Num
 Num       nummy[4]    numeric equality
                 like: Num == nummy
 undef     Any        check whether undefined
                 like: !defined(Any)
 Any       Any        string equality
                 like: Any eq Any

=end original

 Any       Num        数値の等価性
                 like: Any == Num
 Num       nummy[4]    数値の等価性
                 like: Num == nummy
 undef     Any        未定義かどうかを調べる
                 like: !defined(Any)
 Any       Any        文字列の等価性
                 like: Any eq Any

=begin original

Notes:

=end original

注意:

=over

=item 1.
Empty hashes or arrays match.

(1. 空ハッシュや配列はマッチングします。)

=item 2.
That is, each element smartmatches the element of the same index in the other array.[3]

(2. つまり、それぞれの要素は他の配列の同じインデックスの要素とスマートマッチングします。[3])

=item 3.
If a circular reference is found, fall back to referential equality.

(3. 循環参照が見つかると、参照の等価性にフォールバックします。)

=item 4.
Either an actual number, or a string that looks like one.

(4. 実際の数値か、数値に見える文字列のどちらかです。)

=back

=begin original

The smartmatch implicitly dereferences any non-blessed hash or array
reference, so the C<I<HASH>> and C<I<ARRAY>> entries apply in those cases.
For blessed references, the C<I<Object>> entries apply.  Smartmatches
involving hashes only consider hash keys, never hash values.

=end original

スマートマッチングは bless されていないハッシュや配列のリファレンスを暗黙に
デリファレンスするので、それらの場合では C<I<HASH>> と C<I<ARRAY>> の
エントリが適用されます。
bless されたリファレンスでは、C<I<Object>> エントリが適用されます。
ハッシュに関連するスマートマッチングはキーのみを考慮し、ハッシュの値は
考慮しません。

=begin original

The "like" code entry is not always an exact rendition.  For example, the
smartmatch operator short-circuits whenever possible, but C<grep> does
not.  Also, C<grep> in scalar context returns the number of matches, but
C<~~> returns only true or false.

=end original

"like" コードエントリは常に正確な処理を行うわけではありません。
例えば、スマートマッチング演算子は可能なら短絡しますが、C<grep> はしません。
また、スカラコンテキストでは C<grep> はマッチングした数を返しますが、
C<~~> は真か偽かのみを返します。

=begin original

Unlike most operators, the smartmatch operator knows to treat C<undef>
specially:

=end original

ほとんどの演算子と異なり、スマートマッチング演算子は C<undef> を特別に
扱う方法を知っています:

    use v5.10.1;
    @array = (1, 2, 3, undef, 4, 5);
    say "some elements undefined" if undef ~~ @array;

=begin original

Each operand is considered in a modified scalar context, the modification
being that array and hash variables are passed by reference to the
operator, which implicitly dereferences them.  Both elements
of each pair are the same:

=end original

それぞれのオペランドは修正されたスカラコンテキストと考えられます;
修正というのは、配列とハッシュの変数は演算子にリファレンスが渡され、
暗黙にデリファレンスされます。
それぞれの組のどちらの要素も同じです:

    use v5.10.1;

    my %hash = (red    => 1, blue   => 2, green  => 3,
                orange => 4, yellow => 5, purple => 6,
                black  => 7, grey   => 8, white  => 9);

    my @array = qw(red blue green);

    say "some array elements in hash keys" if  @array ~~  %hash;
    say "some array elements in hash keys" if \@array ~~ \%hash;

    say "red in array" if "red" ~~  @array;
    say "red in array" if "red" ~~ \@array;

    say "some keys end in e" if /e$/ ~~  %hash;
    say "some keys end in e" if /e$/ ~~ \%hash;

=begin original

Two arrays smartmatch if each element in the first array smartmatches
(that is, is "in") the corresponding element in the second array,
recursively.

=end original

二つの配列は、最初の配列のそれぞれの要素が、二つ目の配列の対応する要素に
(つまり "in") 再帰的にスマートマッチングするときに、スマートマッチングします。

    use v5.10.1;
    my @little = qw(red blue green);
    my @bigger = ("red", "blue", [ "orange", "green" ] );
    if (@little ~~ @bigger) {  # true!
        say "little is contained in bigger";
    }

=begin original

Because the smartmatch operator recurses on nested arrays, this
will still report that "red" is in the array.

=end original

スマートマッチング演算子はネストした配列を再帰するので、これは "red" が
配列にいると報告するままです。

    use v5.10.1;
    my @array = qw(red blue green);
    my $nested_array = [[[[[[[ @array ]]]]]]];
    say "red in array" if "red" ~~ $nested_array;

=begin original

If two arrays smartmatch each other, then they are deep
copies of each others' values, as this example reports:

=end original

二つの配列が互いにスマートマッチングすると、次の例が報告しているように、
互いの値のディープコピーになります:

    use v5.12.0;
    my @a = (0, 1, 2, [3, [4, 5], 6], 7);
    my @b = (0, 1, 2, [3, [4, 5], 6], 7);

    if (@a ~~ @b && @b ~~ @a) {
        say "a and b are deep copies of each other";
    }
    elsif (@a ~~ @b) {
        say "a smartmatches in b";
    }
    elsif (@b ~~ @a) {
        say "b smartmatches in a";
    }
    else {
        say "a and b don't smartmatch each other at all";
    }

=begin original

If you were to set S<C<$b[3] = 4>>, then instead of reporting that "a and b
are deep copies of each other", it now reports that C<"b smartmatches in a">.
That's because the corresponding position in C<@a> contains an array that
(eventually) has a 4 in it.

=end original

S<C<$b[3] = 4>> に設定すると、"a and b are deep copies of each other" と
報告されるのではなく、C<"b smartmatches in a"> と報告されます。
これは、C<@a> の対応する位置には(最終的に)中に 4 がある配列を
含んでいるからです。

=begin original

Smartmatching one hash against another reports whether both contain the
same keys, no more and no less.  This could be used to see whether two
records have the same field names, without caring what values those fields
might have.  For example:

=end original

あるハッシュを他のものとスマートマッチングすると、両方に同じキーが
含まれているかどうかを報告し、それ以上でもそれ以下でもありません。
これは、値を気にせずに、二つのレコードが同じフィールド名を持っているか
どうかを見るのに使えるかもしれません。
例えば:

    use v5.10.1;
    sub make_dogtag {
        state $REQUIRED_FIELDS = { name=>1, rank=>1, serial_num=>1 };

        my ($class, $init_fields) = @_;

        die "Must supply (only) name, rank, and serial number"
            unless $init_fields ~~ $REQUIRED_FIELDS;

        ...
    }

=begin original

However, this only does what you mean if C<$init_fields> is indeed a hash
reference. The condition C<$init_fields ~~ $REQUIRED_FIELDS> also allows the
strings C<"name">, C<"rank">, C<"serial_num"> as well as any array reference
that contains C<"name"> or C<"rank"> or C<"serial_num"> anywhere to pass
through.

=end original

しかし、これは C<$init_fields> が確かにハッシュリファレンスである場合にのみ
考えている通りに動作します。
C<$init_fields ~~ $REQUIRED_FIELDS> という条件は、文字列
C<"name">, C<"rank">, C<"serial_num"> および、
C<"name">, C<"rank">, C<"serial_num"> のいずれかを含むような
配列リファレンスでも成立します。

=begin original

The smartmatch operator is most often used as the implicit operator of a
C<when> clause.  See the section on "Switch Statements" in L<perlsyn>.

=end original

スマートマッチング演算子は C<when> 節の暗黙の演算子としてもっともよく
使われます。
L<perlsyn> の "Switch Statements" の節を参照してください。

=head3 Smartmatching of Objects

(オブジェクトのスマートマッチング)

=begin original

To avoid relying on an object's underlying representation, if the
smartmatch's right operand is an object that doesn't overload C<~~>,
it raises the exception "C<Smartmatching a non-overloaded object
breaks encapsulation>".  That's because one has no business digging
around to see whether something is "in" an object.  These are all
illegal on objects without a C<~~> overload:

=end original

オブジェクトの基となる表現に依存することを避けるために、スマートマッチングの
右オペランドが C<~~> をオーバーロードしないオブジェクトなら、例外
"C<Smartmatching a non-overloaded object breaks encapsulation>" が発生します。
これは、何かがオブジェクトに「含まれている」かどうかを知るために
調べる筋合いではないからです。
次のものは C<~~> のオーバーロードがなければ全て不正です:

    %hash ~~ $object
       42 ~~ $object
   "fred" ~~ $object

=begin original

However, you can change the way an object is smartmatched by overloading
the C<~~> operator.  This is allowed to
extend the usual smartmatch semantics.
For objects that do have an C<~~> overload, see L<overload>.

=end original

しかし、C<~~> 演算子をオーバーロードすることにオブジェクトが
スマートマッチングする方法を変更できます。
これにより通常のスマートマッチングの意味論を拡張できます。
C<~~> のオーバーロードを持つオブジェクトについては、L<overload> を
参照してください。

=begin original

Using an object as the left operand is allowed, although not very useful.
Smartmatching rules take precedence over overloading, so even if the
object in the left operand has smartmatch overloading, this will be
ignored.  A left operand that is a non-overloaded object falls back on a
string or numeric comparison of whatever the C<ref> operator returns.  That
means that

=end original

左オペランドにオブジェクトを使うことは許されていますが、あまり
有用ではありません。
スマートマッチングの規則はオーバーロードより優先順位が高いので、例え
左オペランドのオブジェクトがスマートマッチングのオーバーロードを
持っていても、無視されます。
左オペランドがオーバーロードされていないオブジェクトなら、C<ref> 演算子が
返したものに従って、文字または数値比較にフォールバックします。
これは、

    $object ~~ X

=begin original

does I<not> invoke the overload method with C<I<X>> as an argument.
Instead the above table is consulted as normal, and based on the type of
C<I<X>>, overloading may or may not be invoked.  For simple strings or
numbers, "in" becomes equivalent to this:

=end original

は C<I<X>> を引数としてオーバーロードメソッドを起動 I<しない> ということです。
通常通り前述の表を見て C<I<X>> の型に依存するのではなく、オーバーロードは
起動されるかもしれませんし、されないかもしれません。
単純な文字列や数値については、"in" は以下と等価になります:

    $object ~~ $number          ref($object) == $number
    $object ~~ $string          ref($object) eq $string

=begin original

For example, this reports that the handle smells IOish
(but please don't really do this!):

=end original

例えば、これは "handle smells IOish" と報告します (しかし実際にこれを
しないでください!):

    use IO::Handle;
    my $fh = IO::Handle->new();
    if ($fh ~~ /\bIO\b/) {
        say "handle smells IOish";
    }

=begin original

That's because it treats C<$fh> as a string like
C<"IO::Handle=GLOB(0x8039e0)">, then pattern matches against that.

=end original

これは、C<$fh> を C<"IO::Handle=GLOB(0x8039e0)"> のような文字列として扱い、
それからパターンはこれに対してマッチングするからです。

=head2 Bitwise And
X<operator, bitwise, and> X<bitwise and> X<&>

(ビットごとの AND)

=begin original

Binary C<"&"> returns its operands ANDed together bit by bit.  Although no
warning is currently raised, the result is not well defined when this operation
is performed on operands that aren't either numbers (see
L</Integer Arithmetic>) nor bitstrings (see L</Bitwise String Operators>).

=end original

二項演算子の C<"&"> は、両オペランドのビットごとに論理積をとって、
その結果を返します。
数値 (L</Integer Arithmetic>) 参照) でもビット文字列
(L</Bitwise String Operators> 参照) でもないオペランドに対してこの演算を
実行した場合、現在のところ警告は出ませんが、結果は未定義です。

=begin original

Note that C<"&"> has lower priority than relational operators, so for example
the parentheses are essential in a test like

=end original

C<"&"> は関係演算子より優先順位が低いので、例えば以下のようなテストでは、
かっこが重要です:

    print "Even\n" if ($x & 1) == 0;

=begin original

If the "bitwise" feature is enabled via S<C<use feature 'bitwise'>> or
C<use v5.28>, then this operator always treats its operands as numbers.
Before Perl 5.28 this feature produced a warning in the
C<"experimental::bitwise"> category.

=end original

S<C<use feature 'bitwise'>> か C<use v5.28> によって "bitwise" 機能が
有効になっている場合、この演算子はオペランドを常に数値として扱います。
Perl 5.28 より前ではこの機能は C<"experimental::bitwise"> カテゴリの
警告が出力されていました。

=head2 Bitwise Or and Exclusive Or
X<operator, bitwise, or> X<bitwise or> X<|> X<operator, bitwise, xor>
X<bitwise xor> X<^>

(ビットごとの OR と XOR)

=begin original

Binary C<"|"> returns its operands ORed together bit by bit.  If both
corresponding bits are 0, the resulting bit is 0; if either is 1, the result is
1.

=end original

二項演算子の C<"|"> は、両オペランドのビットごとに論理和をとって、
その結果を返します。
対応するビットが両方とも 0 なら、結果のビットは 0 です;
どちらかが 1 なら、結果は 1 です。

=begin original

Binary C<"^"> returns its operands XORed together bit by bit.  If both
corresponding bits are 0 or both are 1, the resulting bit is 0; if just
one is 1, the result is 1.

=end original

二項演算子の C<"^"> は、両オペランドのビットごとに排他論理和をとって、
その結果を返します。
対応するビットが両方とも 0 または両方とも 1 なら、結果のビットは 1 です;
一つだけが 1 なら、結果は 1 です。

=begin original

Although no warning is currently raised, the results are not well
defined when these operations are performed on operands that aren't either
numbers (see L</Integer Arithmetic>) nor bitstrings (see L</Bitwise String
Operators>).

=end original

数値 (L</Integer Arithmetic>) 参照) でもビット文字列
(L</Bitwise String Operators> 参照) でもないオペランドに対してこれらの演算を
実行した場合、現在のところ警告は出ませんが、結果は未定義です。

=begin original

Note that C<"|"> and C<"^"> have lower priority than relational operators, so
for example the parentheses are essential in a test like

=end original

C<"|"> と C<"^"> は関係演算子より優先順位が低いので、例えば以下のような
テストでは、かっこが重要です:

    print "false\n" if (8 | 2) != 10;

=begin original

If the "bitwise" feature is enabled via S<C<use feature 'bitwise'>> or
C<use v5.28>, then this operator always treats its operands as numbers.
Before Perl 5.28. this feature produced a warning in the
C<"experimental::bitwise"> category.

=end original

S<C<use feature 'bitwise'>> か C<use v5.28> によって "bitwise" 機能が
有効になっている場合、この演算子はオペランドを常に数値として扱います。
Perl 5.28 より前ではこの機能は C<"experimental::bitwise"> カテゴリの
警告が出力されていました。

=head2 C-style Logical And
X<&&> X<logical and> X<operator, logical, and>

(C スタイルの論理積)

=begin original

Binary C<"&&"> performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=end original

二項演算子の C<"&&"> は、短絡の論理積演算を行ないます。
つまり、左被演算子が偽であれば、右被演算子は評価さえ
行なわれないということです。
評価される場合には、スカラかリストかというコンテキストは、
右被演算子に及びます。

=begin original

C<&&> returns the last value evaluated (unlike C's C<&&>, which returns
0 or 1).

=end original

C<&&> returns the last value evaluated (unlike C's C<&&>, which returns
0 or 1).
(TBT)

=begin original

As an alternative to C<&&> when used for control flow, Perl provides the
C<and> operator (see L<below|/Logical And>).
The short-circuit behavior is identical.  The precedence of C<"and"> is
much lower, however, so that you can safely use it after a list operator
without the need for parentheses.

=end original

As an alternative to C<&&> when used for control flow, Perl provides the
C<and> operator (see L<below|/Logical And>).
The short-circuit behavior is identical.  The precedence of C<"and"> is
much lower, however, so that you can safely use it after a list operator
without the need for parentheses.
(TBT)

=head2 C-style Logical Or, Xor, and Defined Or
X<||> X<operator, logical, or>
X<^^> X<operator, logical, xor>
X<//> X<operator, logical, defined-or>

=begin original

Binary C<"||"> performs a short-circuit logical OR operation.  That is,
if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
does get evaluated.

=end original

二項演算子の C<"||"> は、短絡の論理和演算を行ないます。
つまり、左被演算子が真であれば、右被演算子は評価さえ
行なわれないということです。
評価される場合には、スカラかリストかというコンテキストは、
右被演算子に及びます。

=begin original

As an alternative to C<||> when used for control flow, Perl provides the
C<or> operator (L<see below|/Logical or and Exclusive Or>).
The short-circuit behavior is identical.  The precedence of C<"or"> is
much lower, however, so that you can safely use it after a list operator
without the need for parentheses:

=end original

Perl では、フロー制御に使う場合の C<||> の同義語として、
C<or> 演算子が用意されています (L<下記参照|/Logical or and Exclusive Or>)。
短絡の動作は全く同じです。
しかし、C<"or"> の優先順位はかなり低くしてあるので、引数に括弧を
使っていないリスト演算子のあとに続けて使う場合にも、
安心して使うことができます:

    unlink "alpha", "beta", "gamma"
            or gripe(), next LINE;

=begin original

With the C-style operator that would have been written like this:

=end original

C スタイルの演算子では以下のように書く必要があります。

    unlink("alpha", "beta", "gamma")
            || (gripe(), next LINE);

=begin original

It would be even more readable to write that this way:

=end original

次のようにして書き込みをより読みやすくすることもできます:

    unless(unlink("alpha", "beta", "gamma")) {
        gripe();
        next LINE;
    }

=begin original

Using C<"or"> for assignment is unlikely to do what you want; see below.

=end original

代入で C<"or"> を使うと、したいことと違うことになります; 以下を
参照して下さい。

=begin original

Binary C<"^^"> performs a logical XOR operation.  Both operands are
evaluated and the result is true only if exactly one of the operands is true.
Scalar or list context propagates down to the right operand.

=end original

二項演算子の C<"^^"> は、短絡の排他的論理和演算を行ないます。
両方の被演算子が評価され、被演算子の一つだけが真の時にだけ真になります。
スカラかリストかというコンテキストは、右被演算子に及びます。

=begin original

Although it has no direct equivalent in C, Perl's C<//> operator is related
to its C-style "or".  In fact, it's exactly the same as C<||>, except that it
tests the left hand side's definedness instead of its truth.  Thus,
S<C<< EXPR1 // EXPR2 >>> returns the value of C<< EXPR1 >> if it's defined,
otherwise, the value of C<< EXPR2 >> is returned.
(C<< EXPR1 >> is evaluated in scalar context, C<< EXPR2 >>
in the context of C<< // >> itself).  Usually,
this is the same result as S<C<< defined(EXPR1) ? EXPR1 : EXPR2 >>> (except that
the ternary-operator form can be used as a lvalue, while S<C<< EXPR1 // EXPR2 >>>
cannot).  This is very useful for
providing default values for variables.  If you actually want to test if
at least one of C<$x> and C<$y> is defined, use S<C<defined($x // $y)>>.

=end original

C では直接等価なものはありませんが、Perl の C<//> 演算子は C スタイル
論理和に関連しています。
実際、左辺の真偽ではなく定義されているかを判定することを除けば
C<||> と同じです。
従って S<C<< EXPR1 // EXPR2 >>> は、C<< EXPR1 >> が定義されていればその値を
返し、さもなければ、C<< EXPR2 >> の値を返します。
(C<< EXPR1 >> はスカラコンテキストで、C<< EXPR2 >> は C<< // >> 自身の
コンテキストで評価されます。)
普通はこれは S<C<< defined(EXPR1) ? EXPR1 : EXPR2 >>> と同じ結果になり
完全に等価です (例外は 3 項演算子形式は左辺値として使えますが、
S<C<< EXPR1 // EXPR2 >>> は使えません)。
これは、変数に対するデフォルト値を設定するのにとても有用です。
実際に、C<$x> と C<$y> の少なくとも片方が定義されているかを判定したいなら、
S<C<defined($x // $y)>> を使ってください。

=begin original

The C<||>, C<^^> and C<//> operators return the last value evaluated
(unlike C's C<||> which returns 0 or 1).  Thus, a reasonably
portable way to find out the home directory might be:

=end original

C<||>, C<^^>, C<//> 演算子は、(C の C<||> のように 0 や 1 を
返すのではなく) 最後に評価された値を返します。
これにより、かなり一般的に使えるホームディレクトリを探す方法は:

    $home =  $ENV{HOME}
          // $ENV{LOGDIR}
          // (getpwuid($<))[7]
          // die "You're homeless!\n";

=begin original

In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:

=end original

特に、これは代入のために二つの集合を選択するためには
使うべきではないことを意味します。

    @a = @b || @c;            # This doesn't do the right thing
    @a = scalar(@b) || @c;    # because it really means this.
    @a = @b ? @b : @c;        # This works fine, though.

=head2 Range Operators
X<operator, range> X<range> X<..> X<...>

(範囲演算子)

=begin original

Binary C<".."> is the range operator, which is really two different
operators depending on the context.  In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.  If the left value is greater than the right value then it
returns the empty list.  The range operator is useful for writing
S<C<foreach (1..10)>> loops and for doing slice operations on arrays.
No temporary array is created when the range operator is used as the
expression in C<foreach> loops.

=end original

二項演算子の C<".."> は範囲演算子で、使われるコンテキストによって
異なる動作をする 2 つの演算子を合わせたものです。
リストコンテキストでは、左の値から右の値まで (1 づつ昇順で) 数えあげた値から
なるリストを返します。
左側の値が右側の値より大きい場合は、空リストを返します。
範囲演算子は、S<C<foreach (1..10)>> のようなループを書くときや、
配列のスライス演算を行なうときに便利です。
C<foreach> ループの式の中で範囲演算子を使っても
一時配列は作りません。

=begin original

The range operator also works on strings, using the magical
auto-increment, see below.

=end original

範囲演算子は、マジカル自動インクリメントを使うことで文字列でも動作します;
以下を参照してください。

=begin original

In scalar context, C<".."> returns a boolean value.  The operator is
bistable, like a flip-flop, and emulates the line-range (comma)
operator of B<sed>, B<awk>, and various editors.  Each C<".."> operator
maintains its own boolean state, even across calls to a subroutine
that contains it.  It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, I<AFTER> which the range operator becomes false
again.  It doesn't become false till the next time the range operator
is evaluated.  It can test the right operand and become false on the
same evaluation it became true (as in B<awk>), but it still returns
true once.  If you don't want it to test the right operand until the
next evaluation, as in B<sed>, just use three dots (C<"...">) instead of
two.  In all other regards, C<"..."> behaves just like C<".."> does.

=end original

スカラコンテキストで使われたときには、C<".."> は真偽値を返します。
この演算子は、フリップフロップのように 2 値安定で、
B<sed> や B<awk> や多くのエディタでの行範囲 (コンマ) 演算子を
エミュレートするものとなります。
各々の C<".."> 演算子は、例えそれを含むサブルーチンの呼び出しを
またいでも、それぞれに独立して自分の真偽状態を管理します。
はじめは、左被演算子が偽である間、演算全体も偽となっています。
いったん左被演算子が真になると、範囲演算子は、右被演算子が真である間、
真を返すようになります; 範囲演算子が再び偽になった I<後> です。
次に範囲演算子が評価されるまでは、偽とはなりません。
(B<awk> でのように) 真となった、その評価の中で右被演算子をテストし、
偽とすることができますが、1 度は真を返すことになります。
B<sed> でのように、次に評価されるまで右被演算子をテストしたくなければ、
2 個のドットの代わりに 3 つのドット (C<"...">) を使ってください。
その他の点では、C<"..."> は C<".."> と同様に振舞います．

=begin original

The right operand is not evaluated while the operator is in the
"false" state, and the left operand is not evaluated while the
operator is in the "true" state.  The precedence is a little lower
than || and &&.  The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.  The sequence
number is reset for each range encountered.  The final sequence number
in a range has the string C<"E0"> appended to it, which doesn't affect
its numeric value, but gives you something to search for if you want
to exclude the endpoint.  You can exclude the beginning point by
waiting for the sequence number to be greater than 1.

=end original

右被演算子は、演算子の状態が「偽」である間は評価されることがなく、
左被演算子は、演算子の状態が「真」である間は評価されることがありません。
優先順位は、|| と && の少し下です。
偽としては空文字列が返され、
真としては (1 から始まる) 通し番号が返されます。
この通し番号は、新たに範囲が始まるごとにリセットされます。
範囲の最後の通し番号には、文字列 C<"E0"> が末尾につけられます; これは、
数値としては何の影響もありませんが、範囲の終わりで何か特別なことをしたい
場合に、目印として使うことができます。
範囲の始まりを除きたい場合には、通し番号が 1 よりも大きくなるのを
待てばよいでしょう。

=begin original

If either operand of scalar C<".."> is a constant expression,
that operand is considered true if it is equal (C<==>) to the current
input line number (the C<$.> variable).

=end original

スカラの C<".."> の被演算子が定数表現であるときは、その被演算子は暗黙に、
現在の入力行番号(変数 C<$.>) と等しい(C<==>) 場合に真となります。

=begin original

To be pedantic, the comparison is actually S<C<int(EXPR) == int(EXPR)>>,
but that is only an issue if you use a floating point expression; when
implicitly using C<$.> as described in the previous paragraph, the
comparison is S<C<int(EXPR) == int($.)>> which is only an issue when C<$.>
is set to a floating point value and you are not reading from a file.
Furthermore, S<C<"span" .. "spat">> or S<C<2.18 .. 3.14>> will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.

=end original

とても細かい話をすると、比較は実際には S<C<int(EXPR) == int(EXPR)>> ですが、
これは浮動小数点数を使うときにだけ問題になります; 前の段落で記述したように
明示的に C<$.> を使ったとき、比較は S<C<int(EXPR) == int($.)>> となり、
C<$.> に浮動小数点数がセットされ、ファイルから読み込みを行わない場合にのみ
問題になります。
さらに、S<C<"span" .. "spat">> や S<C<2.18 .. 3.14>> は、それぞれの
オペランドが整数表現を使って評価されるため、スカラコンテキストでは
望みどおりの結果になりません。

=begin original

Examples:

=end original

例:

=begin original

As a scalar operator:

=end original

スカラ演算子として:

    if (101 .. 200) { print; } # print 2nd hundred lines, short for
                               #  if ($. == 101 .. $. == 200) { print; }

    next LINE if 1 .. /^$/;    # skip header lines, short for
                               #   next LINE if $. == 1 .. /^$/;
                               # (typically in a loop labeled LINE)

    s/^/> / if /^$/ .. eof();  # quote body

    # parse mail messages
    while (<>) {
        $in_header =   1  .. /^$/;
        $in_body   = /^$/ .. eof;
        if ($in_header) {
            # do something
        } else { # in body
            # do something else
        }
    } continue {
        close ARGV if eof;             # reset $. each file
    }

=begin original

Here's a simple example to illustrate the difference between
the two range operators:

=end original

以下は二つの範囲演算子の違いを示す単純な例です:

    @lines = ("   - Foo",
              "01 - Bar",
              "1  - Baz",
              "   - Quux");

    foreach (@lines) {
        if (/0/ .. /1/) {
            print "$_\n";
        }
    }

=begin original

This program will print only the line containing "Bar".  If
the range operator is changed to C<...>, it will also print the
"Baz" line.

=end original

このプログラムは "Bar" を含む行だけを表示します。
範囲演算子を C<...> に変更すると、"Baz" の行も表示します。

=begin original

And now some examples as a list operator:

=end original

これはリスト演算子の例です:

=begin original

    for (101 .. 200) { print }      # print $_ 100 times
    @foo = @foo[0 .. $#foo];        # an expensive no-op
    @foo = @foo[$#foo-4 .. $#foo];  # slice last 5 items

=end original

    for (101 .. 200) { print }      # $_ を 100 回出力
    @foo = @foo[0 .. $#foo];        # 高価な no-op
    @foo = @foo[$#foo-4 .. $#foo];  # 末尾の 5 アイテムをスライス

=begin original

Because each operand is evaluated in integer form, S<C<2.18 .. 3.14>> will
return two elements in list context.

=end original

それぞれのオペランドは整数の形で評価されるので、S<C<2.18 .. 3.14>> は
リストコンテキストでは二つの要素を返します。

=begin original

    @list = (2.18 .. 3.14); # same as @list = (2 .. 3);

=end original

    @list = (2.18 .. 3.14); # @list = (2 .. 3); と同じ

=begin original

The range operator in list context can make use of the magical
auto-increment algorithm if both operands are strings, subject to the
following rules:

=end original

リストコンテキストでの範囲演算子は、両方のオペランドが
文字列であるときには、次の規則に従って、マジカルインクリメントの
機能が使えます。

=over

=item *

=begin original

With one exception (below), if both strings look like numbers to Perl,
the magic increment will not be applied, and the strings will be treated
as numbers (more specifically, integers) instead.

=end original

一つの例外(後述)を除いて、
両側の文字列が Perl にとって数値に見える場合、
マジカルインクリメントは適用されず、代わりにその文字列は数値として
(より正確には、整数として)扱われます。

=begin original

For example, C<"-2".."2"> is the same as C<-2..2>, and
C<"2.18".."3.14"> produces C<2, 3>.

=end original

例えば、C<"-2".."2"> は C<-2..2> と同じで、
C<"2.18".."3.14"> は C<2, 3> を生成します。

=item *

=begin original

The exception to the above rule is when the left-hand string begins with
C<0> and is longer than one character, in this case the magic increment
I<will> be applied, even though strings like C<"01"> would normally look
like a number to Perl.

=end original

前述の規則の例外として、
左側の文字列が C<0> で始まっていて 2 文字以上の場合、
C<"01"> のような文字列は通常 Perl にとって数値に見えるにも関わらず、
この場合はマジカルインクリメントは I<適用されます> 。

=begin original

For example, C<"01".."04"> produces C<"01", "02", "03", "04">, and
C<"00".."-1"> produces C<"00"> through C<"99"> - this may seem
surprising, but see the following rules for why it works this way.
To get dates with leading zeros, you can say:

=end original

例えば、C<"01".."04"> は C<"01", "02", "03", "04"> を生成し、
C<"00".."-1"> は C<"00"> から C<"99"> を生成します - これは驚きがあるかも
しれませんが、なぜこれがこのように動作するのかについては
次の規則を見てください。
先頭に 0 があるものから日付を取り出すために、次のようにできます:

    @z2 = ("01" .. "31");
    print $z2[$mday];

=begin original

If you want to force strings to be interpreted as numbers, you could say

=end original

文字列が数値として解釈することを強制したいなら、次のようにできます:

    @numbers = ( 0+$first .. 0+$last );

=begin original

B<Note:> In Perl versions 5.30 and below, I<any> string on the left-hand
side beginning with C<"0">, including the string C<"0"> itself, would
cause the magic string increment behavior. This means that on these Perl
versions, C<"0".."-1"> would produce C<"0"> through C<"99">, which was
inconsistent with C<0..-1>, which produces the empty list. This also means
that C<"0".."9"> now produces a list of integers instead of a list of
strings.

=end original

B<注意:> Perl バージョン 5.30 以下では、左側が C<"0"> で始まる
I<任意の> 文字列 (文字列 C<"0"> 自体を含む)は、マジカル文字列
インクリメントを引き起こします。
つまり、これらの Perl バージョンでは、C<"0".."-1"> は C<"0"> から
C<"99"> までを生成しますが、これは空のリストを生成する C<0..-1> と
矛盾していました。
また、C<"0".."9"> では、文字列のリストではなく整数のリストが
生成されるということです。

=item *

=begin original

If the initial value specified isn't part of a magical increment
sequence (that is, a non-empty string matching C</^[a-zA-Z]*[0-9]*\z/>),
only the initial value will be returned.

=end original

指定された初期値がマジカルインクリメント処理の一部でない場合
(つまり、C</^[a-zA-Z]*[0-9]*\z/> にマッチングする、空でない文字列の場合)、
初期値のみが返されます。

=begin original

For example, C<"ax".."az"> produces C<"ax", "ay", "az">, but
C<"*x".."az"> produces only C<"*x">.

=end original

例えば、C<"ax".."az"> は C<"ax", "ay", "az"> を生成しますが、
C<"*x".."az"> は C<"*x"> だけを生成します。

=item *

=begin original

For other initial values that are strings that do follow the rules of the
magical increment, the corresponding sequence will be returned.

=end original

マジカルインクリメントの規則に従う文字列がもう片方の初期値の場合、
対応する並びが返されます。

=begin original

For example, you can say

=end original

例えば以下のように書くと:

    @alphabet = ("A" .. "Z");

=begin original

to get all normal letters of the English alphabet, or

=end original

英語の大文字すべてを得られますし:

    $hexdigit = (0 .. 9, "a" .. "f")[$num & 15];

=begin original

to get a hexadecimal digit.

=end original

と書けば、16 進の数字が得られます。

=item *

=begin original

If the final value specified is not in the sequence that the magical
increment would produce, the sequence goes until the next value would
be longer than the final value specified. If the length of the final
string is shorter than the first, the empty list is returned.

=end original

マジカルインクリメントによって得られる値の中に指定した最終値に
ちょうど一致するものが見つからないような場合には、
マジカルインクリメントによって得られる次の値の文字列長が、
最終値として指定した値のものより長くなるまでインクリメントが続けられます。
最終値の文字列の長さが最初のものより短い場合、
空リストが返されます。

=begin original

For example, C<"a".."--"> is the same as C<"a".."zz">, C<"0".."xx">
produces C<"0"> through C<"99">, and C<"aaa".."--"> returns the empty
list.

=end original

例えば、C<"a".."--"> は C<"a".."zz"> と同じで、
C<"0".."xx"> は C<"0"> から C<"99"> を出力し、
C<"aaa".."--"> は空リストを返します。

=back

=begin original

As of Perl 5.26, the list-context range operator on strings works as expected
in the scope of L<< S<C<"use feature 'unicode_strings">>|feature/The
'unicode_strings' feature >>. In previous versions, and outside the scope of
that feature, it exhibits L<perlunicode/The "Unicode Bug">: its behavior
depends on the internal encoding of the range endpoint.

=end original

Perl 5.26 から、文字列に対するリストコンテキスト範囲演算子は、
L<< S<C<"use feature 'unicode_strings">>|feature/The
'unicode_strings' feature >> のスコープの中で想定通りに
動作するようになりました。
以前のバージョン、およびこの機能のスコープの外側では、
これは L<perlunicode/The "Unicode Bug"> を起こしていました:
その振る舞いは範囲の両端の内部エンコーディングに依存していました。

=begin original

Because the magical increment only works on non-empty strings matching
C</^[a-zA-Z]*[0-9]*\z/>, the following will only return an alpha:

=end original

マジカルインクリメントは C</^[a-zA-Z]*[0-9]*\z/> にマッチングする
空でない文字列でのみ動作するので、
以下はαのみを返します:

    use charnames "greek";
    my @greek_small =  ("\N{alpha}" .. "\N{omega}");

=begin original

To get the 25 traditional lowercase Greek letters, including both sigmas,
you could use this instead:

=end original

両方のシグマを含む、25 文字の伝統的な小文字のギリシャ文字を得るためには、
代わりに以下のようにしてください:

    use charnames "greek";
    my @greek_small =  map { chr } ( ord("\N{alpha}")
                                        ..
                                     ord("\N{omega}")
                                   );

=begin original

However, because there are I<many> other lowercase Greek characters than
just those, to match lowercase Greek characters in a regular expression,
you could use the pattern C</(?:(?=\p{Greek})\p{Lower})+/> (or the
L<experimental feature|perlrecharclass/Extended Bracketed Character
Classes> C<S</(?[ \p{Greek} & \p{Lower} ])+/>>).

=end original

しかし、小文字のギリシャ文字はここに書いたものよりも I<たくさん> あるので、
正規表現で小文字のギリシャ文字にマッチングさせるためには、
C</(?:(?=\p{Greek})\p{Lower})+/> というパターン (または
L<実験的機能|perlrecharclass/Extended Bracketed Character Classes> である
C<S</(?[ \p{Greek} & \p{Lower} ])+/>>) を使います。

=head2 Conditional Operator
X<operator, conditional> X<operator, ternary> X<ternary> X<?:>

(条件演算子)

=begin original

Ternary C<"?:"> is the conditional operator, just as in C.  It works much
like an if-then-else.  If the argument before the C<?> is true, the
argument before the C<:> is returned, otherwise the argument after the
C<:> is returned.  For example:

=end original

三項演算子の C<"?:"> は、C の場合と同じ条件演算子です。
これは、if-then-else のように働きます。
C<"?"> の前の引数が真であれば C<":"> の前の引数が返されますが、
真でなければ、C<":"> の後の引数が返されます。
例えば:

    printf "I have %d dog%s.\n", $n,
            ($n == 1) ? "" : "s";

=begin original

Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.

=end original

スカラコンテキストかリストコンテキストかという状況は、
選択された 2 番目もしくは 3 番目の引数にまで伝わります。

=begin original

    $x = $ok ? $y : $z;  # get a scalar
    @x = $ok ? @y : @z;  # get an array
    $x = $ok ? @y : @z;  # oops, that's just a count!

=end original

    $x = $ok ? $y : $z;  # スカラを取る
    @x = $ok ? @y : @z;  # 配列を取る
    $x = $ok ? @y : @z;  # うわ、これは単なる数です!

=begin original

The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):

=end original

2 番目と 3 番目の引数双方が左辺値 (代入可能ということ)であれば、
この演算子に代入を行なうこともできます:

    ($x_or_y ? $x : $y) = $z;

=begin original

Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.  For example, this:

=end original

この演算子は代入可能な結果を生み出すので、
括弧なしで代入を行うとおかしくなるかもしれません。
例えばこれは:

    $x % 2 ? $x += 10 : $x += 2

=begin original

Really means this:

=end original

以下を意味し:

    (($x % 2) ? ($x += 10) : $x) += 2

=begin original

Rather than this:

=end original

以下のようにはなりません:

    ($x % 2) ? ($x += 10) : ($x += 2)

=begin original

That should probably be written more simply as:

=end original

恐らく以下のようにもっと単純に書くべきでしょう:

    $x += ($x % 2) ? 10 : 2;

=head2 Assignment Operators
X<assignment> X<operator, assignment> X<=> X<**=> X<+=> X<*=> X<&=>
X<<< <<= >>> X<&&=> X<-=> X</=> X<|=> X<<< >>= >>> X<||=> X<//=> X<.=>
X<%=> X<^=> X<x=> X<&.=> X<|.=> X<^.=> X<^^=>

(代入演算子)

=begin original

C<"="> is the ordinary assignment operator.

=end original

C<"="> は通常の代入演算子です。

=begin original

Assignment operators work as in C.  That is,

=end original

代入演算子は C の場合と同様の働きをします。
つまり、

    $x += 2;

=begin original

is equivalent to

=end original

は以下と等価です:

    $x = $x + 2;

=begin original

although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from C<tie()>.  Other assignment operators work similarly.
The following are recognized:

=end original

しかし、C<tie()> のようなもので起こる左辺値の被参照による
副作用が 2 回起こることはありません。
他の代入演算も同様に働きます。
以下のものが認識されます:

    **=    +=    *=    &=    &.=    <<=    &&=
           -=    /=    |=    |.=    >>=    ||=
           .=    %=    ^=    ^.=           //=
                 x=                        ^^=

=begin original

Although these are grouped by family, they all have the precedence
of assignment.  These combined assignment operators can only operate on
scalars, whereas the ordinary assignment operator can assign to arrays,
hashes, lists and even references.  (See L<"Context"|perldata/Context>
and L<perldata/List value constructors>, and L<perlref/Assigning to
References>.)

=end original

グループ分けしてありますが、これらはいずれも代入演算子として
同じ優先順位となっています。
これらの複合代入演算子はスカラとしてのみ動作しますが、一方
通常の代入演算子は配列、スカラ、リスト、リファレンスに代入できます。
(L<"Context"|perldata/Context>, L<perldata/List value constructors>,
L<perlref/Assigning to References> を参照してください。)

=begin original

Unlike in C, the scalar assignment operator produces a valid lvalue.
Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.  This is useful
for modifying a copy of something, like this:

=end original

C と違って、スカラ代入演算子は有効な左辺値を作り出します。
代入を修正することは、代入を行なってから、その代入された変数を修正するのと
同じことになります。
これは、以下のように何かのコピーを変更したいときに便利です:

    ($tmp = $global) =~ tr/13579/24680/;

=begin original

Although as of 5.14, that can be also be accomplished this way:

=end original

しかし 5.14 現在、これは次のようにしてもできるようになりました:

    use v5.14;
    $tmp = ($global =~  tr/13579/24680/r);

=begin original

Likewise,

=end original

同様に、

    ($x += 2) *= 3;

=begin original

is equivalent to

=end original

は以下と等価です:

    $x += 2;
    $x *= 3;

=begin original

Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.

=end original

同様に、リストコンテキストでのリストへの代入は代入可能な左辺値のリストとなり、
スカラコンテキストでのリストへの代入は代入の右側の式で作成された
要素の数を返します。

=begin original

The three dotted bitwise assignment operators (C<&.=> C<|.=> C<^.=>) are new in
Perl 5.22.  See L</Bitwise String Operators>.

=end original

三つのドット付きビット単位代入演算子 (C<&.=> C<|.=> C<^.=>) は
Perl 5.22 からの新しいものです。
L</Bitwise String Operators> を参照してください。

=head2 Comma Operator
X<comma> X<operator, comma> X<,>

(コンマ演算子)

=begin original

Binary C<","> is the comma operator.  In scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.

=end original

二項演算子の C<","> はコンマ演算子です。
スカラコンテキストではその左引数を評価し、その値を捨てて、
それから右引数を評価し、その値を返します。
これはちょうど、C のコンマ演算子と同じです。

=begin original

In list context, it's just the list argument separator, and inserts
both its arguments into the list.  These arguments are also evaluated
from left to right.

=end original

リストコンテキストでは、これは単にリスト引数の区切り文字で、
双方の引数をそのリストに挿入する働きがあります。
これらの引数も左から右に評価されます。

=begin original

The C<< => >> operator (sometimes pronounced "fat comma") is a synonym
for the comma except that it causes a
word on its left to be interpreted as a string if it begins with a letter
or underscore and is composed only of letters, digits and underscores.
This includes operands that might otherwise be interpreted as operators,
constants, single number v-strings or function calls.  If in doubt about
this behavior, the left operand can be quoted explicitly.

=end original

C<< => >> 演算子(時々「ファットコンマ」と発音されます)はコンマ演算子の
同義語ですが、もし左側の単語が文字か下線で始まっていて、かつ文字、数字、
下線でのみ構成されている場合、これを文字列として扱うという効果もあります。
これには他の場所では演算子、定数、v-文字列、関数呼び出しとして扱われる
オペランドを含みます。
この振る舞いについて迷うことがあるなら、左オペランドを明示的に
クォートすることも出来ます。

=begin original

Otherwise, the C<< => >> operator behaves exactly as the comma operator
or list argument separator, according to context.

=end original

さもなければ、C<< => >> 演算子はコンテキストによって、
カンマ演算子かリスト引数の区切り文字と全く同様に振る舞います。

=begin original

For example:

=end original

例えば:

    use constant FOO => "something";

    my %h = ( FOO => 23 );

=begin original

is equivalent to:

=end original

は、以下と等価です:

    my %h = ("FOO", 23);

=begin original

It is I<NOT>:

=end original

これは I<違います>:

    my %h = ("something", 23);

=begin original

The C<< => >> operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.

=end original

C<< => >> 演算子は、ハッシュのキーと値や、その他のリスト中の組となる
要素の関係を表現するのに便利です。

    %hash = ( $key => $value );
    login( $username => $password );

=begin original

The special quoting behavior ignores precedence, and hence may apply to
I<part> of the left operand:

=end original

特殊なクォートの振る舞いは優先順位を無視し、従って左オペランドの I<一部> に
適用されることがあります:

    print time.shift => "bbb";

=begin original

That example prints something like C<"1314363215shiftbbb">, because the
C<< => >> implicitly quotes the C<shift> immediately on its left, ignoring
the fact that C<time.shift> is the entire left operand.

=end original

この例は C<"1314363215shiftbbb"> のようなものを表示します; なぜなら
C<< => >> は暗黙にすぐ左にある C<shift> をクォートし、 C<time.shift> 全体が
左オペランドであるという事実を無視するからです。

=head2 List Operators (Rightward)
X<operator, list, rightward> X<list operator>

(リスト演算子 (右方向))

=begin original

On the right side of a list operator, the comma has very low precedence,
such that it controls all comma-separated expressions found there.
The only operators with lower precedence are the logical operators
C<"and">, C<"or">, and C<"not">, which may be used to evaluate calls to list
operators without the need for parentheses:

=end original

リスト演算子の右側のものにとって、カンマはとても低い優先順位になります;
これによってコンマで区切った式をリスト演算子の引数として
置くことができます。
これよりも優先順位が低いものは、論理演算子の C<"and">, C<"or">,
C<"not"> のみで、括弧を付けないリスト演算子の呼び出しを評価するために使えます:

    open HANDLE, "< :encoding(UTF-8)", "filename"
        or die "Can't open: $!\n";

=begin original

However, some people find that code harder to read than writing
it with parentheses:

=end original

しかし、かっこ付きで書くよりもコードが読みにくいという人もいます:

    open(HANDLE, "< :encoding(UTF-8)", "filename")
        or die "Can't open: $!\n";

=begin original

in which case you might as well just use the more customary C<"||"> operator:

=end original

この場合、より慣習的な C<"||"> 演算子も使えます:

    open(HANDLE, "< :encoding(UTF-8)", "filename")
        || die "Can't open: $!\n";

=begin original

See also discussion of list operators in L</Terms and List Operators (Leftward)>.

=end original

L</Terms and List Operators (Leftward)> のリスト演算子の議論も参照して下さい。

=head2 Logical Not
X<operator, logical, not> X<not>

(論理否定)

=begin original

Unary C<"not"> returns the logical negation of the expression to its right.
It's the equivalent of C<"!"> except for the very low precedence.

=end original

単項演算子の C<"not"> は右側に来る式の否定を返します。
これは、優先順位がずっと低いことを除いては C<"!"> と等価です。

=head2 Logical And
X<operator, logical, and> X<and>

(論理積)

=begin original

Binary C<"and"> returns the logical conjunction of the two surrounding
expressions.  It's equivalent to C<&&> except for the very low
precedence.  This means that it short-circuits: the right
expression is evaluated only if the left expression is true.

=end original

二項演算子の C<"and"> は両側の式の論理積を返します。
これは、優先順位がずっと低いことを除けば C<&&> と等価です。
つまり、これも短絡演算を行ない、右側の式は左側の式が
「真」であった場合にのみ評価されます。

=head2 Logical or and Exclusive Or
X<operator, logical, or> X<or>
X<operator, logical, xor> X<operator, logical, exclusive or> X<xor>

(論理和と排他論理和)

=begin original

There is no low precedence operator for defined-OR.

=end original

定義性論理和の低優先順位版はありません。

=begin original

Binary C<"or"> returns the logical inclusive disjunction of the two
surrounding expressions.  It's equivalent to C<||> except for it having
very low precedence.  This makes it useful for control flow:

=end original

二項演算子の C<"or"> は両側の式の非排他的論理和を返します。
これは、優先順位がずっと低いことを除いて C<||> と等価です。
これはフローを制御するのに有用です:

    print FH $data              or die "Can't write to FH: $!";

=begin original

This means that it short-circuits: the right expression is evaluated
only if the left expression is false.  Due to its precedence, you must
be careful to avoid using it as replacement for the C<||> operator.
It usually works out better for flow control than in assignments:

=end original

つまり、これも短絡演算を行ない、右側の式は左側の式が
「偽」であった場合にのみ評価されます。
優先度の関係で、これを C<||> 演算子の置き換えに使うのは慎重に
避けなければなりません。
これは普通代入よりも、フローの制御でうまく動作します:

=begin original

    $x = $y or $z;              # bug: this is wrong
    ($x = $y) or $z;            # really means this
    $x = $y || $z;              # better written this way

=end original

    $x = $y or $z;              # バグ: これは間違い
    ($x = $y) or $z;            # 本当にしたいこと
    $x = $y || $z;              # こう書いた方がいい

=begin original

However, when it's a list-context assignment and you're trying to use
C<||> for control flow, you probably need C<"or"> so that the assignment
takes higher precedence.

=end original

しかし、代入がリストコンテキストの時に C<||> をフロー制御に使おうとする場合、
代入により大きな優先順位を持たせるために C<"or"> が必要かもしれません。

=begin original

    @info = stat($file) || die;     # oops, scalar sense of stat!
    @info = stat($file) or die;     # better, now @info gets its due

=end original

    @info = stat($file) || die;     # うわ、stat がスカラの意味だ!
    @info = stat($file) or die;     # よりよい; @info はその目的を果たす

=begin original

Then again, you could always use parentheses.

=end original

もちろん、常に括弧をつけてもよいです。

=begin original

Binary C<"xor"> returns the logical exclusive disjunction of the two
surrounding expressions.  That means it returns C<true> if either, but
not both, are true.  It's equivalent to C<^^> except for it having very
low precedence.  It cannot short-circuit (of course).  It tends to be
used to verify that two mutually-exclusive conditions are actually
mutually exclusive.  For example, in Perl's test suite, we might want to
test that a regular expression pattern can't both match and not match,
for otherwise it would be a bug in our pattern matching code.

=end original

二項演算子の C<"xor"> は両側の式の排他論理和を返します。
つまり、両方ではなく、どちらか片方だけ真の場合に
C<true> を返します。
これは、優先順位がずっと低いことを除いて C<^^> と等価です。
これは (もちろん) 短絡できません。
これは、二つの互いに排他な条件が実際に排他であることを検証するために
使われる傾向があります。
例えば、Perl のテストスイートでは、私たちはある正規表現パターンが
マッチングすることとマッチングしないことが同時に起きないことを
テストした方が良いでしょう;
さもなければパターンマッチングコードにバグがあることになるからです。

 ($x =~ qr/$pat/ xor $x !~ qr/$pat/) or die;

=head2 C Operators Missing From Perl
X<operator, missing from perl> X<&> X<*>
X<typecasting> X<(TYPE)>

(Perl にない C の演算子)

=begin original

Here is what C has that Perl doesn't:

=end original

C にあって Perl に無いものは以下の通りです:

=over 8

=item unary &

=begin original

Address-of operator.  (But see the C<"\"> operator for taking a reference.)

=end original

アドレス演算子。
(しかし C<"\"> 演算子がリファレンスのために用いられます。)

=item unary *

=begin original

Dereference-address operator.  (Perl's prefix dereferencing
operators are typed: C<$>, C<@>, C<%>, and C<&>.)

=end original

被アドレス参照演算子。
(Perl の被参照プリフィクス演算子が型づけを行ないます:
C<$>, C<@>, C<%>, C<&>。)

=item (TYPE)

=begin original

Type-casting operator.

=end original

型のキャスト演算子。

=back

=head2 Quote and Quote-like Operators
X<operator, quote> X<operator, quote-like> X<q> X<qq> X<qx> X<qw> X<m>
X<qr> X<s> X<tr> X<'> X<''> X<"> X<""> X<//> X<`> X<``> X<<< << >>>
X<escape sequence> X<escape>

(クォートとクォート風の演算子)

=begin original

While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a C<{}> represents
any pair of delimiters you choose.

=end original

クォートはリテラル値であると考えるのが普通ですが、Perl において、
クォートは演算子として働き、さまざまな展開やパターンマッチの機能を
持っています。
そのような動作をさせるのに、Perl は慣習的にクォート文字を使っていますが、
どの種類のクォートも、自分でクォート文字を選べるようになっています。
以下の表では、{} がその選んだ区切文字のペアを示しています。

=begin original

    Customary  Generic        Meaning        Interpolates
        ''       q{}          Literal             no
        ""      qq{}          Literal             yes
        ``      qx{}          Command             yes*
                qw{}         Word list            no
        //       m{}       Pattern match          yes*
                qr{}          Pattern             yes*
                 s{}{}      Substitution          yes*
                tr{}{}    Transliteration         no (but see below)
                 y{}{}    Transliteration         no (but see below)
        <<EOF                 here-doc            yes*

=end original

     通常記法  汎用記法        意味             展開
    =================================================
        ''       q{}         リテラル           不可
        ""      qq{}         リテラル           可
        ``      qx{}         コマンド           可 *
                qw{}         単語リスト         不可
        //       m{}      パターンマッチ        可 *
                qr{}         パターン           可 *
                 s{}{}         置換             可 *
                tr{}{}         変換             不可 (但し以下を参照のこと)
                 y{}{}         変換             不可 (但し以下を参照のこと)
        <<EOF            ヒアドキュメント       可 *

=begin original

        * unless the delimiter is ''.

=end original

        * '' がデリミタでない場合のみ

=begin original

Non-bracketing delimiters use the same character fore and aft, but the four
sorts of ASCII brackets (round, angle, square, curly) all nest, which means
that

=end original

選んだ区切文字が括弧の類でない場合には、前後の文字として同一のものを
使いますが、4 つの ASCII のかっこ ((), <>, [], {}) の場合にはネストできます;
つまり、以下のものは、

    q{foo{bar}baz}

=begin original

is the same as

=end original

以下と同じです。

    'foo{bar}baz'

=begin original

Note, however, that this does not always work for quoting Perl code:

=end original

しかし、以下のコードはクォートされた Perl コードでは
いつも正しく動くわけではないことに注意してください:

    $s = q{ if ($x eq "}") ... }; # WRONG

=begin original

is a syntax error.  The C<L<Text::Balanced>> module (standard as of v5.8,
and from CPAN before then) is able to do this properly.

=end original

これは文法エラーとなります。
C<L<Text::Balanced>> モジュール(Perl 5.8 からは標準配布、それ以前は CPAN に
あります)はこれを適切に行います。

=begin original

If the C<extra_paired_delimiters> feature is enabled, then Perl will
additionally recognise a variety of Unicode characters as being paired. For
a full list, see the L</List of Extra Paired Delimiters> at the end of this
document.

=end original

C<extra_paired_delimiters> 機能が有効の場合、
Perl は追加で多くの Unicode 文字を組として認識します。
完全な一覧については、この末尾にある
L</List of Extra Paired Delimiters> を参照してください。

=begin original

There can (and in some cases, must) be whitespace between the operator
and the quoting
characters, except when C<#> is being used as the quoting character.
C<q#foo#> is parsed as the string C<foo>, while S<C<q #foo#>> is the
operator C<q> followed by a comment.  Its argument will be taken
from the next line.  This allows you to write:

=end original

演算子とクォート文字の間に空白を置くことも出来ます (そして場合によっては
必須です); ただし、C<#> をクォート文字として使う場合は例外です。
C<q#foo#> は文字列 C<foo> としてパースされますが、
S<C<q #foo#>> は C<q> 演算子の後にコメントがあるとみなされます。
この引数は次の行から取られます。つまり、以下のように書けます:

=begin original

    s {foo}  # Replace foo
      {bar}  # with bar.

=end original

    s {foo}  # foo を
      {bar}  # bar で置き換える

=begin original

The cases where whitespace must be used are when the quoting character
is a word character (meaning it matches C</\w/>):

=end original

空白が使われなければならないのは、クォート文字が単語文字
(つまり C</\w/> にマッチングする)の場合です:

    q XfooX # Works: means the string 'foo'
    qXfooX  # WRONG!

=begin original

The following escape sequences are available in constructs that interpolate,
and in transliterations whose delimiters aren't single quotes (C<"'">).
In all the ones with braces, any number of blanks and/or tabs adjoining
and within the braces are allowed (and ignored).
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N> X<\N{}>
X<\o{}>

=end original

以下のエスケープシーケンスが、
区切り文字がシングルクォート (C<"'">) でない展開と文字変換の構文で
利用可能です。
中かっこつきのもの全ては、中かっこの中で隣接している任意の数の空白や
タブが許されます(そして無視されます)。
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N> X<\N{}>
X<\o{}>

=begin original

    Sequence     Note  Description
    \t                  tab               (HT, TAB)
    \n                  newline           (NL)
    \r                  return            (CR)
    \f                  form feed         (FF)
    \b                  backspace         (BS)
    \a                  alarm (bell)      (BEL)
    \e                  escape            (ESC)
    \x{263A}     [1,8]  hex char          (example shown: SMILEY)
    \x{ 263A }          Same, but shows optional blanks inside and
                        adjoining the braces
    \x1b         [2,8]  restricted range hex char (example: ESC)
    \N{name}     [3]    named Unicode character or character sequence
    \N{U+263D}   [4,8]  Unicode character (example: FIRST QUARTER MOON)
    \c[          [5]    control char      (example: chr(27))
    \o{23072}    [6,8]  octal char        (example: SMILEY)
    \033         [7,8]  restricted range octal char  (example: ESC)

=end original

    シーケンス   注意  説明
    \t                  タブ              (HT, TAB)
    \n                  改行              (NL)
    \r                  復帰              (CR)
    \f                  改ページ          (FF)
    \b                  バックスペース    (BS)
    \a                  アラーム          (BEL)
    \e                  エスケープ        (ESC)
    \x{263a}     [1,8]  16 進文字         (例: SMILEY)
    \x{ 263A }          同様、しかし中かっこの内側に隣接している
                        オプションの空白を示している
    \x1b         [2,8]  範囲制限された 16 進数で表した文字  (例: ESC)
    \N{name}     [3]    名前つき Unicode 文字または文字シーケンス
    \N{U+263D}   [4,8]  Unicode 文字      (例: FIRST QUARTER MOON)
    \c[          [5]    制御文字          (例: chr(27))
    \o{23072}    [6,8]  8 進文字          (例: SMILEY)
    \033         [7,8]  範囲制限された 8 進文字  (例: ESC)

=begin original

Note that any escape sequence using braces inside interpolated
constructs may have optional blanks (tab or space characters) adjoining
with and inside of the braces, as illustrated above by the second
S<C<\x{ }>> example.

=end original

変数置換構文の中の中かっこを使ったエスケープシーケンスは、
前述の 2 番目の S<C<\x{ }>> の例で図示したように、中かっこの内側隣接の
位置にオプションの空白(タブまたはスペース文字)を置くことができます。

=over 4

=item [1]

=begin original

The result is the character specified by the hexadecimal number between
the braces.  See L</[8]> below for details on which character.

=end original

結果は中かっこで囲まれた 16 進数で指定された文字です。
その文字に関する詳細については以下の L</[8]> を参照してください。

=begin original

Blanks (tab or space characters) may separate the number from either or
both of the braces.

=end original

空白 (タブまたはスペース文字) は、片方または両方の中かっこから数字を
分離します。

=begin original

Otherwise, only hexadecimal digits are valid between the braces.  If an
invalid character is encountered, a warning will be issued and the
invalid character and all subsequent characters (valid or invalid)
within the braces will be discarded.

=end original

さもなければ、中かっこの中には 16 進数字のみが妥当です。
不正な文字に遭遇すると、警告が発生し、中かっこの内側の不正な文字と
それ以降の文字(妥当でも不正でも)は捨てられます。

=begin original

If there are no valid digits between the braces, the generated character is
the NULL character (C<\x{00}>).  However, an explicit empty brace (C<\x{}>)
will not cause a warning (currently).

=end original

中かっこの中に妥当な文字がなければ、生成される文字は NULL 文字
(C<\x{00}>) です。
しかし、明示的な空の中かっこ (C<\x{}>) は(今のところ)警告を出しません。

=item [2]

=begin original

The result is the character specified by the hexadecimal number in the range
0x00 to 0xFF.  See L</[8]> below for details on which character.

=end original

結果は 0x00 から 0xFF の範囲の 16 進数で指定された文字です。
その文字に関する詳細については以下の L</[8]> を参照してください。

=begin original

Only hexadecimal digits are valid following C<\x>.  When C<\x> is followed
by fewer than two valid digits, any valid digits will be zero-padded.  This
means that C<\x7> will be interpreted as C<\x07>, and a lone C<"\x"> will be
interpreted as C<\x00>.  Except at the end of a string, having fewer than
two valid digits will result in a warning.  Note that although the warning
says the illegal character is ignored, it is only ignored as part of the
escape and will still be used as the subsequent character in the string.
For example:

=end original

C<\x> に引き続くのは 16 進数字のみが妥当です。
C<\x> に引き続く妥当な数字が 2 桁ない場合、妥当な数字はゼロで
パッディングされます。
これは、C<\x7> は C<\x07> と解釈され、単独の C<"\x"> は C<\x00> と
解釈されるということです。
文字列の末尾を例外として、妥当な数字が 2 桁ない場合は警告が発生します。
警告は不正な文字が無視されると言うにも関わらず、エスケープの一部のみが
無視され、文字列中の引き続く文字は使われるままであることに注意してください。
例えば:

    Original    Result    Warns?
    "\x7"       "\x07"    no
    "\x"        "\x00"    no
    "\x7q"      "\x07q"   yes
    "\xq"       "\x00q"   yes

=item [3]

=begin original

The result is the Unicode character or character sequence given by I<name>.
See L<charnames>.

=end original

結果は I<name> で指定される Unicode 文字または文字の並びです。
L<charnames> を参照してください。

=item [4]

=begin original

S<C<\N{U+I<hexadecimal number>}>> means the Unicode character whose Unicode code
point is I<hexadecimal number>.

=end original

S<C<\N{U+I<hexadecimal number>}>> は、Unicode 符号位置が
I<hexadecimal number> の Unicode 文字を意味します。

=item [5]

=begin original

The character following C<\c> is mapped to some other character as shown in the
table:

=end original

C<\c> に引き続く文字は以下の表に示すように他の文字にマッピングされます:

    Sequence   Value
      \c@      chr(0)
      \cA      chr(1)
      \ca      chr(1)
      \cB      chr(2)
      \cb      chr(2)
      ...
      \cZ      chr(26)
      \cz      chr(26)
      \c[      chr(27)
                        # See below for chr(28)
      \c]      chr(29)
      \c^      chr(30)
      \c_      chr(31)
      \c?      chr(127) # (on ASCII platforms; see below for link to
                        #  EBCDIC discussion)

=begin original

In other words, it's the character whose code point has had 64 xor'd with
its uppercase.  C<\c?> is DELETE on ASCII platforms because
S<C<ord("?") ^ 64>> is 127, and
C<\c@> is NULL because the ord of C<"@"> is 64, so xor'ing 64 itself produces 0.

=end original

言い換えると、符号位置を 64 で xor して大文字にした文字です。
S<C<ord("?") ^ 64>> は 127 なので C<\c?> は ASCII プラットフォームでは
DELETE で、C<"@"> は 64 のために
64 で xor すると 0 になるので C<\c@> は NUL です。

=begin original

Also, C<\c\I<X>> yields S<C< chr(28) . "I<X>">> for any I<X>, but cannot come at the
end of a string, because the backslash would be parsed as escaping the end
quote.

=end original

また、C<\c\I<X>> は任意の I<X> について S<C< chr(28) . "I<X>">> となりますが、
文字列の末尾には来ません; 逆スラッシュは末尾のクォートをエスケープするように
パースされるからです。

=begin original

On ASCII platforms, the resulting characters from the list above are the
complete set of ASCII controls.  This isn't the case on EBCDIC platforms; see
L<perlebcdic/OPERATOR DIFFERENCES> for a full discussion of the
differences between these for ASCII versus EBCDIC platforms.

=end original

ASCII プラットフォームでは、上述の一覧からの結果の文字は ASCII 制御文字の
完全な集合です。
これは EBCDIC プラットフォームには当てはまりません; これに関する
ASCII プラットフォームと EBCDIC プラットフォームとの違いの完全な議論については
L<perlebcdic/OPERATOR DIFFERENCES> を参照してください。

=begin original

Use of any other character following the C<"c"> besides those listed above is
discouraged, and as of Perl v5.20, the only characters actually allowed
are the printable ASCII ones, minus the left brace C<"{">.  What happens
for any of the allowed other characters is that the value is derived by
xor'ing with the seventh bit, which is 64, and a warning raised if
enabled.  Using the non-allowed characters generates a fatal error.

=end original

C<"c"> に引き続いて上述した以外の文字を使うことは非推奨であり、
as of Perl v5.20, the only characters actually allowed
are the printable ASCII ones, minus the left brace C<"{">.
許されている他の文字を置いたときに起こることは、値が第 7 ビット;
つまり 64 で xor を取ったものになり、
有効の場合は警告が発生します。
許されていない文字を使うと致命的エラーが発生します。

=begin original

To get platform independent controls, you can use C<\N{...}>.

=end original

プラットフォーム非依存の制御文字を得るには、C<\N{...}> を使ってください。

=item [6]

=begin original

The result is the character specified by the octal number between the braces.
See L</[8]> below for details on which character.

=end original

結果は中かっこで囲まれた 8 進数で指定された文字です。
その文字に関する詳細については以下の L</[8]> を参照してください。

=begin original

Blanks (tab or space characters) may separate the number from either or
both of the braces.

=end original

空白 (タブまたはスペース文字) は、片方または両方の中かっこから数字を
分離します。

=begin original

Otherwise, if a character that isn't an octal digit is encountered, a
warning is raised, and the value is based on the octal digits before it,
discarding it and all following characters up to the closing brace.  It
is a fatal error if there are no octal digits at all.

=end original

さもなければ、8 進数でない文字に遭遇すると、警告が発生し、値はそこまでの
8 進数字を基として、それ以降閉じ中かっこまでの全ての文字を捨てます。
8 進数字がまったくないと致命的エラーになります。

=item [7]

=begin original

The result is the character specified by the three-digit octal number in the
range 000 to 777 (but best to not use above 077, see next paragraph).  See
L</[8]> below for details on which character.

=end original

結果は範囲 000 から 777 までの 3 桁の 8 進数で指定される文字です
(しかし 077 より上は使わないのが最良です; 次の段落を参照してください)。
その文字に関する詳細については以下の L</[8]> を参照してください。

=begin original

Some contexts allow 2 or even 1 digit, but any usage without exactly
three digits, the first being a zero, may give unintended results.  (For
example, in a regular expression it may be confused with a backreference;
see L<perlrebackslash/Octal escapes>.)  Starting in Perl 5.14, you may
use C<\o{}> instead, which avoids all these problems.  Otherwise, it is best to
use this construct only for ordinals C<\077> and below, remembering to pad to
the left with zeros to make three digits.  For larger ordinals, either use
C<\o{}>, or convert to something else, such as to hex and use C<\N{U+}>
(which is portable between platforms with different character sets) or
C<\x{}> instead.

=end original

一部のコンテキストでは 2 桁や、1 桁ですら許されますが、正確に 3 桁かつ
先頭が 0、以外の使い方は意図していない結果をもたらすかもしれません。
(例えば、正規表現中では後方参照で混乱するかもしれません;
L<perlrebackslash/Octal escapes> を参照してください。)
Perl 5.14 から、代わりに C<\o{}> を使えます; これはこれらすべての問題を
避けられます。
さもなければ、この構文を値 C<\077> 以下でのみ使用するのが最良です;
3 桁にするために左側にゼロをパッディングするのを忘れないでください。
より大きな値では、C<\o{}> を使うか、代わりに 16 進数にして
C<\N{U+}>
(これは異なった文字集合のプラットフォーム間で移植性があります) を使うか、
または C<\x{}> を
使うような、他のものに変換してください。

=item [8]

=begin original

Several constructs above specify a character by a number.  That number
gives the character's position in the character set encoding (indexed from 0).
This is called synonymously its ordinal, code position, or code point.  Perl
works on platforms that have a native encoding currently of either ASCII/Latin1
or EBCDIC, each of which allow specification of 256 characters.  In general, if
the number is 255 (0xFF, 0377) or below, Perl interprets this in the platform's
native encoding.  If the number is 256 (0x100, 0400) or above, Perl interprets
it as a Unicode code point and the result is the corresponding Unicode
character.  For example C<\x{50}> and C<\o{120}> both are the number 80 in
decimal, which is less than 256, so the number is interpreted in the native
character set encoding.  In ASCII the character in the 80th position (indexed
from 0) is the letter C<"P">, and in EBCDIC it is the ampersand symbol C<"&">.
C<\x{100}> and C<\o{400}> are both 256 in decimal, so the number is interpreted
as a Unicode code point no matter what the native encoding is.  The name of the
character in the 256th position (indexed by 0) in Unicode is
C<LATIN CAPITAL LETTER A WITH MACRON>.

=end original

上述のいくつかの構造は文字を数値で指定しています。
この値は文字集合エンコーディングで (0 から始めた) 文字の位置を指定します。
これは同意語として序数(ordinal)、コード位置(code position)、
符号位置(code point)と呼ばれます。
Perl は現在のところ、それぞれ 256 文字を定義している ASCII/Latin1 または
EBCDIC のどちらかのネイティブエンコーディングを持つプラットフォームで
動作します。
一般的に、数値が 255 (0xFF, 0377) 以下なら、Perl はこれをプラットフォームの
ネイティブエンコーディングと解釈します。
数値が 256 (0x100, 0400) 以上なら、Perl はこれを Unicode 符号位置と解釈し、
結果は対応する Unicode 文字となります。
例えば C<\x{50}> と C<\o{120}> はどちらも 10 進数では 80 で、これは 256 より
小さいので、数値はネイティブ文字集合エンコーディングとして解釈されます。
ASCII では (0 から始めて) 80 番目の位置の文字は C<"P"> で、EBCDIC では
アンパサンド記号 C<"&"> です。
C<\x{100}> と C<\o{400}> はどちらも 10 進数では 256 なので、数値は
ネイティブエンコーディングが何かに関わらず Unicode 符号位置として
解釈されます。
Unicode での (0 から始めて) 256 番目の位置の文字の名前は
C<LATIN CAPITAL LETTER A WITH MACRON> です。

=begin original

An exception to the above rule is that S<C<\N{U+I<hex number>}>> is
always interpreted as a Unicode code point, so that C<\N{U+0050}> is C<"P"> even
on EBCDIC platforms.

=end original

上述の規則の例外として、S<C<\N{U+I<16 進数>}>> は常に Unicode 符号位置として
解釈されるので、C<\N{U+0050}> は EBCDIC プラットフォームでも C<"P"> です。

=back

=begin original

B<NOTE>: Unlike C and other languages, Perl has no C<\v> escape sequence for
the vertical tab (VT, which is 11 in both ASCII and EBCDIC), but you may
use C<\N{VT}>, C<\ck>, C<\N{U+0b}>, or C<\x0b>.  (C<\v>
does have meaning in regular expression patterns in Perl, see L<perlre>.)

=end original

B<注意>: C やその他の言語と違って、Perl は垂直タブ (VT - ASCII と EBCDIC の
両方で 11) のための \v エスケープシーケンスはありませんが、C<\N{VT}>, C<\ck>,
C<\N{U+0b}>, C<\x0b> が使えます。
(C<\v> は Perl の正規表現パターンでは意味があります; L<perlre> を
参照してください。)

=begin original

The following escape sequences are available in constructs that interpolate,
but not in transliterations.
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q> X<\F>

=end original

以下のエスケープシーケンスが展開と文字変換の構文で利用可能です。
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q>
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q> X<\F>

=begin original

    \l          lowercase next character only
    \u          titlecase (not uppercase!) next character only
    \L          lowercase all characters till \E or end of string
    \U          uppercase all characters till \E or end of string
    \F          foldcase all characters till \E or end of string
    \Q          quote (disable) pattern metacharacters till \E or
                end of string
    \E          end either case modification or quoted section
                (whichever was last seen)

=end original

    \l          次の文字だけを小文字にする
    \u          次の文字だけをタイトル文字(大文字ではありません!)にする
    \L          \E か文字列の末尾まで小文字にする
    \U          \E か文字列の末尾まで大文字にする
    \F          \E か文字列の末尾まで畳み込み文字にする
    \Q          \E か文字列の末尾までパターンメタ文字をクォート(無効化)する
    \E          大文字小文字変換かクォート部分(どちらか最後に現れたもの)を
                終了させる

=begin original

See L<perlfunc/quotemeta> for the exact definition of characters that
are quoted by C<\Q>.

=end original

C<\Q> でクォートされる文字の正確な定義については L<perlfunc/quotemeta> を
参照してください。

=begin original

C<\L>, C<\U>, C<\F>, and C<\Q> can stack, in which case you need one
C<\E> for each.  For example:

=end original

C<\L>, C<\U>, C<\F>, C<\Q> はスタックできます; この場合それぞれに対して
C<\E> が必要です。
例えば:

    say "This \Qquoting \ubusiness \Uhere isn't\E done yet,\E is it?";
    This quoting Business HERE ISN'T done yet, is it?

=begin original

If a S<C<use locale>> form that includes C<LC_CTYPE> is in effect (see
L<perllocale>), the case map used by C<\l>, C<\L>, C<\u>, and C<\U> is
taken from the current locale.  If Unicode (for example, C<\N{}> or code
points of 0x100 or beyond) is being used, the case map used by C<\l>,
C<\L>, C<\u>, and C<\U> is as defined by Unicode.  That means that
case-mapping a single character can sometimes produce a sequence of
several characters.
Under S<C<use locale>>, C<\F> produces the same results as C<\L>
for all locales but a UTF-8 one, where it instead uses the Unicode
definition.

=end original

C<LC_CTYPE> を含む S<C<use locale>> 型式が有効の場合(L<perllocale> を
参照して下さい)、C<\l>, C<\L>, C<\u>, C<\U> で使われる
大文字小文字テーブルは現在のロケールのものが使われます。
(例えば、C<\N{}> や、0x100 以上の符号位置の) Unicode が
使われている場合、C<\l>, C<\L>, C<\u>, C<\U> で使われる大文字小文字
テーブルは Unicode で定義されているものになります。
これは、単一の文字の大文字小文字マッピングは複数の文字の並びを生成することが
あるということです。
S<C<use locale>> の基では、C<\F> は、Unicode の定義が使われる UTF-8 以外の
全てのロケールにおいて、C<\L> と同じ結果を生成します。

=begin original

All systems use the virtual C<"\n"> to represent a line terminator,
called a "newline".  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read C<"\r"> as ASCII CR and C<"\n"> as ASCII LF.  For example,
on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed,
and on systems without a line terminator,
printing C<"\n"> might emit no actual data.  In general, use C<"\n"> when
you mean a "newline" for your system, but use the literal ASCII when you
need an exact character.  For example, most networking protocols expect
and prefer a CR+LF (C<"\015\012"> or C<"\cM\cJ">) for line terminators,
and although they often accept just C<"\012">, they seldom tolerate just
C<"\015">.  If you get in the habit of using C<"\n"> for networking,
you may be burned some day.
X<newline> X<line terminator> X<eol> X<end of line>
X<\n> X<\r> X<\r\n>

=end original

全てのシステムでは "newline" と呼ばれる行端末子を表現するために
仮想的な C<"\n"> が用いられます。
普遍の、物理的な "newline" 文字と言うものはありません。
オペレーティングシステム、デバイスドライバ、C ライブラリ、Perl が全て
協力して保存しようとすると言うのは単なる幻想です。
全てのシステムで C<"\r"> を ASCII CR として、また C<"\n"> を
ASCII LF として読み込むわけではありません。
例えば昔の Mac (MacOS X 以前)ではこれらは保存され、行端末子のない
システムでは、C<"\n"> を print しても実際のデータは何も出力しません。
一般に、システムで "newline" を意味したいときには C<"\n"> を使いますが、
正確な文字が必要な場合はリテラルな ASCII を使います。
例えば、ほとんどのネットワークプロトコルでは行端末子として
CR+LF (C<"\015\012"> または C<"\cM\cJ">) を予想し、また好みますが、
しばしば C<"\012"> だけでも許容し、さらに時々は C<"\015"> だけでも認めます。
もしネットワーク関係で C<"\n"> を使う習慣がついていると、
いつか痛い目を見ることになるでしょう。
X<newline> X<line terminator> X<eol> X<end of line>
X<\n> X<\r> X<\r\n>

=begin original

For constructs that do interpolate, variables beginning with "C<$>"
or "C<@>" are interpolated.  Subscripted variables such as C<$a[3]> or
C<< $href->{key}[0] >> are also interpolated, as are array and hash slices.
But method calls such as C<< $obj->meth >> are not.

=end original

展開が行なわれる構文では、"C<$>" や "C<@>" で始まる変数が展開されます。
C<$a[3]> や C<< $href->{key}[0] >> のような添え字付き変数もまた
配列やハッシュのスライスのように展開されます。
しかし、C<< $obj->meth >> のようなメソッド呼び出しは展開されません。

=begin original

Interpolating an array or slice interpolates the elements in order,
separated by the value of C<$">, so is equivalent to interpolating
S<C<join $", @array>>.  "Punctuation" arrays such as C<@*> are usually
interpolated only if the name is enclosed in braces C<@{*}>, but the
arrays C<@_>, C<@+>, and C<@-> are interpolated even without braces.

=end original

配列やスライスの展開は、要素を順番に、C<$"> の値で分割して展開されるので、
S<C<join $", @array>> の展開と等価です。
C<@*> のような「句読点」配列は普通は名前が C<@{*}> のように中かっこで
囲われている場合にのみ展開されますが、配列 C<@_>, C<@+>, C<@-> は
中かっこなしでも展開されます。

=begin original

For double-quoted strings, the quoting from C<\Q> is applied after
interpolation and escapes are processed.

=end original

ダブルクォートされた文字列では、C<\Q> からのクォートは文字変換と
エスケープが処理された後に適用されます。

    "abc\Qfoo\tbar$s\Exyz"

=begin original

is equivalent to

=end original

は以下と等価です:

    "abc" . quotemeta("foo\tbar$s") . "xyz"

=begin original

For the pattern of regex operators (C<qr//>, C<m//> and C<s///>),
the quoting from C<\Q> is applied after interpolation is processed,
but before escapes are processed.  This allows the pattern to match
literally (except for C<$> and C<@>).  For example, the following matches:

=end original

正規表現演算子 (C<qr//>, C<m//>, C<s///>) のパターンでは、C<\Q> による
クォートは変数展開が行われた後、エスケープが処理される前に適用されます。
これによりパターンを (C<$> と C<@> 以外は) リテラルにマッチングできます。
例えば、以下はマッチングします:

    '\s\t' =~ /\Q\s\t/

=begin original

Because C<$> or C<@> trigger interpolation, you'll need to use something
like C</\Quser\E\@\Qhost/> to match them literally.

=end original

C<$> や C<@> は変換を引き起こすので、リテラルにマッチングさせるためには
C<m/\Quser\E\@\Qhost/> などという風に書く必要があります。

=begin original

Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use C<\Q> to
interpolate a variable literally.

=end original

パターンはさらに、正規表現として展開が行なわれます。
これは、変数が展開された後の 2 回目のパスで行なわれるので、変数に正規表現を
含めておき、パターンの中へ展開することができます。
もし、そうしたくないのであれば、C<\Q> を使うと変数の内容を文字通りに
展開することができます。

=begin original

Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.  In particular, contrary to the
expectations of shell programmers, back-quotes do I<NOT> interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.

=end original

上記の振る舞いを除けば、Perl は 複数の段階を踏んで展開を行ないません。
特に、シェルのプログラマの期待とは裏腹に、バッククォートはダブルクォートの
中では展開されませんし、シングルクォートがダブルクォートの中で使われても、
変数の展開を妨げることは I<ありません>。

=head3 Simpler Quote-Like Operators
X<operator, quote-like>

(単純なクォート風演算子)

=over 4

=item C<q/I<STRING>/>
X<q> X<quote, single> X<'> X<''>

=item C<'I<STRING>'>

=begin original

A single-quoted, literal string.  A backslash represents a backslash
unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.

=end original

シングルクォートされた、リテラル文字列です。
バックスラッシュは、後ろに続くものが区切文字か、別のバックスラッシュで
ある場合を除いて単なるバックスラッシュです; 
区切文字やバックスラッシュが続く場合には、その区切文字自身もしくは
バックスラッシュそのものが展開されます。

    $foo = q!I said, "You said, 'She said it.'"!;
    $bar = q('This is it.');
    $baz = '\n';                # a two-character string

=item C<qq/I<STRING>/>
X<qq> X<quote, double> X<"> X<"">

=item C<"I<STRING>">

=begin original

A double-quoted, interpolated string.

=end original

ダブルクォートされた、リテラル文字列です。

    $_ .= qq
     (*** The previous line contains the naughty word "$1".\n)
                if /\b(tcl|java|python)\b/i;      # :-)
    $baz = "\n";                # a one-character string

=item C<qx/I<STRING>/>
X<qx> X<`> X<``> X<backtick>

=item C<`I<STRING>`>

=begin original

A string which is (possibly) interpolated and then executed as a
system command, via F</bin/sh> or its equivalent if required.  Shell
wildcards, pipes, and redirections will be honored.  Similarly to
C<system>, if the string contains no shell metacharacters then it will
be executed directly.  The collected standard output of the command is
returned; standard error is unaffected.  In scalar context, it comes
back as a single (potentially multi-line) string, or C<undef> if the
shell (or command) could not be started.  In list context, returns a
list of lines (however you've defined lines with C<$/> or
C<$INPUT_RECORD_SEPARATOR>), or an empty list if the shell (or command)
could not be started.

=end original

展開され、必要なら F</bin/sh> またはそれと等価なものでシステムの
コマンドとして実行される(であろう)文字列です。
シェルのワイルドカード、パイプ、リダイレクトが有効です。
C<system> と同様、文字列にシェルメタ文字が含まれていないときは、
直接実行されます。
そのコマンドの、標準出力を集めたものが返されます; 標準エラーは影響を
与えません。
スカラコンテキストでは、(複数行を含むかもしれない)
1 つの文字列が戻ってきます;
シェル (またはコマンド) が開始できなかったときは C<undef> を返します。
リストコンテキストでは、(C<$/> もしくは C<$INPUT_RECORD_SEPARATOR> を
どのように設定していても) 行のリストを返します;
シェル (またはコマンド) が開始できなかったときは
空リストを返します。

    print qx/date/; # prints "Sun Jan 28 06:16:19 CST 2024"

=begin original

Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.
To capture a command's STDERR and STDOUT together:

=end original

バッククォートは標準エラーには影響を与えないので、標準エラーを
使いたい場合は(シェルが対応しているものとして)シェルのファイル記述子の
文法を使ってください。
コマンドの STDERR と STDOUT を共に取得したい場合は:

    $output = `cmd 2>&1`;

=begin original

To capture a command's STDOUT but discard its STDERR:

=end original

コマンドの STDOUT は取得するが STDERR は捨てる場合は:

    $output = `cmd 2>/dev/null`;

=begin original

To capture a command's STDERR but discard its STDOUT (ordering is
important here):

=end original

コマンドの STDERR は取得するが STDOUT は捨てる場合は
(ここでは順序が重要です):

    $output = `cmd 2>&1 1>/dev/null`;

=begin original

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:

=end original

STDERR を取得するが、STDOUT は古い STDERR のために残しておくために
STDOUT と STDERR を交換するには:

    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;

=begin original

To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:

=end original

コマンドの STDOUT と STDERR の両方を別々に読み込みたい場合、
一番簡単な方法は別々のファイルにリダイレクトし、
プログラムが終了してからそのファイルを読むことです:

    system("program args 1>program.stdout 2>program.stderr");

=begin original

The STDIN filehandle used by the command is inherited from Perl's STDIN.
For example:

=end original

コマンドによって使われる STDIN ファイルハンドルは Perl の STDIN を
継承します。
例えば:

    open(SPLAT, "stuff")   || die "can't open stuff: $!";
    open(STDIN, "<&SPLAT") || die "can't dupe SPLAT: $!";
    print STDOUT `sort`;

=begin original

will print the sorted contents of the file named F<"stuff">.

=end original

は F<"stuff"> という名前のファイルの内容をソートして表示します。

=begin original

Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:

=end original

シングルクォートをデリミタとして使うと Perl のダブルクォート展開から
保護され、そのままシェルに渡されます:

    $perl_info  = qx(ps $$);            # that's Perl's $$
    $shell_info = qx'ps $$';            # that's the new shell's $$

=begin original

How that string gets evaluated is entirely subject to the command
interpreter on your system.  On most platforms, you will have to protect
shell metacharacters if you want them treated literally.  This is in
practice difficult to do, as it's unclear how to escape which characters.
See L<perlsec> for a clean and safe example of a manual C<fork()> and C<exec()>
to emulate backticks safely.

=end original

この文字列がどのように評価されるかは完全にシステムのコマンドインタプリタに
依存します。
ほとんどのプラットフォームでは、シェルのメタ文字をリテラルに
扱ってほしい場合はそれを守る必要があります。
文字をエスケープする方法が明確ではないので、これは理論的には難しいことです。
逆クォートを安全にエミュレートするために手動で C<fork()> と C<exec()> を
行うためのきれいで安全な例については L<perlsec> を参照してください。

=begin original

On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.  You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (for example, C<;> on
many Unix shells and C<&> on the Windows NT C<cmd> shell).

=end original

(特に DOS 風の)プラットフォームには、シェルが複数行のコマンドを扱うことが
できないものがあるので、文字列に改行を入れるとあなたの望まない結果に
なる場合があります。
シェルが対応していれば、コマンド分割文字で分割することで
1 行に複数のコマンドを入れて解釈させることができます
(この文字は、多くの Unix シェルでは C<;>、Windows NT C<cmd> シェルでは
C<&> です)。

=begin original

Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see L<perlport>).  To be safe, you may need to set
C<$|> (C<$AUTOFLUSH> in C<L<English>>) or call the C<autoflush()> method of
C<L<IO::Handle>> on any open handles.

=end original

Perl は子プロセスの実行前に書き込み用に開いている全ての
ファイルをフラッシュしようとしますが、これに対応していない
プラットフォームもあります(L<perlport> を参照してください)。
安全のためには、C<$|> (C<L<English>> モジュールでは C<$AUTOFLUSH>)を
セットするか、開いている全てのハンドルに対して C<L<IO::Handle>> の
C<autoflush()> メソッドを呼び出す必要があります。

=begin original

Beware that some command shells may place restrictions on the length
of the command line.  You must ensure your strings don't exceed this
limit after any necessary interpolations.  See the platform-specific
release notes for more details about your particular environment.

=end original

コマンド行の長さに制限があるコマンドシェルがあることに注意してください。
全ての必要な変換が行われた後、コマンド文字列がこの制限を越えないことを
保障する必要があります。
特定の環境に関するさらなる詳細についてはプラットフォーム固有の
リリースノートを参照してください。

=begin original

Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.  As one example, the C<type> command under
the POSIX shell is very different from the C<type> command under DOS.
That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.  Perl was made to be
a glue language, and one of the things it glues together is commands.
Just understand what you're getting yourself into.

=end original

この演算子を使うと、プログラムの移殖が困難になります; 呼び出されるシェル
コマンドはシステムによって異なり、実際全く存在しないこともあるからです。
一つの例としては、POSIX シェルの C<type> コマンドは DOS の C<type> コマンドと
大きく異なっています。
これは、何かを為すために正しい方法として逆クォートを使うことを
避けるべきであることを意味しません。
Perl は接着剤のような言語として作られ、接着されるべきものの一つは
コマンドです。
単にあなたが何をしようとしているかを理解しておいてください。

=begin original

Like C<system>, backticks put the child process exit code in C<$?>.
If you'd like to manually inspect failure, you can check all possible
failure modes by inspecting C<$?> like this:

=end original

C<system> シフトと同様、逆クォートは子プロセスの終了コードを C<$?> に
設定します。
手動で失敗を調査したい場合、次のように C<$?> を調べることによって
全てのあり得る失敗モードをチェックできます:

    if ($? == -1) {
        print "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        printf "child died with signal %d, %s coredump\n",
            ($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
        printf "child exited with value %d\n", $? >> 8;
    }

=begin original

Use the L<open> pragma to control the I/O layers used when reading the
output of the command, for example:

=end original

コマンドの出力を読み込むのに使われる I/O 層を制御するには L<open> を使います;
例えば:

    use open IN => ":encoding(UTF-8)";
    my $x = `cmd-producing-utf-8`;

=begin original

C<qx//> can also be called like a function with L<perlfunc/readpipe>.

=end original

C<qx//> はまた、L<perlfunc/readpipe> のような関数から呼び出されます。

=begin original

See L</"I/O Operators"> for more discussion.

=end original

さらなる議論については L</"I/O Operators"> を参照して下さい。

=item C<qw/I<STRING>/>
X<qw> X<quote, list> X<quote, words>

=begin original

Evaluates to a list of the words extracted out of I<STRING>, using embedded
whitespace as the word delimiters.  It can be understood as being roughly
equivalent to:

=end original

埋め込まれた空白を区切文字として、I<STRING> から抜き出した単語のリストを
評価します。
これは、以下の式と大体同じと考えられます:

    split(" ", q/STRING/);

=begin original

the differences being that it only splits on ASCII whitespace,
generates a real list at compile time, and
in scalar context it returns the last element in the list.  So
this expression:

=end original

違いは、ASCII の空白でのみ分割し、実際のリストをコンパイル時に生成し、
スカラコンテキストではリストの最後の要素を返すことです。
従って、以下の表現は:

    qw(foo bar baz)

=begin original

is semantically equivalent to the list:

=end original

以下のリストと文法的に等価です。

    "foo", "bar", "baz"

=begin original

Some frequently seen examples:

=end original

よく行なわれる例としては以下のものです:

    use POSIX qw( setlocale localeconv )
    @EXPORT = qw( foo bar baz );

=begin original

A common mistake is to try to separate the words with commas or to
put comments into a multi-line C<qw>-string.  For this reason, the
S<C<use warnings>> pragma and the B<-w> switch (that is, the C<$^W> variable)
produces warnings if the I<STRING> contains the C<","> or the C<"#"> character.

=end original

よくある間違いは、単語をカンマで区切ったり、複数行の C<qw> 文字列の中に
コメントを書いたりすることです。
このために、S<C<usr warnings>> プラグマと B<-w> スイッチ
(つまり、C<$^W> 変数) は I<STRING> に C<","> や C<"#"> の文字が入っていると
警告を出します。

=back

=head3 Regexp Quote-Like Operators
X<operator, regexp>

(正規表現のクォート風の演算子)

=begin original

Here are the quote-like operators that apply to pattern
matching and related activities.

=end original

以下はパターンマッチングと関連する行動に関するクォート風の演算子です。

=over 8

=item C<qr/I<STRING>/msixpodualn>
X<qr> X</i> X</m> X</o> X</s> X</x> X</p>

=begin original

This operator quotes (and possibly compiles) its I<STRING> as a regular
expression.  I<STRING> is interpolated the same way as I<PATTERN>
in C<m/I<PATTERN>/>.  If C<"'"> is used as the delimiter, no variable
interpolation is done.  Returns a Perl value which may be used instead of the
corresponding C</I<STRING>/msixpodualn> expression.  The returned value is a
normalized version of the original pattern.  It magically differs from
a string containing the same characters: C<ref(qr/x/)> returns "Regexp";
however, dereferencing it is not well defined (you currently get the
normalized version of the original pattern, but this may change).

=end original

この演算子は I<STRING> を正規表現としてクォートします
(そして可能ならコンパイルします)。
I<STRING> は C<m/I<PATTERN>/> 内の I<PATTERN> と同様に文字変換されます。
C<"'"> がデリミタとして使用された場合、変数展開は行われません。
対応する C</I<STRING>/msixpodualn> 表現の代わりに使われた Perl の値を返します。
返り値は元のパターンを正規化したものです。
これは不思議なことに、同じ文字を含む文字列とは異なります:
C<ref(qr/x/)> は "Regexp" を返します; しかし、これのデリファレンスは
定義されていません (現在の所元のパターンの正規化版を返しますが、これは
変更されるかもしれません)。

=begin original

For example,

=end original

例えば:

    $rex = qr/my.STRING/is;
    print $rex;                 # prints (?si-xm:my.STRING)
    s/$rex/foo/;

=begin original

is equivalent to

=end original

は以下と等価です:

    s/my.STRING/foo/is;

=begin original

The result may be used as a subpattern in a match:

=end original

結果はマッチのサブパターンとして使えます:

=begin original

    $re = qr/$pattern/;
    $string =~ /foo${re}bar/;   # can be interpolated in other
                                # patterns
    $string =~ $re;             # or used standalone
    $string =~ /$re/;           # or this way

=end original

    $re = qr/$pattern/;
    $string =~ /foo${re}bar/;   # 他のパターンに展開できる
    $string =~ $re;             # または単独で使う
    $string =~ /$re/;           # またはこのようにする

=begin original

Since Perl may compile the pattern at the moment of execution of the C<qr()>
operator, using C<qr()> may have speed advantages in some situations,
notably if the result of C<qr()> is used standalone:

=end original

Perl は C<qr()> 演算子を実行する瞬間にパターンをコンパイルするので、
C<qr()> を使うことでいくつかの場面で速度的に有利になります;
特に C<qr()> の結果が独立して使われる場合に有利になります。

    sub match {
        my $patterns = shift;
        my @compiled = map qr/$_/i, @$patterns;
        grep {
            my $success = 0;
            foreach my $pat (@compiled) {
                $success = 1, last if /$pat/;
            }
            $success;
        } @_;
    }

=begin original

Precompilation of the pattern into an internal representation at
the moment of C<qr()> avoids the need to recompile the pattern every
time a match C</$pat/> is attempted.  (Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use C<qr()> operator.)

=end original

C<qr()> の時点でパターンを内部表現にプリコンパイルすることにより、
C</$pat/> を試みる毎に毎回パターンを再コンパイルするのを
避けることができます。
(Perl はその他にも多くの内部最適化を行いますが、上の例で C<qr()> 演算子を
使わなかった場合はどの最適化も行われません。)

=begin original

Options (specified by the following modifiers) are:

=end original

(以下の修飾子で指定される)オプションは以下の通りです:

=begin original

    m   Treat string as multiple lines.
    s   Treat string as single line. (Make . match a newline)
    i   Do case-insensitive pattern matching.
    x   Use extended regular expressions; specifying two
        x's means \t and the SPACE character are ignored within
        square-bracketed character classes
    p   When matching preserve a copy of the matched string so
        that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be
        defined (ignored starting in v5.20 as these are always
        defined starting in that release)
    o   Compile pattern only once.
    a   ASCII-restrict: Use ASCII for \d, \s, \w and [[:posix:]]
        character classes; specifying two a's adds the further
        restriction that no ASCII character will match a
        non-ASCII one under /i.
    l   Use the current run-time locale's rules.
    u   Use Unicode rules.
    d   Use Unicode or native charset, as in 5.12 and earlier.
    n   Non-capture mode. Don't let () fill in $1, $2, etc...

=end original

    m   文字列を複数行として扱う。
    s   文字列を一行として扱う。 (. が 改行にマッチングするようにする)
    i   パターンマッチにおいて大文字小文字を区別しない。
    x   拡張正規表現を使う; x を二つ指定すると、
        \t と SPACE 文字は大かっこ文字クラスの中では無視されます
    p   マッチング時にマッチングした文字列を保存するので、
        ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} が定義される
        (このリリースから常に定義されるので、v5.20 から無視される)
    o   一度だけコンパイルする。
    a   ASCII 制限: \d, \s, \w, [[:posix:]] 文字クラスに ASCII を使う;
        a を二つ指定すると、/i で ASCII 文字が非 ASCII 文字に
        マッチングしないようなさらなる制限を追加する。
    l   現在の実行時ロケールの規則を使う。
    u   Unicode の規則を使う。
    d   5.12 以降かどうかで、Unicode かネイティブな文字集合を使う。
    n   非捕捉モード。() で $1, $2 などを埋めない

=begin original

If a precompiled pattern is embedded in a larger pattern then the effect
of C<"msixpluadn"> will be propagated appropriately.  The effect that the
C</o> modifier has is not propagated, being restricted to those patterns
explicitly using it.

=end original

プリコンパイルされたパターンがより大きいパターンに組み込まれている場合、
C<"msixpluadn"> の効果は適切に伝播します。
C</o> 修飾子の効果は伝播せず、明示的に使われたパターンに制限されます。

=begin original

The C</a>, C</d>, C</l>, and C</u> modifiers (added in Perl 5.14)
control the character set rules, but C</a> is the only one you are likely
to want to specify explicitly; the other three are selected
automatically by various pragmas.

=end original

(Perl 5.14 で追加された) C</a>, C</d>, C</l>, C</u> 修飾子は 、
文字集合の規則を制御しますが、明示的に指定したいと思いそうなものは
C</a> だけでしょう;
その他の三つはさまざまなプラグマによって自動的に選択されます。

=begin original

See L<perlre> for additional information on valid syntax for I<STRING>, and
for a detailed look at the semantics of regular expressions.  In
particular, all modifiers except the largely obsolete C</o> are further
explained in L<perlre/Modifiers>.  C</o> is described in the next section.

=end original

I<STRING> として有効な文法に関する追加の情報と、正規表現の意味論に関する
詳細については、L<perlre> を参照してください。
特に、かなり古いものである C</o> 以外の全ての修飾子については
L<perlre/Modifiers> でさらに説明されています。
C</o> は次の節に記述されています。

=item C<m/I<PATTERN>/msixpodualngc>
X<m> X<operator, match>
X<regexp, options> X<regexp> X<regex, options> X<regex>
X</m> X</s> X</i> X</x> X</p> X</o> X</g> X</c>

=item C</I<PATTERN>/msixpodualngc>

=begin original

Searches a string for a pattern match, and in scalar context returns
true if it succeeds, false if it fails.  If no string is specified
via the C<=~> or C<!~> operator, the C<$_> string is searched.  (The
string specified with C<=~> need not be an lvalue--it may be the
result of an expression evaluation, but remember the C<=~> binds
rather tightly.)  See also L<perlre>.

=end original

パターンマッチで文字列検索を行ない、スカラコンテキストでは成功したときは真、
失敗したときは偽を返します。
C<=~> 演算子か C<!~> 演算子で検索対象の文字列を示さなかったときには、
C<$_> の文字列が検索対象となります。
(C<=~> で指定される文字列は、左辺値である必要はありません--
式を評価した結果でもかまいませんが、C<=~> の優先順位がいくぶん高いことに
注意してください。)
L<perlre> も参照してください。

=begin original

Options are as described in C<qr//> above; in addition, the following match
process modifiers are available:

=end original

オプションは上述した C<qr//> に記述されています; さらに、以下の
マッチング処理修飾子が利用可能です:

=begin original

    g  Match globally, i.e., find all occurrences.
    c  Do not reset search position on a failed match when /g is
       in effect.

=end original

    g  グローバルにマッチング、つまり、すべてを探し出す。
    c  /g が有効なとき、マッチングに失敗しても検索位置をリセットしない。

=begin original

If C<"/"> is the delimiter then the initial C<m> is optional.  With the C<m>
you can use any pair of non-whitespace (ASCII) characters
as delimiters.  This is particularly useful for matching path names
that contain C<"/">, to avoid LTS (leaning toothpick syndrome).  If C<"?"> is
the delimiter, then a match-only-once rule applies,
described in C<m?I<PATTERN>?> below.  If C<"'"> (single quote) is the delimiter,
no variable interpolation is performed on the I<PATTERN>.
When using a delimiter character valid in an identifier, whitespace is required
after the C<m>.

=end original

区切文字が C<"/"> のときには、最初の C<m> は付けても付けなくてもかまいません。
C<m> を付けるときには、(ASCII の)空白でもない、任意の文字のペアを
区切文字として使うことができます。
これは特に、C<"/"> を含むパス名にパターンマッチングを行なうときに、
LTS (傾斜楊枝症候群) を避けるために便利でしょう。
"?" がデリミタなら、後述する C<m?I<PATTERN>?> にある「一度だけマッチング」
ルールが適用されます。
C<"'"> (シングルクォート) がデリミタの場合、I<PATTERN> に対する変数展開は
行われません。
識別子として有効な区切り文字を使う場合、C<m> の後に空白が必要です。

=begin original

I<PATTERN> may contain variables, which will be interpolated
every time the pattern search is evaluated, except
for when the delimiter is a single quote.  (Note that C<$(>, C<$)>, and
C<$|> are not interpolated because they look like end-of-string tests.)
Perl will not recompile the pattern unless an interpolated
variable that it contains changes.  You can force Perl to skip the
test and never recompile by adding a C</o> (which stands for "once")
after the trailing delimiter.
Once upon a time, Perl would recompile regular expressions
unnecessarily, and this modifier was useful to tell it not to do so, in the
interests of speed.  But now, the only reasons to use C</o> are one of:

=end original

I<PATTERN> には、変数が含まれていてもよく、パターンが評価されるごとに、
(デリミタがシングルクォートでない限り)変数は展開され
(パターンが再コンパイルされ) ます。
(変数 C<$(>, C<$)>, C<$|> は文字列の終わりを調べるパターンであると
解釈されるので、展開されません。)
Perl は展開された変数の値が変更されない限りパターンを再コンパイルしません。
デリミタに引き続いて C</o> ("once" を意味します) を追加することで、
テストを飛ばして再コンパイルしないようにすることができます。
昔々、Perl は不必要に正規表現を再コンパイルしていたので、速度に関心が
ある場合は再コンパイルしないようにするためにこの修飾子は有用でした。
しかし今では、C</o> を使う理由は以下のいずれかだけです:

=over

=item 1

=begin original

The variables are thousands of characters long and you know that they
don't change, and you need to wring out the last little bit of speed by
having Perl skip testing for that.  (There is a maintenance penalty for
doing this, as mentioning C</o> constitutes a promise that you won't
change the variables in the pattern.  If you do change them, Perl won't
even notice.)

=end original

変数が数千文字の長さで、これが変更されないことが分かっており、これに対する
テストを飛ばすことであともう少しだけ速度を稼ぐ必要がある。
(こうすることには保守上のペナルティがあります; なぜなら C</o> と
言及することでパターン内の変数を変更しないことを約束したことになるからです。
変更しても、Perl は気づきもしません。)

=item 2

=begin original

you want the pattern to use the initial values of the variables
regardless of whether they change or not.  (But there are saner ways
of accomplishing this than using C</o>.)

=end original

変数が変更されようが変更されまいが、変数の初期値を使ったパターンがほしい。
(しかしこれを達成するための、C</o> を使うよりもまともな方法があります。)

=item 3

=begin original

If the pattern contains embedded code, such as

=end original

以下のようにパターンに組み込みコードが含まれている場合

    use re 'eval';
    $code = 'foo(?{ $x })';
    /$code/

=begin original

then perl will recompile each time, even though the pattern string hasn't
changed, to ensure that the current value of C<$x> is seen each time.
Use C</o> if you want to avoid this.

=end original

C<$x> の現在の値を毎回確認するために、例えパターン文字列が
変更されていなくても、毎回再コンパイルされます。
これを避けたい場合は C</o> を使ってください。

=back

=begin original

The bottom line is that using C</o> is almost never a good idea.

=end original

結論としては、C</o> を使うことがいい考えであることはほとんどありません。

=item The empty pattern C<//>

(空パターン C<//>)

=begin original

If the I<PATTERN> evaluates to the empty string, the last
I<successfully> matched regular expression in the current dynamic
scope is used instead (see also L<perlvar/Scoping Rules of Regex Variables>).
In this case, only the C<g> and C<c> flags on the empty pattern are
honored; the other flags are taken from the original pattern. If no
match has previously succeeded, this will (silently) act instead as a
genuine empty pattern (which will always match). Using a user supplied
string as a pattern has the risk that if the string is empty that it
triggers the "last successful match" behavior, which can be very
confusing. In such cases you are recommended to replace C<m/$pattern/>
with C<m/(?:$pattern)/> to avoid this behavior.

=end original

I<PATTERN> を評価した結果が空文字列となった場合には、現在の動的
スコープで最後にマッチングに I<成功した> 正規表現が、代わりに使われます
(L<perlvar/Scoping Rules of Regex Variables> も参照)。
この場合、空パターンに対して C<g> の C<c> フラグだけが有効です;
その他のフラグは元のパターンから取られます。
以前に成功したマッチングがない場合、これは(暗黙に)真の空パターンとして
動作します(つまり常にマッチングします)。
ユーザーが提供した文字列をパターンとして使うことは、
文字列が空だった場合に「最後に成功したマッチング」の振る舞いを引き起こし、
とても混乱するというリスクがあります。
このような場合では、この振る舞いを避けるために、
C<m/$pattern/> を C<m/(?:$pattern)/> に置き換えることを勧めます。

=begin original

The last successful pattern may be accessed as a variable via
C<${^LAST_SUCCESSFUL_PATTERN}>. Matching against it, or the empty
pattern should have the same effect, with the exception that when there
is no last successful pattern the empty pattern will silently match,
whereas using the C<${^LAST_SUCCESSFUL_PATTERN}> variable will produce
undefined warnings (if warnings are enabled). You can check
C<defined(${^LAST_SUCCESSFUL_PATTERN})> to test if there is a "last
successful match" in the current scope.

=end original

最後に成功したパターンは、 C<${^LAST_SUCCESSFUL_PATTERN}> 変数経由で
アクセスされます。
これと、空文字列に対するマッチングは同じ効果を持ちますが、
空文字列が暗黙にマッチングする最後に成功したパターンはないけれども、
C<${^LAST_SUCCESSFUL_PATTERN}> 変数を使うと(警告がが有効なら)
未定義警告発生するという例外があります。
現在のスコープで「最後に成功したマッチング」が
あるかどうかをテストにするには、
C<defined(${^LAST_SUCCESSFUL_PATTERN})> とします。

=begin original

Note that it's possible to confuse Perl into thinking C<//> (the empty
regex) is really C<//> (the defined-or operator).  Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
C<$x///> (is that S<C<($x) / (//)>> or S<C<$x // />>?) and S<C<print $fh //>>
(S<C<print $fh(//>> or S<C<print($fh //>>?).  In all of these examples, Perl
will assume you meant defined-or.  If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an C<m> (so C<//> becomes C<m//>).

=end original

Perl が C<//> (空正規表現) と C<//> (定義性和演算子) を混同する
可能性があることに注意してください。
Perl は普通これをかなりうまく処理しますが、C<$x///> (S<C<($x) / (//)>>
それとも S<C<$x // />>?) や S<C<print $fh //>> (S<C<print $fh(//>>
それとも S<C<print($fh //>>?) のような病的な状況ではこれが起こりえます。
これらの例の全てでは、Perl は定義性和を意味していると仮定します。
もし空正規表現を意味したいなら、あいまいさをなくすために単に
かっこや空白を使うか、空正規表現に接頭辞 C<m> を付けてください
(つまり C<//> を C<m//> にします)。

=item Matching in list context

(リストコンテキストでのマッチング)

=begin original

If the C</g> option is not used, C<m//> in list context returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, that is, (C<$1>, C<$2>, C<$3>...)  (Note that here C<$1> etc. are
also set).  When there are no parentheses in the pattern, the return
value is the list C<(1)> for success.
With or without parentheses, an empty list is returned upon failure.

=end original

C</g> オプションが使われなかった場合、リストコンテキストでのC<m//>は
パターンの中の括弧で括られた部分列にマッチしたもので構成されるリストを
返します; これは、(C<$1>, C<$2>, C<$3>, ...) ということです
(この場合、C<$1> なども設定されます)。
パターンに括弧がない場合は、返り値は成功時はリスト C<(1)> です。
括弧のあるなしに関わらず、失敗時は空リストを返します。

=begin original

Examples:

=end original

例:

    open(TTY, "+</dev/tty")
       || die "can't access /dev/tty: $!";

    <TTY> =~ /^y/i && foo();       # do foo if desired

    if (/Version: *([0-9.]*)/) { $version = $1; }

    next if m#^/usr/spool/uucp#;

    # poor man's grep
    $arg = shift;
    while (<>) {
       print if /$arg/;
    }
    if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

=begin original

This last example splits C<$foo> into the first two words and the
remainder of the line, and assigns those three fields to C<$F1>, C<$F2>, and
C<$Etc>.  The conditional is true if any variables were assigned; that is,
if the pattern matched.

=end original

最後の例は、C<$foo> を最初の 2 つの単語と行の残りに分解し、
C<$F1> と C<$F2> と C<$Etc> に代入しています。
変数に代入されれば、すなわちパターンがマッチすれば、
if の条件が真となります。

=begin original

The C</g> modifier specifies global pattern matching--that is,
matching as many times as possible within the string.  How it behaves
depends on the context.  In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression.  If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.

=end original

C</g> 修飾子は、グローバルなパターンマッチを指定するもので、
文字列の中で可能な限りたくさんマッチを行ないます。
この動作は、コンテキストに依存します。
リストコンテキストでは、正規表現内の括弧付けされたものにマッチした
部分文字列のリストが返されます。
括弧がなければ、パターン全体を括弧で括っていたかのように、
すべてのマッチした文字列のリストが返されます。

=begin original

In scalar context, each execution of C<m//g> finds the next match,
returning true if it matches, and false if there is no further match.
The position after the last match can be read or set using the C<pos()>
function; see L<perlfunc/pos>.  A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the C</c> modifier (for example, C<m//gc>).  Modifying the target
string also resets the search position.

=end original

スカラコンテキストでは、C<m//g> を実行する毎に次のマッチを探します;
マッチした場合は真を返し、もうマッチしなくなったら偽を返します。
最後のマッチの位置は C<pos()> 関数で読み出しや設定ができます;
L<perlfunc/pos> を参照して下さい。
マッチに失敗すると通常は検索位置を文字列の先頭にリセットしますが、
C</c> 修飾子をつける(例えば C<m//gc>)ことでこれを防ぐことができます。
ターゲットとなる文字列が変更された場合も検索位置はリセットされます。

=item C<\G I<assertion>>

(C<\G アサート>)

=begin original

You can intermix C<m//g> matches with C<m/\G.../g>, where C<\G> is a
zero-width assertion that matches the exact position where the
previous C<m//g>, if any, left off.  Without the C</g> modifier, the
C<\G> assertion still anchors at C<pos()> as it was at the start of
the operation (see L<perlfunc/pos>), but the match is of course only
attempted once.  Using C<\G> without C</g> on a target string that has
not previously had a C</g> match applied to it is the same as using
the C<\A> assertion to match the beginning of the string.  Note also
that, currently, C<\G> is only properly supported when anchored at the
very beginning of the pattern.

=end original

C<m//g> マッチを C<m/\G.../g> と混ぜることもできます; C<\G> は前回の
C<m//g> があればその同じ位置でマッチするゼロ文字幅のアサートです。
C</g> 修飾子なしの場合、C<\G> アサートは操作の最初としてC<pos()> に
固定しますが、(L<perlfunc/pos> 参照) マッチはもちろん一度だけ試されます。
以前に C</g> マッチを適用していないターゲット文字列に対して C</g> なしで
C<\G> を使うと、文字列の先頭にマッチする C<\A> アサートを使うのと
同じことになります。
C<\G> は現在のところ、パターンのまさに先頭を示す場合にのみ正しく
対応することにも注意してください。

=begin original

Examples:

=end original

例:

    # list context
    ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

    # scalar context
    local $/ = "";
    while ($paragraph = <>) {
        while ($paragraph =~ /\p{Ll}['")]*[.!?]+['")]*\s/g) {
            $sentences++;
        }
    }
    say $sentences;

=begin original

Here's another way to check for sentences in a paragraph:

=end original

以下は段落内の文をチェックするためのもう一つの方法です:

=begin original

    my $sentence_rx = qr{
        (?: (?<= ^ ) | (?<= \s ) )  # after start-of-string or
                                    # whitespace
        \p{Lu}                      # capital letter
        .*?                         # a bunch of anything
        (?<= \S )                   # that ends in non-
                                    # whitespace
        (?<! \b [DMS]r  )           # but isn't a common abbr.
        (?<! \b Mrs )
        (?<! \b Sra )
        (?<! \b St  )
        [.?!]                       # followed by a sentence
                                    # ender
        (?= $ | \s )                # in front of end-of-string
                                    # or whitespace
    }sx;
    local $/ = "";
    while (my $paragraph = <>) {
        say "NEW PARAGRAPH";
        my $count = 0;
        while ($paragraph =~ /($sentence_rx)/g) {
            printf "\tgot sentence %d: <%s>\n", ++$count, $1;
        }
    }

=end original

    my $sentence_rx = qr{
        (?: (?<= ^ ) | (?<= \s ) )  # 文字列の先頭か空白の後
        \p{Lu}                      # 大文字
        .*?                         # なんでも
        (?<= \S )                   # 空白以外で終わる
        (?<! \b [DMS]r  )           # しかし一般的な省略形ではない
        (?<! \b Mrs )
        (?<! \b Sra )
        (?<! \b St  )
        [.?!]                       # 引き続いて文を終わらせるものが
        (?= $ | \s )                # 文字列の末尾か空白の前に
    }sx;
    local $/ = "";
    while (my $paragraph = <>) {
        say "NEW PARAGRAPH";
        my $count = 0;
        while ($paragraph =~ /($sentence_rx)/g) {
            printf "\tgot sentence %d: <%s>\n", ++$count, $1;
        }
    }

=begin original

Here's how to use C<m//gc> with C<\G>:

=end original

以下は C<m//gc> を C<\G> で使う方法です:

    $_ = "ppooqppqq";
    while ($i++ < 2) {
        print "1: '";
        print $1 while /(o)/gc; print "', pos=", pos, "\n";
        print "2: '";
        print $1 if /\G(q)/gc;  print "', pos=", pos, "\n";
        print "3: '";
        print $1 while /(p)/gc; print "', pos=", pos, "\n";
    }
    print "Final: '$1', pos=",pos,"\n" if /\G(.)/;

=begin original

The last example should print:

=end original

最後のものは以下のものを表示するはずです:

    1: 'oo', pos=4
    2: 'q', pos=5
    3: 'pp', pos=7
    1: '', pos=7
    2: 'q', pos=8
    3: '', pos=8
    Final: 'q', pos=8

=begin original

Notice that the final match matched C<q> instead of C<p>, which a match
without the C<\G> anchor would have done.  Also note that the final match
did not update C<pos>.  C<pos> is only updated on a C</g> match.  If the
final match did indeed match C<p>, it's a good bet that you're running an
ancient (pre-5.6.0) version of Perl.

=end original

C<\G> なしでのマッチが行われたため、最後のマッチでは C<p> ではなく
C<q> がマッチすることに注意してください。
また、最後のマッチは C<pos> を更新しないことに注意してください。
C<pos> は C</g> マッチでのみ更新されます。
もし最後のマッチで C<p> にマッチした場合、かなりの確率で
とても古い (5.6.0 以前の) Perl で実行しているはずです。

=begin original

A useful idiom for C<lex>-like scanners is C</\G.../gc>.  You can
combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.  Each
regexp tries to match where the previous one leaves off.

=end original

C<lex> 風にスキャンするために便利な指定は C</\G.../gc> です。
文字列を部分ごとに処理するためにいくつかの正規表現をつなげて、どの正規表現に
マッチングしたかによって異なる処理をすることができます。
それぞれの正規表現は前の正規表現が飛ばした部分に対してマッチングを試みます。

    $_ = <<'EOL';
        $url = URI::URL->new( "http://example.com/" );
        die if $url eq "xXx";
    EOL

    LOOP: {
        print(" digits"),       redo LOOP if /\G\d+\b[,.;]?\s*/gc;
        print(" lowercase"),    redo LOOP
                                      if /\G\p{Ll}+\b[,.;]?\s*/gc;
        print(" UPPERCASE"),    redo LOOP
                                      if /\G\p{Lu}+\b[,.;]?\s*/gc;
        print(" Capitalized"),  redo LOOP
                                if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc;
        print(" MiXeD"),        redo LOOP
                                         if /\G\pL+\b[,.;]?\s*/gc;
        print(" alphanumeric"), redo LOOP
                              if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc;
        print(" line-noise"),   redo LOOP if /\G\W+/gc;
        print ". That's all!\n";
    }

=begin original

Here is the output (split into several lines):

=end original

出力は以下のようになります(何行かに分割しています):

    line-noise lowercase line-noise UPPERCASE line-noise UPPERCASE
    line-noise lowercase line-noise lowercase line-noise lowercase
    lowercase line-noise lowercase lowercase line-noise lowercase
    lowercase line-noise MiXeD line-noise. That's all!

=item C<m?I<PATTERN>?msixpodualngc>
X<?> X<operator, match-once>

=begin original

This is just like the C<m/I<PATTERN>/> search, except that it matches
only once between calls to the C<reset()> operator.  This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.  Only C<m??>
patterns local to the current package are reset.

=end original

これは、C<reset()> 演算子を呼び出すごとに 1 度だけしかマッチングしないことを
除いては C<m/I<PATTERN>/> による検索と全く同じです。
たとえば、ファイルの集まりの中で個々のファイルについて、あるものを
探すとき、最初の 1 つだけの存在がわかれば良いのであれば、この機能を
使って最適化をはかることができます。
現在のパッケージにローカルとなっている C<m??> のパターンだけが
リセットされます。

    while (<>) {
        if (m?^$?) {
                            # blank line between header and body
        }
    } continue {
        reset if eof;       # clear m?? status for next file
    }

=begin original

Another example switched the first "latin1" encoding it finds
to "utf8" in a pod file:

=end original

次の例は、pod ファイル中の最初の "latin1" エンコーディングを "utf8" に
切り替えます:

    s//utf8/ if m? ^ =encoding \h+ \K latin1 ?x;

=begin original

The match-once behavior is controlled by the match delimiter being
C<?>; with any other delimiter this is the normal C<m//> operator.

=end original

一度だけマッチングという振る舞いはマッチングデリミタが C<?> かどうかで
制御されます: その他のデリミタの場合はこれは通常の C<m//> 演算子です。

=begin original

In the past, the leading C<m> in C<m?I<PATTERN>?> was optional, but omitting it
would produce a deprecation warning.  As of v5.22.0, omitting it produces a
syntax error.  If you encounter this construct in older code, you can just add
C<m>.

=end original

過去には、C<m?I<PATTERN>?> の先頭の C<m> は省略可能でしたが、これを省略すると
廃止予定警告が出ていました。
v5.22.0 から、これを省略すると文法エラーが発生します。
もし古いコードでこの構文に遭遇した場合は、単に C<m> を追加してください。

=item C<s/I<PATTERN>/I<REPLACEMENT>/msixpodualngcer>
X<s> X<substitute> X<substitution> X<replace> X<regexp, replace>
X<regexp, substitute> X</m> X</s> X</i> X</x> X</p> X</o> X</g> X</c> X</e> X</r>

=begin original

Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.  Otherwise it returns false (a value that is both an empty string (C<"">)
and numeric zero (C<0>) as described in L</Relational Operators>).

=end original

文字列中でパターンを検索し、もし見つかれば、置換テキストで置き換え、
置換した数を返します。
見つからなければ、偽 (空文字列 (C<"">) と数値のゼロ (C<0> の両方) を
返します。

=begin original

If the C</r> (non-destructive) option is used then it runs the
substitution on a copy of the string and instead of returning the
number of substitutions, it returns the copy whether or not a
substitution occurred.  The original string is never changed when
C</r> is used.  The copy will always be a plain string, even if the
input is an object or a tied variable.

=end original

C</r> (非破壊) オプションが使われると、文字列のコピーに対して置換が行われ、
置換された数ではなく、置換が行われたかどうかにかかわらずこのコピーが
返されます。
C</r> が使われた場合、元の文字列は決して変更されません。
コピーは、たとえ入力がオブジェクトや tie された変数でも、常に
プレーンな文字列です。

=begin original

If no string is specified via the C<=~> or C<!~> operator, the C<$_>
variable is searched and modified.  Unless the C</r> option is used,
the string specified must be a scalar variable, an array element, a
hash element, or an assignment to one of those; that is, some sort of
scalar lvalue.

=end original

C<=~> 演算子や C<!~> 演算子によって文字列が指定されていなければ、
変数 C<$_> が検索され、修正されます。
C</r> が指定されていない限り、
C<=~> で指定される文字列は、スカラ変数、配列要素、ハッシュ要素、
あるいは、これらへの代入式といったある種の
スカラ左辺値でなければなりません。

=begin original

If the delimiter chosen is a single quote, no variable interpolation is
done on either the I<PATTERN> or the I<REPLACEMENT>.  Otherwise, if the
I<PATTERN> contains a C<$> that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.  If you want the pattern compiled only once the first time
the variable is interpolated, use the C</o> option.  If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.  See L<perlre> for further explanation on these.

=end original

シングルクォートを区切り文字として使った場合には、
I<PATTERN> にも I<REPLACEMENT> にも変数展開を行ないません。
それ以外の場合、文字列の最後を表わすものには見えない C<$> が
I<PATTERN> に含まれると、実行時に変数がパターン内に展開されます。
最初に変数が展開されるときにだけパターンのコンパイルを行ないたいときには、
C</o> オプションを使ってください。
パターンの評価結果が空文字列になった場合には、最後に成功した正規表現が
代わりに使われます。
これについてさらに詳しくは、L<perlre> を参照してください。

=begin original

Options are as with C<m//> with the addition of the following replacement
specific options:

=end original

オプションは、C<m//> のものに加えて、以下の置換固有のものがあります:

=begin original

    e   Evaluate the right side as an expression.
    ee  Evaluate the right side as a string then eval the
        result.
    r   Return substitution and leave the original string
        untouched.

=end original

    e   式の右側の評価を行なう。
    ee  右側を文字列として評価して、その結果を評価する。
    r   置換した結果を返し、もとの文字列はそのままにする。

=begin original

Any non-whitespace delimiter may replace the slashes.  Add space after
the C<s> when using a character allowed in identifiers.  If single quotes
are used, no interpretation is done on the replacement string (the C</e>
modifier overrides this, however).  Note that Perl treats backticks
as normal delimiters; the replacement text is not evaluated as a command.
If the I<PATTERN> is delimited by bracketing quotes, the I<REPLACEMENT> has
its own pair of quotes, which may or may not be bracketing quotes, for example,
C<s(foo)(bar)> or C<< s<foo>/bar/ >>.  A C</e> will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.  It is, however, syntax checked at
compile-time.  A second C<e> modifier will cause the replacement portion
to be C<eval>ed before being run as a Perl expression.

=end original

空白ではない任意の区切り文字で、スラッシュを置き換えられます。
識別子として許されている文字を使うときには C<s> の後に空白を
追加してください。
先に述べたように、シングルクォートを使うと置換文字列での展開は
されません (C</e>修飾子を使えば可能です)。
バッククォートを通常のデリミタとして扱うことに注意してください;
置換テキストはコマンドとして評価されません。
I<PATTERN> を括弧類で括った場合には、I<REPLACEMENT> 用にもう一組の区切り文字を
用意します; これは、括弧類であっても、なくてもかまいません;
C<s(foo)(bar)> や C<< s<foo>/bar/ >>。
C</e> は置換文字列を完全な Perl の式として扱い、その場所で直ちに解釈します。
しかし、これはコンパイル時に構文チェックされます。
二番目の C<e> 修飾子を指定すると、置換部分がまず Perl の式として
C<eval> されます。

=begin original

Examples:

=end original

例:

    s/\bgreen\b/mauve/g;              # don't change wintergreen

    $path =~ s|/usr/bin|/usr/local/bin|;

    s/Login: $foo/Login: $bar/; # run-time pattern

    ($foo = $bar) =~ s/this/that/;      # copy first, then
                                        # change
    ($foo = "$bar") =~ s/this/that/;    # convert to string,
                                        # copy, then change
    $foo = $bar =~ s/this/that/r;       # Same as above using /r
    $foo = $bar =~ s/this/that/r
                =~ s/that/the other/r;  # Chained substitutes
                                        # using /r
    @foo = map { s/this/that/r } @bar   # /r is very useful in
                                        # maps

    $count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-cnt

    $_ = 'abc123xyz';
    s/\d+/$&*2/e;               # yields 'abc246xyz'
    s/\d+/sprintf("%5d",$&)/e;  # yields 'abc  246xyz'
    s/\w/$& x 2/eg;             # yields 'aabbcc  224466xxyyzz'

    s/%(.)/$percent{$1}/g;      # change percent escapes; no /e
    s/%(.)/$percent{$1} || $&/ge;       # expr now, so /e
    s/^=(\w+)/pod($1)/ge;       # use function call

    $_ = 'abc123xyz';
    $x = s/abc/def/r;           # $x is 'def123xyz' and
                                # $_ remains 'abc123xyz'.

    # expand variables in $_, but dynamics only, using
    # symbolic dereferencing
    s/\$(\w+)/${$1}/g;

    # Add one to the value of any numbers in the string
    s/(\d+)/1 + $1/eg;

    # Titlecase words in the last 30 characters only (presuming
    # that the substring doesn't start in the middle of a word)
    substr($str, -30) =~ s/\b(\p{Alpha})(\p{Alpha}*)\b/\u$1\L$2/g;

    # This will expand any embedded scalar variable
    # (including lexicals) in $_ : First $1 is interpolated
    # to the variable name, and then evaluated
    s/(\$\w+)/$1/eeg;

    # Delete (most) C comments.
    $program =~ s {
        /\*     # Match the opening delimiter.
        .*?     # Match a minimal number of characters.
        \*/     # Match the closing delimiter.
    } []gsx;

    s/^\s*(.*?)\s*$/$1/;        # trim whitespace in $_,
                                # expensively

    for ($variable) {           # trim whitespace in $variable,
                                # cheap
        s/^\s+//;
        s/\s+$//;
    }

    s/([^ ]*) *([^ ]*)/$2 $1/;  # reverse 1st two fields

    $foo !~ s/A/a/g;    # Lowercase all A's in $foo; return
                        # 0 if any were found and changed;
                        # otherwise return 1

=begin original

Note the use of C<$> instead of C<\> in the last example.  Unlike
B<sed>, we use the \<I<digit>> form only in the left hand side.
Anywhere else it's $<I<digit>>.

=end original

最後の例で C<\> の代わりに C<$> を使っているのに注意してください。
B<sed> と違って、\<I<数字>> の形式はパターンの方でのみ使用できます。
その他の場所では、$<I<数字>> を使います。

=begin original

Occasionally, you can't use just a C</g> to get all the changes
to occur that you might want.  Here are two common cases:

=end original

ときには、C</g> を付けるだけでは、あなたが望んでいるような形で
すべてを変更することができないことがあります。
良くある例を 2 つ示します:

    # put commas in the right places in an integer
    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;

    # expand tabs to 8-column spacing
    1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

=begin original

X</c>While C<s///> accepts the C</c> flag, it has no effect beyond
producing a warning if warnings are enabled.

=end original

X</c>
C<s///> は C</c> フラグを受け付けますが、
警告が有効の場合に警告を出す以外の効果はありません。

=back

=head3 Transliteration Quote-Like Operators

(文字変換クォート風演算子)

=over

=item C<tr/I<SEARCHLIST>/I<REPLACEMENTLIST>/cdsr>
X<tr> X<y> X<transliterate> X</c> X</d> X</s>

=item C<y/I<SEARCHLIST>/I<REPLACEMENTLIST>/cdsr>

=begin original

These transliterate all occurrences of the characters found (or not found
if the C</c> modifier is specified) in the search list with the
positionally corresponding character in the replacement list, possibly
deleting some, depending on the modifiers specified.  Unless the C</r>
flag is specified, they return the number of characters replaced or
deleted.  If no string is specified via the C<=~> or C<!~> operator, the
C<$_> string is transliterated.

=end original

これらは、検索リスト (SEARCHLIST) に含まれる
(あるいは C</c> 修飾子が指定されている場合は含まれない)文字を、
置換リスト (REPLACEMENTLIST) の位置的に対応する文字に変換します
(指定された修飾子によっては一部が削除されることもあります)。
C</r> フラグが指定されない限り、置換または削除が行なわれた文字数を返します。
C<=~> 演算子や C<!~> 演算子で文字列が指定されていなければ、C<$_> の文字列が
変換されます。

=begin original

For B<sed> devotees, C<y> is provided as a synonym for C<tr>.

=end original

B<sed> 愛好者のために、C<y> が C<tr> の同義語として提供されています。

=begin original

If the C</r> (non-destructive) option is present, a new copy of the string
is made and its characters transliterated, and this copy is returned,
instead of a count, no matter whether it was modified or not: the
original string is always left unchanged.  The new copy is always a
plain string, even if the input string is an object or a tied variable.

=end original

C</r> (非破壊) オプションがあると、文字列の新しいコピーが作られてその
文字が変換され、変更されたかどうかに関わらず、文字数ではなく、
このコピーが返されます: 元の文字列は常に無変更で残されます。
新しいコピーは、たとえ入力がオブジェクトや tie された変数でも、常に
プレーンな文字列です。

=begin original

Unless the C</r> option is used, the string specified with C<=~> must be a
scalar variable, an array element, a hash element, or an assignment to one
of those; in other words, an lvalue.

=end original

C</r> オプションが使われない限り、C<=~> で指定される文字列は、スカラ変数、
配列要素、ハッシュ要素、あるいはこれらへの代入式といった左辺値で
なければなりません。

=begin original

The characters delimiting I<SEARCHLIST> and I<REPLACEMENTLIST>
can be any printable character, not just forward slashes.  If they
are single quotes (C<tr'I<SEARCHLIST>'I<REPLACEMENTLIST>'>), the only
interpolation is removal of C<\> from pairs of C<\\>; so hyphens are
interpreted literally rather than specifying a character range.

=end original

I<SEARCHLIST> と I<REPLACEMENTLIST> を区切る文字は、
スラッシュだけでなく、任意の表示文字が可能です。
それがシングルクォート (C<tr'I<SEARCHLIST>'I<REPLACEMENTLIST>'>) の場合、
C<\\> の組から C<\> を削除する変換のみが行われます; したがって、
ハイフンは文字の範囲ではなく、リテラルに解釈されます。

=begin original

Otherwise, a character range may be specified with a hyphen, so
C<tr/A-J/0-9/> does the same replacement as
C<tr/ACEGIBDFHJ/0246813579/>.

=end original

さもなければ、文字の範囲はハイフンを使って指定できます; C<tr/A-J/0-9/> は
C<tr/ACEGIBDFHJ/0246813579/> と同じ置換を行います。

=begin original

If the I<SEARCHLIST> is delimited by bracketing quotes, the
I<REPLACEMENTLIST> must have its own pair of quotes, which may or may
not be bracketing quotes; for example, C<tr(aeiouy)(yuoiea)> or
C<tr[+\-*/]"ABCD">.  This final example shows a way to visually clarify
what is going on for people who are more familiar with regular
expression patterns than with C<tr>, and who may think forward slash
delimiters imply that C<tr> is more like a regular expression pattern
than it actually is.  (Another option might be to use C<tr[...][...]>.)

=end original

I<SEARCHLIST> をかっこ類で括った場合には、I<REPLACEMENTLIST> 用に、
もう一組の区切り文字を用意しなければなりません;
これは、括弧類であっても、なくてもかまいません;
例えば、C<tr(aeiouy)(yuoiea)> や C<tr[+\-*/]"ABCD"> です。
最後の例は、C<tr> よりも正規表現パターンに親しんでいる人や、
前のスラッシュ区切り文字は、C<tr> が実際以上に正規表現パターンに
似ていることを暗示していると考える人に、何が起きているかを
視覚的に明確化しています。
(もう一つの選択肢は C<tr[...][...]> を使うことかもしれません。)

=begin original

C<tr> isn't fully like bracketed character classes, just
(significantly) more like them than it is to full patterns.  For
example, characters appearing more than once in either list behave
differently here than in patterns, and C<tr> lists do not allow
backslashed character classes such as C<\d> or C<\pL>, nor variable
interpolation, so C<"$"> and C<"@"> are always treated as literals.

=end original

C<tr> は完全に大かっこ文字クラスと同様ではなく、
単に完全なパターンよりは(かなり)そちらにより似ていると言うだけです。
例えば、どちらかのリストに複数回文字が現れた場合、パターンと
異なる振る舞いをします; そして
C<tr> の一覧は C<\d> や C<\pL> といった逆スラッシュ文字クラスや
変数展開を許さないので、C<"$"> と C<"@"> は
常にリテラルとして扱われます。

=begin original

The allowed elements are literals plus C<\'> (meaning a single quote).
If the delimiters aren't single quotes, also allowed are any of the
escape sequences accepted in double-quoted strings.  Escape sequence
details are in L<the table near the beginning of this section|/Quote and
Quote-like Operators>.

=end original

許される要素はリテラルと (シングルクォートを意味する) C<\'> です。
区切り文字がシングルクォートでない場合
ダブルクォート文字列の中で受け入れられるエスケープシーケンスも
許されます。
エスケープシーケンスの詳細は
L<この節の先頭付近の表|/Quote and
Quote-like Operators> にあります。

=begin original

A hyphen at the beginning or end, or preceded by a backslash is also
always considered a literal.  Precede a delimiter character with a
backslash to allow it.

=end original

先頭、末尾、および逆スラッシュが前置されたハイフンもまた常に
リテラルとして扱われます。
それをするために逆スラッシュと共に区切り文字を前に置きます。

=begin original

The C<tr> operator is not equivalent to the C<L<tr(1)>> utility.
C<tr[a-z][A-Z]> will uppercase the 26 letters "a" through "z", but for
case changing not confined to ASCII, use L<C<lc>|perlfunc/lc>,
L<C<uc>|perlfunc/uc>, L<C<lcfirst>|perlfunc/lcfirst>,
L<C<ucfirst>|perlfunc/ucfirst> (all documented in L<perlfunc>), or the
L<substitution operator
C<sE<sol>I<PATTERN>E<sol>I<REPLACEMENT>E<sol>>|/sE<sol>PATTERNE<sol>REPLACEMENTE<sol>msixpodualngcer>
(with C<\U>, C<\u>, C<\L>, and C<\l> string-interpolation escapes in the
I<REPLACEMENT> portion).

=end original

C<tr> 演算子は C<L<tr(1)>> ユーティリティと等価ではありません。
C<tr[a-z][A-Z]> は "a" から "z" までの 26 文字を大文字にしますが、
ASCII の範囲外の大文字小文字を変更する場合は、
L<C<lc>|perlfunc/lc>, L<C<uc>|perlfunc/uc>,
L<C<lcfirst>|perlfunc/lcfirst>, L<C<ucfirst>|perlfunc/ucfirst>
(全て L<perlfunc> に文書化されています), あるいは
L<置換演算子 C<sE<sol>I<PATTERN>E<sol>I<REPLACEMENT>E<sol>>|/sE<sol>PATTERNE<sol>REPLACEMENTE<sol>msixpodualngcer>
(I<REPLACEMENT> 部での C<\U>, C<\u>, C<\L>, C<\l> 文字列変換エスケープ) を
使ってください。

=begin original

Most ranges are unportable between character sets, but certain ones
signal Perl to do special handling to make them portable.  There are two
classes of portable ranges.  The first are any subsets of the ranges
C<A-Z>, C<a-z>, and C<0-9>, when expressed as literal characters.

=end original

ほとんどの範囲は文字集合管で互換性がありませんが、一部のものは互換性を
持たせるために Perl が特別に扱います。
移植性のある範囲には二つのクラスがあります。
一つ目はリテラル文字として記述された C<A-Z>, C<a-z>, C<0-9> の部分集合です。

    tr/h-k/H-K/

=begin original

capitalizes the letters C<"h">, C<"i">, C<"j">, and C<"k"> and nothing
else, no matter what the platform's character set is.  In contrast, all
of

=end original

とすると、プラットフォームの文字集合が何であるかに関わらず、
文字 C<"h">, C<"i">, C<"j">, C<"k"> を大文字にして、それ以外は何もしません。
一方、次のようなもの全ては

    tr/\x68-\x6B/\x48-\x4B/
    tr/h-\x6B/H-\x4B/
    tr/\x68-k/\x48-K/

=begin original

do the same capitalizations as the previous example when run on ASCII
platforms, but something completely different on EBCDIC ones.

=end original

ASCII プラットフォームで実行した場合は前述の例と同じ大文字かを行いますが、
EBCDIC プラットフォームでは全く違うことをします。

=begin original

The second class of portable ranges is invoked when one or both of the
range's end points are expressed as C<\N{...}>

=end original

移植性のある範囲の二つ目のクラスは、範囲の片方または両方の端が
C<\N{...}> として記述された場合です

    $string =~ tr/\N{U+20}-\N{U+7E}//d;

=begin original

removes from C<$string> all the platform's characters which are
equivalent to any of Unicode U+0020, U+0021, ... U+007D, U+007E.  This
is a portable range, and has the same effect on every platform it is
run on.  In this example, these are the ASCII
printable characters.  So after this is run, C<$string> has only
controls and characters which have no ASCII equivalents.

=end original

これは、Unicode での U+0020, U+0021, ... U+007D, U+007E と等価な、
今のプラットフォームでの全ての文字を C<$string> から削除します。
これは移植性のある範囲で、実行される全てのプラットフォームで同じ効果が
あります。
この例では、これらは ASCII の表示文字です。
従ってこれを実行した後、C<$string> は制御文字および ASCII で等価なものがない
文字のみとなります。

=begin original

But, even for portable ranges, it is not generally obvious what is
included without having to look things up in the manual.  A sound
principle is to use only ranges that both begin from, and end at, either
ASCII alphabetics of equal case (C<b-e>, C<B-E>), or digits (C<1-4>).
Anything else is unclear (and unportable unless C<\N{...}> is used).  If
in doubt, spell out the character sets in full.

=end original

しかし、移植性のある範囲であっても、
マニュアルで調べる必要なしには、何が含まれるのかは
一般的に明らかではありません。
健全な原則としては、範囲の最初と最後をどちらも ASCII 英字
(大文字小文字も同じ)(C<b-e>, C<B-E>)にするか、どちらも数字にする(C<1-4>)
ことです。
それ以外は不明確です(そして C<\N{...}> が使われていない限り
移植性はありません)。
疑わしいときは、文字セットを完全に書き出してください。

=begin original

Options:

=end original

オプションは以下の通りです:

=begin original

    c   Complement the SEARCHLIST.
    d   Delete found but unreplaced characters.
    r   Return the modified string instead of a count, and leave the
        original string untouched.
    s   Squash duplicate replaced characters.

=end original

    c   SEARCHLIST を補集合にする。
    d   見つかったが置換されなかった文字を削除する。
    r   文字数の代わりに変更した結果を返し、
        元の文字列はそのままにする。
    s   置換された文字が重なったときに圧縮する。

=begin original

If the C</d> modifier is specified, any characters specified by
I<SEARCHLIST>  not found in I<REPLACEMENTLIST> are deleted.  (Note that
this is slightly more flexible than the behavior of some B<tr> programs,
which delete anything they find in the I<SEARCHLIST>, period.)

=end original

C</d> 修飾子が指定されると、I<SEARCHLIST> に指定されて、
I<REPLACEMENTLIST> に対応するものがない文字が削除されます。
(これは、I<SEARCHLIST> で見つかったものを削除する、ただそれだけの、ある種の
B<tr> プログラムの動作よりと比べれば、いく分柔軟なものになっています。)

=begin original

If the C</s> modifier is specified, sequences of characters, all in a
row, that were transliterated to the same character are squashed down to
a single instance of that character.

=end original

C</s> 修飾子が指定されると、同じ文字に文字変換された文字の並びを、
その文字 1 文字だけに圧縮します。

    my $x = "aaabbbca";
    $x =~ tr/ab/dd/s;     # $x now is "dcd"

=begin original

If the C</d> modifier is used, the I<REPLACEMENTLIST> is always interpreted
exactly as specified.  Otherwise, if the I<REPLACEMENTLIST> is shorter
than the I<SEARCHLIST>, the final character, if any, is replicated until
it is long enough.  There won't be a final character if and only if the
I<REPLACEMENTLIST> is empty, in which case I<REPLACEMENTLIST> is
copied from I<SEARCHLIST>.    An empty I<REPLACEMENTLIST> is useful
for counting characters in a class, or for squashing character sequences
in a class.

=end original

C</d> 修飾子が使われると、I<REPLACEMENTLIST> は、常に指定された通りに
解釈されます。
さもなければ、I<REPLACEMENTLIST> が I<SEARCHLIST> よりも短い場合、
同じ長さになるまで、最後の文字が繰り返されているものとして扱われます。
I<REPLACEMENTLIST> が空文字列のときには最後の文字というものはなく、
その場合は I<REPLACEMENTLIST> は I<SEARCHLIST> からコピーされます。
空の I<REPLACEMENTLIST> は、ある文字クラスに含まれる文字数を数えるときや、
ある文字クラスの文字の並びを圧縮するようなときに便利です。

    tr/abcd//            tr/abcd/abcd/
    tr/abcd/AB/          tr/abcd/ABBB/
    tr/abcd//d           s/[abcd]//g
    tr/abcd/AB/d         (tr/ab/AB/ + s/[cd]//g)  - but run together

=begin original

If the C</c> modifier is specified, the characters to be transliterated
are the ones NOT in I<SEARCHLIST>, that is, it is complemented.  If
C</d> and/or C</s> are also specified, they apply to the complemented
I<SEARCHLIST>.  Recall, that if I<REPLACEMENTLIST> is empty (except
under C</d>) a copy of I<SEARCHLIST> is used instead.  That copy is made
after complementing under C</c>.  I<SEARCHLIST> is sorted by code point
order after complementing, and any I<REPLACEMENTLIST>  is applied to
that sorted result.  This means that under C</c>, the order of the
characters specified in I<SEARCHLIST> is irrelevant.  This can
lead to different results on EBCDIC systems if I<REPLACEMENTLIST>
contains more than one character, hence it is generally non-portable to
use C</c> with such a I<REPLACEMENTLIST>.

=end original

C</c> 修飾子が指定されると、I<SEARCHLIST> に「ない」ものが文字変換されます;
つまり、補集合です。
C</d> や C</s> も指定されている場合、これらは I<SEARCHLIST> の補集合に
適用されます。
I<REPLACEMENTLIST> が空の場合、(C</d> の下でなければ) 
代わりに I<SEARCHLIST> のコピーが使われることを思い出してください。
このコピーは、C</c> の下の補集合化の後で行われます。
I<SEARCHLIST> は補集合化の後で符号位置の順序でソートされ、
I<REPLACEMENTLIST> はソートされた結果に対して適用されます。
つまり、C</c> の下では、I<SEARCHLIST> で指定された文字の順序は
無関係です。
I<REPLACEMENTLIST> に複数の文字が含まれている場合、
EBCDIC システムでは異なった結果を引き起こすことがあるので、
そのような I<REPLACEMENTLIST> に対して
C</c> を使うのは一般的に移植性がありません。

=begin original

Another way of describing the operation is this:
If C</c> is specified, the I<SEARCHLIST> is sorted by code point order,
then complemented.  If I<REPLACEMENTLIST> is empty and C</d> is not
specified, I<REPLACEMENTLIST> is replaced by a copy of I<SEARCHLIST> (as
modified under C</c>), and these potentially modified lists are used as
the basis for what follows.  Any character in the target string that
isn't in I<SEARCHLIST> is passed through unchanged.  Every other
character in the target string is replaced by the character in
I<REPLACEMENTLIST> that positionally corresponds to its mate in
I<SEARCHLIST>, except that under C</s>, the 2nd and following characters
are squeezed out in a sequence of characters in a row that all translate
to the same character.  If I<SEARCHLIST> is longer than
I<REPLACEMENTLIST>, characters in the target string that match a
character in I<SEARCHLIST> that doesn't have a correspondence in
I<REPLACEMENTLIST> are either deleted from the target string if C</d> is
specified; or replaced by the final character in I<REPLACEMENTLIST> if
C</d> isn't specified.

=end original

この操作を説明するもう一つの方法は次のものです:
C</c> が指定されると、I<SEARCHLIST> は符号位置順にソートされ、
それから補集合化されます。
I<REPLACEMENTLIST> が空で C</d> が指定されていないと、
I<REPLACEMENTLIST> は (C</c> で修正された) I<SEARCHLIST> のコピーに
置き換えられ、この変更されているかも知れないリストは引き続くものに対しての
基礎として使われます。
ターゲット文字列のうち、I<SEARCHLIST> ににない文字は変更されずに
そのままになります。
ターゲット文字列のその他のそれぞれの文字は、
I<SEARCHLIST> の中の文字に位置的に対応する、
I<REPLACEMENTLIST> の中の文字に置き換えられます;
C</s> の下では例外で、
連続して同じ文字に変換された文字並びの 2 文字目以降の文字は削除されます。
I<SEARCHLIST> が I<REPLACEMENTLIST> より長い場合、
I<SEARCHLIST> の文字のうち I<REPLACEMENTLIST> に対応するものが
ない文字にマッチングしたターゲット文字列の中の文字は、
C</d> が指定されていればターゲット文字列から削除されます;
C</d> が指定されていなければI<REPLACEMENTLIST> の最後の文字に
置き換えられます。

=begin original

Some examples:

=end original

いくつかの例:

    $ARGV[1] =~ tr/A-Z/a-z/;  # canonicalize to lower case ASCII

    $cnt = tr/*/*/;           # count the stars in $_
    $cnt = tr/*//;            # same thing

    $cnt = $sky =~ tr/*/*/;   # count the stars in $sky
    $cnt = $sky =~ tr/*//;    # same thing

    $cnt = $sky =~ tr/*//c;   # count all the non-stars in $sky
    $cnt = $sky =~ tr/*/*/c;  # same, but transliterate each non-star
                              # into a star, leaving the already-stars
                              # alone.  Afterwards, everything in
                              # $sky is a star.

    $cnt = tr/0-9//;          # count the ASCII digits in $_

    tr/a-zA-Z//s;             # bookkeeper -> bokeper
    tr/o/o/s;                 # bookkeeper -> bokkeeper
    tr/oe/oe/s;               # bookkeeper -> bokkeper
    tr/oe//s;                 # bookkeeper -> bokkeper
    tr/oe/o/s;                # bookkeeper -> bokkopor

    ($HOST = $host) =~ tr/a-z/A-Z/;
     $HOST = $host  =~ tr/a-z/A-Z/r; # same thing

    $HOST = $host =~ tr/a-z/A-Z/r # chained with s///r
                  =~ s/:/ -p/r;

    tr/a-zA-Z/ /cs;               # change non-alphas to single space

    @stripped = map tr/a-zA-Z/ /csr, @original;
                                  # /r with map

    tr [\200-\377]
       [\000-\177];               # wickedly delete 8th bit

    $foo !~ tr/A/a/    # transliterate all the A's in $foo to 'a',
                       # return 0 if any were found and changed.
                       # Otherwise return 1

=begin original

If multiple transliterations are given for a character, only the
first one is used:

=end original

複数の文字変換が一つの文字について指定されると、最初のものだけが使われます。

    tr/AAA/XYZ/

=begin original

will transliterate any A to X.

=end original

は A を X に変換します。

=begin original

Because the transliteration table is built at compile time, neither
the I<SEARCHLIST> nor the I<REPLACEMENTLIST> are subjected to double quote
interpolation.  That means that if you want to use variables, you
must use an C<eval()>:

=end original

変換テーブルはコンパイル時に作られるので、I<SEARCHLIST> も
I<REPLACEMENTLIST> もダブルクォート展開の対象とはなりません。
変数を使いたい場合には、C<eval()> を使わなければならないということです:

    eval "tr/$oldlist/$newlist/";
    die $@ if $@;

    eval "tr/$oldlist/$newlist/, 1" or die $@;

=back

=head3 Here-docs
X<here-doc> X<here-docs> X<heredoc> X<here-document> X<<< << >>>

(ヒアドキュメント)

=over 4

=item C<< <<I<EOT> >>

=item C<< <<~I<EOT> >>

=begin original

A line-oriented form of quoting is based on the shell "here-document"
syntax.  Following a C<< << >> you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.

=end original

クォートの行指向形式は、シェルの「ヒアドキュメント」構文を基にしています。
C<< << >> に引き続いて、クォートされるテキストを終了させる文字列を指定でき、
現在の行の次の行から終端文字列までの全ての行がその項目の値となります。

=begin original

An example is

=end original

An example is
(TBT)

 my $endng = <<WHIMPER;
 This is the way the text ends.
 This is the way the text ends.
 Not with a bang, but with a
 WHIMPER

=begin original

In this case, the terminator is an identifier, the word "WHIMPER".  Most
usually, people capitalize the identifier, just so it stands out, but
this is just a convention that isn't necessary.

=end original

In this case, the terminator is an identifier, the word "WHIMPER".  Most
usually, people capitalize the identifier, just so it stands out, but
this is just a convention that isn't necessary.
(TBT)

=begin original

The terminator may be enclosed in quotes, as detailed below, but without
them, the text of the here-doc acts exactly as if it were double-quoted.

=end original

The terminator may be enclosed in quotes, as detailed below, but without
them, the text of the here-doc acts exactly as if it were double-quoted.
(TBT)

 my $person = 'John';

 print uc <<EOT;
 Hello, $person!
 And the text goes on.
 EOT

=begin original

This yields:

=end original

This yields:
(TBT)

 HELLO, JOHN!
 AND THE TEXT GOES ON.

=begin original

The parentheses in the C<uc> function call don't have to be omitted:

=end original

The parentheses in the C<uc> function call don't have to be omitted:
(TBT)

 print uc(<<EOT);
 Hello, $person!
 And the text goes on.
 EOT

 HELLO, JOHN!
 AND THE TEXT GOES ON.

=begin original

And you can intermix a here-document with other things:

=end original

And you can intermix a here-document with other things:
(TBT)

 print <<EOT, "Followed by the next argument\n";
 Hello, $person!
 And the text goes on.
 EOT

 Hello, John!
 And the text goes on.
 Followed by the next argument

=begin original

And you can have multiple here-documents:

=end original

And you can have multiple here-documents:
(TBT)

 print <<EOT1, <<EOT2;
 Hello, $person!
 And the text goes on.
 EOT1
 Followed by the next argument
 EOT2

 Hello, John!
 And the text goes on.
 Followed by the next argument

=begin original

The terminator doesn't have to be a single word; it may also be some
quoted text:

=end original

The terminator doesn't have to be a single word; it may also be some
quoted text:
(TBT)

 my $pagliaci = << "La Commedia e finita!";
 A troupe comes to town to perform a play, a comedy.  The lead actress
 and lead actor are in an unhappy marriage.  On stage, he stabs her
 for real; then he stabs her lover who has rushed from the audience to
 defend her.  Both die.
 La Commedia e finita!

=begin original

There may not be a space between the C<< << >> and the identifier unless
the terminator is quoted, as demonstrated in the example just above.
Quoting rules for the terminator are unrelated to Perl's quoting rules.
Only C<"">, C<''>, and C<``> can be used to quote it, NOT C<q()>,
C<qq()>, and the like.  The only interpolation is for backslashing the
quoting character:

=end original

直前の例で図示したように、終端子がクォートされていない限り、
C<< << >> と識別子の間にスペースを置くことはできません。
終端子に対するクォートルールは Perl のクォート規則とは
関係ありません。
C<"">, C<''>, C<``> のみがクォートに使うことができ、
C<q()>, C<qq()>, およびその亜種は使えません。
文字をクォートするための逆スラッシュだけが展開されます:

    print << "abc\"def";
    testing...
    abc"def

=begin original

The terminating string must appear by itself (unquoted and with no
surrounding whitespace) on the terminating line.  Also, it cannot span
multiple lines.  The general rule is that the identifier must be a
string literal.  Stick with that, and you should be safe.

=end original

終端文字列は終端行に単体で (クォートされず周りに空白も置かず)
現れる必要があります。
また、これは複数行にかかることはありません。
識別子に関する一般的なルールは、文字列リテラルでなければならないことです。
これに従っていれば、安全のはずです。

=begin original

Don't forget that you have to put a semicolon on the end to finish the
statement, as Perl doesn't know you're not going to try to do this:

=end original

以下のようなことをしたいのではないということが Perl にはわからないので、
文を終わらせるためには末尾にセミコロンをつけなければならないことを
忘れないで下さい:

    print <<ABC
    10
    ABC
       + 20;

=begin original

which prints C<30> and no line terminator.

=end original

これは行終端子なしで C<30> を出力します。

=begin original

If you want your here-doc to not have a line terminator on the final
line, use C<chomp()>.

=end original

ヒアドキュメントが最終行の行終端子を持たないようにしたい場合は、
C<chomp()> を使ってください。

    chomp($string = <<'END');
    This is the first line.
    This second line won't end in a \n.
    END

=begin original

If you use a here-doc within a delimited construct, such as in C<s///eg>,
the quoted material must still come on the line following the
C<<< <<TERMINATOR >>> marker, which means it may be inside the delimited
construct:

=end original

C<s///eg> のようなデリミタ構造の中でヒアドキュメントを使う場合、
クォートされたものは、やはり区切られた構造の内側を意味するかもしれない
C<<< <<TERMINATOR >>> マーカーに引き続くものとして来なければなりません:

    s/this/<<E . 'that'
    the other
    E
     . 'more '/eg;

=begin original

(It works this way as of Perl 5.18.  Historically, it was inconsistent, and
you would have to write

=end original

(この方法は Perl 5.18 から動作します。
歴史的には、これは一貫性がなく、以下のように

    s/this/<<E . 'that'
     . 'more '/eg;
    the other
    E

=begin original

outside of string evals.)

=end original

文字列 eval の外側で書く必要があります。)

=begin original

A problem with the Here-doc syntax given so far is that it must be at the
left margin of your program, messing up the indentation.  Starting in
Perl v5.26, the tilde C<~> modifier allows you to indent your here-docs
to make the code more readable.

=end original

これまでのヒアドキュメント構文の問題の一つは、プログラムの左マージンに
置かなければならず、インデントがおかしくなることです。
Perl v5.26 から、チルダ修飾子 C<~> は、コードをより読みやすくするために
ヒアドキュメントをインデントできるようにします。

    if ($some_var) {
        print <<~EOF;
          This is a here-doc
          EOF
    }

=begin original

This will print...

=end original

これは次のものを...

    This is a here-doc

=begin original

...with no leading whitespace.

=end original

...先頭の空白なしで表示します。

=begin original

The line containing the delimiter that marks the end of the here-doc
determines the indentation template for the whole thing.  Compilation
croaks if any non-empty line inside the here-doc does not begin with the
precise indentation of the terminating line.  (An empty line consists of
the single character "\n".)  For example, suppose the terminating line
begins with a tab character followed by 4 space characters.  Every
non-empty line in the here-doc must begin with a tab followed by 4
spaces.  They are stripped from each line, and any leading white space
remaining on a line serves as the indentation for that line.  Currently,
only the TAB and SPACE characters are treated as whitespace for this
purpose.  Tabs and spaces may be mixed, but are matched exactly; tabs
remain tabs and are not expanded.

=end original

ヒアドキュメントの末尾を記す区切り文字を含む行は、
全体のためのインデントテンプレートを決定します。
ヒアドキュメントの非空行が末尾行と正確に同じインデントで始まっていない場合、
コンパイルは croak します。
(空行は単一の文字 "\n" からなります。)  
例えば、終了行がタブ文字と、それに引き続いて四つのスペース文字で
始まっていたとします。
ヒアドキュメントの全ての非空行はタブとそれに引き続く四つのスペースで
始まっていなければなりません。
それらは各行から取り除かれ、行に残った戦闘の空白は
その行のインデントとして動作します。
現在の所、この目的には TAB と SPACE の文字だけが空白として扱われます。
タブとスペースは混ぜることが出来ますが、正確に
マッチングしなければなりません;
タブはタブのままで、展開はされません。

=begin original

Additional beginning whitespace (beyond what preceded the
delimiter) will be preserved:

=end original

(区切り文字で指定された以上の)追加の先頭の空白は保存されます:

 print <<~EOF;
   This text is not indented
     This text is indented with two spaces
		This line is indented with two tabs, though those may
                have been converted to spaces by various filters by
                the time you read this. 
   EOF

=back

=head4 Quoting the delimiter

=begin original

As mentioned above, the terminating string may be quoted.  There are
three types of quoting possible.  The type used determines the treatment
of the text.

=end original

As mentioned above, the terminating string may be quoted.  There are
three types of quoting possible.  The type used determines the treatment
of the text.
(TBT)

=over 4

=item Double Quotes

(ダブルクォート)

=begin original

Double quotes surrounding the terminating word or string behave as if
no quotes were there, namely the text will be interpolated using exactly
the same rules as normal double quoted strings, as in all the examples
above.  So

=end original

終端子を囲むダブルクォートは、クォートがないかのように振る舞います;
つまり、上述の全ての例のように、
通常のダブルクォートされた文字列と全く同じ規則を使って
変数展開されることを示します。

 my $person = 'John';

 print uc << "EOT";
 Hello, $person!
 And the text goes on.
 EOT

=begin original

yields:

=end original

は次のようになり:

 HELLO, JOHN!
 AND THE TEXT GOES ON.

=begin original

which is the same result as without quotes.

=end original

クォートなしと同じ結果になります。

=item Single Quotes

(シングルクォート)

=begin original

If instead, single quotes are used, the text is treated literally, with
no interpolation of its content.

=end original

代わりにシングルクォートが使われた場合、
内容が展開されずにリテラルに扱われることを意味します。

 my $person = 'John';
 print uc <<'EOT';
 Hello, $person!
 And the text goes on.
 EOT

 HELLO, $PERSON!
 AND THE TEXT GOES ON.

=begin original

The difference between a single-quoted here-doc and a single-quoted
string is that backslashes have no special meaning in a here-doc, with
C<\\> being treated as two backslashes and not one as they would in
every other quoting construct.

=end original

これはシングルクォートヒアドキュメントとシングルクォート文字列の違いは、
バックスラッシュは特別な意味を持たず、他の全てのクォート構造と違って、
C<\\> は二つのバックスラッシュとして扱われることです。

=begin original

Just as in the shell, a backslashed bareword following the C<<< << >>>
means the same thing as a single-quoted string does:

=end original

シェルでの場合と同様、C<<< << >>> に引き続いてバックスラッシュ付きの
裸の単語があると、シングルクォートされた文字列と同じこととなります:

    $cost = <<'VISTA';  # hasta la ...
    That'll be $10 please, ma'am.
    VISTA

    $cost = <<\VISTA;   # Same thing!
    That'll be $10 please, ma'am.
    VISTA

=begin original

These two forms are the only ways of quoting in Perl where there is no
need to worry about escaping content, something that code generators can
and do make good use of.

=end original

これら二つの形式だけが、Perl において、内容のエスケープについて心配する
必要のない形で、コードジェネレータがうまく使えるものです。

=item Backticks

(逆クォート)

=begin original

Finally, if instead backticks are used to quote the terminating string,
the content of the here doc is treated just as it would be if it were a
string embedded in backticks.  Thus the content is interpolated as
though it were double quoted and then executed via the shell, with the
results of the execution returned.

=end original

最後に、終端文字列をクォートするために逆クォートが使われた場合、
ヒアドキュメントのの内容は、文字列が逆クォートで
埋め込まれているかのように扱われます。
したがって、その内容、はダブルクォートされているかのように変数展開され、
その後シェル経由で実行され、実行された結果になります。

    print << `EOC`; # execute command and get results
    echo hi there
    EOC

=back

=head3 Gory details of parsing quoted constructs
X<quote, gory details>

(クォートされた構造のパースに関する詳細)

=begin original

When presented with something that might have several different
interpretations, Perl uses the B<DWIM> (that's "Do What I Mean")
principle to pick the most probable interpretation.  This strategy
is so successful that Perl programmers often do not suspect the
ambiguity of what they write.  But from time to time, Perl's
notions differ substantially from what the author honestly meant.

=end original

何か複数の解釈が可能な表現があった場合、Perl は最も確からしい解釈を
選択するために B<DWIM> ("Do What I Mean")原則を使います。
この戦略は非常に成功したので、Perl プログラマはしばしば
自分が書いたものの曖昧さを疑いません。
しかし時間がたつにつれて、Perl の概念は作者が本当に意味していたものから
かなり変わりました。

=begin original

This section hopes to clarify how Perl handles quoted constructs.
Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.

=end original

この章では Perl がどのようにクォートされた構造を扱うかを
明確にしようと思います。
これを学ぼうとする最もよくある理由は正規表現の迷宮をほぐすためですが、
パースの初期ステップは全てのクォート演算子で同じなので、全て同時に扱います。

=begin original

The most important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.  If you understand
this rule, you may skip the rest of this section on the first
reading.  The other rules are likely to contradict the user's
expectations much less frequently than this first one.

=end original

Perl のパースに関するルールで最も重要なものは以下で述べているうち
最初のものです: つまり、クォートされた構造を処理するときは、Perl はまずその
構造の最後を探して、それから中身を解釈します。
このルールがわかれば、とりあえずはこの章の残りは読み飛ばしてもかまいません。
その他のルールは最初のルールに比べてユーザーの予想に反する頻度は
はるかに少ないです。

=begin original

Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.  For different
quoting constructs, Perl performs different numbers of passes, from
one to four, but these passes are always performed in the same order.

=end original

以下で議論するパスには同時に実行されるものもありますが、
結果は同じことなので、別々に考えることにします。
クォート構造の種類によって、Perl が実行するパスの数は
1 から 4 まで異なりますが、これらのパスは常に同じ順番で実行されます。

=over 4

=item Finding the end

(最後を探す)

=begin original

The first pass is finding the end of the quoted construct.  This results
in saving to a safe location a copy of the text (between the starting
and ending delimiters), normalized as necessary to avoid needing to know
what the original delimiters were.

=end original

最初のパスは、クォート構造の末尾を探すことです。
これにより、(開始デリミタと終了デリミタの間の)テキストは安全な場所に
コピーされ、元のデリミタが何だったかを知る必要がないように正規化されます。

=begin original

If the construct is a here-doc, the ending delimiter is a line
that has a terminating string as the content.  Therefore C<<<EOF> is
terminated by C<EOF> immediately followed by C<"\n"> and starting
from the first column of the terminating line.
When searching for the terminating line of a here-doc, nothing
is skipped.  In other words, lines after the here-doc syntax
are compared with the terminating string line by line.

=end original

構造がヒアドキュメントの場合、終了デリミタは内容として終端文字列を持つ
行です。
従って、C<<<EOF> は、C<"\n"> の直後の、終端行の最初の列から始まる C<EOF> で
終端します。
ヒアドキュメントの終端行を探すとき、読み飛ばされるものはありません。
言い換えると、ヒアドキュメント文法以降の行は、1 行毎に終端文字列と
比較されます。

=begin original

For the constructs except here-docs, single characters are used as starting
and ending delimiters.  If the starting delimiter is an opening punctuation
(that is C<(>, C<[>, C<{>, or C<< < >>), the ending delimiter is the
corresponding closing punctuation (that is C<)>, C<]>, C<}>, or C<< > >>).
If the starting delimiter is an unpaired character like C</> or a closing
punctuation, the ending delimiter is the same as the starting delimiter.
Therefore a C</> terminates a C<qq//> construct, while a C<]> terminates
both C<qq[]> and C<qq]]> constructs.

=end original

ヒアドキュメント以外の構造では、1 文字が開始デリミタと終了デリミタとして
使われます。
開始デリミタが組の開き文字(C<(>, C<[>, C<{>, C<< < >> のいずれか)の場合、
終了デリミタは対応する組の閉じ文字(つまり C<)>, C<]>, C<}>, C<< > >>) です。
開始デリミタが C</> 組になる文字や、組の閉じ文字の場合、終了デリミタは
開始デリミタと同じです。
従って C</> は C<qq//> 構造を終端し、一方 C<]> は C<qq[]> と C<qq]]> の
両方の構文を終端します。

=begin original

When searching for single-character delimiters, escaped delimiters
and C<\\> are skipped.  For example, while searching for terminating C</>,
combinations of C<\\> and C<\/> are skipped.  If the delimiters are
bracketing, nested pairs are also skipped.  For example, while searching
for a closing C<]> paired with the opening C<[>, combinations of C<\\>, C<\]>,
and C<\[> are all skipped, and nested C<[> and C<]> are skipped as well.
However, when backslashes are used as the delimiters (like C<qq\\> and
C<tr\\\>), nothing is skipped.
During the search for the end, backslashes that escape delimiters or
other backslashes are removed (exactly speaking, they are not copied to the
safe location).

=end original

1 文字のデリミタを探す場合、エスケープされたデリミタと C<\\> は
読み飛ばします。
例えば、C</> を探しているときには、C<\\> と C<\/> の組み合わせを
読み飛ばします。
デリミタがかっこでくくられている場合は、ネストした組も読み飛ばされます。
例えば、開きの C<[> と組になる閉じの C<]> を探しているときには、
C<\\>, C<\]>, C<\[> の組み合わせをは全て読み飛ばし、
さらにネストした C<[>, C<]> も読み飛ばします。
しかし、(C<qq\\> や C<tr\\\> のように)バックスラッシュがデリミタとして
使われた場合、何も読み飛ばしません。
末尾の検索中、デリミタやその他のバックスラッシュをエスケープする
バックスラッシュは除去されます(述べたとおりに正確に、安全な場所に
コピーはされません)。

=begin original

For constructs with three-part delimiters (C<s///>, C<y///>, and
C<tr///>), the search is repeated once more.
If the first delimiter is not an opening punctuation, the three delimiters must
be the same, such as C<s!!!> and C<tr)))>,
in which case the second delimiter
terminates the left part and starts the right part at once.
If the left part is delimited by bracketing punctuation (that is C<()>,
C<[]>, C<{}>, or C<< <> >>), the right part needs another pair of
delimiters such as C<s(){}> and C<tr[]//>.  In these cases, whitespace
and comments are allowed between the two parts, although the comment must follow
at least one whitespace character; otherwise a character expected as the
start of the comment may be regarded as the starting delimiter of the right part.

=end original

3 つのデリミタからなる構造 (C<s///>, C<y///>, C<tr///>) の場合、
検索はもう一度繰り返されます。
最初のデリミタが開きかっこでない場合、C<s!!!> and C<tr)))> のように
3 つのデリミタは同じでなければなりません;
この場合、2 番目のデリミタが左側の終端と右側の開始を同時に行います。
左側のデリミタがかっこを構成するもの (これは C<()>,
C<[]>, C<{}>, C<< <> >> のいずれか) の場合、右側も
C<s(){}> や C<tr[]//> のようなデリミタである必要があります。
これらの場合、右側と左側の間には空白やコメントを置けますが、
コメントは少なくとも一つの空白文字の後である必要があります;
さもなければコメントの開始文字が右側の開始デリミタとして扱われてしまいます。

=begin original

During this search no attention is paid to the semantics of the construct.
Thus:

=end original

検索する間、構造の文脈は考慮しません。
従って:

    "$hash{"$foo/$bar"}"

=begin original

or:

=end original

または:

    m/
      bar       # NOT a comment, this slash / terminated m//!
     /x

=begin original

do not form legal quoted expressions.   The quoted part ends on the
first C<"> and C</>, and the rest happens to be a syntax error.
Because the slash that terminated C<m//> was followed by a C<SPACE>,
the example above is not C<m//x>, but rather C<m//> with no C</x>
modifier.  So the embedded C<#> is interpreted as a literal C<#>.

=end original

は正しいクォート表現ではありません。
クォートは最初の C<"> や C</> で終わりとなり、残りの部分は文法エラーと
なります。
C<m//> を終わらせているスラッシュの次に来ているのが C<空白> なので、
上の例では C<m//x> ではなく、C</x> なしの C<m//> となります。
従って、中にある C<#> はリテラルな C<#> として扱われます。

=begin original

Also no attention is paid to C<\c\> (multichar control char syntax) during
this search.  Thus the second C<\> in C<qq/\c\/> is interpreted as a part
of C<\/>, and the following C</> is not recognized as a delimiter.
Instead, use C<\034> or C<\x1c> at the end of quoted constructs.

=end original

この検索の間、C<\c\> (マルチバイト文字制御文法)に注意は払われません。
従って、C<qq/\c\/> の 2 番目の C<\> は C<\/> の一部として扱われ、
引き続く C</> はデリミタとして認識されません。
代わりに、クォート構造の末尾に C<\034> か C<\x1c> を使ってください。

=item Interpolation
X<interpolation>

(展開)

=begin original

The next step is interpolation in the text obtained, which is now
delimiter-independent.  There are multiple cases.

=end original

次のステップは、得られた(デリミタに依存しない)テキストに対する展開です。
複数のケースがあります。

=over 4

=item C<<<'EOF'>

=begin original

No interpolation is performed.
Note that the combination C<\\> is left intact, since escaped delimiters
are not available for here-docs.

=end original

展開は行われません。
C<\\> の組み合わせはそのままであることに注意してください;
ヒアドキュメントではデリミタのエスケープはできないからです。

=item  C<m''>, the pattern of C<s'''>

=begin original

No interpolation is performed at this stage.
Any backslashed sequences including C<\\> are treated at the stage
of L</"Parsing regular expressions">.

=end original

このステージでは展開は行われません。
C<\\> を含む、バックスラッシュ付きのシーケンスは
L</"Parsing regular expressions"> で扱われます。

=item C<''>, C<q//>, C<tr'''>, C<y'''>, the replacement of C<s'''>

=begin original

The only interpolation is removal of C<\> from pairs of C<\\>.
Therefore C<"-"> in C<tr'''> and C<y'''> is treated literally
as a hyphen and no character range is available.
C<\1> in the replacement of C<s'''> does not work as C<$1>.

=end original

C<\\> の組における C<\> の削除のみが行われます。
従って、C<tr'''> や C<y'''> の中にある C<"-"> は文字通りハイフンとして扱われ、
文字範囲は使えません。
C<s'''> の置換文字列での C<\1> は C<$1> としては動作しません。

=item C<tr///>, C<y///>

=begin original

No variable interpolation occurs.  String modifying combinations for
case and quoting such as C<\Q>, C<\U>, and C<\E> are not recognized.
The other escape sequences such as C<\200> and C<\t> and backslashed
characters such as C<\\> and C<\-> are converted to appropriate literals.
The character C<"-"> is treated specially and therefore C<\-> is treated
as a literal C<"-">.

=end original

変数展開は行われません。
C<\Q>, C<\U>, C<\E> のような、大文字小文字やクォートに関する、文字列を
変更するような組み合わせは認識されません。
C<\200> や C<\t> のようなその他のエスケープシーケンスや、
C<\\> や C<\-> のようなバックスラッシュ付きの文字は、適切なリテラルに
変換されます。
文字 C<"-"> は特別扱いされるので、C<\-> はリテラルな C<"-"> として扱われます。

=item C<"">, C<``>, C<qq//>, C<qx//>, C<< <file*glob> >>, C<<<"EOF">

=begin original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F> (possibly paired with C<\E>) are
converted to corresponding Perl constructs.  Thus, C<"$foo\Qbaz$bar">
is converted to S<C<$foo . (quotemeta("baz" . $bar))>> internally.
The other escape sequences such as C<\200> and C<\t> and backslashed
characters such as C<\\> and C<\-> are replaced with appropriate
expansions.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F> (おそらくは C<\E> との組)は
対応する Perl 構造に変換されます。
従って、C<"$foo\Qbaz$bar"> は内部的に
S<C<$foo . (quotemeta("baz" . $bar))>> に変換されます。
C<\200> や C<\t> のような、その他のエスケープシーケンスや、C<\\> や
C<\-> のような、バックスラッシュがつけられた文字は適切な拡張に
置換されます。

=begin original

Let it be stressed that I<whatever falls between C<\Q> and C<\E>>
is interpolated in the usual way.  Something like C<"\Q\\E"> has
no C<\E> inside.  Instead, it has C<\Q>, C<\\>, and C<E>, so the
result is the same as for C<"\\\\E">.  As a general rule, backslashes
between C<\Q> and C<\E> may lead to counterintuitive results.  So,
C<"\Q\t\E"> is converted to C<quotemeta("\t")>, which is the same
as C<"\\\t"> (since TAB is not alphanumeric).  Note also that:

=end original

I<C<\Q> と C<\E> の間にある全てのもの> が通常の方法で展開されます。
C<"\Q\\E"> のようなものは内部にあるのは C<\E> ではありません。
C<\Q>, C<\\>, C<E> であるので、結果は C<"\\\\E"> と同じになります。
一般的なルールとして、C<\Q> と C<\E> の間にあるバックスラッシュは
直感に反した結果になります。
それで、C<"\Q\t\E"> は C<quotemeta("\t")> に変換され、これは(TAB は
英数字ではないので C<"\\\t"> と同じです。
以下のようなことにも注意してください:

    $str = '\t';
    return "\Q$str";

=begin original

may be closer to the conjectural I<intention> of the writer of C<"\Q\t\E">.

=end original

これは C<"\Q\t\E"> を書いた人の憶測上の I<意図> により近いです。

=begin original

Interpolated scalars and arrays are converted internally to the C<join> and
C<"."> catenation operations.  Thus, S<C<"$foo XXX '@arr'">> becomes:

=end original

展開されたスカラと配列は内部で C<join> と C<"."> の結合操作に変換されます。
従って、S<C<"$foo XXX '@arr'">> は以下のようになります:

    $foo . " XXX '" . (join $", @arr) . "'";

=begin original

All operations above are performed simultaneously, left to right.

=end original

上記の全ての操作は、左から右に同時に行われます。

=begin original

Because the result of S<C<"\Q I<STRING> \E">> has all metacharacters
quoted, there is no way to insert a literal C<$> or C<@> inside a
C<\Q\E> pair.  If protected by C<\>, C<$> will be quoted to become
C<"\\\$">; if not, it is interpreted as the start of an interpolated
scalar.

=end original

S<C<"\Q I<STRING> \E">> の結果は全てのメタ文字がクォートされているので、
C<\Q\E> の組の内側にリテラルの C<$> や C<@> を挿入する方法はありません。
C<\> によって守られている場合、C<$> はクォートされて C<"\\\$"> と
なります; そうでない場合、これは展開されるスカラ変数の開始として
解釈されます。

=begin original

Note also that the interpolation code needs to make a decision on
where the interpolated scalar ends.  For instance, whether
S<C<< "a $x -> {c}" >>> really means:

=end original

展開コードは、展開するスカラ変数がどこで終わるかを決定する必要が
あることにも注意してください。
例えば、S<C<< "a $x -> {c}" >>> が実際には以下のどちらかになります:

    "a " . $x . " -> {c}";

=begin original

or:

=end original

または:

    "a " . $x -> {c};

=begin original

Most of the time, the longest possible text that does not include
spaces between components and which contains matching braces or
brackets.  because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.
Fortunately, it's usually correct for ambiguous cases.

=end original

ほとんどの場合、要素と、マッチする中かっこや大かっこの間に空白を含まない、
最も長いテキストになります。
出力は発見的な推定器をよる投票によって決定されるので、結果は厳密には
予測できません。
幸い、紛らわしい場合でも普通は正しいです。

=item The replacement of C<s///>

=begin original

Processing of C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F> and interpolation
happens as with C<qq//> constructs.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F> の処理と展開が C<qq//> 構造と
同じように起こります。

=begin original

It is at this step that C<\1> is begrudgingly converted to C<$1> in
the replacement text of C<s///>, in order to correct the incorrigible
I<sed> hackers who haven't picked up the saner idiom yet.  A warning
is emitted if the S<C<use warnings>> pragma or the B<-w> command-line flag
(that is, the C<$^W> variable) was set.

=end original

このステップでは、より健全な文法をまだ導入していない、手に負えない I<sed>
ハッカーのために、C<s///> の置換テキストの中にある C<\1> を、しぶしぶながら
C<$1> に変換します。
S<C<use warnings>> プラグマやコマンドラインオプション B<-w> (これは C<$^W>
変数です) がセットされていると警告が生成されます。

=item C<RE> in C<m?RE?>, C</RE/>, C<m/RE/>, C<s/RE/foo/>,

=begin original

Processing of C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F>, C<\E>,
and interpolation happens (almost) as with C<qq//> constructs.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\F>, C<\E> の処理と展開が C<qq//> 構文と
(ほとんど)同じように起こります。

=begin original

Processing of C<\N{...}> is also done here, and compiled into an intermediate
form for the regex compiler.  (This is because, as mentioned below, the regex
compilation may be done at execution time, and C<\N{...}> is a compile-time
construct.)

=end original

C<\N{...}> の処理もここで行われ、正規表現コンパイラのための中間形式に
コンパイルされます。
(これは、後述するように、正規表現のコンパイルは実行時に行われ、
C<\N{...}> はコンパイル時の構文だからです。)

=begin original

However any other combinations of C<\> followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step.
As C<\c> is skipped at this step, C<@> of C<\c@> in RE is possibly
treated as an array symbol (for example C<@foo>),
even though the same text in C<qq//> gives interpolation of C<\c@>.

=end original

しかし、その他の、C<\> の後に文字が続く組み合わせは置換されず、単に
読み飛ばされます; これは以下のステップで正規表現としてパースするためです。
ここでは C<\c> は読み飛ばされるので、正規表現中の C<\c@> の C<@> は
配列のシンボル(例えば C<@foo>) と扱われる可能性があります;
一方 C<qq//> 内の同じテキストは C<\c@> と展開されます。

=begin original

Code blocks such as C<(?{BLOCK})> are handled by temporarily passing control
back to the perl parser, in a similar way that an interpolated array
subscript expression such as C<"foo$array[1+f("[xyz")]bar"> would be.

=end original

C<(?{BLOCK})> のようなコードブロックは、一時的に制御を perl パーサに
渡すことで扱われます; これは C<"foo$array[1+f("[xyz")]bar"> のような、
変数展開される配列添え字表現と同様の方法です。

=begin original

Moreover, inside C<(?{BLOCK})>, S<C<(?# comment )>>, and
a C<#>-comment in a C</x>-regular expression, no processing is
performed whatsoever.  This is the first step at which the presence
of the C</x> modifier is relevant.

=end original

さらに、C<(?{BLOCK})>, S<C<(?# comment )>>, C</x> 正規表現での C<#> の
コメントの中では、どのような処理も行われません。
これは C</x> 修飾子が影響を与える最初のステップです。

=begin original

Interpolation in patterns has several quirks: C<$|>, C<$(>, C<$)>, C<@+>
and C<@-> are not interpolated, and constructs C<$var[SOMETHING]> are
voted (by several different estimators) to be either an array element
or C<$var> followed by an RE alternative.  This is where the notation
C<${arr[$bar]}> comes handy: C</${arr[0-9]}/> is interpreted as
array element C<-9>, not as a regular expression from the variable
C<$arr> followed by a digit, which would be the interpretation of
C</$arr[0-9]/>.  Since voting among different estimators may occur,
the result is not predictable.

=end original

パターン内の展開ではいくつか特殊な動作をします:
C<$|>, C<$(>, C<$)>, C<@+>, C<@-> は展開されず、
C<$var[SOMETHING]> は(いくつかの異なる推定器によって)配列の要素か
C<$var> の後に正規表現が続いているのかが投票されます。
これは C<${arr[$bar]}> が便利になるところです: C</${arr[0-9]}/> は
配列要素 C<-9> として解釈され、C</$arr[0-9]/> の場合のように C<$arr> の後に
数値が続いているような正規表現としては解釈されません。
異なった推定器によって投票されることがあるので、結果は予測できません。

=begin original

The lack of processing of C<\\> creates specific restrictions on
the post-processed text.  If the delimiter is C</>, one cannot get
the combination C<\/> into the result of this step.  C</> will
finish the regular expression, C<\/> will be stripped to C</> on
the previous step, and C<\\/> will be left as is.  Because C</> is
equivalent to C<\/> inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in C<s*foo*bar*>, C<m[foo]>, or C<m?foo?>; or an
alphanumeric char, as in:

=end original

C<\\> を処理しないことにより、後処理したテキストに特定の制限があります。
デリミタが C</> の場合、このステップの結果として C<\/> を得ることは
できません。
C</> は正規表現を終わらせ、C<\/> は前のステップで C</> に展開され、
C<\\/> はそのまま残されます。
C</> は正規表現の中では C<\/> と等価なので、これはたまたまデリミタが
正規検索エンジンにとって特別な文字の場合、つまり C<s*foo*bar*>,
C<m[foo]>, C<m?foo?> のような場合、あるいは以下のように英数字でなければ、
問題にはなりません:

    m m ^ a \s* b mmx;

=begin original

In the RE above, which is intentionally obfuscated for illustration, the
delimiter is C<m>, the modifier is C<mx>, and after delimiter-removal the
RE is the same as for S<C<m/ ^ a \s* b /mx>>.  There's more than one
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.

=end original

上記の正規表現では、説明のために意図的にわかりにくくしていますが、
デリミタは C<m> で、修飾子は C<mx> で、デリミタを取り除いた後の
正規表現は S<C<m/ ^ a \s* b /mx>> と同じです。
デリミタを英数字や空白でないものに制限するべきである理由は複数あります。

=back

=begin original

This step is the last one for all constructs except regular expressions,
which are processed further.

=end original

これは正規表現以外の全ての構造にとって最後のステップです; 正規表現は
さらに処理が続きます。

=item Parsing regular expressions
X<regexp, parse>

(正規表現のパース)

=begin original

Previous steps were performed during the compilation of Perl code,
but this one happens at run time, although it may be optimized to
be calculated at compile time if appropriate.  After preprocessing
described above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved, the
resulting I<string> is passed to the RE engine for compilation.

=end original

以前のステップは Perl コードのコンパイル中に実行されますが、
これは実行時に起こりますが、もし適切ならコンパイル時に
計算できるように最適化されることもあります。
上記の前処理の後、そして必要なら連結、結合、大文字小文字変換、
メタクォート化が行われた後、結果の I<文字列> がコンパイルのために
正規表現エンジンに渡されます。

=begin original

Whatever happens in the RE engine might be better discussed in L<perlre>,
but for the sake of continuity, we shall do so here.

=end original

正規表現エンジンで起こることについては L<perlre> で議論した方が
よいでしょうが、継続性のために、ここでそれを行います。

=begin original

This is another step where the presence of the C</x> modifier is
relevant.  The RE engine scans the string from left to right and
converts it into a finite automaton.

=end original

これも C</x> 修飾子の存在が関連するステップの一つです。
正規表現エンジンは文字列を左から右にスキャンして、有限状態オートマトンに
変換します。

=begin original

Backslashed characters are either replaced with corresponding
literal strings (as with C<\{>), or else they generate special nodes
in the finite automaton (as with C<\b>).  Characters special to the
RE engine (such as C<|>) generate corresponding nodes or groups of
nodes.  C<(?#...)> comments are ignored.  All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and C<#>-style comments if C</x> is present).

=end original

バックスラッシュ付きの文字は(C<\{> のように)対応するリテラル文字列に
置換されるか、あるいは(C<\b> のように)有限状態オートマトンの特別な
ノードを生成します。
(C<|> のような)正規表現エンジンにとって特別な文字は対応するノードか
ノードのグループを生成します。
C<(?#...)> コメントは無視されます。
残りの全てはマッチするリテラル文字列に変換されるか、そうでなければ
(C</x> が指定された時の空白と C<#> スタイルのコメントと同様に)
無視されます。

=begin original

Parsing of the bracketed character class construct, C<[...]>, is
rather different than the rule used for the rest of the pattern.
The terminator of this construct is found using the same rules as
for finding the terminator of a C<{}>-delimited construct, the only
exception being that C<]> immediately following C<[> is treated as
though preceded by a backslash.

=end original

文字クラス構造 C<[...]> のパースは他のパターンとはルールが異なります。
この構造の終端は C<{}> でデリミタされた構造の終端を検索するのと同じルールで
検索されます; 唯一の例外は、C<[> の直後の C<]> はバックスラッシュが
先行しているものとして扱われます。

=begin original

The terminator of runtime C<(?{...})> is found by temporarily switching
control to the perl parser, which should stop at the point where the
logically balancing terminating C<}> is found.

=end original

実行時 C<(?{...})> の終端は、一時的に perl パーサに制御を切り替えることで
見つけられ、論理的にバランスした終端 C<}> が見つかって場所で停止します。

=begin original

It is possible to inspect both the string given to RE engine and the
resulting finite automaton.  See the arguments C<debug>/C<debugcolor>
in the S<C<use L<re>>> pragma, as well as Perl's B<-Dr> command-line
switch documented in L<perlrun/"Command Switches">.

=end original

正規表現に与えられる文字列と、結果としての有限状態オートマトンの両方を
検査できます。
S<C<use L<re>>> プラグマの C<debug>/C<debugcolor> 引数と、
L<perlrun/"Command Switches"> に記述されている B<-Dr> コマンドライン
オプションを参照してください。

=item Optimization of regular expressions
X<regexp, optimization>

(正規表現の最適化)

=begin original

This step is listed for completeness only.  Since it does not change
semantics, details of this step are not documented and are subject
to change without notice.  This step is performed over the finite
automaton that was generated during the previous pass.

=end original

このステップは完全性のためだけにリストされています。
これは意味論的には変化がないので、このステップの詳細は文書化されておらず、
将来予告なしに変更されることがあります。
このステップはここまでの処理で生成された有限オートマトンに対して
適用されます。

=begin original

It is at this stage that C<split()> silently optimizes C</^/> to
mean C</^/m>.

=end original

C<split()> で C</^/> を暗黙に C</^/m> に最適化するのもこのステップです。

=back

=head2 I/O Operators
X<operator, i/o> X<operator, io> X<io> X<while> X<filehandle>
X<< <> >> X<< <<>> >> X<@ARGV>
X<diamond operator> X<double diamond operator>

(I/O 演算子)

=begin original

There are several I/O operators you should know about.

=end original

知っておいた方がよい I/O 演算子もいくつかあります。

=begin original

A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.  In scalar context, a single string
consisting of all output is returned.  In list context, a list of
values is returned, one per line of output.  (You can set C<$/> to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.  The status value of the command is
returned in C<$?> (see L<perlvar> for the interpretation of C<$?>).
Unlike in B<csh>, no translation is done on the return data--newlines
remain newlines.  Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.  To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.  The generalized form of backticks is C<qx//>, or you can
call the L<perlfunc/readpipe> function.  (Because
backticks always undergo shell expansion as well, see L<perlsec> for
security concerns.)
X<qx> X<`> X<``> X<backtick> X<glob>

=end original

バッククォートで括られた文字列は、まず、ダブルクォート補完のように
変数の展開が行なわれます。
その後、シェルでの場合と同じように、外部コマンドとして解釈され、
そのコマンドの出力がこのバッククォート文字列の値となります。
スカラーコンテキストでは、出力すべてを含む一個の文字列が返されます。
リストコンテキストでは、出力の 1 行 1 行が個々の要素となるリストが返されます。
(C<$/> を設定すれば、行の終わりを示す文字を変えることができます。)
コマンドは、この擬似リテラルが評価されるごとに実行されます。
コマンドのステータス値は C<$?> に返されます (C<$?> の解釈については、
L<perlvar> を参照してください)。
B<csh> での場合とは違って、結果のデータに対する変換は行なわれず、
改行は改行のままです。
どのシェルとも違って、シングルクォートがコマンド中の変数名を
解釈させないようにすることはありません。
シェルにリテラルなドル記号を渡すには、バックスラッシュで
エスケープしなければなりません。
バッククォートの一般形は、C<qx//> か、
L<perlfunc/readpipe> 関数を呼び出せます。
(バッククォートは常にシェル展開されます;
セキュリティに関しては L<perlsec> を参照して下さい。)

=begin original

In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
C<undef> at end-of-file or on error.  When C<$/> is set to C<undef>
(sometimes known as file-slurp mode) and the file is empty, it
returns C<''> the first time, followed by C<undef> subsequently.

=end original

スカラーコンテキストで山括弧の中のファイルハンドルを評価すると、
そのファイルから、次の行を読み込むことになります
(改行があればそれも含まれます); ファイルの最後またはエラーの場合は
C<undef> を返します。
C<$/> が C<undef> に設定されている場合(ファイル吸い込みモードと呼ばれます)
でファイルが空の場合、
最初は C<''> を返し、次は C<undef> を返します。

=begin original

Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.  If
and only if the input symbol is the only thing inside the conditional
of a C<while> statement (even if disguised as a C<for(;;)> loop),
the value is automatically assigned to the global variable C<$_>,
destroying whatever was there previously.  (This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The C<$_> variable is not implicitly localized.
You'll have to put a S<C<local $_;>> before the loop if you want that
to happen.  Furthermore, if the input symbol or an explicit assignment
of the input symbol to a scalar is used as a C<while>/C<for> condition,
then the condition actually tests for definedness of the expression's
value, not for its regular truth value.

=end original

通常は、返された値を変数に代入しなければなりませんが、自動的に
代入される場合が 1 つだけあります。
この入力シンボルが、while 文(C<for(;;)> の形になっていたとしても)の条件式中に
単独で現れた場合だけは、その値が自動的にグローバル変数 C<$_> に代入されます;
以前の値は破壊されます。
(これは、奇妙に思えるかもしれませんが、ほとんどすべての Perl スクリプトで
これが必要になることでしょう。)
C<$_> 変数は暗黙にはローカル化されません。
そうしたい場合はループの前に S<C<local $_;>> と書く必要があります。
さらに、入力シンボルまたは入力シンボルからスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

=begin original

Thus the following lines are equivalent:

=end original

従って、以下のものは互いに同値なものです:

    while (defined($_ = <STDIN>)) { print; }
    while ($_ = <STDIN>) { print; }
    while (<STDIN>) { print; }
    for (;<STDIN>;) { print; }
    print while defined($_ = <STDIN>);
    print while ($_ = <STDIN>);
    print while <STDIN>;

=begin original

This also behaves similarly, but assigns to a lexical variable
instead of to C<$_>:

=end original

以下は同様の振る舞いをしますが、C<$_> おｎ代わりにレキシカル変数に
代入します:

    while (my $line = <STDIN>) { print $line }

=begin original

In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.  The defined test avoids problems where the line has a string
value that would be treated as false by Perl; for example a "" or
a C<"0"> with no trailing newline.  If you really mean for such values
to terminate the loop, they should be tested for explicitly:

=end original

これらのループ構造の中で、代入された値は (代入が自動か明示的かに関わりなく)
定義されているかどうかを見るためにテストされます。
定義テストは、行が Perl にとって偽となる文字列値を持っているかどうかの
問題を避けます; 例えば newline のついていない "" や C<"0"> です。
もし本当にこのような値でループを終了させたいときは、
以下のように明示的にテストするべきです:

    while (($_ = <STDIN>) ne '0') { ... }
    while (<STDIN>) { last unless $_; ... }

=begin original

In other boolean contexts, C<< <I<FILEHANDLE>> >> without an
explicit C<defined> test or comparison elicits a warning if the
S<C<use warnings>> pragma or the B<-w>
command-line switch (the C<$^W> variable) is in effect.

=end original

その他の真偽値コンテキストでは、明示的な C<defined> や比較なしに
C<< <I<FILEHANDLE>> >> を使うと、S<C<use warnings>> プラグマや
B<-w> コマンドラインスイッチ (C<$^W> 変数) が有効なときには、
警告を発生させます。

=begin original

The filehandles STDIN, STDOUT, and STDERR are predefined.  (The
filehandles C<stdin>, C<stdout>, and C<stderr> will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the C<open()> function, amongst others.  See L<perlopentut> and
L<perlfunc/open> for details on this.
X<stdin> X<stdout> X<sterr>

=end original

STDIN、STDOUT、STDERR というファイルハンドルは、あらかじめ定義されています。
(C<stdin>、C<stdout>、C<stderr> というファイルハンドルも、
ローカルな名前でこれらのグローバルな名前が見えなくなっている
パッケージを除けば、使用することができます。)
その他のファイルハンドルは、C<open()> 関数などで作ることができます。
これに関する詳細については L<perlopentut> と L<perlfunc/open> を
参照して下さい。
X<stdin> X<stdout> X<sterr>

=begin original

If a C<< <I<FILEHANDLE>> >> is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.  It's easy to grow to a rather large data space this
way, so use with care.

=end original

C<< <I<FILEHANDLE>> >> がリストを必要とするコンテキストで用いられると、
1 要素に 1 行の入力行すべてからなるリストが返されます。
これを使うと簡単にかなり大きなデータになってしまいますので、
注意を要します。

=begin original

C<< <I<FILEHANDLE>> >>  may also be spelled C<readline(*I<FILEHANDLE>)>.
See L<perlfunc/readline>.

=end original

C<< <I<FILEHANDLE>> >> は C<readline(*I<FILEHANDLE>)> とも書けます。
L<perlfunc/readline> を参照して下さい。

=begin original

The null filehandle C<< <> >> (sometimes called the diamond operator) is
special: it can be used to emulate the
behavior of B<sed> and B<awk>, and any other Unix filter program
that takes a list of filenames, doing the same to each line
of input from all of them.  Input from C<< <> >> comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time C<< <> >> is evaluated, the C<@ARGV> array is
checked, and if it is empty, C<$ARGV[0]> is set to C<"-">, which when opened
gives you standard input.  The C<@ARGV> array is then processed as a list
of filenames.  The loop

=end original

ヌルファイルハンドル C<< <> >> (時々ダイヤモンド演算子と呼ばれます) は特別で、
B<sed> や B<awk> および、ファイル名のリストを取って、
それら全てからの入力の各行に同じことをするような
その他の Unix フィルタプログラムをエミュレートするために使われます。
C<< <> >> からの入力は、標準入力からか、コマンドライン上に並べられた個々の
ファイルから行なわれます。
動作の概要は、以下のようになります: 最初に C<< <> >> が評価されると、配列
C<@ARGV> が調べられ、空であれば、C<$ARGV[0]> に C<"-"> を設定します。
これは、open されるとき標準入力となります。
その後、配列 C<@ARGV> がファイル名のリストとして処理されます。

    while (<>) {
        ...                     # code for each line
    }

=begin original

is equivalent to the following Perl-like pseudo code:

=end original

は以下ののような Perl の擬似コードと等価です:

    unshift(@ARGV, '-') unless @ARGV;
    while ($ARGV = shift) {
        open(ARGV, $ARGV);
        while (<ARGV>) {
            ...         # code for each line
        }
    }

=begin original

except that it isn't so cumbersome to say, and will actually work.
It really does shift the C<@ARGV> array and put the current filename
into the C<$ARGV> variable.  It also uses filehandle I<ARGV>
internally.  C<< <> >> is just a synonym for C<< <ARGV> >>, which
is magical.  (The pseudo code above doesn't work because it treats
C<< <ARGV> >> as non-magical.)

=end original

但し、わずらわしく書かなくても、動作します。
実際に C<@ARGV> を shift しますし、その時点のファイル名を変数 C<$ARGV> に
入れています。
また、内部的にファイルハンドル I<ARGV> を使っています。
C<< <> >> は C<< <ARGV> >> の同義語で、マジカルです。
(上記の擬似コードは、C<< <ARGV> >> をマジカルではないものとして
扱っているので、うまく動作しません。)

=begin original

Since the null filehandle uses the two argument form of L<perlfunc/open>
it interprets special characters, so if you have a script like this:

=end original

空ファイルハンドルは 2 引数の L<perlfunc/open> を使った特別な文字列なので、
もし以下のようなスクリプトを書いて:

    while (<>) {
        print;
    }

=begin original

and call it with S<C<perl dangerous.pl 'rm -rfv *|'>>, it actually opens a
pipe, executes the C<rm> command and reads C<rm>'s output from that pipe.
If you want all items in C<@ARGV> to be interpreted as file names, you
can use the module C<ARGV::readonly> from CPAN, or use the double
diamond operator:

=end original

これを S<C<perl dangerous.pl 'rm -rfv *|'>> として呼び出すと、実際には
パイプを開き、C<rm> コマンドを実行して、 C<rm> の出力をパイプから読みます。
もし C<@ARGV> の全ての要素をファイル名として解釈させたいなら、
CPAN にある C<ARGV::readonly> モジュールか、二重ダイヤモンド演算子が
使えます。

    while (<<>>) {
        print;
    }

=begin original

Using double angle brackets inside of a while causes the open to use the
three argument form (with the second argument being C<< < >>), so all
arguments in C<ARGV> are treated as literal filenames (including C<"-">).
(Note that for convenience, if you use C<< <<>> >> and if C<@ARGV> is
empty, it will still read from the standard input.)

=end original

while の中で二重角かっこを使うと、
3 引数型式 (かつ 2 番目の引数が C<< < >> の) open を引き起こすので、
C<ARGV> の全ての引数は (C<"-"> を含めて) リテラル名ファイル名として
扱われます。
(便宜のため、C<< <<>> >> を使って C<@ARGV> が空の場合、標準入力から
読み込みます。)

=begin original

You can modify C<@ARGV> before the first C<< <> >> as long as the array ends up
containing the list of filenames you really want.  Line numbers (C<$.>)
continue as though the input were one big happy file.  See the example
in L<perlfunc/eof> for how to reset line numbers on each file.

=end original

最終的に、C<@ARGV> に扱いたいと思っているファイル名が含まれるのであれば、
最初に C<< <> >> を評価する前に C<@ARGV> を変更することも可能です。
行番号 (C<$.>) は、入力ファイルがあたかも 1 つの大きなファイルで
あるかのように、続けてカウントされます。
個々のファイルごとにリセットする方法は、L<perlfunc/eof> の例を
参照してください。

=begin original

If you want to set C<@ARGV> to your own list of files, go right ahead.
This sets C<@ARGV> to all plain text files if no C<@ARGV> was given:

=end original

最初から C<@ARGV> に自分でファイルのリストを設定してもかまいません。
以下は C<@ARGV> が与えられなかったときに全てのテキストファイルを
C<@ARGV> に設定します。

    @ARGV = grep { -f && -T } glob('*') unless @ARGV;

=begin original

You can even set them to pipe commands.  For example, this automatically
filters compressed arguments through B<gzip>:

=end original

ここにパイプコマンドを置くことも出来ます。
例えば、以下は圧縮された引数を自動的に B<gzip> のフィルタに通します:

    @ARGV = map { /\.(gz|Z)$/ ? "gzip -dc < $_ |" : $_ } @ARGV;

=begin original

If you want to pass switches into your script, you can use one of the
C<Getopts> modules or put a loop on the front like this:

=end original

スクリプトにスイッチを渡したいのであれば、C<Getopts> モジュールを
使うこともできますし、実際の処理の前にのようなループを置くこともできます。

    while ($_ = $ARGV[0], /^-/) {
        shift;
        last if /^--$/;
        if (/^-D(.*)/) { $debug = $1 }
        if (/^-v/)     { $verbose++  }
        # ...           # other switches
    }

    while (<>) {
        # ...           # code for each line
    }

=begin original

The C<< <> >> symbol will return C<undef> for end-of-file only once.
If you call it again after this, it will assume you are processing another
C<@ARGV> list, and if you haven't set C<@ARGV>, will read input from STDIN.

=end original

シンボル C<< <> >> がファイルの最後で C<undef> を返すのは一度きりです。
そのあとでもう一度呼び出すと、新たに別の C<@ARGV> を処理するものとみなされ、
その時に C<@ARGV> を設定しなおしていないと、STDIN からの入力を
読み込むことになります。

=begin original

If what the angle brackets contain is a simple scalar variable (for example,
C<$foo>), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.  For example:

=end original

山括弧の中の文字列が (C<$foo> のような) 単純スカラ変数であれば、
その変数が入力を行なうファイルハンドルの名前そのもの、名前への型グロブ、
名前へのリファレンスのいずれかを示しているとみなされます。
例えば:

    $fh = \*STDIN;
    $line = <$fh>;

=begin original

If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic
grounds alone.  That means C<< <$x> >> is always a C<readline()> from
an indirect handle, but C<< <$hash{key}> >> is always a C<glob()>.
That's because C<$x> is a simple scalar variable, but C<$hash{key}> is
not--it's a hash element.  Even C<< <$x > >> (note the extra space)
is treated as C<glob("$x ")>, not C<readline($x)>.

=end original

山括弧の中の文字列がファイルハンドルでもファイルハンドル名、型グロブ、
型グロブリファレンスのいずれかが入った単純スカラ変数でもなければ、
グロブを行なうファイル名のパターンと解釈され、コンテキストによって
ファイル名のリストか、そのリストの次のファイル名が返されます。
この区別は単に構文的に行われます。
C<< <$x> >> は常に間接ハンドルから C<readline()> しますが、
C<< <$hash{key}> >> は常に C<glob()> します。
C<$x> は単純スカラー変数ですが、C<$hash{key}> は違う(ハッシュ要素)からです。
C<< <$x > >> (余分な空白に注意) ですら C<readline($x)> ではなく
C<glob("$x ")> として扱われます。

=begin original

One level of double-quote interpretation is done first, but you can't
say C<< <$foo> >> because that's an indirect filehandle as explained
in the previous paragraph.  (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
C<< <${foo}> >>.  These days, it's considered cleaner to call the
internal function directly as C<glob($foo)>, which is probably the right
way to have done it in the first place.)  For example:

=end original

まず、1 段階だけダブルクォート展開が行なわれますが、前の段落に書いた
間接ファイルハンドルと同じになる、C<< <$foo> >> のようには書けません。
(Perl の古いバージョンでは、ファイル名グロブと解釈させるために
C<< <${foo}> >> のように中括弧を入れていました。
最近ではより明確にするために、C<glob($foo)> と内部関数を呼ぶことも
できます; おそらく、まず、こちらの方で試すのが正解でしょう。)
例えば:

    while (<*.c>) {
        chmod 0644, $_;
    }

=begin original

is roughly equivalent to:

=end original

はだいたい以下と等価です:

    open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
    while (<FOO>) {
        chomp;
        chmod 0644, $_;
    }

=begin original

except that the globbing is actually done internally using the standard
C<L<File::Glob>> extension.  Of course, the shortest way to do the above is:

=end original

但し実際のグロブは内部的に標準の C<L<File::Glob>> モジュールを使います。
もちろん、もっと簡単に以下のように書けます:

    chmod 0644, <*.c>;

=begin original

A (file)glob evaluates its (embedded) argument only when it is
starting a new list.  All values must be read before it will start
over.  In list context, this isn't important because you automatically
get them all anyway.  However, in scalar context the operator returns
the next value each time it's called, or C<undef> when the list has
run out.  As with filehandle reads, an automatic C<defined> is
generated when the glob occurs in the test part of a C<while>,
because legal glob returns (for example,
a file called F<0>) would otherwise
terminate the loop.  Again, C<undef> is returned only once.  So if
you're expecting a single value from a glob, it is much better to
say

=end original

(ファイル)グロブは新しいリストを開始するときにだけ(組み込みの)引数を
評価します。
全ての値は開始する前に読み込んでいなければなりません。
これはリストコンテキストでは、とにかく自動的に全てを取り込むので
重要ではありません。
しかし、スカラコンテキストではこの演算子は呼び出された時の
次の値か、リストがなくなったときには C<undef> を返します。
ファイルハンドルを読み込む場合は、グロブが C<while> の条件部にある場合は
自動的な C<defined> が生成されます;
なぜならそうしないと、本来の glob の返り値 (例えば、F<0> というファイル) が
ループを終了させるからです。
ここでも、C<undef> は一度だけ返されます。
従って、もしグロブから一つの値だけを想定している場合、
以下のように書くことが:

    ($file) = <blurch*>;

=begin original

than

=end original

以下のように書くよりはるかに良いです:

    $file = <blurch*>;

=begin original

because the latter will alternate between returning a filename and
returning false.

=end original

なぜなら後者はファイル名を返す場合と偽を返す場合があるからです。

=begin original

If you're trying to do variable interpolation, it's definitely better
to use the C<glob()> function, because the older notation can cause people
to become confused with the indirect filehandle notation.

=end original

変数変換に挑戦する場合、明らかに C<glob()> 関数を使う方が良いです;
なぜなら古い表記は間接ファイルハンドル表記と混乱するかも知れないからです。

    @files = glob("$dir/*.[ch]");
    @files = glob($files[$i]);

=begin original

If an angle-bracket-based globbing expression is used as the condition of
a C<while> or C<for> loop, then it will be implicitly assigned to C<$_>.
If either a globbing expression or an explicit assignment of a globbing
expression to a scalar is used as a C<while>/C<for> condition, then
the condition actually tests for definedness of the expression's value,
not for its regular truth value.

=end original

角かっこグロブ式が C<while> や C<for> ループの条件として使われた場合、
これは暗黙に C<$_> に代入されます。
さらに、グロブ式またはグロブ式からスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

=head2 Constant Folding
X<constant folding> X<folding>

(定数の畳み込み)

=begin original

Like C, Perl does a certain amount of expression evaluation at
compile time whenever it determines that all arguments to an
operator are static and have no side effects.  In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.  Backslash interpolation also happens at
compile time.  You can say

=end original

C と同じように Perl でも、演算子に対するすべての引数がスタティックで、
副作用がないと判断できれば、コンパイル時に式の評価を行なってしまいます。
特に、変数置換の無いリテラルどうしの文字列連結はコンパイル時に行なわれます。
バックスラッシュの解釈もコンパイル時に行なわれます。
以下のように書けて、

      'Now is the time for all'
    . "\n"
    .  'good men to come to.'

=begin original

and this all reduces to one string internally.  Likewise, if
you say

=end original

内部的に 1 つの文字列になります。同様に

    foreach $file (@filenames) {
        if (-s $file > 5 + 100 * 2**16) {  }
    }

=begin original

the compiler precomputes the number which that expression
represents so that the interpreter won't have to.

=end original

と書くとコンパイラは、式が表わす数値をあらかじめ計算しますので、
インタプリタで計算する必要がなくなっています。

=head2 No-ops
X<no-op> X<nop>

(無実行)

=begin original

Perl doesn't officially have a no-op operator, but the bare constants
C<0> and C<1> are special-cased not to produce a warning in void
context, so you can for example safely do

=end original

Perl は公式には無実行演算子はありませんが、裸の定数 C<0> と C<1> は
特別に無効コンテキストでも警告を出さないことになっているので、
例えば安全に以下のように書けます:

    1 while foo();

=head2 Bitwise String Operators
X<operator, bitwise, string> X<&.> X<|.> X<^.> X<~.>

(ビット列演算子)

=begin original

Bitstrings of any size may be manipulated by the bitwise operators
(C<~ | & ^>).

=end original

任意のサイズのビット列はビット単位演算子(C<~ | & ^>)で操作できます。

=begin original

If the operands to a binary bitwise op are strings of different
sizes, B<|> and B<^> ops act as though the shorter operand had
additional zero bits on the right, while the B<&> op acts as though
the longer operand was truncated to the length of the shorter.
The granularity for such extension or truncation is one or more
bytes.

=end original

二項ビット単位演算子のオペランドが異なった長さの文字列だった場合、
B<|> と B<^> の演算子は短い側のオペランドの右側に追加のゼロが
ついているとみなします; 一方 B<&> 演算子は長い方のオペランドが短い方に
切り詰められます。
この拡張や短縮の粒度はバイト単位です。

    # ASCII-based examples
    print "j p \n" ^ " a h";            # prints "JAPH\n"
    print "JA" | "  ph\n";              # prints "japh\n"
    print "japh\nJunk" & '_____';       # prints "JAPH\n";
    print 'p N$' ^ " E<H\n";            # prints "Perl\n";

=begin original

If you are intending to manipulate bitstrings, be certain that
you're supplying bitstrings: If an operand is a number, that will imply
a B<numeric> bitwise operation.  You may explicitly show which type of
operation you intend by using C<""> or C<0+>, as in the examples below.

=end original

ビット列を操作したい場合は、確実にビット列が渡されるようにしてください:
オペランドが数字の場合、B<数値> ビット単位演算を仮定します。
明示的に演算の型を指定するときには、以下の例のように
C<""> か C<0+> を使ってください。

=begin original

    $foo =  150  |  105;        # yields 255  (0x96 | 0x69 is 0xFF)
    $foo = '150' |  105;        # yields 255
    $foo =  150  | '105';       # yields 255
    $foo = '150' | '105';       # yields string '155' (under ASCII)

=end original

    $foo =  150  |  105;        # 255 になる (0x96 | 0x69 は 0xFF)
    $foo = '150' |  105;        # 255 になる
    $foo =  150  | '105';       # 255 になる
    $foo = '150' | '105';       # (ASCII では) 文字列 '155' になる

=begin original

    $baz = 0+$foo & 0+$bar;     # both ops explicitly numeric
    $biz = "$foo" ^ "$bar";     # both ops explicitly stringy

=end original

    $baz = 0+$foo & 0+$bar;     # どちらのオペランドも明示的に数値
    $biz = "$foo" ^ "$bar";     # どちらのオペランドも明示的に文字列

=begin original

This somewhat unpredictable behavior can be avoided with the "bitwise"
feature, new in Perl 5.22.  You can enable it via S<C<use feature
'bitwise'>> or C<use v5.28>.  Before Perl 5.28, it used to emit a warning
in the C<"experimental::bitwise"> category.  Under this feature, the four
standard bitwise operators (C<~ | & ^>) are always numeric.  Adding a dot
after each operator (C<~. |. &. ^.>) forces it to treat its operands as
strings:

=end original

この、いくらか予測の難しい振る舞いは、Perl 5.22 で導入された
"bitwise" 機能で避けることができます。
これは S<C<use feature 'bitwise'>> か C<use v5.28> で有効にできます。
Perl 5.28 より前では、これは C<"experimental::bitwise"> カテゴリの警告を
出力していました。
この機能の基では、四つのビット単位演算子 (C<~ | & ^>) は常に数値です。
それぞれの演算子の後にピリオドを付ける (C<~. |. &. ^.>) ことで、
そのオペランドを文字列として扱うことを強制します:

    use feature "bitwise";
    $foo =  150  |  105;        # yields 255  (0x96 | 0x69 is 0xFF)
    $foo = '150' |  105;        # yields 255
    $foo =  150  | '105';       # yields 255
    $foo = '150' | '105';       # yields 255
    $foo =  150  |. 105;        # yields string '155'
    $foo = '150' |. 105;        # yields string '155'
    $foo =  150  |.'105';       # yields string '155'
    $foo = '150' |.'105';       # yields string '155'

    $baz = $foo &  $bar;        # both operands numeric
    $biz = $foo ^. $bar;        # both operands stringy

=begin original

The assignment variants of these operators (C<&= |= ^= &.= |.= ^.=>)
behave likewise under the feature.

=end original

この機能の基では、これらの演算子の亜種 (C<&= |= ^= &.= |.= ^.=>) も
同様に振る舞います。

=begin original

It is a fatal error if an operand contains a character whose ordinal
value is above 0xFF, and hence not expressible except in UTF-8.  The
operation is performed on a non-UTF-8 copy for other operands encoded in
UTF-8.  See L<perlunicode/Byte and Character Semantics>.

=end original

値が 0xFF 以上で、UTF-8 以外で表現できない文字がオペランドに含まれている
場合、これは致命的エラーになります。
他の UTF-8 でエンコードされたオペランドに対して
非 UTF-8 のコピーに対して操作が行われます。
L<perlunicode/Byte and Character Semantics> を参照してください。

=begin original

See L<perlfunc/vec> for information on how to manipulate individual bits
in a bit vector.

=end original

ビットベクタの個々のビットをどのように操作するかの情報については
L<perlfunc/vec> を参照して下さい。

=head2 Integer Arithmetic
X<integer>

(整数演算)

=begin original

By default, Perl assumes that it must do most of its arithmetic in
floating point.  But by saying

=end original

デフォルトでは、Perl は演算を浮動小数で行なわなければならないものと
しています。
しかし、(もしそうしたいなら)

    use integer;

=begin original

you may tell the compiler to use integer operations
(see L<integer> for a detailed explanation) from here to the end of
the enclosing BLOCK.  An inner BLOCK may countermand this by saying

=end original

と書けば、その場所から現在の BLOCK の終わりまでは、整数演算
(詳しい説明は L<integer> を参照してください) を
行なってよいと、コンパイラに指示することができます。
内部の BLOCK で、

    no integer;

=begin original

which lasts until the end of that BLOCK.  Note that this doesn't
mean everything is an integer, merely that Perl will use integer
operations for arithmetic, comparison, and bitwise operators.  For
example, even under S<C<use integer>>, if you take the C<sqrt(2)>, you'll
still get C<1.4142135623731> or so.

=end original

と書けば、その BLOCK の終わりまでは、指示を取り消すことになります。
これは全てを整数だけを使って処理することを意味するわけではなく、
単に Perl が算術、比較、ビット単位演算子で整数演算を
するというだけであることに注意してください。
例えば、S<C<use integer>> の指定があっても、C<sqrt(2)> とすると、
C<1.4142135623731> といった結果が返ってきます。

=begin original

Used on numbers, the bitwise operators (C<&> C<|> C<^> C<~> C<< << >>
C<< >> >>) always produce integral results.  (But see also
L</Bitwise String Operators>.)  However, S<C<use integer>> still has meaning for
them.  By default, their results are interpreted as unsigned integers, but
if S<C<use integer>> is in effect, their results are interpreted
as signed integers.  For example, C<~0> usually evaluates to a large
integral value.  However, S<C<use integer; ~0>> is C<-1> on two's-complement
machines.

=end original

数値を使う場合、ビット単位演算子 (C<&> C<|> C<^> C<~> C<< << >> C<< >> >>) は
常に整数の結果を生成します。
(但し L</Bitwise String Operators> も参照して下さい。)
しかし、それでも S<C<use integer>> は意味があります。
デフォルトでは、これらの結果は符号なし整数として解釈されますが、
S<C<use integer>> が有効の場合は、符号付き整数として解釈されます。
例えば、C<~0> は通常大きな整数の値として評価されます。
しかし、S<C<use integer; ~0>> は 2 の補数のマシンでは C<-1> になります。

=head2 Floating-point Arithmetic

(浮動小数点数演算)

=begin original

X<floating-point> X<floating point> X<float> X<real>

=end original

X<floating-point> X<floating point> X<float> X<real>
(TBT)

=begin original

While S<C<use integer>> provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.  For rounding to a certain number
of digits, C<sprintf()> or C<printf()> is usually the easiest route.
See L<perlfaq4>.

=end original

S<C<use integer>> が整数演算を提供する一方、数を特定の桁で自動的に丸めたり
切り捨てたりする機構はありません。
数を丸めるには、C<sprintf()> や C<printf()> を使うのが一番簡単な方法です。
L<perlfaq4> を参照して下さい。

=begin original

Floating-point numbers are only approximations to what a mathematician
would call real numbers.  There are infinitely more reals than floats,
so some corners must be cut.  For example:

=end original

浮動小数点数は数学者が実数と呼ぶものの近似でしかありません。
実数は浮動小数点より無限に続くので、多少角が丸められます。
例えば:

    printf "%.20g\n", 123456789123456789;
    #        produces 123456789123456784

=begin original

Testing for exact floating-point equality or inequality is not a
good idea.  Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.  See Knuth, volume II, for a more robust treatment of
this topic.

=end original

浮動小数点数が等しいかどうかをちょうど同じかどうかで比較するのはよい
考えではありません。
以下に、二つの浮動小数点数が指定された桁まで等しいかどうかを
比較する(比較的重い)次善の策を示します。
この問題に関するより厳密な扱いについては Knuth, volume II を参照して下さい。

    sub fp_equal {
        my ($X, $Y, $POINTS) = @_;
        my ($tX, $tY);
        $tX = sprintf("%.${POINTS}g", $X);
        $tY = sprintf("%.${POINTS}g", $Y);
        return $tX eq $tY;
    }

=begin original

The POSIX module (part of the standard perl distribution) implements
C<ceil()>, C<floor()>, and other mathematical and trigonometric functions.
The C<L<Math::Complex>> module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.  C<Math::Complex> is not as efficient as POSIX, but
POSIX can't work with complex numbers.

=end original

POSIX モジュール(Perl 標準配布パッケージの一部) は C<ceil()>, C<floor()> 及び
その他の数学関数や三角関数を実装しています。
C<L<Math::Complex>> モジュール(Perl 標準配布パッケージの一部)は実数と虚数の
両方で動作する数学関数を定義しています。
C<Math::Complex> は POSIX ほど効率的ではありませんが、POSIX は複素数は
扱えません。

=begin original

Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

=end original

金融アプリケーションにおける丸めは深刻な影響を与える可能性があり、
使用する丸めメソッドは指定された精度で行われるべきです。
このような場合、Perl が使用するシステム丸めを信用せず、
代わりに自分自身で丸め関数を実装するべきです。

=head2 Bigger Numbers
X<number, arbitrary precision>

(より大きな数)

=begin original

The standard C<L<Math::BigInt>>, C<L<Math::BigRat>>, and
C<L<Math::BigFloat>> modules,
along with the C<bignum>, C<bigint>, and C<bigrat> pragmas, provide
variable-precision arithmetic and overloaded operators, although
they're currently pretty slow.  At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.

=end original

標準の C<L<Math::BigInt>>, C<L<Math::BigRat>>,
C<L<Math::BigFloat>> モジュールと
C<bignum>, C<bigint>, C<bigrat> プラグマは多倍長演算を提供し、
演算子をオーバーロードしますが、これらは現在のところかなり遅いです。
多少の領域とかなりの速度を犠牲にして、桁数が制限されていることによる
ありがちな落とし穴を避けることができます。

    use 5.010;
    use bigint;  # easy interface to Math::BigInt
    $x = 123456789123456789;
    say $x * $x;
    +15241578780673678515622620750190521

=begin original

Or with rationals:

=end original

あるいは分数を使って:

    use 5.010;
    use bigrat;
    $x = 3/22;
    $y = 4/6;
    say "x/y is ", $x/$y;
    say "x*y is ", $x*$y;
    x/y is 9/44
    x*y is 1/11

=begin original

Several modules let you calculate with unlimited or fixed precision
(bound only by memory and CPU time).  There
are also some non-standard modules that
provide faster implementations via external C libraries.

=end original

(メモリと CPU 時間のみに依存する)無制限か固定の精度での計算ができる
モジュールがいくつかあります。
さらに外部 C ライブラリを使ってより速い実装を提供する
非標準のモジュールもあります。

=begin original

Here is a short, but incomplete summary:

=end original

以下は短いですが不完全なリストです。

=begin original

    Math::String           treat string sequences like numbers
    Math::FixedPrecision   calculate with a fixed precision
    Math::Currency         for currency calculations
    Bit::Vector            manipulate bit vectors fast (uses C)
    Math::BigIntFast       Bit::Vector wrapper for big numbers
    Math::Pari             provides access to the Pari C library
    Math::Cephes           uses the external Cephes C library (no
                           big numbers)
    Math::Cephes::Fraction fractions via the Cephes library
    Math::GMP              another one using an external C library
    Math::GMPz             an alternative interface to libgmp's big ints
    Math::GMPq             an interface to libgmp's fraction numbers
    Math::GMPf             an interface to libgmp's floating point numbers

=end original

    Math::String           文字列を数値のように扱う
    Math::FixedPrecision   固定精度で計算する
    Math::Currency         通貨の計算用
    Bit::Vector            (C を使って)ビットベクタを速く操作する
    Math::BigIntFast       大きな数のための Bit::Vector のラッパー
    Math::Pari             Pari C ライブラリへのアクセスを提供する
    Math::Cephes           外部の Cephes C を使う(大きな数はなし)
    Math::Cephes::Fraction Cephes ライブラリを使った分数
    Math::GMP              これも外部 C ライブラリを使う
    Math::GMPz             libgmp の大きな整数へのもう一つのインターフェース
    Math::GMPq             libgmp の分数へのインターフェース
    Math::GMPf             libgmp の浮動小数点のインターフェース

=begin original

Choose wisely.

=end original

うまく選んでください。

=head2 C-style Logical Or

(C スタイルの論理和)

=begin original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.

=end original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.
(TBT)

=head2 C-style Logical Xor

(C スタイルの排他的論理和)

=begin original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.

=end original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.
(TBT)

=head2 Logical Defined-Or

(論理定義性和)

=begin original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.

=end original

This section has been superceded by
L</C-style Logical Or, Xor, and Defined Or>.  The heading is retained
only to prevent breaking any pre-existing links to it from outside.
(TBT)

=head2 Quote-Like Operators

(クォート風演算子)

=begin original

This section has been replaced by L</Simpler Quote-Like Operators>

=end original

This section has been replaced by L</Simpler Quote-Like Operators>
(TBT)

=head2 Indented Here-docs

=begin original

This section has been merged into L</Here-docs>

=end original

This section has been merged into L</Here-docs>
(TBT)

=head1 APPENDIX

=head2 List of Extra Paired Delimiters

=begin original

The complete list of accepted paired delimiters as of Unicode 16.0 is:

=end original

Unicode 16.0 の時点で組の区切り文字として受け入れられるものの一覧です:

 (  )    U+0028, U+0029   LEFT/RIGHT PARENTHESIS
 <  >    U+003C, U+003E   LESS-THAN/GREATER-THAN SIGN
 [  ]    U+005B, U+005D   LEFT/RIGHT SQUARE BRACKET
 {  }    U+007B, U+007D   LEFT/RIGHT CURLY BRACKET
 «  »    U+00AB, U+00BB   LEFT/RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
 »  «    U+00BB, U+00AB   RIGHT/LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
 ༺  ༻    U+0F3A, U+0F3B   TIBETAN MARK GUG RTAGS GYON,  TIBETAN MARK GUG
                          RTAGS GYAS
 ༼  ༽    U+0F3C, U+0F3D   TIBETAN MARK ANG KHANG GYON,  TIBETAN MARK ANG
                          KHANG GYAS
 ᚛  ᚜    U+169B, U+169C   OGHAM FEATHER MARK,  OGHAM REVERSED FEATHER MARK
 ‘  ’    U+2018, U+2019   LEFT/RIGHT SINGLE QUOTATION MARK
 ’  ‘    U+2019, U+2018   RIGHT/LEFT SINGLE QUOTATION MARK
 “  ”    U+201C, U+201D   LEFT/RIGHT DOUBLE QUOTATION MARK
 ”  “    U+201D, U+201C   RIGHT/LEFT DOUBLE QUOTATION MARK
 ‵  ′    U+2035, U+2032   REVERSED PRIME,  PRIME
 ‶  ″    U+2036, U+2033   REVERSED DOUBLE PRIME,  DOUBLE PRIME
 ‷  ‴    U+2037, U+2034   REVERSED TRIPLE PRIME,  TRIPLE PRIME
 ‹  ›    U+2039, U+203A   SINGLE LEFT/RIGHT-POINTING ANGLE QUOTATION MARK
 ›  ‹    U+203A, U+2039   SINGLE RIGHT/LEFT-POINTING ANGLE QUOTATION MARK
 ⁅  ⁆    U+2045, U+2046   LEFT/RIGHT SQUARE BRACKET WITH QUILL
 ⁍  ⁌    U+204D, U+204C   BLACK RIGHT/LEFTWARDS BULLET
 ⁽  ⁾    U+207D, U+207E   SUPERSCRIPT LEFT/RIGHT PARENTHESIS
 ₍  ₎    U+208D, U+208E   SUBSCRIPT LEFT/RIGHT PARENTHESIS
 →  ←    U+2192, U+2190   RIGHT/LEFTWARDS ARROW
 ↛  ↚    U+219B, U+219A   RIGHT/LEFTWARDS ARROW WITH STROKE
 ↝  ↜    U+219D, U+219C   RIGHT/LEFTWARDS WAVE ARROW
 ↠  ↞    U+21A0, U+219E   RIGHT/LEFTWARDS TWO HEADED ARROW
 ↣  ↢    U+21A3, U+21A2   RIGHT/LEFTWARDS ARROW WITH TAIL
 ↦  ↤    U+21A6, U+21A4   RIGHT/LEFTWARDS ARROW FROM BAR
 ↪  ↩    U+21AA, U+21A9   RIGHT/LEFTWARDS ARROW WITH HOOK
 ↬  ↫    U+21AC, U+21AB   RIGHT/LEFTWARDS ARROW WITH LOOP
 ↱  ↰    U+21B1, U+21B0   UPWARDS ARROW WITH TIP RIGHT/LEFTWARDS
 ↳  ↲    U+21B3, U+21B2   DOWNWARDS ARROW WITH TIP RIGHT/LEFTWARDS
 ⇀  ↼    U+21C0, U+21BC   RIGHT/LEFTWARDS HARPOON WITH BARB UPWARDS
 ⇁  ↽    U+21C1, U+21BD   RIGHT/LEFTWARDS HARPOON WITH BARB DOWNWARDS
 ⇉  ⇇    U+21C9, U+21C7   RIGHT/LEFTWARDS PAIRED ARROWS
 ⇏  ⇍    U+21CF, U+21CD   RIGHT/LEFTWARDS DOUBLE ARROW WITH STROKE
 ⇒  ⇐    U+21D2, U+21D0   RIGHT/LEFTWARDS DOUBLE ARROW
 ⇛  ⇚    U+21DB, U+21DA   RIGHT/LEFTWARDS TRIPLE ARROW
 ⇝  ⇜    U+21DD, U+21DC   RIGHT/LEFTWARDS SQUIGGLE ARROW
 ⇢  ⇠    U+21E2, U+21E0   RIGHT/LEFTWARDS DASHED ARROW
 ⇥  ⇤    U+21E5, U+21E4   RIGHT/LEFTWARDS ARROW TO BAR
 ⇨  ⇦    U+21E8, U+21E6   RIGHT/LEFTWARDS WHITE ARROW
 ⇴  ⬰    U+21F4, U+2B30   RIGHT/LEFT ARROW WITH SMALL CIRCLE
 ⇶  ⬱    U+21F6, U+2B31   THREE RIGHT/LEFTWARDS ARROWS
 ⇸  ⇷    U+21F8, U+21F7   RIGHT/LEFTWARDS ARROW WITH VERTICAL STROKE
 ⇻  ⇺    U+21FB, U+21FA   RIGHT/LEFTWARDS ARROW WITH DOUBLE VERTICAL
                          STROKE
 ⇾  ⇽    U+21FE, U+21FD   RIGHT/LEFTWARDS OPEN-HEADED ARROW
 ∈  ∋    U+2208, U+220B   ELEMENT OF,  CONTAINS AS MEMBER
 ∉  ∌    U+2209, U+220C   NOT AN ELEMENT OF,  DOES NOT CONTAIN AS MEMBER
 ∊  ∍    U+220A, U+220D   SMALL ELEMENT OF,  SMALL CONTAINS AS MEMBER
 ≤  ≥    U+2264, U+2265   LESS-THAN/GREATER-THAN OR EQUAL TO
 ≦  ≧    U+2266, U+2267   LESS-THAN/GREATER-THAN OVER EQUAL TO
 ≨  ≩    U+2268, U+2269   LESS-THAN/GREATER-THAN BUT NOT EQUAL TO
 ≪  ≫    U+226A, U+226B   MUCH LESS-THAN/GREATER-THAN
 ≮  ≯    U+226E, U+226F   NOT LESS-THAN/GREATER-THAN
 ≰  ≱    U+2270, U+2271   NEITHER LESS-THAN/GREATER-THAN NOR EQUAL TO
 ≲  ≳    U+2272, U+2273   LESS-THAN/GREATER-THAN OR EQUIVALENT TO
 ≴  ≵    U+2274, U+2275   NEITHER LESS-THAN/GREATER-THAN NOR EQUIVALENT TO
 ≺  ≻    U+227A, U+227B   PRECEDES/SUCCEEDS
 ≼  ≽    U+227C, U+227D   PRECEDES/SUCCEEDS OR EQUAL TO
 ≾  ≿    U+227E, U+227F   PRECEDES/SUCCEEDS OR EQUIVALENT TO
 ⊀  ⊁    U+2280, U+2281   DOES NOT PRECEDE/SUCCEED
 ⊂  ⊃    U+2282, U+2283   SUBSET/SUPERSET OF
 ⊄  ⊅    U+2284, U+2285   NOT A SUBSET/SUPERSET OF
 ⊆  ⊇    U+2286, U+2287   SUBSET/SUPERSET OF OR EQUAL TO
 ⊈  ⊉    U+2288, U+2289   NEITHER A SUBSET/SUPERSET OF NOR EQUAL TO
 ⊊  ⊋    U+228A, U+228B   SUBSET/SUPERSET OF WITH NOT EQUAL TO
 ⊣  ⊢    U+22A3, U+22A2   LEFT/RIGHT TACK
 ⊦  ⫞    U+22A6, U+2ADE   ASSERTION,  SHORT LEFT TACK
 ⊨  ⫤    U+22A8, U+2AE4   TRUE,  VERTICAL BAR DOUBLE LEFT TURNSTILE
 ⊩  ⫣    U+22A9, U+2AE3   FORCES,  DOUBLE VERTICAL BAR LEFT TURNSTILE
 ⊰  ⊱    U+22B0, U+22B1   PRECEDES/SUCCEEDS UNDER RELATION
 ⋐  ⋑    U+22D0, U+22D1   DOUBLE SUBSET/SUPERSET
 ⋖  ⋗    U+22D6, U+22D7   LESS-THAN/GREATER-THAN WITH DOT
 ⋘  ⋙    U+22D8, U+22D9   VERY MUCH LESS-THAN/GREATER-THAN
 ⋜  ⋝    U+22DC, U+22DD   EQUAL TO OR LESS-THAN/GREATER-THAN
 ⋞  ⋟    U+22DE, U+22DF   EQUAL TO OR PRECEDES/SUCCEEDS
 ⋠  ⋡    U+22E0, U+22E1   DOES NOT PRECEDE/SUCCEED OR EQUAL
 ⋦  ⋧    U+22E6, U+22E7   LESS-THAN/GREATER-THAN BUT NOT EQUIVALENT TO
 ⋨  ⋩    U+22E8, U+22E9   PRECEDES/SUCCEEDS BUT NOT EQUIVALENT TO
 ⋲  ⋺    U+22F2, U+22FA   ELEMENT OF/CONTAINS WITH LONG HORIZONTAL STROKE
 ⋳  ⋻    U+22F3, U+22FB   ELEMENT OF/CONTAINS WITH VERTICAL BAR AT END OF
                          HORIZONTAL STROKE
 ⋴  ⋼    U+22F4, U+22FC   SMALL ELEMENT OF/CONTAINS WITH VERTICAL BAR AT
                          END OF HORIZONTAL STROKE
 ⋶  ⋽    U+22F6, U+22FD   ELEMENT OF/CONTAINS WITH OVERBAR
 ⋷  ⋾    U+22F7, U+22FE   SMALL ELEMENT OF/CONTAINS WITH OVERBAR
 ⌈  ⌉    U+2308, U+2309   LEFT/RIGHT CEILING
 ⌊  ⌋    U+230A, U+230B   LEFT/RIGHT FLOOR
 ⌦  ⌫    U+2326, U+232B   ERASE TO THE RIGHT/LEFT
 〈 〉   U+2329, U+232A   LEFT/RIGHT-POINTING ANGLE BRACKET
 ⍈  ⍇    U+2348, U+2347   APL FUNCTIONAL SYMBOL QUAD RIGHT/LEFTWARDS ARROW
 ⏩ ⏪   U+23E9, U+23EA   BLACK RIGHT/LEFT-POINTING DOUBLE TRIANGLE
 ⏭  ⏮    U+23ED, U+23EE   BLACK RIGHT/LEFT-POINTING DOUBLE TRIANGLE WITH
                          VERTICAL BAR
 ☛  ☚    U+261B, U+261A   BLACK RIGHT/LEFT POINTING INDEX
 ☞  ☜    U+261E, U+261C   WHITE RIGHT/LEFT POINTING INDEX
 ⚞  ⚟    U+269E, U+269F   THREE LINES CONVERGING RIGHT/LEFT
 ❨  ❩    U+2768, U+2769   MEDIUM LEFT/RIGHT PARENTHESIS ORNAMENT
 ❪  ❫    U+276A, U+276B   MEDIUM FLATTENED LEFT/RIGHT PARENTHESIS ORNAMENT
 ❬  ❭    U+276C, U+276D   MEDIUM LEFT/RIGHT-POINTING ANGLE BRACKET
                          ORNAMENT
 ❮  ❯    U+276E, U+276F   HEAVY LEFT/RIGHT-POINTING ANGLE QUOTATION MARK
                          ORNAMENT
 ❰  ❱    U+2770, U+2771   HEAVY LEFT/RIGHT-POINTING ANGLE BRACKET ORNAMENT
 ❲  ❳    U+2772, U+2773   LIGHT LEFT/RIGHT TORTOISE SHELL BRACKET ORNAMENT
 ❴  ❵    U+2774, U+2775   MEDIUM LEFT/RIGHT CURLY BRACKET ORNAMENT
 ⟃  ⟄    U+27C3, U+27C4   OPEN SUBSET/SUPERSET
 ⟅  ⟆    U+27C5, U+27C6   LEFT/RIGHT S-SHAPED BAG DELIMITER
 ⟈  ⟉    U+27C8, U+27C9   REVERSE SOLIDUS PRECEDING SUBSET,  SUPERSET
                          PRECEDING SOLIDUS
 ⟞  ⟝    U+27DE, U+27DD   LONG LEFT/RIGHT TACK
 ⟦  ⟧    U+27E6, U+27E7   MATHEMATICAL LEFT/RIGHT WHITE SQUARE BRACKET
 ⟨  ⟩    U+27E8, U+27E9   MATHEMATICAL LEFT/RIGHT ANGLE BRACKET
 ⟪  ⟫    U+27EA, U+27EB   MATHEMATICAL LEFT/RIGHT DOUBLE ANGLE BRACKET
 ⟬  ⟭    U+27EC, U+27ED   MATHEMATICAL LEFT/RIGHT WHITE TORTOISE SHELL
                          BRACKET
 ⟮  ⟯    U+27EE, U+27EF   MATHEMATICAL LEFT/RIGHT FLATTENED PARENTHESIS
 ⟴  ⬲    U+27F4, U+2B32   RIGHT/LEFT ARROW WITH CIRCLED PLUS
 ⟶  ⟵    U+27F6, U+27F5   LONG RIGHT/LEFTWARDS ARROW
 ⟹  ⟸    U+27F9, U+27F8   LONG RIGHT/LEFTWARDS DOUBLE ARROW
 ⟼  ⟻    U+27FC, U+27FB   LONG RIGHT/LEFTWARDS ARROW FROM BAR
 ⟾  ⟽    U+27FE, U+27FD   LONG RIGHT/LEFTWARDS DOUBLE ARROW FROM BAR
 ⟿  ⬳    U+27FF, U+2B33   LONG RIGHT/LEFTWARDS SQUIGGLE ARROW
 ⤀  ⬴    U+2900, U+2B34   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH VERTICAL
                          STROKE
 ⤁  ⬵    U+2901, U+2B35   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH DOUBLE
                          VERTICAL STROKE
 ⤃  ⤂    U+2903, U+2902   RIGHT/LEFTWARDS DOUBLE ARROW WITH VERTICAL
                          STROKE
 ⤅  ⬶    U+2905, U+2B36   RIGHT/LEFTWARDS TWO-HEADED ARROW FROM BAR
 ⤇  ⤆    U+2907, U+2906   RIGHT/LEFTWARDS DOUBLE ARROW FROM BAR
 ⤍  ⤌    U+290D, U+290C   RIGHT/LEFTWARDS DOUBLE DASH ARROW
 ⤏  ⤎    U+290F, U+290E   RIGHT/LEFTWARDS TRIPLE DASH ARROW
 ⤐  ⬷    U+2910, U+2B37   RIGHT/LEFTWARDS TWO-HEADED TRIPLE DASH ARROW
 ⤑  ⬸    U+2911, U+2B38   RIGHT/LEFTWARDS ARROW WITH DOTTED STEM
 ⤔  ⬹    U+2914, U+2B39   RIGHT/LEFTWARDS ARROW WITH TAIL WITH VERTICAL
                          STROKE
 ⤕  ⬺    U+2915, U+2B3A   RIGHT/LEFTWARDS ARROW WITH TAIL WITH DOUBLE
                          VERTICAL STROKE
 ⤖  ⬻    U+2916, U+2B3B   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH TAIL
 ⤗  ⬼    U+2917, U+2B3C   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH TAIL WITH
                          VERTICAL STROKE
 ⤘  ⬽    U+2918, U+2B3D   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH TAIL WITH
                          DOUBLE VERTICAL STROKE
 ⤚  ⤙    U+291A, U+2919   RIGHT/LEFTWARDS ARROW-TAIL
 ⤜  ⤛    U+291C, U+291B   RIGHT/LEFTWARDS DOUBLE ARROW-TAIL
 ⤞  ⤝    U+291E, U+291D   RIGHT/LEFTWARDS ARROW TO BLACK DIAMOND
 ⤠  ⤟    U+2920, U+291F   RIGHT/LEFTWARDS ARROW FROM BAR TO BLACK DIAMOND
 ⤳  ⬿    U+2933, U+2B3F   WAVE ARROW POINTING DIRECTLY RIGHT/LEFT
 ⤷  ⤶    U+2937, U+2936   ARROW POINTING DOWNWARDS THEN CURVING RIGHT/
                          LEFTWARDS
 ⥅  ⥆    U+2945, U+2946   RIGHT/LEFTWARDS ARROW WITH PLUS BELOW
 ⥇  ⬾    U+2947, U+2B3E   RIGHT/LEFTWARDS ARROW THROUGH X
 ⥓  ⥒    U+2953, U+2952   RIGHT/LEFTWARDS HARPOON WITH BARB UP TO BAR
 ⥗  ⥖    U+2957, U+2956   RIGHT/LEFTWARDS HARPOON WITH BARB DOWN TO BAR
 ⥛  ⥚    U+295B, U+295A   RIGHT/LEFTWARDS HARPOON WITH BARB UP FROM BAR
 ⥟  ⥞    U+295F, U+295E   RIGHT/LEFTWARDS HARPOON WITH BARB DOWN FROM BAR
 ⥤  ⥢    U+2964, U+2962   RIGHT/LEFTWARDS HARPOON WITH BARB UP ABOVE
                          RIGHT/LEFTWARDS HARPOON WITH BARB DOWN
 ⥬  ⥪    U+296C, U+296A   RIGHT/LEFTWARDS HARPOON WITH BARB UP ABOVE LONG
                          DASH
 ⥭  ⥫    U+296D, U+296B   RIGHT/LEFTWARDS HARPOON WITH BARB DOWN BELOW
                          LONG DASH
 ⥱  ⭀    U+2971, U+2B40   EQUALS SIGN ABOVE RIGHT/LEFTWARDS ARROW
 ⥲  ⭁    U+2972, U+2B41   TILDE OPERATOR ABOVE RIGHTWARDS ARROW,  REVERSE
                          TILDE OPERATOR ABOVE LEFTWARDS ARROW
 ⥴  ⭋    U+2974, U+2B4B   RIGHTWARDS ARROW ABOVE TILDE OPERATOR,
                          LEFTWARDS ARROW ABOVE REVERSE TILDE OPERATOR
 ⥵  ⭂    U+2975, U+2B42   RIGHTWARDS ARROW ABOVE ALMOST EQUAL TO,
                          LEFTWARDS ARROW ABOVE REVERSE ALMOST EQUAL TO
 ⥹  ⥻    U+2979, U+297B   SUBSET/SUPERSET ABOVE RIGHT/LEFTWARDS ARROW
 ⦃  ⦄    U+2983, U+2984   LEFT/RIGHT WHITE CURLY BRACKET
 ⦅  ⦆    U+2985, U+2986   LEFT/RIGHT WHITE PARENTHESIS
 ⦇  ⦈    U+2987, U+2988   Z NOTATION LEFT/RIGHT IMAGE BRACKET
 ⦉  ⦊    U+2989, U+298A   Z NOTATION LEFT/RIGHT BINDING BRACKET
 ⦋  ⦌    U+298B, U+298C   LEFT/RIGHT SQUARE BRACKET WITH UNDERBAR
 ⦍  ⦐    U+298D, U+2990   LEFT/RIGHT SQUARE BRACKET WITH TICK IN TOP
                          CORNER
 ⦏  ⦎    U+298F, U+298E   LEFT/RIGHT SQUARE BRACKET WITH TICK IN BOTTOM
                          CORNER
 ⦑  ⦒    U+2991, U+2992   LEFT/RIGHT ANGLE BRACKET WITH DOT
 ⦓  ⦔    U+2993, U+2994   LEFT/RIGHT ARC LESS-THAN/GREATER-THAN BRACKET
 ⦕  ⦖    U+2995, U+2996   DOUBLE LEFT/RIGHT ARC GREATER-THAN/LESS-THAN
                          BRACKET
 ⦗  ⦘    U+2997, U+2998   LEFT/RIGHT BLACK TORTOISE SHELL BRACKET
 ⦨  ⦩    U+29A8, U+29A9   MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW
                          POINTING UP AND RIGHT/LEFT
 ⦪  ⦫    U+29AA, U+29AB   MEASURED ANGLE WITH OPEN ARM ENDING IN ARROW
                          POINTING DOWN AND RIGHT/LEFT
 ⦳  ⦴    U+29B3, U+29B4   EMPTY SET WITH RIGHT/LEFT ARROW ABOVE
 ⧀  ⧁    U+29C0, U+29C1   CIRCLED LESS-THAN/GREATER-THAN
 ⧘  ⧙    U+29D8, U+29D9   LEFT/RIGHT WIGGLY FENCE
 ⧚  ⧛    U+29DA, U+29DB   LEFT/RIGHT DOUBLE WIGGLY FENCE
 ⧼  ⧽    U+29FC, U+29FD   LEFT/RIGHT-POINTING CURVED ANGLE BRACKET
 ⩹  ⩺    U+2A79, U+2A7A   LESS-THAN/GREATER-THAN WITH CIRCLE INSIDE
 ⩻  ⩼    U+2A7B, U+2A7C   LESS-THAN/GREATER-THAN WITH QUESTION MARK ABOVE
 ⩽  ⩾    U+2A7D, U+2A7E   LESS-THAN/GREATER-THAN OR SLANTED EQUAL TO
 ⩿  ⪀    U+2A7F, U+2A80   LESS-THAN/GREATER-THAN OR SLANTED EQUAL TO WITH
                          DOT INSIDE
 ⪁  ⪂    U+2A81, U+2A82   LESS-THAN/GREATER-THAN OR SLANTED EQUAL TO WITH
                          DOT ABOVE
 ⪃  ⪄    U+2A83, U+2A84   LESS-THAN/GREATER-THAN OR SLANTED EQUAL TO WITH
                          DOT ABOVE RIGHT/LEFT
 ⪅  ⪆    U+2A85, U+2A86   LESS-THAN/GREATER-THAN OR APPROXIMATE
 ⪇  ⪈    U+2A87, U+2A88   LESS-THAN/GREATER-THAN AND SINGLE-LINE NOT
                          EQUAL TO
 ⪉  ⪊    U+2A89, U+2A8A   LESS-THAN/GREATER-THAN AND NOT APPROXIMATE
 ⪍  ⪎    U+2A8D, U+2A8E   LESS-THAN/GREATER-THAN ABOVE SIMILAR OR EQUAL
 ⪕  ⪖    U+2A95, U+2A96   SLANTED EQUAL TO OR LESS-THAN/GREATER-THAN
 ⪗  ⪘    U+2A97, U+2A98   SLANTED EQUAL TO OR LESS-THAN/GREATER-THAN WITH
                          DOT INSIDE
 ⪙  ⪚    U+2A99, U+2A9A   DOUBLE-LINE EQUAL TO OR LESS-THAN/GREATER-THAN
 ⪛  ⪜    U+2A9B, U+2A9C   DOUBLE-LINE SLANTED EQUAL TO OR LESS-THAN/
                          GREATER-THAN
 ⪝  ⪞    U+2A9D, U+2A9E   SIMILAR OR LESS-THAN/GREATER-THAN
 ⪟  ⪠    U+2A9F, U+2AA0   SIMILAR ABOVE LESS-THAN/GREATER-THAN ABOVE
                          EQUALS SIGN
 ⪡  ⪢    U+2AA1, U+2AA2   DOUBLE NESTED LESS-THAN/GREATER-THAN
 ⪦  ⪧    U+2AA6, U+2AA7   LESS-THAN/GREATER-THAN CLOSED BY CURVE
 ⪨  ⪩    U+2AA8, U+2AA9   LESS-THAN/GREATER-THAN CLOSED BY CURVE ABOVE
                          SLANTED EQUAL
 ⪪  ⪫    U+2AAA, U+2AAB   SMALLER THAN/LARGER THAN
 ⪬  ⪭    U+2AAC, U+2AAD   SMALLER THAN/LARGER THAN OR EQUAL TO
 ⪯  ⪰    U+2AAF, U+2AB0   PRECEDES/SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
 ⪱  ⪲    U+2AB1, U+2AB2   PRECEDES/SUCCEEDS ABOVE SINGLE-LINE NOT EQUAL TO
 ⪳  ⪴    U+2AB3, U+2AB4   PRECEDES/SUCCEEDS ABOVE EQUALS SIGN
 ⪵  ⪶    U+2AB5, U+2AB6   PRECEDES/SUCCEEDS ABOVE NOT EQUAL TO
 ⪷  ⪸    U+2AB7, U+2AB8   PRECEDES/SUCCEEDS ABOVE ALMOST EQUAL TO
 ⪹  ⪺    U+2AB9, U+2ABA   PRECEDES/SUCCEEDS ABOVE NOT ALMOST EQUAL TO
 ⪻  ⪼    U+2ABB, U+2ABC   DOUBLE PRECEDES/SUCCEEDS
 ⪽  ⪾    U+2ABD, U+2ABE   SUBSET/SUPERSET WITH DOT
 ⪿  ⫀    U+2ABF, U+2AC0   SUBSET/SUPERSET WITH PLUS SIGN BELOW
 ⫁  ⫂    U+2AC1, U+2AC2   SUBSET/SUPERSET WITH MULTIPLICATION SIGN BELOW
 ⫃  ⫄    U+2AC3, U+2AC4   SUBSET/SUPERSET OF OR EQUAL TO WITH DOT ABOVE
 ⫅  ⫆    U+2AC5, U+2AC6   SUBSET/SUPERSET OF ABOVE EQUALS SIGN
 ⫇  ⫈    U+2AC7, U+2AC8   SUBSET/SUPERSET OF ABOVE TILDE OPERATOR
 ⫉  ⫊    U+2AC9, U+2ACA   SUBSET/SUPERSET OF ABOVE ALMOST EQUAL TO
 ⫋  ⫌    U+2ACB, U+2ACC   SUBSET/SUPERSET OF ABOVE NOT EQUAL TO
 ⫏  ⫐    U+2ACF, U+2AD0   CLOSED SUBSET/SUPERSET
 ⫑  ⫒    U+2AD1, U+2AD2   CLOSED SUBSET/SUPERSET OR EQUAL TO
 ⫕  ⫖    U+2AD5, U+2AD6   SUBSET/SUPERSET ABOVE SUBSET/SUPERSET
 ⫥  ⊫    U+2AE5, U+22AB   DOUBLE VERTICAL BAR DOUBLE LEFT/RIGHT TURNSTILE
 ⫷  ⫸    U+2AF7, U+2AF8   TRIPLE NESTED LESS-THAN/GREATER-THAN
 ⫹  ⫺    U+2AF9, U+2AFA   DOUBLE-LINE SLANTED LESS-THAN/GREATER-THAN OR
                          EQUAL TO
 ⭆  ⭅    U+2B46, U+2B45   RIGHT/LEFTWARDS QUADRUPLE ARROW
 ⭇  ⭉    U+2B47, U+2B49   REVERSE TILDE OPERATOR ABOVE RIGHTWARDS ARROW,
                          TILDE OPERATOR ABOVE LEFTWARDS ARROW
 ⭈  ⭊    U+2B48, U+2B4A   RIGHTWARDS ARROW ABOVE REVERSE ALMOST EQUAL
                          TO,  LEFTWARDS ARROW ABOVE ALMOST EQUAL TO
 ⭌  ⥳    U+2B4C, U+2973   RIGHTWARDS ARROW ABOVE REVERSE TILDE OPERATOR,
                          LEFTWARDS ARROW ABOVE TILDE OPERATOR
 ⭢  ⭠    U+2B62, U+2B60   RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW
 ⭬  ⭪    U+2B6C, U+2B6A   RIGHT/LEFTWARDS TRIANGLE-HEADED DASHED ARROW
 ⭲  ⭰    U+2B72, U+2B70   RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW TO BAR
 ⭼  ⭺    U+2B7C, U+2B7A   RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH
                          DOUBLE VERTICAL STROKE
 ⮆  ⮄    U+2B86, U+2B84   RIGHT/LEFTWARDS TRIANGLE-HEADED PAIRED ARROWS
 ⮊  ⮈    U+2B8A, U+2B88   RIGHT/LEFTWARDS BLACK CIRCLED WHITE ARROW
 ⮕  ⬅    U+2B95, U+2B05   RIGHT/LEFTWARDS BLACK ARROW
 ⮚  ⮘    U+2B9A, U+2B98   THREE-D TOP-LIGHTED RIGHT/LEFTWARDS EQUILATERAL
                          ARROWHEAD
 ⮞  ⮜    U+2B9E, U+2B9C   BLACK RIGHT/LEFTWARDS EQUILATERAL ARROWHEAD
 ⮡  ⮠    U+2BA1, U+2BA0   DOWNWARDS TRIANGLE-HEADED ARROW WITH LONG TIP
                          RIGHT/LEFTWARDS
 ⮣  ⮢    U+2BA3, U+2BA2   UPWARDS TRIANGLE-HEADED ARROW WITH LONG TIP
                          RIGHT/LEFTWARDS
 ⮩  ⮨    U+2BA9, U+2BA8   BLACK CURVED DOWNWARDS AND RIGHT/LEFTWARDS ARROW
 ⮫  ⮪    U+2BAB, U+2BAA   BLACK CURVED UPWARDS AND RIGHT/LEFTWARDS ARROW
 ⮱  ⮰    U+2BB1, U+2BB0   RIBBON ARROW DOWN RIGHT/LEFT
 ⮳  ⮲    U+2BB3, U+2BB2   RIBBON ARROW UP RIGHT/LEFT
 ⯮  ⯬    U+2BEE, U+2BEC   RIGHT/LEFTWARDS TWO-HEADED ARROW WITH TRIANGLE
                          ARROWHEADS
 ⸂  ⸃    U+2E02, U+2E03   LEFT/RIGHT SUBSTITUTION BRACKET
 ⸃  ⸂    U+2E03, U+2E02   RIGHT/LEFT SUBSTITUTION BRACKET
 ⸄  ⸅    U+2E04, U+2E05   LEFT/RIGHT DOTTED SUBSTITUTION BRACKET
 ⸅  ⸄    U+2E05, U+2E04   RIGHT/LEFT DOTTED SUBSTITUTION BRACKET
 ⸉  ⸊    U+2E09, U+2E0A   LEFT/RIGHT TRANSPOSITION BRACKET
 ⸊  ⸉    U+2E0A, U+2E09   RIGHT/LEFT TRANSPOSITION BRACKET
 ⸌  ⸍    U+2E0C, U+2E0D   LEFT/RIGHT RAISED OMISSION BRACKET
 ⸍  ⸌    U+2E0D, U+2E0C   RIGHT/LEFT RAISED OMISSION BRACKET
 ⸑  ⸐    U+2E11, U+2E10   REVERSED FORKED PARAGRAPHOS,  FORKED PARAGRAPHOS
 ⸜  ⸝    U+2E1C, U+2E1D   LEFT/RIGHT LOW PARAPHRASE BRACKET
 ⸝  ⸜    U+2E1D, U+2E1C   RIGHT/LEFT LOW PARAPHRASE BRACKET
 ⸠  ⸡    U+2E20, U+2E21   LEFT/RIGHT VERTICAL BAR WITH QUILL
 ⸡  ⸠    U+2E21, U+2E20   RIGHT/LEFT VERTICAL BAR WITH QUILL
 ⸢  ⸣    U+2E22, U+2E23   TOP LEFT/RIGHT HALF BRACKET
 ⸤  ⸥    U+2E24, U+2E25   BOTTOM LEFT/RIGHT HALF BRACKET
 ⸦  ⸧    U+2E26, U+2E27   LEFT/RIGHT SIDEWAYS U BRACKET
 ⸨  ⸩    U+2E28, U+2E29   LEFT/RIGHT DOUBLE PARENTHESIS
 ⸶  ⸷    U+2E36, U+2E37   DAGGER WITH LEFT/RIGHT GUARD
 ⹂  „    U+2E42, U+201E   DOUBLE LOW-REVERSED-9 QUOTATION MARK,  DOUBLE
                          LOW-9 QUOTATION MARK
 ⹕  ⹖    U+2E55, U+2E56   LEFT/RIGHT SQUARE BRACKET WITH STROKE
 ⹗  ⹘    U+2E57, U+2E58   LEFT/RIGHT SQUARE BRACKET WITH DOUBLE STROKE
 ⹙  ⹚    U+2E59, U+2E5A   TOP HALF LEFT/RIGHT PARENTHESIS
 ⹛  ⹜    U+2E5B, U+2E5C   BOTTOM HALF LEFT/RIGHT PARENTHESIS
 〈 〉   U+3008, U+3009   LEFT/RIGHT ANGLE BRACKET
 《 》   U+300A, U+300B   LEFT/RIGHT DOUBLE ANGLE BRACKET
 「 」   U+300C, U+300D   LEFT/RIGHT CORNER BRACKET
 『 』   U+300E, U+300F   LEFT/RIGHT WHITE CORNER BRACKET
 【 】   U+3010, U+3011   LEFT/RIGHT BLACK LENTICULAR BRACKET
 〔 〕   U+3014, U+3015   LEFT/RIGHT TORTOISE SHELL BRACKET
 〖 〗   U+3016, U+3017   LEFT/RIGHT WHITE LENTICULAR BRACKET
 〘 〙   U+3018, U+3019   LEFT/RIGHT WHITE TORTOISE SHELL BRACKET
 〚 〛   U+301A, U+301B   LEFT/RIGHT WHITE SQUARE BRACKET
 〝 〞   U+301D, U+301E   REVERSED DOUBLE PRIME QUOTATION MARK,  DOUBLE
                          PRIME QUOTATION MARK
 ꧁  ꧂    U+A9C1, U+A9C2   JAVANESE LEFT/RIGHT RERENGGAN
 ﴾  ﴿    U+FD3E, U+FD3F   ORNATE LEFT/RIGHT PARENTHESIS
 ﹙ ﹚   U+FE59, U+FE5A   SMALL LEFT/RIGHT PARENTHESIS
 ﹛ ﹜   U+FE5B, U+FE5C   SMALL LEFT/RIGHT CURLY BRACKET
 ﹝ ﹞   U+FE5D, U+FE5E   SMALL LEFT/RIGHT TORTOISE SHELL BRACKET
 ﹤ ﹥   U+FE64, U+FE65   SMALL LESS-THAN/GREATER-THAN SIGN
 （ ）   U+FF08, U+FF09   FULLWIDTH LEFT/RIGHT PARENTHESIS
 ＜ ＞   U+FF1C, U+FF1E   FULLWIDTH LESS-THAN/GREATER-THAN SIGN
 ［ ］   U+FF3B, U+FF3D   FULLWIDTH LEFT/RIGHT SQUARE BRACKET
 ｛ ｝   U+FF5B, U+FF5D   FULLWIDTH LEFT/RIGHT CURLY BRACKET
 ｟ ｠   U+FF5F, U+FF60   FULLWIDTH LEFT/RIGHT WHITE PARENTHESIS
 ｢  ｣    U+FF62, U+FF63   HALFWIDTH LEFT/RIGHT CORNER BRACKET
 ￫  ￩    U+FFEB, U+FFE9   HALFWIDTH RIGHT/LEFTWARDS ARROW
 𝄃  𝄂    U+1D103, U+1D102 MUSICAL SYMBOL REVERSE FINAL BARLINE,  MUSICAL
                          SYMBOL FINAL BARLINE
 𝄆  𝄇    U+1D106, U+1D107 MUSICAL SYMBOL LEFT/RIGHT REPEAT SIGN
 👉 👈   U+1F449, U+1F448 WHITE RIGHT/LEFT POINTING BACKHAND INDEX
 🔈 🕨    U+1F508, U+1F568 SPEAKER,  RIGHT SPEAKER
 🔉 🕩    U+1F509, U+1F569 SPEAKER WITH ONE SOUND WAVE,  RIGHT SPEAKER WITH
                          ONE SOUND WAVE
 🔊 🕪    U+1F50A, U+1F56A SPEAKER WITH THREE SOUND WAVES,  RIGHT SPEAKER
                          WITH THREE SOUND WAVES
 🕻  🕽    U+1F57B, U+1F57D LEFT/RIGHT HAND TELEPHONE RECEIVER
 🖙  🖘    U+1F599, U+1F598 SIDEWAYS WHITE RIGHT/LEFT POINTING INDEX
 🖛  🖚    U+1F59B, U+1F59A SIDEWAYS BLACK RIGHT/LEFT POINTING INDEX
 🖝  🖜    U+1F59D, U+1F59C BLACK RIGHT/LEFT POINTING BACKHAND INDEX
 🗦  🗧    U+1F5E6, U+1F5E7 THREE RAYS LEFT/RIGHT
 🠂  🠀    U+1F802, U+1F800 RIGHT/LEFTWARDS ARROW WITH SMALL TRIANGLE
                          ARROWHEAD
 🠆  🠄    U+1F806, U+1F804 RIGHT/LEFTWARDS ARROW WITH MEDIUM TRIANGLE
                          ARROWHEAD
 🠊  🠈    U+1F80A, U+1F808 RIGHT/LEFTWARDS ARROW WITH LARGE TRIANGLE
                          ARROWHEAD
 🠒  🠐    U+1F812, U+1F810 RIGHT/LEFTWARDS ARROW WITH SMALL EQUILATERAL
                          ARROWHEAD
 🠖  🠔    U+1F816, U+1F814 RIGHT/LEFTWARDS ARROW WITH EQUILATERAL ARROWHEAD
 🠚  🠘    U+1F81A, U+1F818 HEAVY RIGHT/LEFTWARDS ARROW WITH EQUILATERAL
                          ARROWHEAD
 🠞  🠜    U+1F81E, U+1F81C HEAVY RIGHT/LEFTWARDS ARROW WITH LARGE
                          EQUILATERAL ARROWHEAD
 🠢  🠠    U+1F822, U+1F820 RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH
                          NARROW SHAFT
 🠦  🠤    U+1F826, U+1F824 RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH
                          MEDIUM SHAFT
 🠪  🠨    U+1F82A, U+1F828 RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH BOLD
                          SHAFT
 🠮  🠬    U+1F82E, U+1F82C RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH
                          HEAVY SHAFT
 🠲  🠰    U+1F832, U+1F830 RIGHT/LEFTWARDS TRIANGLE-HEADED ARROW WITH VERY
                          HEAVY SHAFT
 🠶  🠴    U+1F836, U+1F834 RIGHT/LEFTWARDS FINGER-POST ARROW
 🠺  🠸    U+1F83A, U+1F838 RIGHT/LEFTWARDS SQUARED ARROW
 🠾  🠼    U+1F83E, U+1F83C RIGHT/LEFTWARDS COMPRESSED ARROW
 🡂  🡀    U+1F842, U+1F840 RIGHT/LEFTWARDS HEAVY COMPRESSED ARROW
 🡆  🡄    U+1F846, U+1F844 RIGHT/LEFTWARDS HEAVY ARROW
 🡒  🡐    U+1F852, U+1F850 RIGHT/LEFTWARDS SANS-SERIF ARROW
 🡢  🡠    U+1F862, U+1F860 WIDE-HEADED RIGHT/LEFTWARDS LIGHT BARB ARROW
 🡪  🡨    U+1F86A, U+1F868 WIDE-HEADED RIGHT/LEFTWARDS BARB ARROW
 🡲  🡰    U+1F872, U+1F870 WIDE-HEADED RIGHT/LEFTWARDS MEDIUM BARB ARROW
 🡺  🡸    U+1F87A, U+1F878 WIDE-HEADED RIGHT/LEFTWARDS HEAVY BARB ARROW
 🢂  🢀    U+1F882, U+1F880 WIDE-HEADED RIGHT/LEFTWARDS VERY HEAVY BARB
                          ARROW
 🢒  🢐    U+1F892, U+1F890 RIGHT/LEFTWARDS TRIANGLE ARROWHEAD
 🢖  🢔    U+1F896, U+1F894 RIGHT/LEFTWARDS WHITE ARROW WITHIN TRIANGLE
                          ARROWHEAD
 🢚  🢘    U+1F89A, U+1F898 RIGHT/LEFTWARDS ARROW WITH NOTCHED TAIL
 🢡  🢠    U+1F8A1, U+1F8A0 RIGHTWARDS BOTTOM SHADED WHITE ARROW,
                          LEFTWARDS BOTTOM-SHADED WHITE ARROW
 🢣  🢢    U+1F8A3, U+1F8A2 RIGHT/LEFTWARDS TOP SHADED WHITE ARROW
 🢥  🢦    U+1F8A5, U+1F8A6 RIGHT/LEFTWARDS RIGHT-SHADED WHITE ARROW
 🢧  🢤    U+1F8A7, U+1F8A4 RIGHT/LEFTWARDS LEFT-SHADED WHITE ARROW
 🢩  🢨    U+1F8A9, U+1F8A8 RIGHT/LEFTWARDS BACK-TILTED SHADOWED WHITE ARROW
 🢫  🢪    U+1F8AB, U+1F8AA RIGHT/LEFTWARDS FRONT-TILTED SHADOWED WHITE
                          ARROW
 🢶  🢴    U+1F8B6, U+1F8B4 NEGATIVE SQUARED RIGHT/LEFTWARDS ARROW

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp> (5.000)
Update: Kentaro Shirakata <argrath@ub32.org> (5.6.1-)
Status: in progress

=end meta

