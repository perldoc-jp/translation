
=encoding utf8

=head1 NAME
X<function>

=begin original

perlfunc - Perl builtin functions

=end original

perlfunc - Perl 組み込み関数

=head1 DESCRIPTION

=begin original

The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in L<perlop>.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.  If it does both, scalar arguments
come first and list argument follow, and there can only ever
be one such list argument.  For instance,
L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST> has three scalar arguments
followed by a list, whereas L<C<gethostbyname>|/gethostbyname NAME> has
four scalar arguments.

=end original

この節の関数は、式の中で項として使うことができます。
これらは、大きく二つに分けられます:
リスト演算子と名前付き単項演算子です。
これらの違いは、その後に出て来るコンマとの優先順位の関係にあります。
(L<perlop> の優先順位の表を参照してください。)
リスト演算子は 2 個以上の引数をとるのに対して、単項演算子が複数の引数を
とることはありません。
つまり、コンマは単項演算子の引数の終わりとなりますが、リスト演算子の
場合には、引数の区切りでしかありません。
単項演算子は一般に、引数に対してスカラコンテキストを与えるのに対して、
スカラ演算子の場合には、引数に対してスカラコンテキストを与える場合も、
リストコンテキストを与える場合もあります。
一つのリスト演算子が両方のコンテキストを与える場合には、スカラ引数が
いくつか並び、最後にリスト引数が一つ続きます;
そしてそのようなリスト引数は一つだけしかありません。
たとえば、L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST> は三つのスカラ引数に
一つのリスト引数が続きます;
一方 L<C<gethostbyname>|/gethostbyname NAME> は四つのスカラ引数を持ちます。

=begin original

In the syntax descriptions that follow, list operators that expect a
list (and provide list context for elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Commas should separate literal elements of the LIST.

=end original

後に載せる構文記述では、リストをとり (そのリストの要素にリストコンテキストを
与える)リスト演算子は、引数として LIST をとるように書いています;
そのようなリストには、任意のスカラ引数の組み合わせやリスト値を
含めることができ、リスト値はリストの中に、個々の要素が展開されたように
埋め込まれます。
1 次元の長いリスト値が形成されることになります。
LIST のリテラルな要素は、コンマで区切られます。

=begin original

Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use parentheses, the simple but occasionally
surprising rule is this: It I<looks> like a function, therefore it I<is> a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  Whitespace
between the function and left parenthesis doesn't count, so sometimes
you need to be careful:

=end original

以下のリストの関数はすべて、引数の前後の括弧は省略可能となっています。
(構文記述では省略しています。)
括弧を使うときには、単純な、(しかし、ときには驚く結果となる規則が
適用できます:
I<関数に見える>ならば、I<それは関数>で、優先順位は関係ありません。
そう見えなければ、それはリスト演算子か単項演算子で、優先順位が関係します。
関数と開き括弧の間の空白は関係ありませんので、ときに
気を付けなければなりません:

    print 1+2+4;      # Prints 7.
    print(1+2) + 4;   # Prints 3.
    print (1+2)+4;    # Also prints 3!
    print +(1+2)+4;   # Prints 7.
    print ((1+2)+4);  # Prints 7.

=begin original

If you run Perl with the L<C<use warnings>|warnings> pragma, it can warn
you about this.  For example, the third line above produces:

=end original

Perl に L<C<use warnings>|warnings> プラグマを付けて実行すれば、
こういったものには警告を出してくれます。
たとえば、上記の三つめは、以下のような警告が出ます:

    print (...) interpreted as function at - line 1.
    Useless use of integer addition in void context at - line 1.

=begin original

A few functions take no arguments at all, and therefore work as neither
unary nor list operators.  These include such functions as
L<C<time>|/time> and L<C<endpwent>|/endpwent>.  For example,
C<time+86_400> always means C<time() + 86_400>.

=end original

いくつかの関数は引数を全くとらないので、単項演算子としても
リスト演算子としても動作しません。
このような関数としては L<C<time>|/time> や L<C<endpwent>|/endpwent> が
あります。
例えば、C<time+86_400> は常に C<time() + 86_400> として扱われます。

=begin original

For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in scalar context by
returning the undefined value, and in list context by returning the
empty list.

=end original

スカラコンテキストでも、リストコンテキストでも使える関数は、致命的でない
エラーを示すために、スカラコンテキストでは未定義値を返し、
リストコンテキストでは空リストを返します。

=begin original

Remember the following important rule: There is B<no rule> that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value would be most
appropriate to return in scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
X<context>

=end original

以下に述べる重要なルールを忘れないで下さい: リストコンテキストでの
振る舞いとスカラコンテキストでの振る舞いの関係、あるいはその逆に
B<ルールはありません>。
2 つの全く異なったことがあります。
それぞれの演算子と関数は、スカラコンテキストでは、もっとも適切と
思われる値を返します。
リストコンテキストで返す時のリストの長さを返す演算子もあります。
リストの最初の値を返す演算子もあります。
リストの最後の値を返す演算子もあります。
成功した操作の数を返す演算子もあります。
一般的には、一貫性を求めない限り、こちらが求めることをします。
X<context>

=begin original

A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like C<(1,2,3)> into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list concatenation version of the comma.  That means it
was never a list to start with.

=end original

スカラコンテキストでの名前付き配列は、スカラコンテキストでのリストを
一目見たものとは全く違います。
コンパイラはコンパイル時にコンテキストを知っているので、
C<(1,2,3)> のようなリストをスカラコンテキストで得ることはできません。
これはスカラコンマ演算子を生成し、コンマのリスト結合版ではありません。
これは初めからリストであることはないことを意味します。

=begin original

In general, functions in Perl that serve as wrappers for system calls
("syscalls") of the same name (like L<chown(2)>, L<fork(2)>,
L<closedir(2)>, etc.) return true when they succeed and
L<C<undef>|/undef EXPR> otherwise, as is usually mentioned in the
descriptions below.  This is different from the C interfaces, which
return C<-1> on failure.  Exceptions to this rule include
L<C<wait>|/wait>, L<C<waitpid>|/waitpid PID,FLAGS>, and
L<C<syscall>|/syscall NUMBER, LIST>.  System calls also set the special
L<C<$!>|perlvar/$!> variable on failure.  Other functions do not, except
accidentally.

=end original

一般的に、同じ名前のシステムコールのラッパーとして動作する Perl の関数
(L<chown(2)>, L<fork(2)>, L<closedir(2)> など)は、以下に述べるように、
成功時に真を返し、そうでなければ L<C<undef>|/undef EXPR> を返します。
これは失敗時に C<-1> を返す C のインターフェースとは違います。
このルールの例外は L<C<wait>|/wait>, L<C<waitpid>|/waitpid PID,FLAGS>,
L<C<syscall>|/syscall NUMBER, LIST> です。
システムコールは失敗時に特殊変数 L<C<$!>|perlvar/$!> をセットします。
その他の関数は、事故を除いて、セットしません。

=begin original

Extension modules can also hook into the Perl parser to define new
kinds of keyword-headed expression.  These may look like functions, but
may also look completely different.  The syntax following the keyword
is defined entirely by the extension.  If you are an implementor, see
L<perlapi/PL_keyword_plugin> for the mechanism.  If you are using such
a module, see the module's documentation for details of the syntax that
it defines.

=end original

エクステンションモジュールは、新しい種類のキーワードが頭に付いた式を
定義するために Perl パーサをフックできます。
これらは関数のように見えるかもしれませんが、全く別物かもしれません。
キーワード以降の文法は完全にエクステンションによって定義されます。
もしあなたが実装者なら、この機構については L<perlapi/PL_keyword_plugin> を
参照してください。
もしあなたがそのようなモジュールを使っているなら、
定義されている文法の詳細についてはモジュールの文書を参照してください。

=head2 Perl Functions by Category
X<function>

(カテゴリ別の Perl 関数)

=begin original

Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.  Any warnings, including those produced by
keywords, are described in L<perldiag> and L<warnings>.

=end original

以下に、カテゴリ別の関数(キーワードや名前付き演算子のような、
関数のように見えるものも含みます)を示します。
複数の場所に現れる関数もあります。
キーワードによって生成されるものを含む全ての警告は
L<perldiag> と L<warnings> に記述されています。

=over 4

=item Functions for SCALARs or strings
X<scalar> X<string> X<character>

(スカラや文字列のための関数)

=for Pod::Functions =String

L<C<chomp>|/chomp VARIABLE>, L<C<chop>|/chop VARIABLE>,
L<C<chr>|/chr NUMBER>, L<C<crypt>|/crypt PLAINTEXT,SALT>,
L<C<fc>|/fc EXPR>, L<C<hex>|/hex EXPR>,
L<C<index>|/index STR,SUBSTR,POSITION>, L<C<lc>|/lc EXPR>,
L<C<lcfirst>|/lcfirst EXPR>, L<C<length>|/length EXPR>,
L<C<oct>|/oct EXPR>, L<C<ord>|/ord EXPR>,
L<C<pack>|/pack TEMPLATE,LIST>,
L<C<qE<sol>E<sol>>|/qE<sol>STRINGE<sol>>,
L<C<qqE<sol>E<sol>>|/qqE<sol>STRINGE<sol>>, L<C<reverse>|/reverse LIST>,
L<C<rindex>|/rindex STR,SUBSTR,POSITION>,
L<C<sprintf>|/sprintf FORMAT, LIST>,
L<C<substr>|/substr EXPR,OFFSET,LENGTH,REPLACEMENT>,
L<C<trE<sol>E<sol>E<sol>>|/trE<sol>E<sol>E<sol>>, L<C<uc>|/uc EXPR>,
L<C<ucfirst>|/ucfirst EXPR>,
L<C<yE<sol>E<sol>E<sol>>|/yE<sol>E<sol>E<sol>>

=begin original

L<C<fc>|/fc EXPR> is available only if the
L<C<"fc"> feature|feature/The 'fc' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"fc"> feature|feature/The 'fc' feature> is enabled automatically
with a C<use v5.16> (or higher) declaration in the current scope.

=end original

L<C<fc>|/fc EXPR> は L<C<"fc"> 機能|feature/The 'fc' feature> が有効か
C<CORE::> が前置されたときにのみ利用可能です。
L<C<"fc"> 機能|feature/The 'fc' feature> は現在のスコープで
C<use v5.16> (またはそれ以上) が宣言されると自動的に有効になります。

=item Regular expressions and pattern matching
X<regular expression> X<regex> X<regexp>

(正規表現とパターンマッチング)

=for Pod::Functions =Regexp

L<C<mE<sol>E<sol>>|/mE<sol>E<sol>>, L<C<pos>|/pos SCALAR>,
L<C<qrE<sol>E<sol>>|/qrE<sol>STRINGE<sol>>,
L<C<quotemeta>|/quotemeta EXPR>,
L<C<sE<sol>E<sol>E<sol>>|/sE<sol>E<sol>E<sol>>,
L<C<split>|/split E<sol>PATTERNE<sol>,EXPR,LIMIT>,
L<C<study>|/study SCALAR>

=item Numeric functions
X<numeric> X<number> X<trigonometric> X<trigonometry>

(数値関数)

=for Pod::Functions =Math

L<C<abs>|/abs VALUE>, L<C<atan2>|/atan2 Y,X>, L<C<cos>|/cos EXPR>,
L<C<exp>|/exp EXPR>, L<C<hex>|/hex EXPR>, L<C<int>|/int EXPR>,
L<C<log>|/log EXPR>, L<C<oct>|/oct EXPR>, L<C<rand>|/rand EXPR>,
L<C<sin>|/sin EXPR>, L<C<sqrt>|/sqrt EXPR>, L<C<srand>|/srand EXPR>

=item Functions for real @ARRAYs
X<array>

(実配列のための関数)

=for Pod::Functions =ARRAY

L<C<each>|/each HASH>, L<C<keys>|/keys HASH>, L<C<pop>|/pop ARRAY>,
L<C<push>|/push ARRAY,LIST>, L<C<shift>|/shift ARRAY>,
L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST>,
L<C<unshift>|/unshift ARRAY,LIST>, L<C<values>|/values HASH>

=item Functions for list data
X<list>

(リストデータのための関数)

=for Pod::Functions =LIST

L<C<all>|/all BLOCK LIST>, L<C<any>|/any BLOCK LIST>,
L<C<grep>|/grep BLOCK LIST>, L<C<join>|/join EXPR,LIST>,
L<C<map>|/map BLOCK LIST>, L<C<qwE<sol>E<sol>>|/qwE<sol>STRINGE<sol>>,
L<C<reverse>|/reverse LIST>, L<C<sort>|/sort SUBNAME LIST>,
L<C<unpack>|/unpack TEMPLATE,EXPR>

=item Functions for real %HASHes
X<hash>

(実ハッシュのための関数)

=for Pod::Functions =HASH

L<C<delete>|/delete EXPR>, L<C<each>|/each HASH>,
L<C<exists>|/exists EXPR>, L<C<keys>|/keys HASH>,
L<C<values>|/values HASH>

=item Input and output functions
X<I/O> X<input> X<output> X<dbm>

(入出力関数)

=for Pod::Functions =I/O

L<C<binmode>|/binmode FILEHANDLE, LAYER>, L<C<close>|/close FILEHANDLE>,
L<C<closedir>|/closedir DIRHANDLE>, L<C<dbmclose>|/dbmclose HASH>,
L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK>, L<C<die>|/die LIST>,
L<C<eof>|/eof FILEHANDLE>, L<C<fileno>|/fileno FILEHANDLE>,
L<C<flock>|/flock FILEHANDLE,OPERATION>, L<C<format>|/format>,
L<C<getc>|/getc FILEHANDLE>, L<C<print>|/print FILEHANDLE LIST>,
L<C<printf>|/printf FILEHANDLE FORMAT, LIST>,
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<readdir>|/readdir DIRHANDLE>, L<C<readline>|/readline EXPR>,
L<C<rewinddir>|/rewinddir DIRHANDLE>, L<C<say>|/say FILEHANDLE LIST>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<seekdir>|/seekdir DIRHANDLE,POS>,
L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT>,
L<C<syscall>|/syscall NUMBER, LIST>,
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<tell>|/tell FILEHANDLE>, L<C<telldir>|/telldir DIRHANDLE>,
L<C<truncate>|/truncate FILEHANDLE,LENGTH>, L<C<warn>|/warn LIST>,
L<C<write>|/write FILEHANDLE>

=begin original

L<C<say>|/say FILEHANDLE LIST> is available only if the
L<C<"say"> feature|feature/The 'say' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"say"> feature|feature/The 'say' feature> is enabled automatically
with a C<use v5.10> (or higher) declaration in the current scope.

=end original

L<C<say>|/say FILEHANDLE LIST> は
L<C<"say"> 機能|feature/The 'say' feature> が有効か C<CORE::> が
前置されたときにのみ利用可能です。
L<C<"say"> 機能|feature/The 'say' feature> は現在のスコープで
C<use v5.10> (またはそれ以上) が宣言されると自動的に有効になります。

=item Functions for fixed-length data or records

(固定長データやレコードのための関数)

=for Pod::Functions =Binary

L<C<pack>|/pack TEMPLATE,LIST>,
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syscall>|/syscall NUMBER, LIST>,
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<unpack>|/unpack TEMPLATE,EXPR>, L<C<vec>|/vec EXPR,OFFSET,BITS>

=item Functions for filehandles, files, or directories
X<file> X<filehandle> X<directory> X<pipe> X<link> X<symlink>

(ファイルハンドル、ファイル、ディレクトリのための関数)

=for Pod::Functions =File

L<C<-I<X>>|/-X FILEHANDLE>, L<C<chdir>|/chdir EXPR>,
L<C<chmod>|/chmod LIST>, L<C<chown>|/chown LIST>,
L<C<chroot>|/chroot FILENAME>,
L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR>, L<C<glob>|/glob EXPR>,
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR>,
L<C<link>|/link OLDFILE,NEWFILE>, L<C<lstat>|/lstat FILEHANDLE>,
L<C<mkdir>|/mkdir FILENAME,MODE>, L<C<open>|/open FILEHANDLE,MODE,EXPR>,
L<C<opendir>|/opendir DIRHANDLE,EXPR>, L<C<readlink>|/readlink EXPR>,
L<C<rename>|/rename OLDNAME,NEWNAME>, L<C<rmdir>|/rmdir FILENAME>,
L<C<select>|/select FILEHANDLE>, L<C<stat>|/stat FILEHANDLE>,
L<C<symlink>|/symlink OLDFILE,NEWFILE>,
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE>,
L<C<umask>|/umask EXPR>, L<C<unlink>|/unlink LIST>,
L<C<utime>|/utime LIST>

=item Keywords related to the control flow of your Perl program
X<control flow>

(プログラムの流れを制御することに関連するキーワード)

=for Pod::Functions =Flow

L<C<break>|/break>, L<C<caller>|/caller EXPR>,
L<C<continue>|/continue BLOCK>, L<C<die>|/die LIST>, L<C<do>|/do BLOCK>,
L<C<dump>|/dump LABEL>, L<C<eval>|/eval EXPR>,
L<C<evalbytes>|/evalbytes EXPR>, L<C<exit>|/exit EXPR>,
L<C<__FILE__>|/__FILE__>, L<C<goto>|/goto LABEL>,
L<C<last>|/last LABEL>, L<C<__LINE__>|/__LINE__>,
L<C<method>|/method NAME BLOCK>,
L<C<next>|/next LABEL>, L<C<__PACKAGE__>|/__PACKAGE__>,
L<C<redo>|/redo LABEL>, L<C<return>|/return EXPR>,
L<C<sub>|/sub NAME BLOCK>, L<C<__SUB__>|/__SUB__>,
L<C<wantarray>|/wantarray>

=begin original

L<C<break>|/break> is available only if you enable the experimental
L<C<"switch"> feature|feature/The 'switch' feature> or use the C<CORE::>
prefix.  The L<C<"switch"> feature|feature/The 'switch' feature> also
enables the C<default>, C<given> and C<when> statements, which are
documented in L<perlsyn/"Switch Statements">.
The L<C<"switch"> feature|feature/The 'switch' feature> is enabled
automatically with a C<use v5.10> (or higher) declaration in the current
scope.  In Perl v5.14 and earlier, L<C<continue>|/continue BLOCK>
required the L<C<"switch"> feature|feature/The 'switch' feature>, like
the other keywords.

=end original

L<C<break>|/break> は、実験的な
L<C<"switch"> 機能|feature/The 'switch' feature> が有効か C<CORE::> 接頭辞を
使ったときにのみ利用可能です。
L<C<"switch"> 機能|feature/The 'switch' feature> は、
L<perlsyn/"Switch Statements"> で文書化されている
C<default>, C<given>, C<when> 文も有効にします。
L<C<"switch"> 機能|feature/The 'switch' feature> は、現在のスコープで
C<use v5.10> (またはそれ以上) 宣言があると自動的に有効になります。
Perl v5.14 以前では、L<C<continue>|/continue BLOCK> は他のキーワードと同様に
L<C<"switch"> 機能|feature/The 'switch' feature> が必要です。

=begin original

L<C<evalbytes>|/evalbytes EXPR> is only available with the
L<C<"evalbytes"> feature|feature/The 'unicode_eval' and 'evalbytes' features>
(see L<feature>) or if prefixed with C<CORE::>.  L<C<__SUB__>|/__SUB__>
is only available with the
L<C<"current_sub"> feature|feature/The 'current_sub' feature> or if
prefixed with C<CORE::>.  Both the
L<C<"evalbytes">|feature/The 'unicode_eval' and 'evalbytes' features>
and L<C<"current_sub">|feature/The 'current_sub' feature> features are
enabled automatically with a C<use v5.16> (or higher) declaration in the
current scope.

=end original

L<C<evalbytes>|/evalbytes EXPR> は
L<C<"evalbytes"> 機能|feature/The 'unicode_eval' and 'evalbytes' features>
(L<feature> 参照) が有効か C<CORE::> が前置されたときにのみ利用可能です。
L<C<__SUB__>|/__SUB__> は
L<C<"current_sub"> 機能|feature/The 'current_sub' feature> が有効か
C<CORE::> が前置されたときにのみ利用可能です。
L<C<"evalbytes">|feature/The 'unicode_eval' and 'evalbytes' features> と
L<C<"current_sub">|feature/The 'current_sub' feature> の両方の機能は
現在のスコープで
C<use v5.16> (またはそれ以上) が宣言されると自動的に有効になります。

=item Keywords related to scoping

(スコープに関するキーワード)

=for Pod::Functions =Namespace

L<C<caller>|/caller EXPR>,
L<C<class>|/class NAMESPACE>, 
L<C<field>|/field VARNAME>,
L<C<import>|/import LIST>,
L<C<local>|/local EXPR>,
L<C<my>|/my VARLIST>,
L<C<our>|/our VARLIST>,
L<C<package>|/package NAMESPACE>,
L<C<state>|/state VARLIST>,
L<C<use>|/use Module VERSION LIST>

=begin original

L<C<state>|/state VARLIST> is available only if the
L<C<"state"> feature|feature/The 'state' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"state"> feature|feature/The 'state' feature> is enabled
automatically with a C<use v5.10> (or higher) declaration in the current
scope.

=end original

L<C<state>|/state VARLIST> は
L<C<"state"> 機能|feature/The 'state' feature> が有効か C<CORE::> を
前置した場合にのみ利用可能です。
L<C<"state"> 機能|feature/The 'state' feature> は現在のスコープで
C<use v5.10> (またはそれ以上) を宣言した場合自動的に有効になります。

=item Miscellaneous functions

(さまざまな関数)

=for Pod::Functions =Misc

L<C<defined>|/defined EXPR>, L<C<formline>|/formline PICTURE,LIST>,
L<C<lock>|/lock THING>, L<C<prototype>|/prototype FUNCTION>,
L<C<reset>|/reset EXPR>, L<C<scalar>|/scalar EXPR>,
L<C<undef>|/undef EXPR>

=item Functions for processes and process groups
X<process> X<pid> X<process id>

(プロセスとプロセスグループのための関数)

=for Pod::Functions =Process

L<C<alarm>|/alarm SECONDS>, L<C<exec>|/exec LIST>, L<C<fork>|/fork>,
L<C<getpgrp>|/getpgrp PID>, L<C<getppid>|/getppid>,
L<C<getpriority>|/getpriority WHICH,WHO>, L<C<kill>|/kill SIGNAL, LIST>,
L<C<pipe>|/pipe READHANDLE,WRITEHANDLE>,
L<C<qxE<sol>E<sol>>|/qxE<sol>STRINGE<sol>>,
L<C<readpipe>|/readpipe EXPR>, L<C<setpgrp>|/setpgrp PID,PGRP>,
L<C<setpriority>|/setpriority WHICH,WHO,PRIORITY>,
L<C<sleep>|/sleep EXPR>, L<C<system>|/system LIST>, L<C<times>|/times>,
L<C<wait>|/wait>, L<C<waitpid>|/waitpid PID,FLAGS>

=item Keywords related to Perl modules
X<module>

(Perl モジュールに関するキーワード)

=for Pod::Functions =Modules

L<C<do>|/do EXPR>, L<C<import>|/import LIST>,
L<C<no>|/no MODULE VERSION LIST>, L<C<package>|/package NAMESPACE>,
L<C<require>|/require VERSION>, L<C<use>|/use Module VERSION LIST>

=item Keywords related to classes and object-orientation
X<object> X<class> X<package>

(クラスとオブジェクト指向に関するキーワード)

=for Pod::Functions =Objects

L<C<bless>|/bless REF,CLASSNAME>,
L<C<class>|/class NAMESPACE>,
L<C<__CLASS__>|/__CLASS__>,
L<C<dbmclose>|/dbmclose HASH>,
L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK>,
L<C<field>|/field VARNAME>,
L<C<method>|/method NAME BLOCK>,
L<C<package>|/package NAMESPACE>,
L<C<ref>|/ref EXPR>,
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST>,
L<C<tied>|/tied VARIABLE>,
L<C<untie>|/untie VARIABLE>,
L<C<use>|/use Module VERSION LIST>

=item Low-level socket functions
X<socket> X<sock>

(低レベルソケット関数)

=for Pod::Functions =Socket

L<C<accept>|/accept NEWSOCKET,GENERICSOCKET>,
L<C<bind>|/bind SOCKET,NAME>, L<C<connect>|/connect SOCKET,NAME>,
L<C<getpeername>|/getpeername SOCKET>,
L<C<getsockname>|/getsockname SOCKET>,
L<C<getsockopt>|/getsockopt SOCKET,LEVEL,OPTNAME>,
L<C<listen>|/listen SOCKET,QUEUESIZE>,
L<C<recv>|/recv SOCKET,SCALAR,LENGTH,FLAGS>,
L<C<send>|/send SOCKET,MSG,FLAGS,TO>,
L<C<setsockopt>|/setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL>,
L<C<shutdown>|/shutdown SOCKET,HOW>,
L<C<socket>|/socket SOCKET,DOMAIN,TYPE,PROTOCOL>,
L<C<socketpair>|/socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL>

=item System V interprocess communication functions
X<IPC> X<System V> X<semaphore> X<shared memory> X<memory> X<message>

(System V プロセス間通信関数)

=for Pod::Functions =SysV

L<C<msgctl>|/msgctl ID,CMD,ARG>, L<C<msgget>|/msgget KEY,FLAGS>,
L<C<msgrcv>|/msgrcv ID,VAR,SIZE,TYPE,FLAGS>,
L<C<msgsnd>|/msgsnd ID,MSG,FLAGS>,
L<C<semctl>|/semctl ID,SEMNUM,CMD,ARG>,
L<C<semget>|/semget KEY,NSEMS,FLAGS>, L<C<semop>|/semop KEY,OPSTRING>,
L<C<shmctl>|/shmctl ID,CMD,ARG>, L<C<shmget>|/shmget KEY,SIZE,FLAGS>,
L<C<shmread>|/shmread ID,VAR,POS,SIZE>,
L<C<shmwrite>|/shmwrite ID,STRING,POS,SIZE>

=item Fetching user and group info
X<user> X<group> X<password> X<uid> X<gid>  X<passwd> X</etc/passwd>

(ユーザーとグループの情報取得)

=for Pod::Functions =User

L<C<endgrent>|/endgrent>, L<C<endhostent>|/endhostent>,
L<C<endnetent>|/endnetent>, L<C<endpwent>|/endpwent>,
L<C<getgrent>|/getgrent>, L<C<getgrgid>|/getgrgid GID>,
L<C<getgrnam>|/getgrnam NAME>, L<C<getlogin>|/getlogin>,
L<C<getpwent>|/getpwent>, L<C<getpwnam>|/getpwnam NAME>,
L<C<getpwuid>|/getpwuid UID>, L<C<setgrent>|/setgrent>,
L<C<setpwent>|/setpwent>

=item Fetching network info
X<network> X<protocol> X<host> X<hostname> X<IP> X<address> X<service>

(ネットワーク情報取得)

=for Pod::Functions =Network

L<C<endprotoent>|/endprotoent>, L<C<endservent>|/endservent>,
L<C<gethostbyaddr>|/gethostbyaddr ADDR,ADDRTYPE>,
L<C<gethostbyname>|/gethostbyname NAME>, L<C<gethostent>|/gethostent>,
L<C<getnetbyaddr>|/getnetbyaddr ADDR,ADDRTYPE>,
L<C<getnetbyname>|/getnetbyname NAME>, L<C<getnetent>|/getnetent>,
L<C<getprotobyname>|/getprotobyname NAME>,
L<C<getprotobynumber>|/getprotobynumber NUMBER>,
L<C<getprotoent>|/getprotoent>,
L<C<getservbyname>|/getservbyname NAME,PROTO>,
L<C<getservbyport>|/getservbyport PORT,PROTO>,
L<C<getservent>|/getservent>, L<C<sethostent>|/sethostent STAYOPEN>,
L<C<setnetent>|/setnetent STAYOPEN>,
L<C<setprotoent>|/setprotoent STAYOPEN>,
L<C<setservent>|/setservent STAYOPEN>

=item Time-related functions
X<time> X<date>

(時刻に関する関数)

=for Pod::Functions =Time

L<C<gmtime>|/gmtime EXPR>, L<C<localtime>|/localtime EXPR>,
L<C<time>|/time>, L<C<times>|/times>

=item Non-function keywords

=for Pod::Functions =!Non-functions

C<ADJUST>,
C<and>,
C<AUTOLOAD>,
C<BEGIN>,
C<catch>,
C<CHECK>,
C<cmp>,
C<CORE>,
C<__DATA__>,
C<default>,
C<defer>,
C<DESTROY>,
C<else>,
C<elseif>,
C<elsif>,
C<END>,
C<__END__>,
C<eq>,
C<finally>,
C<for>,
C<foreach>,
C<ge>,
C<given>,
C<gt>,
C<if>,
C<INIT>,
C<isa>,
C<le>,
C<lt>,
C<ne>,
C<not>,
C<or>,
C<try>,
C<UNITCHECK>,
C<unless>,
C<until>,
C<when>,
C<while>,
C<x>,
C<xor>

=back

=head2 Portability
X<portability> X<Unix> X<portable>

(移植性)

=begin original

Perl was born in Unix and can therefore access all common Unix
system calls.  In non-Unix environments, the functionality of some
Unix system calls may not be available or details of the available
functionality may differ slightly.  The Perl functions affected
by this are:

=end original

Perl は Unix 環境で生まれたので、全ての共通する Unix システムコールに
アクセスします。
非 Unix 環境では、いくつかの Unix システムコールの機能が使えなかったり、
使える機能の詳細が多少異なったりします。
これによる影響を受ける Perl 関数は以下のものです:

L<C<-I<X>>|/-X FILEHANDLE>, L<C<binmode>|/binmode FILEHANDLE, LAYER>,
L<C<chmod>|/chmod LIST>, L<C<chown>|/chown LIST>,
L<C<chroot>|/chroot FILENAME>, L<C<crypt>|/crypt PLAINTEXT,SALT>,
L<C<dbmclose>|/dbmclose HASH>, L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK>,
L<C<dump>|/dump LABEL>, L<C<endgrent>|/endgrent>,
L<C<endhostent>|/endhostent>, L<C<endnetent>|/endnetent>,
L<C<endprotoent>|/endprotoent>, L<C<endpwent>|/endpwent>,
L<C<endservent>|/endservent>, L<C<exec>|/exec LIST>,
L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR>,
L<C<flock>|/flock FILEHANDLE,OPERATION>, L<C<fork>|/fork>,
L<C<getgrent>|/getgrent>, L<C<getgrgid>|/getgrgid GID>,
L<C<gethostbyname>|/gethostbyname NAME>, L<C<gethostent>|/gethostent>,
L<C<getlogin>|/getlogin>,
L<C<getnetbyaddr>|/getnetbyaddr ADDR,ADDRTYPE>,
L<C<getnetbyname>|/getnetbyname NAME>, L<C<getnetent>|/getnetent>,
L<C<getppid>|/getppid>, L<C<getpgrp>|/getpgrp PID>,
L<C<getpriority>|/getpriority WHICH,WHO>,
L<C<getprotobynumber>|/getprotobynumber NUMBER>,
L<C<getprotoent>|/getprotoent>, L<C<getpwent>|/getpwent>,
L<C<getpwnam>|/getpwnam NAME>, L<C<getpwuid>|/getpwuid UID>,
L<C<getservbyport>|/getservbyport PORT,PROTO>,
L<C<getservent>|/getservent>,
L<C<getsockopt>|/getsockopt SOCKET,LEVEL,OPTNAME>,
L<C<glob>|/glob EXPR>, L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR>,
L<C<kill>|/kill SIGNAL, LIST>, L<C<link>|/link OLDFILE,NEWFILE>,
L<C<lstat>|/lstat FILEHANDLE>, L<C<msgctl>|/msgctl ID,CMD,ARG>,
L<C<msgget>|/msgget KEY,FLAGS>,
L<C<msgrcv>|/msgrcv ID,VAR,SIZE,TYPE,FLAGS>,
L<C<msgsnd>|/msgsnd ID,MSG,FLAGS>, L<C<open>|/open FILEHANDLE,MODE,EXPR>,
L<C<pipe>|/pipe READHANDLE,WRITEHANDLE>, L<C<readlink>|/readlink EXPR>,
L<C<rename>|/rename OLDNAME,NEWNAME>,
L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT>,
L<C<semctl>|/semctl ID,SEMNUM,CMD,ARG>,
L<C<semget>|/semget KEY,NSEMS,FLAGS>, L<C<semop>|/semop KEY,OPSTRING>,
L<C<setgrent>|/setgrent>, L<C<sethostent>|/sethostent STAYOPEN>,
L<C<setnetent>|/setnetent STAYOPEN>, L<C<setpgrp>|/setpgrp PID,PGRP>,
L<C<setpriority>|/setpriority WHICH,WHO,PRIORITY>,
L<C<setprotoent>|/setprotoent STAYOPEN>, L<C<setpwent>|/setpwent>,
L<C<setservent>|/setservent STAYOPEN>,
L<C<setsockopt>|/setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL>,
L<C<shmctl>|/shmctl ID,CMD,ARG>, L<C<shmget>|/shmget KEY,SIZE,FLAGS>,
L<C<shmread>|/shmread ID,VAR,POS,SIZE>,
L<C<shmwrite>|/shmwrite ID,STRING,POS,SIZE>,
L<C<socket>|/socket SOCKET,DOMAIN,TYPE,PROTOCOL>,
L<C<socketpair>|/socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL>,
L<C<stat>|/stat FILEHANDLE>, L<C<symlink>|/symlink OLDFILE,NEWFILE>,
L<C<syscall>|/syscall NUMBER, LIST>,
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE>,
L<C<system>|/system LIST>, L<C<times>|/times>,
L<C<truncate>|/truncate FILEHANDLE,LENGTH>, L<C<umask>|/umask EXPR>,
L<C<unlink>|/unlink LIST>, L<C<utime>|/utime LIST>, L<C<wait>|/wait>,
L<C<waitpid>|/waitpid PID,FLAGS>

=begin original

For more information about the portability of these functions, see
L<perlport> and other available platform-specific documentation.

=end original

これらの関数の移植性に関するさらなる情報については、
L<perlport> とその他のプラットホーム固有のドキュメントを参照してください。

=head2 Alphabetical Listing of Perl Functions

=over

=item -X FILEHANDLE
X<-r>X<-w>X<-x>X<-o>X<-R>X<-W>X<-X>X<-O>X<-e>X<-z>X<-s>X<-f>X<-d>X<-l>X<-p>
X<-S>X<-b>X<-c>X<-t>X<-u>X<-g>X<-k>X<-T>X<-B>X<-M>X<-A>X<-C>

=item -X EXPR

=item -X DIRHANDLE

=item -X

=for Pod::Functions a file test (-r, -x, etc)

=begin original

A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename, a filehandle, or a dirhandle,
and tests the associated file to see if something is true about it.  If the
argument is omitted, tests L<C<$_>|perlvar/$_>, except for C<-t>, which
tests STDIN.  Unless otherwise documented, it returns C<1> for true and
C<''> for false.  If the file doesn't exist or can't be examined, it
returns L<C<undef>|/undef EXPR> and sets L<C<$!>|perlvar/$!> (errno).
With the exception of the C<-l> test they all follow symbolic links
because they use C<stat()> and not C<lstat()> (so dangling symlinks can't
be examined and will therefore report failure).

=end original

X は以下にあげる文字で、ファイルテストを行ないます。
この単項演算子は、ファイル名かファイルハンドルを唯一の引数として動作し、
「あること」について真であるか否かを判定した結果を返します。
引数が省略されると、C<-t> では STDIN を調べますが、その他は
L<C<$_>|perlvar/$_> を調べます。
特に記述されていなければ、真として C<1> を返し、偽として C<''> を返します。
ファイルが存在しないか、テスト出来なければ、L<C<undef>|/undef EXPR> を返し、
L<C<$!>|perlvar/$!> (errno) を設定します。
C<-l> テストを例外として、これら全てはシンボリックリンクに従います;
C<lstat()> ではなく C<stat()> を使っているからです
(従って壊れたシンボリックリンクは検査されず、失敗が報告されます)。

=begin original

Despite the funny names, precedence is the same as any other named unary
operator.  The operator may be any of:

=end original

みかけは変わっていますが、優先順位は名前付き単項演算子と同じで、
他の単項演算子と同じく、引数を括弧で括ることもできます。
演算子には以下のものがあります:

=begin original

    -r  File is readable by effective uid/gid.
    -w  File is writable by effective uid/gid.
    -x  File is executable by effective uid/gid.
    -o  File is owned by effective uid.

=end original

    -r  ファイルが実効 uid/gid で読み出し可。
    -w  ファイルが実効 uid/gid で書き込み可。
    -x  ファイルが実効 uid/gid で実行可。
    -o  ファイルが実効 uid の所有物。

=begin original

    -R  File is readable by real uid/gid.
    -W  File is writable by real uid/gid.
    -X  File is executable by real uid/gid.
    -O  File is owned by real uid.

=end original

    -R  ファイルが実 uid/gid で読み出し可。
    -W  ファイルが実 uid/gid で書き込み可。
    -X  ファイルが実 uid/gid で実行可。
    -O  ファイルが実 uid の所有物。

=begin original

    -e  File exists.
    -z  File has zero size (is empty).
    -s  File has nonzero size (returns size in bytes).

=end original

    -e  ファイルが存在する。
    -z  ファイルの大きさがゼロ(空)。
    -s  ファイルの大きさがゼロ以外 (バイト単位での大きさを返す)。

=begin original

    -f  File is a plain file.
    -d  File is a directory.
    -l  File is a symbolic link (false if symlinks aren't
        supported by the file system).
    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
    -S  File is a socket.
    -b  File is a block special file.
    -c  File is a character special file.
    -t  Filehandle is opened to a tty.

=end original

    -f  ファイルは通常ファイル。
    -d  ファイルはディレクトリ。
    -l  ファイルはシンボリックリンク(ファイルシステムが非対応なら偽)。
    -p  ファイルは名前付きパイプ (FIFO) またはファイルハンドルはパイプ。
    -S  ファイルはソケット。
    -b  ファイルはブロック特殊ファイル。
    -c  ファイルはキャラクタ特殊ファイル。
    -t  ファイルハンドルは tty にオープンされている。

=begin original

    -u  File has setuid bit set.
    -g  File has setgid bit set.
    -k  File has sticky bit set.

=end original

    -u  ファイルの setuid ビットがセットされている。
    -g  ファイルの setgid ビットがセットされている。
    -k  ファイルの sticky ビットがセットされている。

=begin original

    -T  File is an ASCII or UTF-8 text file (heuristic guess).
    -B  File is a "binary" file (opposite of -T).

=end original

    -T  ファイルは ASCII または UTF-8 テキストファイル (発見的に推測します)。
    -B  ファイルは「バイナリ」ファイル (-T の反対)。

=begin original

    -M  Script start time minus file modification time, in days.
    -A  Same for access time.
    -C  Same for inode change time (Unix, may differ for other
	platforms)

=end original

    -M  スクリプト実行開始時刻からファイル修正時刻を引いたもの(日単位)。
    -A  同様にアクセスがあってからの日数。
    -C  同様に(Unix では) inode が変更されてからの日数(それ以外の
	プラットフォームでは違うかもしれません)。

=begin original

Example:

=end original

例:

    while (<>) {
        chomp;
        next unless -f $_;  # ignore specials
        #...
    }

=begin original

Note that C<-s/a/b/> does not do a negated substitution.  Saying
C<-exp($foo)> still works as expected, however: only single letters
following a minus are interpreted as file tests.

=end original

C<-s/a/b> は、置換演算 (s///) の符号反転ではありません。
しかし、C<-exp($foo)> は期待どおりに動作します; しかし、マイナス記号の後に
英字が 1 字続くときにのみ、ファイルテストと解釈されます。

=begin original

These operators are exempt from the "looks like a function rule" described
above.  That is, an opening parenthesis after the operator does not affect
how much of the following code constitutes the argument.  Put the opening
parentheses before the operator to separate it from code that follows (this
applies only to operators with higher precedence than unary operators, of
course):

=end original

これらの演算子は上述の「関数のように見えるルール」から免除されます。
つまり、演算子の後の開きかっこは、引き続くコードのどこまでが引数を
構成するかに影響を与えません。
演算子を引き続くコードから分離するには、演算子の前に開きかっこを
置いてください (これはもちろん、単項演算子より高い優先順位を持つ
演算子にのみ適用されます):

    -s($file) + 1024   # probably wrong; same as -s($file + 1024)
    (-s $file) + 1024  # correct

=begin original

The interpretation of the file permission operators C<-r>, C<-R>,
C<-w>, C<-W>, C<-x>, and C<-X> is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.  Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.

=end original

ファイルのパーミッション演算子 C<-r>, C<-R>, C<-w>, C<-W>, C<-x>,
C<-X> の解釈は、ファイルのモードとユーザの実効／実 uid と
実効／実 gid のみから判断されます。
実際にファイルが読めたり、書けたり、実行できたりするためには、
別の条件が必要かもしれません:
例えば、ネットワークファイルシステムアクセスコントロール、
ACL(アクセスコントロールリスト)、読み込み専用ファイルシステム、
認識できない実行ファイルフォーマット、などです。
これらの 6 つの演算子を、特定の操作が可能かどうかを確認するために使うのは
通常は誤りであることに注意してください; なぜなら、これらは競合条件を
招きやすいからです。

=begin original

Also note that, for the superuser on the local filesystems, the C<-r>,
C<-R>, C<-w>, and C<-W> tests always return 1, and C<-x> and C<-X> return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a L<C<stat>|/stat FILEHANDLE> to determine the
actual mode of the file, or temporarily set their effective uid to
something else.

=end original

ローカルファイルシステムのスーパーユーザには、
C<-r>, C<-R>, C<-w>, C<-W> に対して、常に 1 が返り、モード中の
いずれかの実行許可ビットが立っていれば、C<-x>, C<-X> にも 1 が
返ることにも注意してください。
スーパーユーザが実行するスクリプトでは、ファイルのモードを調べるためには、
L<C<stat>|/stat FILEHANDLE> を行なうか、実効 uid を一時的に別のものにする
必要があるでしょう。

=begin original

If you are using ACLs, there is a pragma called L<C<filetest>|filetest>
that may produce more accurate results than the bare
L<C<stat>|/stat FILEHANDLE> mode bits.
When under C<use filetest 'access'>, the above-mentioned filetests
test whether the permission can(not) be granted using the L<access(2)>
family of system calls.  Also note that the C<-x> and C<-X> tests may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls' definitions.  Note also that, due to
the implementation of C<use filetest 'access'>, the C<_> special
filehandle won't cache the results of the file tests when this pragma is
in effect.  Read the documentation for the L<C<filetest>|filetest>
pragma for more information.

=end original

ACL を使っている場合は、生の L<C<stat>|/stat FILEHANDLE> モードビットより
精度の高い結果を作成する L<C<filetest>|filetest> プラグマがあります。
C<use filetest 'access'> とした場合、上述したファイルテストは
システムコールの L<access(2)> ファミリーを使って権限が与えられているか
どうかをテストします。
また、このプラグマが指定されている場合、C<-x> と C<-X> テストは
たとえ実行許可ビット(または追加の実行許可 ACL)がセットされていない
場合でも真を返すことに注意してください。
この挙動は使用するシステムコールの定義によるものです。
C<use filetest 'access'> の実装により、このプラグマが有効の場合は
C<_> 特殊ファイルハンドルはファイルテストの結果をキャッシュしないことに
注意してください。
さらなる情報については L<C<filetest>|filetest> プラグマのドキュメントを
参照してください。

=begin original

The C<-T> and C<-B> tests work as follows.  The first block or so of
the file is examined to see if it is valid UTF-8 that includes non-ASCII
characters.  If so, it's a C<-T> file.  Otherwise, that same portion of
the file is examined for odd characters such as strange control codes or
characters with the high bit set.  If more than a third of the
characters are strange, it's a C<-B> file; otherwise it's a C<-T> file.
Also, any file containing a zero byte in the examined portion is
considered a binary file.  (If executed within the scope of a L<S<use
locale>|perllocale> which includes C<LC_CTYPE>, odd characters are
anything that isn't a printable nor space in the current locale.)  If
C<-T> or C<-B> is used on a filehandle, the current IO buffer is
examined
rather than the first block.  Both C<-T> and C<-B> return true on an empty
file, or a file at EOF when testing a filehandle.  Because you have to
read a file to do the C<-T> test, on most occasions you want to use a C<-f>
against the file first, as in C<next unless -f $file && -T $file>.

=end original

ファイルテスト C<-T> と C<-B> の動作原理は、次のようになっています。
ファイルの最初の数ブロックを調べて、非 ASCII 文字を含む妥当な UTF-8 かどうかを
調べます。
もしそうなら、それは C<-T> ファイルです。
さもなければ、ファイルの同じ位置から、変わった制御コードや
上位ビットがセットされているような、通常のテキストには現れない文字を探します。
三分の一以上がおかしな文字なら、それは C<-B> ファイルでです;
さもなければ C<-T> ファイルです。
また、調べた位置にヌル文字が含まれるファイルも、バイナリファイルと
みなされます。
(C<LC_CTYPE> を含む L<S<use locale>|perllocale> のスコープの中で実行されると、
おかしな文字というのは現在のロケールで表示可能でもスペースでもないものです。)
C<-T> や C<-B> をファイルハンドルに対して用いると、
最初のブロックを調べる代わりに、IO バッファを調べます。
調べたファイルの中身が何もないときや、
ファイルハンドルを調べたときに EOF に達して
いたときには、C<-T> も C<-B> も「真」を返します。
C<-T> テストをするためにはファイルを読み込まないといけないので、
たいていは C<next unless -f $file && -T $file> というような形で
まず調べたいファイルに対して C<-f> を使いたいはずです。

=begin original

If any of the file tests (or either the L<C<stat>|/stat FILEHANDLE> or
L<C<lstat>|/lstat FILEHANDLE> operator) is given the special filehandle
consisting of a solitary underline, then the stat structure of the
previous file test (or L<C<stat>|/stat FILEHANDLE> operator) is used,
saving a system call.  (This doesn't work with C<-t>, and you need to
remember that L<C<lstat>|/lstat FILEHANDLE> and C<-l> leave values in
the stat structure for the symbolic link, not the real file.)  (Also, if
the stat buffer was filled by an L<C<lstat>|/lstat FILEHANDLE> call,
C<-T> and C<-B> will reset it with the results of C<stat _>).
Example:

=end original

どのファイルテスト (あるいは、L<C<stat>|/stat FILEHANDLE> や
L<C<lstat>|/lstat FILEHANDLE>) 演算子にも、
下線だけから成る特別なファイルハンドルを与えると、
前回のファイルテスト (や L<C<stat>|/stat FILEHANDLE> 演算子) の
stat 構造体が使われ、システムコールを省きます。
(C<-t> には使えませんし、L<C<lstat>|/lstat FILEHANDLE> や C<-l> は
実ファイルではなく、シンボリックリンクの情報を stat 構造体に残すことを
覚えておく必要があります。)
(また、stat バッファが L<C<lstat>|/lstat FILEHANDLE> 呼び出しで埋まった場合、
C<-T> と C<-B> の結果は C<stat _> の結果でリセットされます。
例:

    print "Can do.\n" if -r $x || -w _ || -x _;

    stat($filename);
    print "Readable\n" if -r _;
    print "Writable\n" if -w _;
    print "Executable\n" if -x _;
    print "Setuid\n" if -u _;
    print "Setgid\n" if -g _;
    print "Sticky\n" if -k _;
    print "Text\n" if -T _;
    print "Binary\n" if -B _;

=begin original

As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file
test operators, in a way that C<-f -w -x $file> is equivalent to
C<-x $file && -w _ && -f _>.  (This is only fancy syntax: if you use
the return value of C<-f $file> as an argument to another filetest
operator, no special magic will happen.)

=end original

Perl 5.10.0 から、純粋にシンタックスシュガーとして、ファイルテスト演算子を
スタックさせることができるので、C<-f -w -x $file> は
C<-x $file && -w _ && -f _> と等価です。
(これは文法上だけの話です; もし C<-f $file> の返り値を他のファイルテスト
演算子の引数として使う場合は、何の特別なことも起きません。)

=begin original

Portability issues: L<perlport/-X>.

=end original

移植性の問題: L<perlport/-X>。

=begin original

To avoid confusing would-be users of your code with mysterious
syntax errors, put something like this at the top of your script:

=end original

あなたのコードのユーザーが不思議な文法エラーで混乱することを
避けるために、スクリプトの先頭に以下のようなことを書いてください:

    use v5.10;  # so filetest ops can stack

=item abs VALUE
X<abs> X<absolute>

=item abs

=for Pod::Functions absolute value function

=begin original

Returns the absolute value of its argument.
If VALUE is omitted, uses L<C<$_>|perlvar/$_>.

=end original

引数の絶対値を返します。
VALUE が省略された場合は、L<C<$_>|perlvar/$_> を使います。

=item accept NEWSOCKET,GENERICSOCKET
X<accept>

=for Pod::Functions accept an incoming socket connect

=begin original

Accepts an incoming socket connect, just as L<accept(2)>
does.  Returns the packed address if it succeeded, false otherwise.
See the example in L<perlipc/"Sockets: Client/Server Communication">.

=end original

L<accept(2)> システムコールと同様に、着信するソケットの接続を受け付けます。
成功時にはパックされたアドレスを返し、失敗すれば偽を返します。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of L<C<$^F>|perlvar/$^F>.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは L<C<$^F>|perlvar/$^F> の値で決定される、新しくオープンされた
ファイル記述子に対してセットされます。
L<perlvar/$^F> を参照してください。

=item alarm SECONDS
X<alarm>
X<SIGALRM>
X<timer>

=item alarm

=for Pod::Functions schedule a SIGALRM

=begin original

Arranges to have a SIGALRM delivered to this process after the
specified number of wallclock seconds has elapsed.  If SECONDS is not
specified, the value stored in L<C<$_>|perlvar/$_> is used.  (On some
machines, unfortunately, the elapsed time may be up to one second less
or more than you specified because of how seconds are counted, and
process scheduling may delay the delivery of the signal even further.)

=end original

指定した壁時計秒数が経過した後に、自プロセスに SIGALRM が
送られてくるようにします。
SECONDS が指定されていない場合は、L<C<$_>|perlvar/$_> に格納されている値を
使います。
(マシンによっては、秒の数え方が異なるため、指定した秒数よりも最大で
1 秒ずれます。)

=begin original

Only one timer may be counting at once.  Each call disables the
previous timer, and an argument of C<0> may be supplied to cancel the
previous timer without starting a new one.  The returned value is the
amount of time remaining on the previous timer.

=end original

一度には一つのタイマだけが設定可能です。
呼び出しを行なう度に、以前のタイマを無効にしますし、
新しくタイマを起動しないで以前のタイマをキャンセルするために
引数に C<0> を指定して呼び出すことができます。
以前のタイマの残り時間が、返り値となります。

=begin original

For delays of finer granularity than one second, the L<Time::HiRes> module
(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides
L<C<ualarm>|Time::HiRes/ualarm ( $useconds [, $interval_useconds ] )>.
You may also use Perl's four-argument version of
L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> leaving the first three
arguments undefined, or you might be able to use the
L<C<syscall>|/syscall NUMBER, LIST> interface to access L<setitimer(2)>
if your system supports it.  See L<perlfaq8> for details.

=end original

1 秒より精度の高いスリープを行なうには、L<Time::HiRes> モジュール(CPAN から、
また Perl 5.8 からは標準配布されています) が
L<C<usleep>|Time::HiRes/usleep ( $useconds )> を提供します。
Perl の 4 引数版 L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> を最初の
3 引数を未定義にして使うか、L<setitimer(2)> をサポートしているシステムでは、
Perl の L<C<syscall>|/syscall NUMBER, LIST> インタフェースを使って
アクセスすることもできます。
詳しくは L<perlfaq8> を参照してください。

=begin original

It is usually a mistake to intermix C<alarm> and
L<C<sleep>|/sleep EXPR> calls, because L<C<sleep>|/sleep EXPR> may be
internally implemented on your system with C<alarm>.

=end original

C<alarm> と L<C<sleep>|/sleep EXPR> を混ぜて使うのは
普通は間違いです; なぜなら、L<C<sleep>|/sleep EXPR> は内部的に
C<alarm> を使って内部的に実装されているかも
しれないからです。

=begin original

If you want to use C<alarm> to time out a system call
you need to use an L<C<eval>|/eval EXPR>/L<C<die>|/die LIST> pair.  You
can't rely on the alarm causing the system call to fail with
L<C<$!>|perlvar/$!> set to C<EINTR> because Perl sets up signal handlers
to restart system calls on some systems.  Using
L<C<eval>|/eval EXPR>/L<C<die>|/die LIST> always works, modulo the
caveats given in L<perlipc/"Signals">.

=end original

C<alarm> をシステムコールの時間切れのために使いたいなら、
L<C<eval>|/eval EXPR>/L<C<die>|/die LIST> のペアで使う必要があります。
システムコールが失敗したときに L<C<$!>|perlvar/$!> に C<EINTR> が
セットされることに頼ってはいけません; なぜならシステムによっては Perl は
システムコールを再開するためにシグナルハンドラを設定するからです。
L<C<eval>|/eval EXPR>/L<C<die>|/die LIST> は常にうまく動きます;
注意点については L<perlipc/"Signals"> を参照してください。

    eval {
        local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
        alarm $timeout;
        my $nread = sysread $socket, $buffer, $size;
        alarm 0;
    };
    if ($@) {
        die unless $@ eq "alarm\n";   # propagate unexpected errors
        # timed out
    }
    else {
        # didn't
    }

=begin original

For more information see L<perlipc>.

=end original

さらなる情報については L<perlipc> を参照してください。

=begin original

Portability issues: L<perlport/alarm>.

=end original

移植性の問題: L<perlport/alarm>。

=item all BLOCK LIST

=for Pod::Functions test if every value in a list satisfies the given condition

=begin original

Evaluates the BLOCK for each element of the LIST (locally setting
L<C<$_>|perlvar/$_> to each element) and checks the truth of the result of
that block.  Returns true if every element makes the block yield true, or
returns false if at least one element makes the block false.

=end original

LIST の各要素に対して BLOCK を評価し(各要素はローカルに
L<C<$_>|perlvar/$_> に設定されます)、ブロックの真偽をチェックします。
全ての要素がブロックの結果を真にした場合に真になり、
少なくとも一つの要素がブロックの結果を偽にした場合に偽になります。

=begin original

As soon as any element makes the block yield false, then the result of this
operator is determined.  It will short-circuit in that case and not consider
any further elements.

=end original

どれかの要素がブロックの結果を偽にした時点で、この演算子の結果は
決定されます。
この場合短絡評価され、残りの要素は考慮されません。

=begin original

When used as a condition, this is similar to using L<C<grep>|/grep BLOCK LIST>
to count that every value satisfies the condition, except for this
short-circuit behaviour.

=end original

条件として使うと、これは次の短絡評価の振る舞いを除いて、
条件を満たす値の数を数える L<C<grep>|/grep BLOCK LIST> を
使うのと似ています。

    if( all { length $_ } @strings ) {
        say "Every string is non-empty";
    }

=begin original

is roughly equivalent to

=end original

これはおおまかに次と等価です:

    if( @strings == grep { length $_ } @strings ) ...

=begin original

This operator is only available if the
L<C<keyword_all> feature|feature/"The 'keyword_all' feature"> is enabled.

=end original

この演算子は、L<C<keyword_all> 機能|feature/"The 'keyword_all' feature"> が
有効の場合にのみ利用可能です。

=begin original

It is currently considered B<experimental>, and will issue a compile-time
warning in the category C<experimental::all> unless that category is silenced.

=end original

これは現在のところ B<実験的> と考えられており、C<experimental::all> カテゴリの
警告を抑制しない限り、このカテゴリのコンパイル時警告が発生します。

=item any BLOCK LIST

=for Pod::Functions test if at least one value in a list satisfies the given condition

=begin original

Evaluates the BLOCK for each element of the LIST (locally setting
L<C<$_>|perlvar/$_> to each element) and checks the truth of the result of
that block.  Returns true if at least one element makes the block yield
true, or returns false if no element is found to make it true.

=end original

LIST の各要素に対して BLOCK を評価し(各要素はローカルに
L<C<$_>|perlvar/$_> に設定されます)、ブロックの真偽をチェックします。
少なくとも一つの要素がブロックの結果を真にした場合に真になり、
どの要素もがブロックの結果を真にしなかった場合に偽になります。

=begin original

As soon as any element makes the block yield true, then the result of this
operator is determined.  It will short-circuit in that case and not consider
any further elements.

=end original

どれかの要素がブロックの結果を真にした時点で、この演算子の結果は
決定されます。
この場合短絡評価され、残りの要素は考慮されません。

=begin original

When used as a condition, this is similar to L<C<grep>|/grep BLOCK LIST>,
except for this short-circuit behaviour.

=end original

条件として使うと、これは次の短絡評価の振る舞いを除いて
L<C<grep>|/grep BLOCK LIST> と似ています。

    if( any { length $_ } @strings ) {
        say "At least one string is non-empty";
    }

=begin original

is roughly equivalent to

=end original

これはおおまかに次と等価です:

    if( grep { length $_ } @strings ) ...

=begin original

This operator is only available if the
L<C<keyword_any> feature|feature/"The 'keyword_any' feature"> is enabled.

=end original

この演算子は、L<C<keyword_any> 機能|feature/"The 'keyword_any' feature"> が
有効の場合にのみ利用可能です。

=begin original

It is currently considered B<experimental>, and will issue a compile-time
warning in the category C<experimental::any> unless that category is silenced.

=end original

これは現在のところ B<実験的> と考えられており、C<experimental::any> カテゴリの
警告を抑制しない限り、このカテゴリのコンパイル時警告が発生します。

=item atan2 Y,X
X<atan2> X<arctangent> X<tan> X<tangent>

=for Pod::Functions arctangent of Y/X in the range -PI to PI

=begin original

Returns the arctangent of Y/X in the range -PI to PI.

=end original

-πからπの範囲で Y/X の逆正接を返します。

=begin original

For the tangent operation, you may use the
L<C<Math::Trig::tan>|Math::Trig/B<tan>> function, or use the familiar
relation:

=end original

正接を求めたいときは、L<C<Math::Trig::tan>|Math::Trig/B<tan>> を使うか、
以下のよく知られた関係を使ってください。

    sub tan { sin($_[0]) / cos($_[0])  }

=begin original

The return value for C<atan2(0,0)> is implementation-defined; consult
your L<atan2(3)> manpage for more information.

=end original

C<atan2(0,0)> の返り値は実装依存です; さらなる情報については
L<atan2(3)> man ページを参照してください。

=begin original

Portability issues: L<perlport/atan2>.

=end original

移植性の問題: L<perlport/atan2>。

=item bind SOCKET,NAME
X<bind>

=for Pod::Functions binds an address to a socket

=begin original

Binds a network address to a socket, just as L<bind(2)>
does.  Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

L<bind(2)> システムコールと同様に、ネットワークアドレスをソケットに
結び付けます。
成功時には真を、さもなければ偽を返します。
NAME は、ソケットに対する、適切な型のパックされた
アドレスでなければなりません。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=item binmode FILEHANDLE, LAYER
X<binmode> X<binary> X<text> X<DOS> X<Windows>

=item binmode FILEHANDLE

=for Pod::Functions prepare binary files for I/O

=begin original

Arranges for FILEHANDLE to be read or written in "binary" or "text"
mode on systems where the run-time libraries distinguish between
binary and text files.  If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.  Returns true on success,
otherwise it returns L<C<undef>|/undef EXPR> and sets
L<C<$!>|perlvar/$!> (errno).

=end original

バイナリファイルとテキストファイルを区別する OS において、
FILEHANDLE を「バイナリ」または「テキスト」で読み書きするように
指定します。
FILEHANDLE が式である場合には、その式の値がファイルハンドルの
名前として使われます。
成功時には真を返し、失敗時には L<C<undef>|/undef EXPR> を返して
L<C<$!>|perlvar/$!> (errno) を設定します。

=begin original

On some systems (in general, DOS- and Windows-based systems)
C<binmode> is necessary when you're not
working with a text file.  For the sake of portability it is a good idea
always to use it when appropriate, and never to use it when it isn't
appropriate.  Also, people can set their I/O to be by default
UTF8-encoded Unicode, not bytes.

=end original

テキストファイルでないものを扱う場合に
C<binmode> が必要な
システムもあります(一般的には DOS と Windows ベースのシステムです)。
移植性のために、適切なときには常にこれを使い、適切でないときには
決して使わないというのは良い考えです。
また、デフォルトとして I/O を bytes ではなく UTF-8 エンコードされた
Unicode にセットすることも出来ます。

=begin original

In other words: regardless of platform, use
C<binmode> on binary data, like images,
for example.

=end original

言い換えると: プラットフォームに関わらず、
例えばイメージのようなバイナリファイルに対しては
C<binmode> を使ってください。

=begin original

If LAYER is present it is a single string, but may contain multiple
directives.  The directives alter the behaviour of the filehandle.
When LAYER is present, using binmode on a text file makes sense.

=end original

LAYER が存在すると、それは単一の文字列ですが、複数の指示子を
含むことができます。
指示子はファイルハンドルの振る舞いを変更します。
LAYER が存在すると、テキストファイルでの binmode が意味を持ちます。

=begin original

If LAYER is omitted or specified as C<:raw> the filehandle is made
suitable for passing binary data.  This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).
Note that, despite what may be implied in I<"Programming Perl"> (the
Camel, 3rd edition) or elsewhere, C<:raw> is I<not> simply the inverse of C<:crlf>.
Other layers that would affect the binary nature of the stream are
I<also> disabled.  See L<PerlIO>, and the discussion about the PERLIO
environment variable in L<perlrun|perlrun/PERLIO>.

=end original

LAYER が省略されたり、C<:raw> が指定されると、ファイルハンドルはバイナリ
データの通過に適するように設定されます。
これには CRLF 変換をオフにしたり、それぞれを(Unicode 文字ではなく)
バイトであるとマークしたりすることを含みます。
I<"プログラミング Perl">(ラクダ本第三版) やその他で暗示されているにも関わらず、
C<:raw> は単なる C<:crlf> の I<逆ではありません>。
ストリームのバイナリとしての性質に影響を与える
I<その他の層も無効にされます>。
L<PerlIO>, および L<perlrun|perlrun/PERLIO> の PERLIO 環境変数に関する議論を
参照してください。

=begin original

The C<:bytes>, C<:crlf>, C<:utf8>, and any other directives of the
form C<:...>, are called I/O I<layers>.  The L<open> pragma can be used to
establish default I/O layers.

=end original

C<:bytes>, C<:crlf>, and C<:utf8>, 及びその他の C<:...> 形式の指示子は
I/O I<層> が呼び出されます。
L<open> プラグマはデフォルト I/O 層を指定するために使われます。

=begin original

I<The LAYER parameter of the C<binmode>
function is described as "DISCIPLINE" in "Programming Perl, 3rd
Edition".  However, since the publishing of this book, by many known as
"Camel III", the consensus of the naming of this functionality has moved
from "discipline" to "layer".  All documentation of this version of Perl
therefore refers to "layers" rather than to "disciplines".  Now back to
the regularly scheduled documentation...>

=end original

I<C<binmode> 関数の LAYER パラメータは
「プログラミングPerl 第 3 版」では
「ディシプリン(DISCIPLINE)」と表現されていました。
しかし、「ラクダ本第 3 版」として知られているこの本の出版後、この機能の名前は
「ディシプリン」から「層」に変更することで合意されました。
従って、このバージョンの Perl の全ての文書では「ディシプリン」ではなく
「層」と記述されています。では通常の解説に戻ります…>

=begin original

To mark FILEHANDLE as UTF-8, use C<:utf8> or C<:encoding(UTF-8)>.
C<:utf8> just marks the data as UTF-8 without further checking,
while C<:encoding(UTF-8)> checks the data for actually being valid
UTF-8.  More details can be found in L<PerlIO::encoding>.

=end original

FILEHANDLE が UTF-8 であるというマークをつけるには、C<:utf8> か
C<:encoding(UTF-8)> を使ってください。
C<:utf8> は、さらなるチェックなしにデータが UTF-8 としてマークしますが、
C<:encoding(UTF-8)> はデータが実際に有効な UTF-8 かどうかをチェックします。
さらなる詳細は L<PerlIO::encoding> にあります。

=begin original

In general, C<binmode> should be called
after L<C<open>|/open FILEHANDLE,MODE,EXPR> but before any I/O is done on the
filehandle.  Calling C<binmode> normally
flushes any pending buffered output data (and perhaps pending input
data) on the handle.  An exception to this is the C<:encoding> layer
that changes the default character encoding of the handle.
The C<:encoding> layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.  C<:encoding>
also implicitly pushes on top of itself the C<:utf8> layer because
internally Perl operates on UTF8-encoded Unicode characters.

=end original

一般的に C<binmode> は
L<C<open>|/open FILEHANDLE,MODE,EXPR> を呼び出した後、このファイルハンドルに
対するI/O 操作をする前に呼び出すべきです。
C<binmode> を呼び出すと、普通はこの
ファイルハンドルに対してバッファリングされている全ての出力データ
(およびおそらくは入力データ)をフラッシュします。
例外は、このハンドルに対するデフォルト文字エンコーディングを変更する
C<:encoding> 層です。
C<:encoding> 層はストリームの途中で呼び出す必要があることがあり、
それによってストリームはフラッシュされません。
Perl は内部で UTF-8 エンコードされた Unicode 文字を操作しているので、
C<:encoding> は暗黙のうちに自身を C<:utf8> 層の上に押し上げます。

=begin original

The operating system, device drivers, C libraries, and Perl run-time
system all conspire to let the programmer treat a single
character (C<\n>) as the line terminator, irrespective of external
representation.  On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of C<\n> is made up of more than
one character.

=end original

オペレーティングシステム、デバイスドライバ、C ライブラリ、
Perl ランタイムシステムは全て、プログラマが外部表現に関わらず
1 文字 (C<\n>) を行終端として扱えるように協調作業します。
多くのオペレーティングシステムでは、ネイティブテキストファイル表現は
内部表現と同じですが、C<\n> の外部表現が複数文字になる
プラットフォームもあります。

=begin original

All variants of Unix, Mac OS (old and new), and Stream_LF files on VMS use
a single character to end each line in the external representation of text
(even though that single character is CARRIAGE RETURN on old, pre-Darwin
flavors of Mac OS, and is LINE FEED on Unix and most VMS files).  In other
systems like OS/2, DOS, and the various flavors of MS-Windows, your program
sees a C<\n> as a simple C<\cJ>, but what's stored in text files are the
two characters C<\cM\cJ>.  That means that if you don't use
C<binmode> on these systems, C<\cM\cJ>
sequences on disk will be converted to C<\n> on input, and any C<\n> in
your program will be converted back to C<\cM\cJ> on output.  This is
what you want for text files, but it can be disastrous for binary files.

=end original

全ての Unix 系、(新旧の)Mac OS、VMS の Stream_LF ファイルは
テキストの外部表現として各行の末尾に一つの文字を
使っています(しかしその文字は古い Darwin 以前の Mac OS では復帰で、
Unix とほとんどのVMS のファイルでは改行です)。
VMS, MS-DOS, MS-Windows 系といったその他のシステムでは、
プログラムからは C<\n> は単純に C<\cJ> に見えますが、
テキストファイルとして保存される場合は C<\cM\cJ> の 2 文字になります。
つまり、もしこれらのシステムで C<binmode> を
使わないと、ディスク上の C<\cM\cJ> という並びは入力時に C<\n> に変換され、
プログラムが出力した全ての C<\n> は C<\cM\cJ> に逆変換されます。
これはテキストファイルの場合は思い通りの結果でしょうが、
バイナリファイルの場合は悲惨です。

=begin original

Another consequence of using C<binmode>
(on some systems) is that special end-of-file markers will be seen as
part of the data stream.  For systems from the Microsoft family this
means that, if your binary data contain C<\cZ>, the I/O subsystem will
regard it as the end of the file, unless you use
C<binmode>.

=end original

C<binmode> を(いくつかのシステムで)
使うことによるその他の作用としては、特別なファイル終端マーカーが
データストリームの一部として見られることです。
Microsoft ファミリーのシステムでは、
C<binmode> を使っていないと、
もしバイナリデータに C<\cZ> が含まれていたときに、
I/O サブシステムがこれをファイル終端とみなすことを意味します。

=begin original

C<binmode> is important not only for
L<C<readline>|/readline EXPR> and L<C<print>|/print FILEHANDLE LIST>
operations, but also when using
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET> and
L<C<tell>|/tell FILEHANDLE> (see L<perlport> for more details).  See the
L<C<$E<sol>>|perlvar/$E<sol>> and L<C<$\>|perlvar/$\> variables in
L<perlvar> for how to manually set your input and output
line-termination sequences.

=end original

C<binmode> は L<C<readline>|/readline EXPR> と
L<C<print>|/print FILEHANDLE LIST> 操作にだけではなく、
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<tell>|/tell FILEHANDLE> を使うときにも重要です
(詳細は L<perlport> を参照してください)。
入出力の行端末シーケンスを手動でセットする方法については
L<perlvar> の L<C<$E<sol>>|perlvar/$E<sol>> 変数と
L<C<$\>|perlvar/$\> 変数を参照してください。

=begin original

Portability issues: L<perlport/binmode>.

=end original

移植性の問題: L<perlport/binmode>。

=item bless REF,CLASSNAME
X<bless>

=item bless REF

=for Pod::Functions create an object

=begin original

C<bless> tells Perl to mark the item referred to by C<REF> as an
object in a package.  The two-argument version of C<bless> is
always preferable unless there is a specific reason to I<not>
use it.

=end original

C<bless> は Perl に、C<REF> で参照しているアイテムを
パッケージのオブジェクトとしてマークします。
それを I<使わない> 明確な理由がないかぎり、
2 引数版の C<bless> が好ましいです。

=over

=item * Bless the referred-to item into a specific package
(recommended form):

    bless $ref, $package;

=begin original

The two-argument form adds the object to the package specified
as the second argument.

=end original

2 引数形式では、2 番目の引数として指定されたパッケージへの
オブジェクトを追加します。

=item * Bless the referred-to item into package C<main>:

    bless $ref, "";

=begin original

If the second argument is an empty string, C<bless> adds the
object to package C<main>.

=end original

2 番目の引数が空文字列の場合、C<bless> はパッケージ C<main> への
オブジェクトを追加します。

=item * Bless the referred-to item into the current package (not
inheritable):

    bless $ref;

=begin original

If C<bless> is used without its second argument, the object is
created in the current package. The second argument should
always be supplied if a derived class might inherit a method
executing C<bless>. Because it is a potential source of bugs,
one-argument C<bless> is discouraged.

=end original

2 番目の引数なしで C<bless> を使うと、オブジェクトは
現在のパッケージ内に作成されます。
派生クラスが C<bless> を実行するメソッドを継承する可能性がある場合は、
2 番目の引数を常に指定する必要があります。
これは潜在的なバグの元なので、引数が一つの C<bless> は
推奨されません。

=back

=begin original

See L<perlobj> for more about the blessing (and blessings) of
objects.

=end original

オブジェクトの bless についてのさらなる情報については
L<perlobj> を参照してください。

=begin original

C<bless> returns its first argument, the
supplied reference, as the value of the function; since C<bless>
is commonly the last thing executed in constructors, this means
that the reference to the object is returned as the
constructor's value and allows the caller to immediately use
this returned object in method calls.

=end original

C<bless> は、最初の引数である指定された
参照を関数の値として返します。
C<bless> は通常、コンストラクタで最後に実行されるため、
オブジェクトへの参照がコンストラクタの値として返され、
呼び出し側はこの返されたオブジェクトをメソッド呼び出しで
すぐに使用できます。

=begin original

C<CLASSNAME> should always be a mixed-case name, as
all-uppercase and all-lowercase names are meant to be used only
for Perl builtin types and pragmas, respectively. Avoid creating
all-uppercase or all-lowercase package names to prevent
confusion.

=end original

すべて大文字の名前とすべて小文字の名前は、それぞれ Perl の
組み込み型とプラグマにのみ使われるため、C<CLASSNAME> は
常に大文字と小文字が混在した名前にする必要があります。
混乱を避けるために、すべて大文字またはすべて小文字の
パッケージ名は作成しないでください。

=begin original

Also avoid C<bless>ing things into the class name C<0>; this
will cause code which (erroneously) checks the result of
C<ref> to see if a reference is C<bless>ed to fail,
as "0", a false value, is returned.

=end original

また、クラス名 C<0> に何かを C<bless> することも避けてください;
これにより、
参照が C<bless> されているかどうかを確認するために(誤って)
C<ref> の結果をチェックするコードが失敗する原因となります;
偽の値である「0」が返されるためです。

=begin original

See L<perlmod/"Perl Modules"> for more details.

=end original

さらなる詳細については L<perlmod/"Perl Modules"> を参照してください。

=item break

=for Pod::Functions +switch break out of a C<given> block

=begin original

Break out of a C<given> block.

=end original

C<given> ブロックから脱出します。

=begin original

C<break> is available only if the
L<C<"switch"> feature|feature/The 'switch' feature> is enabled or if it
is prefixed with C<CORE::>. The
L<C<"switch"> feature|feature/The 'switch' feature> is enabled
automatically with a C<use v5.10> (or higher) declaration in the current
scope.

=end original

L<C<break>|/break> は、L<C<"switch"> 機能|feature/The 'switch' feature> が
有効か、C<CORE::> 接頭辞を使ったときにのみ利用可能です。
L<C<"switch"> 機能|feature/The 'switch' feature> は、現在のスコープで
C<use v5.10> (またはそれ以上) 宣言があると自動的に有効になります。

=item caller EXPR
X<caller> X<call stack> X<stack> X<stack trace>

=item caller

=for Pod::Functions get context of the current subroutine call

=begin original

Returns the context of the current pure perl subroutine call.  In scalar
context, returns the caller's package name if there I<is> a caller (that is, if
we're in a subroutine or L<C<eval>|/eval EXPR> or
L<C<require>|/require VERSION>) and the undefined value otherwise.
C<caller> never returns XS subs and they are skipped.  The next pure perl
sub will appear instead of the XS sub in caller's return values.  In
list context, caller returns

=end original

その時点のピュア perl サブルーチン呼び出しのコンテキストを返します。
スカラコンテキストでは、呼び元が I<ある> 場合
(サブルーチン、L<C<eval>|/eval EXPR>、L<C<require>|/require VERSION> の中に
いるとき) には呼び出し元のパッケージ名を返し、
その他のときには未定義値を返します。
C<caller> は XS サブルーチンを返すことはなく、それらは飛ばされます。
XS サブルーチンの代わりに次のピュア perl サブルーチンが caller の返り値に
なります。
リストコンテキストでは、caller は以下を返します:

       # 0         1          2
    my ($package, $filename, $line) = caller;

=begin original

Like L<C<__FILE__>|/__FILE__> and L<C<__LINE__>|/__LINE__>, the filename and
line number returned here may be altered by the mechanism described at
L<perlsyn/"Plain Old Comments (Not!)">.

=end original

L<C<__FILE__>|/__FILE__> と L<C<__LINE__>|/__LINE__> 同様、
ここで返されるファイル名と行番号は
L<perlsyn/"Plain Old Comments (Not!)"> で記述されている機構によって
置き換えられます。

=begin original

With EXPR, it returns some extra information that the debugger uses to
print a stack trace.  The value of EXPR indicates how many call frames
to go back before the current one.

=end original

EXPR を付けると、デバッガがスタックトレースを表示するために使う情報を返します。
EXPR の値は、現状から数えて、
いくつ前のコールフレームまで戻るかを示します。

    #  0         1          2      3            4
 my ($package, $filename, $line, $subroutine, $hasargs,

    #  5          6          7            8       9         10
    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
  = caller($i);

=begin original

Here, $subroutine is the function that the caller called (rather than the
function containing the caller).  Note that $subroutine may be C<(eval)> if
the frame is not a subroutine call, but an L<C<eval>|/eval EXPR>.  In
such a case additional elements $evaltext and C<$is_require> are set:
C<$is_require> is true if the frame is created by a
L<C<require>|/require VERSION> or L<C<use>|/use Module VERSION LIST>
statement, $evaltext contains the text of the C<eval EXPR> statement.
In particular, for an C<eval BLOCK> statement, $subroutine is C<(eval)>,
but $evaltext is undefined.  (Note also that each
L<C<use>|/use Module VERSION LIST> statement creates a
L<C<require>|/require VERSION> frame inside an C<eval EXPR> frame.)
$subroutine may also be C<(unknown)> if this particular subroutine
happens to have been deleted from the symbol table.  C<$hasargs> is true
if a new instance of L<C<@_>|perlvar/@_> was set up for the frame.
C<$hints> and C<$bitmask> contain pragmatic hints that the caller was
compiled with.  C<$hints> corresponds to L<C<$^H>|perlvar/$^H>, and
C<$bitmask> corresponds to
L<C<${^WARNING_BITS}>|perlvar/${^WARNING_BITS}>.  The C<$hints> and
C<$bitmask> values are subject to change between versions of Perl, and
are not meant for external use.

=end original

ここで、$subroutine は、(caller を含む関数ではなく) caller が呼び出した
関数です。
フレームがサブルーチン呼び出しではなく L<C<eval>|/eval EXPR> だった場合、この
$subroutine は C<(eval)> になることに注意してください。
この場合、追加の要素である $evaltext と C<$is_require> がセットされます:
C<$is_require> はフレームが L<C<require>|/require VERSION> または
L<C<use>|/use Module VERSION LIST> で作られた場合に真になり、
$evaltext は C<eval EXPR> のテキストが入ります。
特に、C<eval BLOCK> の場合、$subroutine は C<(eval)> になりますが、
$evaltext は未定義値になります。
(それぞれの L<C<use>|/use Module VERSION LIST> は C<eval EXPR> の中で
L<C<require>|/require VERSION> フレームを作ることに注意してください。)
$subroutine は、そのサブルーチンがシンボルテーブルから削除された場合は
C<(unknown)> になります。
C<$hasargs> はこのフレーム用に L<C<@_>|perlvar/@_> の新しい実体が
設定された場合に真となります。
C<$hints> と C<$bitmask> は caller がコンパイルされたときの
実際的なヒントを含みます。
C<$hints> は L<C<$^H>|perlvar/$^H> に対応し、C<$bitmask> は
L<C<${^WARNING_BITS}>|perlvar/${^WARNING_BITS}> に
対応します。
C<$hints> は C<$bitmask> は Perl のバージョンによって変更される
可能性があるので、外部での使用を想定していません。

=begin original

C<$hinthash> is a reference to a hash containing the value of
L<C<%^H>|perlvar/%^H> when the caller was compiled, or
L<C<undef>|/undef EXPR> if L<C<%^H>|perlvar/%^H> was empty.  Do not
modify the values of this hash, as they are the actual values stored in
the optree.

=end original

C<$hinthash> は、caller がコンパイルされた時の L<C<%^H>|perlvar/%^H> の値を
含むハッシュへのリファレンスか、あるいは L<C<%^H>|perlvar/%^H> が空の場合は
L<C<undef>|/undef EXPR> です。
このハッシュの値は構文木に保管されている実際の値なので、変更しないで下さい。

=begin original

Note that the only types of call frames that are visible are subroutine
calls and C<eval>. Other forms of context, such as C<while> or C<foreach>
loops or C<try> blocks are not considered interesting to C<caller>, as they
do not alter the behaviour of the C<return> expression.

=end original

見ることができる呼び出しフレームの種類はサブルーチン呼び出しと
C<eval> だけであることに注意してください。
C<while> や C<foreach> のループや C<try> ブロックのようなその他の構造は、
C<caller> の関心外です; これらは C<return> 式の振る舞いを変えないからです。

=begin original

Furthermore, when called from within the DB package in
list context, and with an argument, caller returns more
detailed information: it sets the list variable C<@DB::args> to be the
arguments with which the subroutine was invoked.

=end original

さらに、DB パッケージの中からリストコンテキストで引数付きで呼ばれた場合は、
caller はより詳細な情報を返します; サブルーチンが起動されたときの引数を
変数 C<@DB::args> に設定します。

=begin original

Be aware that the optimizer might have optimized call frames away before
C<caller> had a chance to get the information.  That
means that C<caller(N)> might not return information about the call
frame you expect it to, for C<< N > 1 >>.  In particular, C<@DB::args>
might have information from the previous time C<caller>
was called.

=end original

C<caller> が情報を得る前にオプティマイザが呼び出しフレームを
最適化してしまうかもしれないことに注意してください。
これは、C<caller(N)> が C<< N > 1 >> のとき、
あなたが予測した呼び出しフレームの情報を返さないかもしれないことを意味します。
特に、C<@DB::args> は C<caller> が前回呼び出された時の情報を
持っているかもしれません。

=begin original

Be aware that setting C<@DB::args> is I<best effort>, intended for
debugging or generating backtraces, and should not be relied upon.  In
particular, as L<C<@_>|perlvar/@_> contains aliases to the caller's
arguments, Perl does not take a copy of L<C<@_>|perlvar/@_>, so
C<@DB::args> will contain modifications the subroutine makes to
L<C<@_>|perlvar/@_> or its contents, not the original values at call
time.  C<@DB::args>, like L<C<@_>|perlvar/@_>, does not hold explicit
references to its elements, so under certain cases its elements may have
become freed and reallocated for other variables or temporary values.
Finally, a side effect of the current implementation is that the effects
of C<shift @_> can I<normally> be undone (but not C<pop @_> or other
splicing, I<and> not if a reference to L<C<@_>|perlvar/@_> has been
taken, I<and> subject to the caveat about reallocated elements), so
C<@DB::args> is actually a hybrid of the current state and initial state
of L<C<@_>|perlvar/@_>.  Buyer beware.

=end original

C<@DB::args> の設定は I<ベストエフォート> で、デバッグやバックトレースの
生成を目的としていて、これに依存するべきではないということにも
注意してください。
特に、L<C<@_>|perlvar/@_> は呼び出し元の引数へのエイリアスを含んでいるので、
Perl は L<C<@_>|perlvar/@_> のコピーを取らず、従って C<@DB::args> は
サブルーチンが L<C<@_>|perlvar/@_> やその内容に行った変更を含んでいて、
呼び出し時の元の値ではありません。
C<@DB::args> は、L<C<@_>|perlvar/@_> と同様、その要素への明示的な
リファレンスを保持しないので、ある種の状況では、解放されて他の変数や
一時的な値のために再割り当てされているかもしれません。
最後に、現在の実装の副作用は、C<shift @_> の効果は I<普通は> 行われない
(しかし C<pop @_> やその他の splice は違い、I<そして> もし
L<C<@_>|perlvar/@_> のリファレンスが取られると違い、I<そして> 再割り当てされた
要素に関する問題になりやすいです)ことなので、C<@DB::args> は実際には現在の
状態と L<C<@_>|perlvar/@_> の初期状態との合成物となります。
ご用心を。

=item chdir EXPR
X<chdir>
X<cd>
X<directory, change>

=item chdir FILEHANDLE

=item chdir DIRHANDLE

=item chdir

=for Pod::Functions change your current working directory

=begin original

Changes the working directory to EXPR, if possible.  If EXPR is omitted,
changes to the directory specified by C<$ENV{HOME}>, if set; if not,
changes to the directory specified by C<$ENV{LOGDIR}>.  (Under VMS, the
variable C<$ENV{'SYS$LOGIN'}> is also checked, and used if it is set.)  If
neither is set, C<chdir> does nothing and fails.  It
returns true on success, false otherwise.  See the example under
L<C<die>|/die LIST>.

=end original

(可能であれば、) カレントディレクトリを EXPR に移します。
EXPR を指定しないと、C<$ENV{HOME}> が設定されていれば、そのディレクトリに
移ります; そうでなく、C<$ENV{LOGDIR}>が設定されていれば、そのディレクトリに
移ります。
(VMS では C<$ENV{'SYS$LOGIN'}> もチェックされ、もしセットされていれば
使われます。)
どちらも設定されていなければ、C<chdir> は何もせずに失敗します。
成功時には真を返し、そうでなければ偽を返します。
L<C<die>|/die LIST> の項の例を参照してください。

=begin original

On systems that support L<fchdir(2)>, you may pass a filehandle or
directory handle as the argument.  On systems that don't support L<fchdir(2)>,
passing handles raises an exception.

=end original

L<fchdir(2)> に対応しているシステムでは、ファイルハンドルや
ディレクトリハンドルを引数として渡せます。
L<fchdir(2)> に対応していないシステムでは、ハンドルを渡すと例外が発生します。

=item chmod LIST
X<chmod> X<permission> X<mode>

=for Pod::Functions changes the permissions on a list of files

=begin original

Changes the permissions of a list of files.  The first element of the
list must be the numeric mode, which should probably be an octal
number, and which definitely should I<not> be a string of octal digits:
C<0644> is okay, but C<"0644"> is not.  Returns the number of files
successfully changed.  See also L<C<oct>|/oct EXPR> if all you have is a
string.

=end original

LIST に含まれるファイルの、パーミッションを変更します。
LIST の最初の要素は、数値表現のモードでなければなりません;
恐らく 8 進表記の数であるべきでしょう: しかし、8 進表記の
文字列では I<いけません>: C<0644> は OK ですが、 C<"0644"> は
だめ、ということです。
変更に成功したファイルの数を返します。
文字列を使いたい場合は、L<C<oct>|/oct EXPR> を参照してください。

    my $cnt = chmod 0755, "foo", "bar";
    chmod 0755, @executables;
    my $mode = "0644"; chmod $mode, "foo";      # !!! sets mode to
                                                # --w----r-T
    my $mode = "0644"; chmod oct($mode), "foo"; # this is better
    my $mode = 0644;   chmod $mode, "foo";      # this is best

=begin original

On systems that support L<fchmod(2)>, you may pass filehandles among the
files.  On systems that don't support L<fchmod(2)>, passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

L<fchmod(2)> に対応しているシステムでは、ファイルハンドルを引数として
渡せます。
L<fchmod(2)> に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません;
裸の単語はファイル名として扱われます。

    open(my $fh, "<", "foo");
    my $perm = (stat $fh)[2] & 07777;
    chmod($perm | 0600, $fh);

=begin original

You can also import the symbolic C<S_I*> constants from the
L<C<Fcntl>|Fcntl> module:

=end original

L<C<Fcntl>|Fcntl> モジュールから C<S_I*> シンボル定数を
インポートすることもできます:

    use Fcntl qw( :mode );
    chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
    # Identical to the chmod 0755 of the example above.

=begin original

Portability issues: L<perlport/chmod>.

=end original

移植性の問題: L<perlport/chmod>。

=item chomp VARIABLE
X<chomp> X<INPUT_RECORD_SEPARATOR> X<$/> X<newline> X<eol>

=item chomp( LIST )

=item chomp

=for Pod::Functions remove a trailing record separator from a string

=begin original

This safer version of L<C<chop>|/chop VARIABLE> removes any trailing
string that corresponds to the current value of
L<C<$E<sol>>|perlvar/$E<sol>> (also known as C<$INPUT_RECORD_SEPARATOR>
in the L<C<English>|English> module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph
mode (C<$/ = ''>), it removes all trailing newlines from the string.
When in slurp mode (C<$/ = undef>) or fixed-length record mode
(L<C<$E<sol>>|perlvar/$E<sol>> is a reference to an integer or the like;
see L<perlvar>), C<chomp> won't remove anything.
If VARIABLE is omitted, it chomps L<C<$_>|perlvar/$_>.  Example:

=end original

より安全な L<C<chop>|/chop VARIABLE> (以下を参照してください) です;
L<C<$E<sol>>|perlvar/$E<sol>> (L<C<English>|English> モジュールでは、
C<$INPUT_RECORD_SEPARATOR> とも言う) のその時点の
値に対応する行末文字を削除します。
全ての引数から削除した文字数の合計を返します。
入力レコードから、改行を削除したいのだけれど、最後のレコードには改行が
入っているのかわからないような場合に、使用できます。
段落モード (C<$/ = ''>) では、レコードの最後の改行をすべて取り除きます。
吸い込みモード (C<$/ = undef>) や 固定長レコードモード
(L<C<$E<sol>>|perlvar/$E<sol>> が整数へのリファレンスや類似のものの場合;
L<perlvar>を参照してください)では、C<chomp> は
何も取り除きません。
VARIABLE が省略されると、L<C<$_>|perlvar/$_> を対象として chomp します。
例:

    while (<>) {
        chomp;  # avoid \n on last field
        my @array = split(/:/);
        # ...
    }

=begin original

If VARIABLE is a hash, it chomps the hash's values, but not its keys,
resetting the L<C<each>|/each HASH> iterator in the process.

=end original

VARIABLE がハッシュなら、ハッシュのキーではなく値について chomp し、
このプロセスの L<C<each>|/each HASH> 反復子をリセットします。

=begin original

You can actually chomp anything that's an lvalue, including an assignment:

=end original

左辺値であれば、代入を含めて、任意のものを chomp できます:

    chomp(my $cwd = `pwd`);
    chomp(my $answer = <STDIN>);

=begin original

If you chomp a list, each element is chomped, and the total number of
characters removed is returned.

=end original

リストを chomp すると、個々の要素が chomp され、
削除された文字数の合計が返されます。

=begin original

Note that parentheses are necessary when you're chomping anything
that is not a simple variable.  This is because C<chomp $cwd = `pwd`;>
is interpreted as C<(chomp $cwd) = `pwd`;>, rather than as
C<chomp( $cwd = `pwd` )> which you might expect.  Similarly,
C<chomp $x, $y> is interpreted as C<chomp($x), $y> rather than
as C<chomp($x, $y)>.

=end original

単純な変数以外のものを chomp する場合はかっこが必要であることに
注意してください。
これは、C<chomp $cwd = `pwd`;> は、予測している
C<chomp( $cwd = `pwd` )> ではなく、C<(chomp $cwd) = `pwd`;> と
解釈されるからです。
同様に、C<chomp $x, $y> は C<chomp($x, $y)> ではなく C<chomp($x), $y>
と解釈されます。

=item chop VARIABLE
X<chop>

=item chop( LIST )

=item chop

=for Pod::Functions remove the last character from a string

=begin original

Chops off the last character of a string and returns the character
chopped.  It is much more efficient than C<s/.$//s> because it neither
scans nor copies the string.  If VARIABLE is omitted, chops
L<C<$_>|perlvar/$_>.
If VARIABLE is a hash, it chops the hash's values, but not its keys,
resetting the L<C<each>|/each HASH> iterator in the process.

=end original

文字列の最後の文字を切り捨てて、その切り取った文字を返します。
文字列の検索もコピーも行ないませんので
C<s/.$//s> よりも、ずっと効率的です。
VARIABLE が省略されると、L<C<$_>|perlvar/$_> を対象として chop します。
VARIABLE がハッシュの場合、ハッシュのキーではなく値について chop し、
このプロセスの L<C<each>|/each HASH> 反復子をリセットします。

=begin original

You can actually chop anything that's an lvalue, including an assignment.

=end original

実際のところ、代入を含む左辺値となりうるなんでも chop できます。

=begin original

If you chop a list, each element is chopped.  Only the value of the
last C<chop> is returned.

=end original

リストを chop すると、個々の要素が chop されます。
最後の C<chop> の値だけが返されます。

=begin original

Note that C<chop> returns the last character.  To
return all but the last character, use C<substr($string, 0, -1)>.

=end original

C<chop> は最後の文字を返すことに注意してください。
最後以外の全ての文字を返すためには、C<substr($string, 0, -1)> を
使ってください。

=begin original

See also L<C<chomp>|/chomp VARIABLE>.

=end original

L<C<chomp>|/chomp VARIABLE> も参照してください。

=item chown LIST
X<chown> X<owner> X<user> X<group>

=for Pod::Functions change the ownership on a list of files

=begin original

Changes the owner (and group) of a list of files.  The first two
elements of the list must be the I<numeric> uid and gid, in that
order.  A value of -1 in either position is interpreted by most
systems to leave that value unchanged.  Returns the number of files
successfully changed.

=end original

LIST に含まれるファイルの所有者 (とグループ) を変更します。
LIST の最初の二つの要素には、I<数値表現> の uid と gid を
この順序で与えなければなりません。
どちらかの値を -1 にすると、ほとんどのシステムではその値は
変更しないと解釈します。
変更に成功したファイルの数を返します。

    my $cnt = chown $uid, $gid, 'foo', 'bar';
    chown $uid, $gid, @filenames;

=begin original

On systems that support L<fchown(2)>, you may pass filehandles among the
files.  On systems that don't support L<fchown(2)>, passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

L<fchown(2)> に対応しているシステムでは、ファイルハンドルを引数として渡せます。
L<fchown(2)> に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません; 裸の単語はファイル名として扱われます。

=begin original

Here's an example that looks up nonnumeric uids in the passwd file:

=end original

passwd ファイルから数値表現でない uid を検索する例を
示します:

    print "User: ";
    chomp(my $user = <STDIN>);
    print "Files: ";
    chomp(my $pattern = <STDIN>);

    my ($login,$pass,$uid,$gid) = getpwnam($user)
        or die "$user not in passwd file";

    my @ary = glob($pattern);  # expand filenames
    chown $uid, $gid, @ary;

=begin original

On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
On POSIX systems, you can detect this condition this way:

=end original

ほとんどのシステムでは、スーパーユーザーだけがファイルの所有者を
変更できますが、グループは実行者の副グループに変更できるべきです。
安全でないシステムでは、この制限はゆるめられています; しかしこれは
移植性のある仮定ではありません。
POSIX システムでは、以下のようにしてこの条件を検出できます:

    use POSIX qw(pathconf _PC_CHOWN_RESTRICTED);
    my $can_chown_giveaway =
        ! pathconf($path_of_interest, _PC_CHOWN_RESTRICTED);

=begin original

Portability issues: L<perlport/chown>.

=end original

移植性の問題: L<perlport/chown>。

=item chr NUMBER
X<chr> X<character> X<ASCII> X<Unicode>

=item chr

=for Pod::Functions get character this number represents

=begin original

Returns the character represented by that NUMBER in the character set.
For example, C<chr(65)> is C<"A"> in either ASCII or Unicode, and
C<chr(0x263a)> is a Unicode smiley face.

=end original

特定の文字セットでの NUMBER で表わされる文字を返します。
たとえば、C<chr(65)> は ASCII と Unicode の両方で C<"A"> となります;
C<chr(0x263a)> は Unicode のスマイリーフェイスです。 

=begin original

Negative values give the Unicode replacement character (C<chr(0xfffd)>),
except under the L<bytes> pragma, where the low eight bits of the value
(truncated to an integer) are used.

=end original

負の数は Unicode の置換文字 (C<chr(0xfffd)>) を与えますが、
L<bytes> プラグマの影響下では、(integer に切り詰められた)値の下位 8 ビットが
使われます。

=begin original

If NUMBER is omitted, uses L<C<$_>|perlvar/$_>.

=end original

NUMBER が省略された場合、L<C<$_>|perlvar/$_> を使います。

=begin original

For the reverse, use L<C<ord>|/ord EXPR>.

=end original

逆を行うためには、L<C<ord>|/ord EXPR> を参照してください。

=begin original

Note that characters from 128 to 255 (inclusive) are by default
internally not encoded as UTF-8 for backward compatibility reasons.

=end original

128 から 255 までの文字は過去との互換性のために
デフォルトでは UTF-8 Unicode にエンコードされません。

=begin original

See L<perlunicode> for more about Unicode.

=end original

Unicode については L<perlunicode> を参照してください。

=item chroot FILENAME
X<chroot> X<root>

=item chroot

=for Pod::Functions make directory new root for path lookups

=begin original

This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a C</> by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If FILENAME is
omitted, does a C<chroot> to L<C<$_>|perlvar/$_>.

=end original

同じ名前のシステムコールと同じことをします: 現在のプロセス及び子プロセスに
対して、C</>で始まるパス名に関して指定されたディレクトリを新しい
ルートディレクトリとして扱います。
(これはカレントディレクトリを変更しません; カレントディレクトリは
そのままです。)
セキュリティ上の理由により、この呼び出しはスーパーユーザーしか行えません。
FILENAME を省略すると、L<C<$_>|perlvar/$_> へ
C<chroot> します。

=begin original

B<NOTE:>  It is mandatory for security to C<chdir("/")>
(L<C<chdir>|/chdir EXPR> to the root directory) immediately after a
C<chroot>, otherwise the current working directory
may be outside of the new root.

=end original

B<注意:> C<chroot> の直後に (ルートディレクトリに
L<C<chdir>|/chdir EXPR> する)
C<chdir("/")> するのはセキュリティ上必須です;
さもなければ現在の作業ディレクトリは新しいルートの外側かもしれません。

=begin original

Portability issues: L<perlport/chroot>.

=end original

移植性の問題: L<perlport/chroot>。

=item class NAMESPACE

=item class NAMESPACE VERSION

=item class NAMESPACE BLOCK

=item class NAMESPACE VERSION BLOCK

=for Pod::Functions declare a separate global namespace that is an object class

=begin original

Declares the BLOCK or the rest of the compilation unit as being in the given
namespace, which implements an object class (see L<perlclass>).  This
behaves similarly to L<C<package>|/package NAMESPACE>, except that the
newly-created package behaves as a class.

=end original

BLOCK またはコンパイル単位の残りの部分を、オブジェクトクラスを
実装する指定された名前空間にあるものとして宣言します (L<perlclass> 参照)。
これは、新しく作成されたパッケージがクラスとして振る舞うことを
除いて、L<C<package>|/package NAMESPACE> と同様に動作します。

=item close FILEHANDLE
X<close>

=item close

=for Pod::Functions close file (or pipe or socket) handle

=begin original

Closes the file or pipe associated with the filehandle, flushes the IO
buffers, and closes the system file descriptor.  Returns true if those
operations succeed, and if no error was reported by any PerlIO layer,
and there was no existing error on the filehandle.

=end original

FILEHANDLE に対応したファイルまたはパイプをクローズして、
IO バッファをフラッシュし、システムファイル記述子をクローズします。
操作が成功し、PerlIO 層からエラーが報告されず、
このファイルハンドルに既存のエラーがない場合に真を返します。

=begin original

If there was an existing error on the filehandle, close will return
false and L<C<$!>|perlvar/$!> will be set to the error from the
failing operation, so you can safely use its value when reporting the
error.

=end original

ファイルハンドルに既存のエラーがある場合、close は偽を返し、
L<C<$!>|perlvar/$!> は失敗した操作のエラーに設定されるので、
エラーを報告するときにその値を安全に使えます。

=begin original

Closes the currently selected filehandle if the argument is
omitted.

=end original

引数が省略された場合、現在選択されているファイルハンドルをクローズします。

=begin original

You don't have to close FILEHANDLE if you are immediately going to do
another L<C<open>|/open FILEHANDLE,MODE,EXPR> on it, because
L<C<open>|/open FILEHANDLE,MODE,EXPR> closes it for you.  (See
L<C<open>|/open FILEHANDLE,MODE,EXPR>.) However, an explicit
C<close> on an input file resets the line counter
(L<C<$.>|perlvar/$.>), while the implicit close done by
L<C<open>|/open FILEHANDLE,MODE,EXPR> does not.

=end original

クローズしてすぐにまた、同じファイルハンドルに対してオープンを行なう
場合には、L<C<open>|/open FILEHANDLE,MODE,EXPR> が自動的に
L<C<close>|/close FILEHANDLE> を行ないますので、
close FILEHANDLE する必要はありません。
(L<C<open>|/open FILEHANDLE,MODE,EXPR> を参照してください。)
ただし、明示的に C<close> を行なったときにのみ入力ファイルの
行番号 (L<C<$.>|perlvar/$.>) のリセットが行なわれ、
L<C<open>|/open FILEHANDLE,MODE,EXPR> によって行なわれる
暗黙の L<C<close>|/close FILEHANDLE> では行なわれません。

=begin original

If the filehandle came from a piped open, C<close>
returns false if one of the other syscalls involved fails or if its
program exits with non-zero status.  If the only problem was that the
program exited non-zero, L<C<$!>|perlvar/$!> will be set to C<0>.
Closing a pipe also waits for the process executing on the pipe to
exit--in case you wish to look at the output of the pipe afterwards--and
implicitly puts the exit status value of that command into
L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.

=end original

ファイルハンドルがパイプつきオープンなら、C<close> は
その他のシステムコールが失敗したりプログラムが非ゼロのステータスで終了した
場合にも偽を返します。
プログラムが非ゼロで終了しただけの場合は、L<C<$!>|perlvar/$!> が C<0> に
セットされます。
後でパイプの出力を見たい場合のために、パイプのクローズでは、パイプ上で
実行されているプロセスの終了を待ち、また自動的にコマンドのステータス値を
L<C<$?>|perlvar/$?> と
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> に設定します。

=begin original

If there are multiple threads running, C<close> on
a filehandle from a piped open returns true without waiting for the
child process to terminate, if the filehandle is still open in another
thread.

=end original

複数のスレッドがある場合、パイプで開かれたファイルハンドルに対する
C<close> は、そのファイルハンドルが他のスレッドで
まだ開かれている場合、子プロセスの終了を待たずに真を返します。

=begin original

Closing the read end of a pipe before the process writing to it at the
other end is done writing results in the writer receiving a SIGPIPE.  If
the other end can't handle that, be sure to read all the data before
closing the pipe.

=end original

書き込み側が閉じる前に途中でパイプの読み込み側が閉じた場合、
書き込み側に SIGPIPE が配送されます。
書き込み側がこれを扱えない場合、パイプを閉じる前に
確実に全てのデータが読み込まれるようにする必要があります。

=begin original

Example:

=end original

例:

    open(OUTPUT, '|sort >foo')  # pipe to sort
        or die "Can't start sort: $!";
    #...                        # print stuff to output
    close OUTPUT                # wait for sort to finish
        or warn $! ? "Error closing sort pipe: $!"
                   : "Exit status $? from sort";
    open(INPUT, 'foo')          # get sort's results
        or die "Can't open 'foo' for input: $!";

=begin original

FILEHANDLE may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name or an autovivified handle.

=end original

FILEHANDLE は式でもかまいません; この場合、値は間接ファイルハンドルと
して扱われ、普通は実際のファイルハンドル名か自動有効化されたハンドルです。

=begin original

If an error occurs when perl implicitly closes a handle, perl will
produce a L<warning|perldiag/"Warning: unable to close filehandle %s
properly: %s">.  Explicitly calling close on the handle prevents that
warning.

=end original

perl が暗黙的にハンドルを閉じたときにエラーが発生した場合、perl は
L<warning|perldiag/"Warning: unable to close filehandle %s properly: %s"> を
生成します。
ハンドルに対して明示的に close を呼び出すと、この警告を抑制します。

=item closedir DIRHANDLE
X<closedir>

=for Pod::Functions close directory handle

=begin original

Closes a directory opened by L<C<opendir>|/opendir DIRHANDLE,EXPR> and
returns the success of that system call.

=end original

L<C<opendir>|/opendir DIRHANDLE,EXPR> でオープンしたディレクトリをクローズし、
システムコールの返り値を返します。

=item connect SOCKET,NAME
X<connect>

=for Pod::Functions connect to a remote socket

=begin original

Attempts to connect to a remote socket, just like L<connect(2)>.
Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

L<connect(2)> システムコールと同様に、リモートソケットへの接続を試みます。
成功時には真を、さもなければ偽を返します。
NAME は、ソケットに対する、適切な型のパックされた
アドレスでなければなりません。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=item continue BLOCK
X<continue>

=item continue

=for Pod::Functions optional trailing block in a while or foreach

=begin original

When followed by a BLOCK, C<continue> is actually a
flow control statement rather than a function.  If there is a
C<continue> BLOCK attached to a BLOCK (typically in a
C<while> or C<foreach>), it is always executed just before the
conditional is about to be evaluated again, just like the third part of
a C<for> loop in C.  Thus it can be used to increment a loop variable,
even when the loop has been continued via the L<C<next>|/next LABEL>
statement (which is similar to the C C<continue>
statement).

=end original

BLOCK が引き続く場合、C<continue> は実際には関数ではなく、
実行制御文です。
C<continue> BLOCK が BLOCK (典型的には C<while> または
C<foreach> の中)にあると、これは条件文が再評価される直前に常に実行されます;
これは C における C<for> ループの 3 番目の部分と同様です。
従って、これは L<C<next>|/next LABEL> 文 (これは C の
C<continue> 文と似ています) を使って
ループが繰り返されるときでもループ変数を増やしたいときに使えます。

=begin original

L<C<last>|/last LABEL>, L<C<next>|/next LABEL>, or
L<C<redo>|/redo LABEL> may appear within a
C<continue> block; L<C<last>|/last LABEL> and
L<C<redo>|/redo LABEL> behave as if they had been executed within the
main block.  So will L<C<next>|/next LABEL>, but since it will execute a
C<continue> block, it may be more entertaining.

=end original

L<C<last>|/last LABEL>, L<C<next>|/next LABEL>, L<C<redo>|/redo LABEL> が
C<continue> ブロック内に現れる可能性があります;
L<C<last>|/last LABEL> と L<C<redo>|/redo LABEL> はメインブロックの中で
実行されたのと同じように振舞います。
L<C<next>|/next LABEL> の場合は、C<continue> ブロックを
実行することになるので、より面白いことになります。

    while (EXPR) {
        ### redo always comes here
        do_something;
    } continue {
        ### next always comes here
        do_something_else;
        # then back to the top to re-check EXPR
    }
    ### last always comes here

=begin original

Omitting the C<continue> section is equivalent to
using an empty one, logically enough, so L<C<next>|/next LABEL> goes
directly back to check the condition at the top of the loop.

=end original

C<continue> 節を省略するのは、空の節を指定したのと同じで、
論理的には十分なので、この場合、L<C<next>|/next LABEL> は直接ループ先頭の
条件チェックに戻ります。

=begin original

When there is no BLOCK, C<continue> is a function
that falls through the current C<when> or C<default> block instead of
iterating a dynamically enclosing C<foreach> or exiting a lexically
enclosing C<given>.  In Perl 5.14 and earlier, this form of
C<continue> was only available when the
L<C<"switch"> feature|feature/The 'switch' feature> was enabled.  See
L<feature> and L<perlsyn/"Switch Statements"> for more information.

=end original

BLOCK がなければ、C<continue> は動的に囲まれた C<foreach> や
レキシカルに囲まれた C<given> で反復するのではなく、現在の C<when> または
C<default> のブロックを通り抜けるための文です。
Perl 5.14 以前では、この形式の C<continue> は
L<C<"switch"> 機能|feature/The 'switch' feature> が有効の場合にのみ
利用可能です。
さらなる情報については L<feature> と L<perlsyn/"Switch Statements"> を
参照してください。

=item cos EXPR
X<cos> X<cosine> X<acos> X<arccosine>

=item cos

=for Pod::Functions cosine function

=begin original

Returns the cosine of EXPR (expressed in radians).  If EXPR is omitted,
takes the cosine of L<C<$_>|perlvar/$_>.

=end original

(ラジアンで示した) EXPR の余弦を返します。
EXPR が省略されたときには、L<C<$_>|perlvar/$_> の余弦を取ります。

=begin original

For the inverse cosine operation, you may use the
L<C<Math::Trig::acos>|Math::Trig> function, or use this relation:

=end original

逆余弦を求めるためには、L<C<Math::Trig::acos>|Math::Trig> 関数を使うか、
以下の関係を使ってください。

    sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

=item crypt PLAINTEXT,SALT
X<crypt> X<digest> X<hash> X<salt> X<plaintext> X<password>
X<decrypt> X<cryptography> X<passwd> X<encrypt>

=for Pod::Functions one-way passwd-style encryption

=begin original

Creates a digest string exactly like the L<crypt(3)> function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munition).

=end original

C ライブラリの L<crypt(3)> 関数と全く同じように、ダイジェスト文字列を
作成します(一時的な必需品として、まだ絶滅していないバージョンを
持っていると仮定しています)。

=begin original

C<crypt> is a one-way hash function.  The
PLAINTEXT and SALT are turned
into a short string, called a digest, which is returned.  The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.  Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.

=end original

C<crypt> は一方向ハッシュ関数です。
PLAINTEXT と SALT はダイジェストと呼ばれる短い文字列に変えられて、
それが返されます。
PLAINTEXT と SALT が同じ場合は常に同じ文字列を返しますが、ハッシュから
元の PLAINTEXT を得る(既知の)方法はありません。
PLAINTEXT や SALT を少し変更してもダイジェストは大きく変更されます。

=begin original

There is no decrypt function.  This function isn't all that useful for
cryptography (for that, look for F<Crypt> modules on your nearby CPAN
mirror) and the name "crypt" is a bit of a misnomer.  Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.  An example is checking
if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
C<crypt>'d with the same salt as the stored
digest.  If the two digests match, the password is correct.

=end original

復号化関数はありません。
この関数は暗号化のためにはまったく役に立ちません(このためには、
お近くの CPAN ミラーで F<Crypt> モジュールを探してください)ので、
"crypt" という名前は少し間違った名前です。
その代わりに、一般的には二つのテキスト片が同じかどうかをテキストそのものを
転送したり保管したりせずにチェックするために使います。
例としては、正しいパスワードが与えられたかどうかをチェックがあります。
パスワード自身ではなく、パスワードのダイジェストが保管されます。
ユーザーがパスワードを入力すると、保管されているダイジェストと同じ
salt で C<crypt> します。
二つのダイジェストが同じなら、パスワードは正しいです。

=begin original

When verifying an existing digest string you should use the digest as
the salt (like C<crypt($plain, $digest) eq $digest>).  The SALT used
to create the digest is visible as part of the digest.  This ensures
C<crypt> will hash the new string with the same
salt as the digest.  This allows your code to work with the standard
C<crypt> and with more exotic implementations.
In other words, assume nothing about the returned string itself nor
about how many bytes of SALT may matter.

=end original

すでにあるダイジェスト文字列を検証するには、ダイジェストを
(C<crypt($plain, $digest) eq $digest> のようにして)salt として使います。
ダイジェストを作るのに使われた SALT はダイジェストの一部として見えます。
これにより、C<crypt> は同じ salt で新しい文字列を
ダイジェストとしてハッシュ化できるようにします。
これによって標準的な C<crypt> や、より風変わりな
実装でも動作します。
言い換えると、返される文字列や、SALT が何バイトあるかといったことに対して、
どのような仮定もしてはいけません。

=begin original

Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C<[./0-9A-Za-z]>, and only
the first eight bytes of PLAINTEXT mattered.  But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.

=end original

伝統的には結果は 13 バイトの文字列です: 最初の 2 バイトは salt、引き続いて
集合 C<[./0-9A-Za-z]> からの 11 バイトで、PLAINTEXT の最初の
8 バイトだけが意味があります。
しかし、(MD5 のように) 異なったハッシュ手法、
(C2 のような) 高レベルセキュリティ手法、非 Unix プラットフォームでの
実装などでは異なった文字列が生成されることがあります。

=begin original

When choosing a new salt create a random two character string whose
characters come from the set C<[./0-9A-Za-z]> (like C<join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]>).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts C<crypt> accepts.

=end original

新しい salt を選択する場合は、集合 C<[./0-9A-Za-z]> から
(C<join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]> の
ようにして)ランダムに2 つの文字を選びます。
この文字集合は単なる推薦です; salt として許される文字はシステムの暗号化
ライブラリだけに依存し、Perl は C<crypt> が
どのような salt を受け付けるかについて制限しません。

=begin original

Here's an example that makes sure that whoever runs this program knows
their password:

=end original

プログラムを実行する人が、
自分のパスワードを知っていることを確認する例です:

    my $pwd = (getpwuid($<))[1];

    system "stty -echo";
    print "Password: ";
    chomp(my $word = <STDIN>);
    print "\n";
    system "stty echo";

    if (crypt($word, $pwd) ne $pwd) {
        die "Sorry...\n";
    } else {
        print "ok\n";
    }

=begin original

Of course, typing in your own password to whoever asks you
for it is unwise.

=end original

もちろん、自分自身のパスワードを誰にでも入力するのは賢明ではありません。

=begin original

The C<crypt> function is unsuitable for hashing
large quantities of data, not least of all because you can't get the
information back.  Look at the L<Digest> module for more robust
algorithms.

=end original

C<crypt> 関数は大量のデータのハッシュ化には
向いていません; これは情報を戻せないという理由だけではありません。
より頑強なアルゴリズムについては L<Digest> モジュールを参照してください。

=begin original

If using C<crypt> on a Unicode string (which
I<potentially> has characters with codepoints above 255), Perl tries to
make sense of the situation by trying to downgrade (a copy of) the
string back to an eight-bit byte string before calling
C<crypt> (on that copy).  If that works, good.
If not, C<crypt> dies with
L<C<Wide character in crypt>|perldiag/Wide character in %s>.

=end original

Unicode 文字列(I<潜在的には> 255 を越えるコードポイントを持つ文字を
含みます)に C<crypt> を使った場合、Perl は
C<crypt> を呼び出す前に与えられた
文字列を8 ビットバイト文字列にダウングレードする(文字列のコピーを作る)
ことで状況のつじつまを合わせようとします。
うまく動けば、それでよし。
動かなければ、C<crypt> は
L<C<Wide character in crypt>|perldiag/Wide character in %s> という
メッセージと共に die します。

=begin original

Portability issues: L<perlport/crypt>.

=end original

移植性の問題: L<perlport/crypt>。

=item dbmclose HASH
X<dbmclose>

=for Pod::Functions breaks binding on a tied dbm file

=begin original

[This function has been largely superseded by the
L<C<untie>|/untie VARIABLE> function.]

=end original

[この関数は、L<C<untie>|/untie VARIABLE> 関数に大きくとって代わられました。]

=begin original

Breaks the binding between a DBM file and a hash.

=end original

DBM ファイルとハッシュの連結をはずします。

=begin original

Portability issues: L<perlport/dbmclose>.

=end original

移植性の問題: L<perlport/dbmclose>。

=item dbmopen HASH,DBNAME,MASK
X<dbmopen> X<dbm> X<ndbm> X<sdbm> X<gdbm>

=for Pod::Functions create binding on a tied dbm file

=begin original

[This function has been largely superseded by the
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> function.]

=end original

[この関数は、L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> 関数に
大きくとって代わられました。]

=begin original

This binds a L<dbm(3)>, L<ndbm(3)>, L<sdbm(3)>, L<gdbm(3)>, or Berkeley
DB file to a hash.  HASH is the name of the hash.  (Unlike normal
L<C<open>|/open FILEHANDLE,MODE,EXPR>, the first argument is I<not> a
filehandle, even though it looks like one).  DBNAME is the name of the
database (without the F<.dir> or F<.pag> extension if any).  If the
database does not exist, it is created with protection specified by MASK
(as modified by the L<C<umask>|/umask EXPR>).  To prevent creation of
the database if it doesn't exist, you may specify a MASK of 0, and the
function will return a false value if it can't find an existing
database.  If your system supports only the older DBM functions, you may
make only one C<dbmopen> call in your
program.  In older versions of Perl, if your system had neither DBM nor
ndbm, calling C<dbmopen> produced a fatal
error; it now falls back to L<sdbm(3)>.

=end original

L<dbm(3)>, L<ndbm(3)>, L<sdbm(3)>, L<gdbm(3)> ファイルまたは
Berkeley DB ファイルを連想配列に結び付けます。
HASH は、その連想配列の名前です。
(普通の L<C<open>|/open FILEHANDLE,MODE,EXPR> とは違って、最初の引数は
ファイルハンドル I<ではありません>; まあ、似たようなものですが)。
DBNAME は、データベースの名前です (拡張子の .dir や .pag はもしあっても
つけません)。
データベースが存在しなければ、MASK (を L<C<umask>|/umask EXPR> で
修正したもの) で指定されたモードで作られます。
存在しないときにデータベースを作成しないようにするには、MASK に 0 を
設定でき、データベースを見つけられなかった場合は関数は偽を返します。
古い DBM 関数のみをサポートしているシステムでは、プログラム中で 1 度だけ
C<dbmopen> を実行することができます。
昔のバージョンの Perl では、DBM も ndbm も持っていないシステムでは、
C<dbmopen> を呼び出すと致命的エラーになります;
現在では L<sdbm(3)> にフォールバックします。

=begin original

If you don't have write access to the DBM file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an
L<C<eval>|/eval EXPR> to trap the error.

=end original

DBM ファイルに対して、書き込み権が無いときには、ハッシュ
配列を読みだすことだけができ、設定することはできません。
書けるか否かを調べたい場合には、ファイルテスト
演算子を使うか、エラーをトラップするための L<C<eval>|/eval EXPR> の中で、
ダミーのハッシュエントリを設定してみることになります。

=begin original

Note that functions such as L<C<keys>|/keys HASH> and
L<C<values>|/values HASH> may return huge lists when used on large DBM
files.  You may prefer to use the L<C<each>|/each HASH> function to
iterate over large DBM files.  Example:

=end original

大きな DBM ファイルを扱うときには、L<C<keys>|/keys HASH> や
L<C<values>|/values HASH> のような関数は、巨大なリストを返します。
大きな DBM ファイルでは、L<C<each>|/each HASH> 関数を使って繰り返しを
行なった方が良いかもしれません。
例:

    # print out history file offsets
    dbmopen(%HIST,'/usr/lib/news/history',0666);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    dbmclose(%HIST);

=begin original

See also L<AnyDBM_File> for a more general description of the pros and
cons of the various dbm approaches, as well as L<DB_File> for a particularly
rich implementation.

=end original

様々な dbm 手法に対する利点欠点に関するより一般的な記述および
特にリッチな実装である L<DB_File> に関しては
L<AnyDBM_File> も参照してください。

=begin original

You can control which DBM library you use by loading that library
before you call C<dbmopen>:

=end original

C<dbmopen> を呼び出す前にライブラリを
読み込むことで、どの DBM ライブラリを使うかを制御できます:

    use DB_File;
    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
        or die "Can't open netscape history file: $!";

=begin original

Portability issues: L<perlport/dbmopen>.

=end original

移植性の問題: L<perlport/dbmopen>。

=item defined EXPR
X<defined> X<undef> X<undefined>

=item defined

=for Pod::Functions test whether a value, variable, or function is defined

=begin original

Returns a Boolean value telling whether EXPR has a value other than the
undefined value L<C<undef>|/undef EXPR>.  If EXPR is not present,
L<C<$_>|perlvar/$_> is checked.

=end original

左辺値 EXPR が未定義値 L<C<undef>|/undef EXPR> 以外の値を持つか否かを示す、
ブール値を返します。
EXPR がない場合は、L<C<$_>|perlvar/$_> がチェックされます。

=begin original

Many operations return L<C<undef>|/undef EXPR> to indicate failure, end
of file, system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish
L<C<undef>|/undef EXPR> from other values.  (A simple Boolean test will
not distinguish among L<C<undef>|/undef EXPR>, zero, the empty string,
and C<"0">, which are all equally false.)  Note that since
L<C<undef>|/undef EXPR> is a valid scalar, its presence doesn't
I<necessarily> indicate an exceptional condition: L<C<pop>|/pop ARRAY>
returns L<C<undef>|/undef EXPR> when its argument is an empty array,
I<or> when the element to return happens to be L<C<undef>|/undef EXPR>.

=end original

多くの演算子が、EOF や未初期化変数、システムエラーといった、
例外的な条件で L<C<undef>|/undef EXPR> を返すようになっています。
この関数は、他の値と L<C<undef>|/undef EXPR> とを区別するために使えます。
(単純な真偽値テストでは、L<C<undef>|/undef EXPR>、0、C<"0"> のいずれも偽を
返すので、区別することができません。)
L<C<undef>|/undef EXPR> は有効なスカラ値なので、その存在が I<必ずしも>
例外的な状況を表すとは限らないということに注意してください:
L<C<pop>|/pop ARRAY> は引数が空の配列だったときに L<C<undef>|/undef EXPR> を
返しますが、I<あるいは> 返すべき要素がたまたま
L<C<undef>|/undef EXPR> だったのかもしれません。

=begin original

You may also use C<defined(&func)> to check whether subroutine C<func>
has ever been defined.  The return value is unaffected by any forward
declarations of C<func>.  A subroutine that is not defined
may still be callable: its package may have an C<AUTOLOAD> method that
makes it spring into existence the first time that it is called; see
L<perlsub>.

=end original

C<defined(&func)> とすることでサブルーチン C<func> の存在を、
確かめることもできます。
返り値は C<func> の前方定義には影響されません。
定義されていないサブルーチンも呼び出し可能です:
最初に呼び出されたときに存在するようにするための
C<AUTOLOAD> メソッドを持ったパッケージかもしれません;
L<perlsub> を参照してください。

=begin original

Use of C<defined> on aggregates (hashes and arrays) is
no longer supported. It used to report whether memory for that
aggregate had ever been allocated.  You should instead use a simple
test for size:

=end original

集合(ハッシュや配列)への C<defined> の使用は
もはや対応していません。
これはその集合にメモリが割り当てられたかを報告するのに用いられていました。
代わりにサイズに対する簡単なテストを使うべきです。

    if (@an_array) { print "has array elements\n" }
    if (%a_hash)   { print "has hash members\n"   }

=begin original

When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use L<C<exists>|/exists EXPR>
for the latter purpose.

=end original

ハッシュの要素に対して用いると、value が定義されているか否かを
返すものであって、ハッシュに key が存在するか否かを返すのではありません。
この用途には、L<C<exists>|/exists EXPR> を使ってください。

=begin original

Examples:

=end original

例:

    print if defined $switch{D};
    print "$val\n" while defined($val = pop(@ary));
    die "Can't readlink $sym: $!"
        unless defined($value = readlink $sym);
    sub foo { defined &$bar ? $bar->(@_) : die "No bar"; }
    $debugging = 0 unless defined $debugging;

=begin original

Note:  Many folks tend to overuse C<defined> and are
then surprised to discover that the number C<0> and C<""> (the
zero-length string) are, in fact, defined values.  For example, if you
say

=end original

注意: 多くの人々が C<defined> を使いすぎて、C<0> と
C<"">(空文字列) が実際のところ定義された値であることに驚くようです。
例えば、以下のように書くと:

    "ab" =~ /a(.*)b/;

=begin original

The pattern match succeeds and C<$1> is defined, although it
matched "nothing".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use C<defined> only when questioning the
integrity of what you're trying to do.  At other times, a simple
comparison to C<0> or C<""> is what you want.

=end original

パターンマッチングが成功し、C<$1> が定義されても、実際には
「なし」にマッチしています。
しかしこれは何にもマッチしていないわけではありません。
何かにはマッチしているのですが、たまたまそれが長さ 0 だっただけです。
これは非常に率直で正直なことです。
関数が未定義値を返すとき、正直な答えを返すことができないことを
告白しています。
ですので、あなたが自分がしようとしていることの完全性を確認するときにだけ
C<defined> を使うべきです。
その他の場合では、単に C<0> または C<""> と比較するというのがあなたの
求めているものです。

=begin original

See also L<C<undef>|/undef EXPR>, L<C<exists>|/exists EXPR>,
L<C<ref>|/ref EXPR>.

=end original

L<C<undef>|/undef EXPR>, L<C<exists>|/exists EXPR>, L<C<ref>|/ref EXPR> も
参照してください。

=item delete EXPR
X<delete>

=for Pod::Functions deletes a value from a hash

=begin original

Given an expression that specifies an element or slice of a hash,
C<delete> deletes the specified elements from that hash
so that L<C<exists>|/exists EXPR> on that element no longer returns
true.  Setting a hash element to the undefined value does not remove its
key, but deleting it does; see L<C<exists>|/exists EXPR>.

=end original

ハッシュの要素やスライスを指定する式を取り、C<delete> は
指定された要素をハッシュから削除するので、
その要素に対する L<C<exists>|/exists EXPR> はもはや真を返さなくなります。
ハッシュ要素に未定義値をセットしてもそのキーは削除されませんが、
delete では削除されます; L<C<exists>|/exists EXPR> を参照してください。

=begin original

In list context, usually returns the value or values deleted, or the last such
element in scalar context.  The return list's length corresponds to that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions. Since Perl 5.28, a
L<keyE<sol>value hash slice|perldata/KeyE<sol>Value Hash Slices> can be passed
to C<delete>, and the return value is a list of key/value pairs (two elements
for each item deleted from the hash).

=end original

リストコンテキストでは通常は削除された要素を返し、スカラコンテキストでは
削除された要素のうち最後のものを返します。
返されたリストの長さは常に引数リストの長さに対応します:
存在しない要素を削除すると、対応する位置に未定義値をセットして返します。
Perl 5.28 から、
L<キーE<sol>値ハッシュスライス|perldata/KeyE<sol>Value Hash Slices> を
C<delete> に渡すことができ、
そして返り値はキー/値の組(それぞれのアイテムについて
二つの要素が元のハッシュから削除されたもの)です。

=begin original

C<delete> may also be used on arrays and array slices,
but its behavior is less straightforward.  Although
L<C<exists>|/exists EXPR> will return false for deleted entries,
deleting array elements never changes indices of existing values; use
L<C<shift>|/shift ARRAY> or L<C<splice>|/splice
ARRAY,OFFSET,LENGTH,LIST> for that.  However, if any deleted elements
fall at the end of an array, the array's size shrinks to the position of
the highest element that still tests true for L<C<exists>|/exists EXPR>,
or to 0 if none do.  In other words, an array won't have trailing
nonexistent elements after a delete.

=end original

C<delete> は配列や配列のスライスに対しても使えますが、その
振る舞いはあまり直感的ではありません。
削除されたエントリに対しては L<C<exists>|/exists EXPR> は偽を返しますが、
配列要素を削除しても、存在する値の添え字は変わりません; このためには
L<C<shift>|/shift ARRAY> や L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST> を
使ってください。
しかし、削除された要素が配列の末尾であった場合、配列のサイズは
L<C<exists>|/exists EXPR> が真となる最大位置の要素(それがない場合は 0)に
切り詰められます。
言い換えると、delete の後には配列の末尾に値のない要素はありません。

=begin original

B<WARNING:> Calling C<delete> on array values is
strongly discouraged.  The
notion of deleting or checking the existence of Perl array elements is not
conceptually coherent, and can lead to surprising behavior.

=end original

B<警告:> 配列の値に対して C<delete> を呼び出すことは強く
非推奨です。
Perl の配列要素を削除したり存在を調べたりする記法は概念的に一貫しておらず、
驚くべき振る舞いを引き起こすことがあります。

=begin original

Deleting from L<C<%ENV>|perlvar/%ENV> modifies the environment.
Deleting from a hash tied to a DBM file deletes the entry from the DBM
file.  Deleting from a L<C<tied>|/tied VARIABLE> hash or array may not
necessarily return anything; it depends on the implementation of the
L<C<tied>|/tied VARIABLE> package's DELETE method, which may do whatever
it pleases.

=end original

L<C<%ENV>|perlvar/%ENV> から削除を行なうと、実際に環境変数を変更します。
DBM ファイルに tie された配列からの削除は、その DBM ファイルからエントリを
削除します。
しかし、L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> されたハッシュや配列からの
削除は、値を返すとは限りません; これは
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> されたパッケージの DELETE
メソッドの実装に依存するので、どんなことでも起こります。

=begin original

The C<delete local EXPR> construct localizes the deletion to the current
block at run time.  Until the block exits, elements locally deleted
temporarily no longer exist.  See L<perlsub/"Localized deletion of elements
of composite types">.

=end original

C<delete local EXPR> 構文は、現在のブロックの削除を実行時にローカル化します。
ブロックから出るまで、ローカルで削除された要素は存在しなくなります。
L<perlsub/"Localized deletion of elements of composite types"> を
参照してください。

    my %hash = (foo => 11, bar => 22, baz => 33);
    my $scalar = delete $hash{foo};         # $scalar is 11
    $scalar = delete @hash{qw(foo bar)}; # $scalar is 22
    my @array  = delete @hash{qw(foo baz)}; # @array  is (undef,33)

=begin original

The following (inefficiently) deletes all the values of %HASH and @ARRAY:

=end original

以下は、%HASH と @ARRAY のすべての値を(非効率的に)削除します:

    foreach my $key (keys %HASH) {
        delete $HASH{$key};
    }

    foreach my $index (0 .. $#ARRAY) {
        delete $ARRAY[$index];
    }

=begin original

And so do these:

=end original

そして以下のようにもできます:

    delete @HASH{keys %HASH};

    delete @ARRAY[0 .. $#ARRAY];

=begin original

But both are slower than assigning the empty list
or undefining %HASH or @ARRAY, which is the customary
way to empty out an aggregate:

=end original

しかし、これら二つは両方とも、構造を空にするための慣習的な方法である、
単に空リストを代入するか、%HASH や @ARRAY を
undef するより遅いです:

    %HASH = ();     # completely empty %HASH
    undef %HASH;    # forget %HASH ever existed

    @ARRAY = ();    # completely empty @ARRAY
    undef @ARRAY;   # forget @ARRAY ever existed

=begin original

The EXPR can be arbitrarily complicated provided its
final operation is an element or slice of an aggregate:

=end original

最終的な操作が集合の要素かスライスである限りは、
いずれかである限りは、EXPR には任意の複雑な式を置くことができます:

    delete $ref->[$x][$y]{$key};
    delete $ref->[$x][$y]->@{$key1, $key2, @morekeys};

    delete $ref->[$x][$y][$index];
    delete $ref->[$x][$y]->@[$index1, $index2, @moreindices];

=item die LIST
X<die> X<throw> X<exception> X<raise> X<$@> X<abort>

=for Pod::Functions raise an exception or bail out

=begin original

C<die> raises an exception.  Inside an L<C<eval>|/eval EXPR>
the exception is stuffed into L<C<$@>|perlvar/$@> and the L<C<eval>|/eval
EXPR> is terminated with the undefined value.  If the exception is
outside of all enclosing L<C<eval>|/eval EXPR>s, then the uncaught
exception is printed to C<STDERR> and perl exits with an exit code
indicating failure.  If you need to exit the process with a specific
exit code, see L<C<exit>|/exit EXPR>.

=end original

C<die> は例外を発生させます。
L<C<eval>|/eval EXPR> の中で使用すると、例外が
L<C<$@>|perlvar/$@> に入り、L<C<eval>|/eval EXPR> は
未定義値を返して終了します。
例外が全ての L<C<eval>|/eval EXPR> の外側の場合は、捕捉されなかった例外は
C<STDERR> に表示され、perl は失敗を示す終了コードで終了します。
特定の終了コードでプロセスを終了させる必要がある場合は、
L<C<exit>|/exit EXPR> を参照してください。

=begin original

Equivalent examples:

=end original

等価な例:

    die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
    chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

=begin original

Most of the time, C<die> is called with a string to use as the exception.
You may either give a single non-reference operand to serve as the
exception, or a list of two or more items, which will be stringified
and concatenated to make the exception.

=end original

ほとんどの場合、C<die> は例外として使うための文字列と共に呼び出されます。
例外として扱われる単一の非リファレンスオペランドか、
例外を作るために文字列化されて連結される、二つ以上のアイテムのリストを
指定することができます。

=begin original

If the string exception does not end in a newline, the current
script line number and input line number (if any) and a newline
are appended to it.  Note that the "input line number" (also
known as "chunk") is subject to whatever notion of "line" happens to
be currently in effect, and is also available as the special variable
L<C<$.>|perlvar/$.>.  See L<perlvar/"$/"> and L<perlvar/"$.">.

=end original

文字列例外が改行で終わっていなければ、その時点のスクリプト名と
スクリプトの行番号、(もしあれば) 入力ファイルの行番号と改行文字が
それに追加されます。
「入力行番号」("chunk" とも呼ばれます)は「行」という概念が現在有効であると
仮定しています; また特殊変数 L<C<$.>|perlvar/$.> でも利用可能です。
L<perlvar/"$/"> と L<perlvar/"$."> も参照してください。

=begin original

Hint: sometimes appending C<", stopped"> to your message will cause it
to make better sense when the string C<"at foo line 123"> is appended.
Suppose you are running script "canasta".

=end original

ヒント: メッセージの最後を C<", stopped"> のようなもので
終わるようにしておけば、C<"at foo line 123"> のように
追加されて、わかりやすくなります。
"canasta" というスクリプトを実行しているとします。

    die "/etc/games is no good";
    die "/etc/games is no good, stopped";

=begin original

produce, respectively

=end original

これは、それぞれ以下のように表示します。

    /etc/games is no good at canasta line 123.
    /etc/games is no good, stopped at canasta line 123.

=begin original

If LIST was empty or made an empty string, and L<C<$@>|perlvar/$@>
already contains an exception value (typically from a previous
L<C<eval>|/eval EXPR>), then that value is reused after
appending C<"\t...propagated">.  This is useful for propagating exceptions:

=end original

出力が空か空文字列を作り、L<C<$@>|perlvar/$@> が
(典型的には前回の L<C<eval>|/eval EXPR> で)
既に例外値を持っている場合、
値は C<"\t...propagated"> を追加した後再利用されます。
これは例外を伝播させる場合に有効です:

    eval { ... };
    die unless $@ =~ /Expected exception/;

=begin original

If LIST was empty or made an empty string,
and L<C<$@>|perlvar/$@> contains an object
reference that has a C<PROPAGATE> method, that method will be called
with additional file and line number parameters.  The return value
replaces the value in L<C<$@>|perlvar/$@>;  i.e., as if
C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >> were called.

=end original

出力が空か空文字列を作り、L<C<$@>|perlvar/$@> が C<PROPAGATE> メソッドを
含むオブジェクトへのリファレンスを含む場合、
このメソッドが追加ファイルと行番号を引数として呼び出されます。
返り値は L<C<$@>|perlvar/$@> の値を置き換えます;
つまり、C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >> が
呼び出されたかのようになります。

=begin original

If LIST was empty or made an empty string, and L<C<$@>|perlvar/$@>
is also empty, then the string C<"Died"> is used.

=end original

LIST が空か空文字列を作り、L<C<$@>|perlvar/$@> も空の場合、
C<"Died"> が使われます。

=begin original

You can also call C<die> with a reference argument, and if
this is trapped within an L<C<eval>|/eval EXPR>, L<C<$@>|perlvar/$@>
contains that reference.  This permits more elaborate exception handling
using objects that maintain arbitrary state about the exception.  Such a
scheme is sometimes preferable to matching particular string values of
L<C<$@>|perlvar/$@> with regular expressions.

=end original

C<die> はリファレンス引数と共に呼び出すこともでき、これが
L<C<eval>|/eval EXPR> 内部でトラップされた場合、L<C<$@>|perlvar/$@> は
そのリファレンスを持ちます。
これは、例外の性質について任意の状態を管理するオブジェクトを使った
より複雑な例外処理の実装を可能にします。
このようなスキームは L<C<$@>|perlvar/$@> の特定の文字列値を正規表現を使って
マッチングするときに時々好まれます。

=begin original

Because Perl stringifies uncaught exception messages before display,
you'll probably want to overload stringification operations on
exception objects.  See L<overload> for details about that.
The stringified message should be non-empty, and should end in a newline,
in order to fit in with the treatment of string exceptions.
Also, because an exception object reference cannot be stringified
without destroying it, Perl doesn't attempt to append location or other
information to a reference exception.  If you want location information
with a complex exception object, you'll have to arrange to put the
location information into the object yourself.

=end original

perl は捕らえられなかった例外のメッセージを表示する前に文字列化するので、
このようなカスタム例外オブジェクトの文字列化をオーバーロードしたいと
思うかもしれません。
これに関する詳細は L<overload> を参照してください。
文字列化されたメッセージは、文字列例外の扱いに合わせるために、
空ではなく、末尾は改行であるべきです。
また、例外オブジェクトリファレンスはそれを破壊することなく
文字列化することができないので、Perl はリファレンス例外に位置や
その他の情報を追加しようとしません。
複雑な例外オブジェクトに位置情報が欲しい場合、
オブジェクト自身に位置情報を設定するように用意する必要があります。

=begin original

Because L<C<$@>|perlvar/$@> is a global variable, be careful that
analyzing an exception caught by C<eval> doesn't replace the reference
in the global variable.  It's
easiest to make a local copy of the reference before any manipulations.
Here's an example:

=end original

L<C<$@>|perlvar/$@> はグローバル変数なので、
C<eval> により補足された例外の解析はグローバル変数の
リファレンスを置き換えないことに注意を払わなければなりません。
他の操作をする前にリファレンスのローカルコピーを
作るのが一番簡単です。
以下に例を示します:

    use Scalar::Util "blessed";

    eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
    if (my $ev_err = $@) {
        if (blessed($ev_err)
            && $ev_err->isa("Some::Module::Exception")) {
            # handle Some::Module::Exception
        }
        else {
            # handle all other possible exceptions
        }
    }

=begin original

If an uncaught exception results in interpreter exit, the exit code is
determined from the values of L<C<$!>|perlvar/$!> and
L<C<$?>|perlvar/$?> with this pseudocode:

=end original

例外が捕捉されないとインタプリタは終了し、終了コードは以下の
擬似コードのように、L<C<$!>|perlvar/$!> と L<C<$?>|perlvar/$?> の値から
決定されます:

    exit $! if $!;              # errno
    exit $? >> 8 if $? >> 8;    # child exit status
    exit 255;                   # last resort

=begin original

As with L<C<exit>|/exit EXPR>, L<C<$?>|perlvar/$?> is set prior to
unwinding the call stack; any C<DESTROY> or C<END> handlers can then
alter this value, and thus Perl's exit code.

=end original

L<C<exit>|/exit EXPR> と同様に、コールスタックを巻き戻す前に
L<C<$?>|perlvar/$?> が設定されます; C<DESTROY> と C<END> のハンドラが
それからこの値を変更して、これが Perl の終了コードになります。

=begin original

The intent is to squeeze as much possible information about the likely cause
into the limited space of the system exit code.  However, as
L<C<$!>|perlvar/$!> is the value of C's C<errno>, which can be set by
any system call, this means that the value of the exit code used by
C<die> can be non-predictable, so should not be relied
upon, other than to be non-zero.

=end original

この意図は、できるだけ多くの似たような原因に関する情報を、システム終了
コードという限られた領域に圧縮することです。
しかし、L<C<$!>|perlvar/$!> はシステムコールによって設定される可能性がある C の
C<errno> の値であり、C<die> によって使われる終了コードの値は
予測不能であることを意味するので、非 0 ということ以上にこの値に
依存するべきではありません。

=begin original

You can arrange for a callback to be run just before the
C<die> does its deed, by setting the
L<C<$SIG{__DIE__}>|perlvar/%SIG> hook.  The associated handler is called
with the exception as an argument, and can change the exception,
if it sees fit, by
calling C<die> again.  See L<perlvar/%SIG> for details on
setting L<C<%SIG>|perlvar/%SIG> entries, and L<C<eval>|/eval EXPR> for some
examples.  Although this feature was to be run only right before your
program was to exit, this is not currently so: the
L<C<$SIG{__DIE__}>|perlvar/%SIG> hook is currently called even inside
L<C<eval>|/eval EXPR>ed blocks/strings!  If one wants the hook to do
nothing in such situations, put

=end original

L<C<$SIG{__DIE__}>|perlvar/%SIG> フックをセットすることで、
C<die> がその行動を行う
直前に実行されるコールバックを設定できます。
結び付けられたハンドラは例外を引数として呼び出され、
必要なら再び C<die> を呼び出すことで例外を変更できます。
L<C<%SIG>|perlvar/%SIG> のエントリをセットする詳細については、
L<perlvar/%SIG> を、例については L<C<eval>|/eval EXPR> を参照してください。
この機能はプログラムが終了しようとする前に 1 回だけ実行していましたが、
現在ではそうではありません:
L<C<$SIG{__DIE__}>|perlvar/%SIG> フックは L<C<eval>|/eval EXPR> された
ブロック/文字列の中でも呼ばれるのです!
もしそのような状況で何もしなくない時は:

    die @_ if $^S;

=begin original

as the first line of the handler (see L<perlvar/$^S>).  Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.

=end original

をハンドラの最初の行に置いてください(L<perlvar/$^S> を参照してください)。
これは離れたところで不思議な行動を引き起こすので、
この直感的でない振る舞いは将来のリリースで修正されるかもしれません。

=begin original

See also L<C<exit>|/exit EXPR>, L<C<warn>|/warn LIST>, and the L<Carp>
module.

=end original

L<C<exit>|/exit EXPR> と L<C<warn>|/warn LIST> と L<Carp> モジュールも
参照してください。

=item do BLOCK
X<do> X<block>

=for Pod::Functions turn a BLOCK into a TERM

=begin original

Not really a function.  Returns the value of the last command in the
sequence of commands indicated by BLOCK.  When modified by the C<while> or
C<until> loop modifier, executes the BLOCK once before testing the loop
condition.  (On other statements the loop modifiers test the conditional
first.)

=end original

実際は関数ではありません。
BLOCK で示されるコマンド列の最後の値を返します。
C<while> や C<until> ループ修飾子で修飾すると、
ループ条件を調べる前に 1 度、BLOCK を実行します。
(これ以外の実行文は、ループ修飾子により、条件が最初に
調べられます。)

=begin original

C<do BLOCK> does I<not> count as a loop, so the loop control statements
L<C<next>|/next LABEL>, L<C<last>|/last LABEL>, or
L<C<redo>|/redo LABEL> cannot be used to leave or restart the block.
See L<perlsyn> for alternative strategies.

=end original

C<do BLOCK> はループとしては I<扱われません>; 従って、L<C<next>|/next LABEL>,
L<C<last>|/last LABEL>,L<C<redo>|/redo LABEL> といったループ制御文は
ブロックから抜けたり再開することはできません。
その他の戦略については L<perlsyn> を参照してください。

=item do EXPR
X<do>

=begin original

Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script:

=end original

EXPR の値をファイル名として用い、そのファイルの中身を
Perl のスクリプトとして実行します:

    # load the exact specified file (./ and ../ special-cased)
    do '/foo/stat.pl';
    do './stat.pl';
    do '../foo/stat.pl';

    # search for the named file within @INC
    do 'stat.pl';
    do 'foo/stat.pl';

=begin original

C<do './stat.pl'> is largely like

=end original

C<do './stat.pl'> はだいたい以下のものと同じようなものですが、

    eval `cat stat.pl`;

=begin original

except that it's more concise, runs no external processes, and keeps
track of the current filename for error messages. It also differs in that
code evaluated with C<do FILE> cannot see lexicals in the enclosing
scope; C<eval STRING> does.  It's the same, however, in that it does
reparse the file every time you call it, so you probably don't want
to do this inside a loop.

=end original

より簡潔で、外部プログラムを起動せず、エラーメッセージでファイル名がわかる、
といったことがあります。
C<do FILE> で評価されたコードは、入れ子のスコープにある
レキシカル変数を見ることができないのに対し、C<eval STRING>ではできる、
という違いがあります。
しかし、呼び出すたびにファイルを解析し直すという点では同じですから、
ループ内でこれを使おうなどとは、間違っても思ったりしないように。

=begin original

Using C<do> with a relative path (except for F<./> and F<../>), like

=end original

次のように、C<do> に (F<./> と F<../> 以外の) 相対パスを使うと:

    do 'foo/stat.pl';

=begin original

will search the L<C<@INC>|perlvar/@INC> directories, and update
L<C<%INC>|perlvar/%INC> if the file is found.  See L<perlvar/@INC>
and L<perlvar/%INC> for these variables. In particular, note that
whilst historically L<C<@INC>|perlvar/@INC> contained '.' (the
current directory) making these two cases equivalent, that is no
longer necessarily the case, as '.' is not included in C<@INC> by default
in perl versions 5.26.0 onwards. Instead, perl will now warn:

=end original

L<C<@INC>|perlvar/@INC> ディレクトリを検索し、ファイルが見つかれば
L<C<%INC>|perlvar/%INC> を更新します。
これらの変数については L<perlvar/@INC> と L<perlvar/%INC> を参照してください。
特に、歴史的には L<C<@INC>|perlvar/@INC> に '.' (カレントディレクトリ) を
含んでいたのでこの二つの場合は等価でしたが、
perl バージョン 5.26.0 以降ではデフォルトでは C<@INC> に '.' を
含んでいないので、もはやそうではないことに注意してください。
代わりに、perl は次のような警告を出します:

    do "stat.pl" failed, '.' is no longer in @INC;
    did you mean do "./stat.pl"?

=begin original

If C<do> can read the file but cannot compile it, it
returns L<C<undef>|/undef EXPR> and sets an error message in
L<C<$@>|perlvar/$@>.  If C<do> cannot read the file, it
returns undef and sets L<C<$!>|perlvar/$!> to the error.  Always check
L<C<$@>|perlvar/$@> first, as compilation could fail in a way that also
sets L<C<$!>|perlvar/$!>.  If the file is successfully compiled,
C<do> returns the value of the last expression evaluated.

=end original

C<do> がファイルを読み込めたがコンパイルできなかった場合、
L<C<undef>|/undef EXPR> を返して L<C<$@>|perlvar/$@> にエラーメッセージを
設定します。
C<do> がファイルを読み込めなかった場合、undef を返して
L<C<$!>|perlvar/$!> にエラーを設定します。
コンパイルに失敗したときにも L<C<$!>|perlvar/$!> が設定されるので、
常に L<C<$@>|perlvar/$@> を先にチェックします。
ファイルのコンパイルに成功した場合、C<do> は最後に評価した表現の
値を返します。

=begin original

Inclusion of library modules is better done with the
L<C<use>|/use Module VERSION LIST> and L<C<require>|/require VERSION>
operators, which also do automatic error checking and raise an exception
if there's a problem.

=end original

ライブラリモジュールのインクルードには、
L<C<use>|/use Module VERSION LIST> 演算子や
L<C<require>|/require VERSION> 演算子を使った方がよいです;
これらは自動的にエラーをチェックして、問題があれば例外を発生させます。

=begin original

You might like to use C<do> to read in a program
configuration file.  Manual error checking can be done this way:

=end original

C<do> をプログラム設定ファイルを読み込むのに
使いたいかもしれません。
手動のエラーチェックは以下のようにして行えます:

    # Read in config files: system first, then user.
    # Beware of using relative pathnames here.
    for $file ("/share/prog/defaults.rc",
               "$ENV{HOME}/.someprogrc")
    {
        unless ($return = do $file) {
            warn "couldn't parse $file: $@" if $@;
            warn "couldn't do $file: $!"    unless defined $return;
            warn "couldn't run $file"       unless $return;
        }
    }

=item dump LABEL
X<dump> X<core> X<undump>

=item dump EXPR

=item dump

=for Pod::Functions create an immediate core dump

=begin original

This function causes an immediate core dump.  See also the B<-u>
command-line switch in L<perlrun|perlrun/-u>, which does the same thing.
Primarily this is so that you can use the B<undump> program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a C<goto LABEL> (with all the restrictions that L<C<goto>|/goto LABEL>
suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If C<LABEL> is omitted, restarts the program from the top.  The
C<dump EXPR> form, available starting in Perl 5.18.0, allows a name to be
computed at run time, being otherwise identical to C<dump LABEL>.

=end original

この関数は即座にコアダンプを行ないます。
同様のことを行う <perlrun|perlrun/-u> の B<-u> オプションも参照してください。
プログラムの先頭で、
すべての変数を初期化したあとのコアダンプを B<undump>
プログラム(提供していません)を使って実行ファイルに返ることができます。
この新しいバイナリが実行されると、C<goto LABEL> から始めます
(L<C<goto>|/goto LABEL> に関する制限はすべて適用されます)。
コアダンプをはさんで再生する goto と考えてください。
C<LABEL> が省略されると、プログラムを先頭から再開します。
Perl 5.18.0 から利用可能な C<dump EXPR> 形式では、実行時に計算される
名前が使えます; その他は C<dump LABEL> と同一です。

=begin original

B<WARNING>: Any files opened at the time of the dump will I<not>
be open any more when the program is reincarnated, with possible
resulting confusion by Perl.

=end original

B<警告>: dump 時点でオープンされていたファイルは、プログラムが
再生されたときには、もはやオープンされて I<いません>; Perl を
混乱させる可能性があります。

=begin original

This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable.  As of Perl 5.30, it must be invoked
as C<CORE::dump()>.

=end original

この関数は大幅に時代遅れのものです; 主な理由としては、コアファイルを
実行形式に変換するのが非常に困難であることです。
Perl 5.30 から、これは C<CORE::dump()> として起動しなければなりません。

=begin original

Unlike most named operators, this has the same precedence as assignment.
It is also exempt from the looks-like-a-function rule, so
C<dump ("foo")."bar"> will cause "bar" to be part of the argument to
C<dump>.

=end original

ほとんどの名前付き演算子と異なり、これは代入と同じ優先順位を持ちます。
また、関数のように見えるものの規則からも免れるので、C<dump ("foo")."bar"> と
すると "bar" は C<dump> への引数の一部になります。

=begin original

Portability issues: L<perlport/dump>.

=end original

移植性の問題: L<perlport/dump>。

=item each HASH
X<each> X<hash, iterator>

=item each ARRAY
X<array, iterator>

=for Pod::Functions retrieve the next key/value pair from a hash or index/value from an array

=begin original

When called on a hash in list context, returns a 2-element list
consisting of the key and value for the next element of a hash.
When called in scalar context, returns only the key (not the value).

=end original

ハッシュに対してリストコンテキストで呼び出した場合は、次の要素に対する、
ハッシュのキーと値を返します。
スカラコンテキストで呼び出した場合は、(値ではなく)キーのみを返します。

=begin original

When called on an array in list context, in Perl 5.12 and later, it
returns a 2-element list consisting of the index and value for the next
element of the array so that you can iterate over it; older Perls
consider this a syntax error.  When called in scalar context, returns
only the index in the array.

=end original

Perl 5.12 以降で、配列に対してリストコンテキストで呼び出した場合は、
配列のインデックスと値からなる
2 要素のリストを返すので、反復を行えます; より古い Perl ではこれは
文法エラーと見なされます。
スカラコンテキストで呼び出した場合は、
配列のインデックスだけを返します。

=begin original

Hash entries are returned in an apparently random order.  The actual random
order is specific to a given hash; the exact same series of operations
on two hashes may result in a different order for each hash.  Any insertion
into the hash may change the order, as will any deletion, with the exception
that the most recent key returned by C<each> or
L<C<keys>|/keys HASH> may be deleted without changing the order.  So
long as a given hash is unmodified you may rely on
L<C<keys>|/keys HASH>, L<C<values>|/values HASH> and
C<each> to repeatedly return the same order
as each other.  See L<perlsec/"Algorithmic Complexity Attacks"> for
details on why hash order is randomized.  Aside from the guarantees
provided here, the exact details of Perl's hash algorithm and the hash
traversal order are subject to change in any release of Perl.

=end original

ハッシュ要素は見かけ上、ランダムな順序で返されます。
実際のランダムな順序はハッシュに固有です; 二つのハッシュに全く同じ一連の
操作を行っても、ハッシュによって異なった順序になります。
ハッシュへの挿入によって順序が変わることがあります; 削除も同様ですが、
C<each> または L<C<keys>|/keys HASH> によって返されたもっとも
最近のキーは順序を変えることなく削除できます。
ハッシュが変更されない限り、L<C<keys>|/keys HASH>, L<C<values>|/values HASH>,
C<each> が繰り返し同じ順序で返すことに依存してもかまいません。
なぜハッシュの順序がランダム化されているかの詳細については
L<perlsec/"Algorithmic Complexity Attacks"> を参照してください。
ここで保証したことを除いて、Perl のハッシュアルゴリズムとハッシュ横断順序の
正確な詳細は Perl のリリースによって変更される可能性があります。

=begin original

Array entries are returned lowest index first.

=end original

配列エントリはインデックスの小さいものから順に返されます。

 my @colors = (qw(red, green, blue));
 while (my ($index, $value) = each @colors) {
     print "[$index] = $value\n";
 }

 [0] = red
 [1] = green
 [2] = blue

=begin original

After C<each> has returned all entries from the hash or
array, the next call to C<each> returns the empty list in
list context and L<C<undef>|/undef EXPR> in scalar context; the next
call following I<that> one restarts iteration.  Each hash or array has
its own internal iterator, accessed by C<each>,
L<C<keys>|/keys HASH>, and L<C<values>|/values HASH>.  The iterator is
implicitly reset when C<each> has reached the end as just
described; it can be explicitly reset by calling L<C<keys>|/keys HASH>
or L<C<values>|/values HASH> on the hash or array, or by referencing
the hash (but not array) in list context.  If you add or delete
a hash's elements while iterating over it, the effect on the iterator is
unspecified; for example, entries may be skipped or duplicated--so don't
do that.  Exception: It is always safe to delete the item most recently
returned by C<each>, so the following code works properly:

=end original

C<each> がハッシュをすべて読み込んでしまった後、
次の C<each> 呼び出しでは、リストコンテキストでは空リストが
返され、スカラコンテキストでは L<C<undef>|/undef EXPR> が返されます;
I<そのあと> もう一度呼び出すと、再び反復を始めます。
ハッシュや配列毎にそれぞれ反復子があり、C<each>、
L<C<keys>|/keys HASH>、L<C<values>|/values HASH> でアクセスされます。
反復子は、前述したように C<each> が要素をすべて読むことによって
暗黙にリセットされます; また、ハッシュや配列に対して L<C<keys>|/keys HASH>,
L<C<values>|/values HASH> を呼び出すか、リストコンテキストで
(配列ではなく)ハッシュを参照ことで明示的にリセットできます。
繰り返しを行なっている間に、ハッシュに要素を追加したり削除したりすると、
反復子の動作は未定義です; 例えば、要素が飛ばされたり重複したりします--
従って、してはいけません。
例外: 一番最近に C<each> から返されたものを削除するのは常に
安全です; これは以下のようなコードが正しく動くことを意味します:

    while (my ($key, $value) = each %hash) {
        print $key, "\n";
        delete $hash{$key};   # This is safe
    }

=begin original

Tied hashes may have a different ordering behaviour to perl's hash
implementation.

=end original

tie されたハッシュは、順序に関して Perl のハッシュと異なった振る舞いをします。

=begin original

The iterator used by C<each> is attached to the hash or array, and is
shared between all iteration operations applied to the same hash or array.
Thus all uses of C<each> on a particular hash or array advance the same
iterator location.  All uses of C<each> are also subject to having the
iterator reset by any use of C<keys> or C<values> on the same hash or
array, or by the hash (but not array) being referenced in list context.
This makes C<each>-based loops quite fragile: it is easy to arrive at
such a loop with the iterator already part way through the object, or to
accidentally clobber the iterator state during execution of the loop body.
It's easy enough to explicitly reset the iterator before starting a loop,
but there is no way to insulate the iterator state used by a loop from
the iterator state used by anything else that might execute during the
loop body.

=end original

C<each> で使われる反復子はハッシュや配列に付随し、
同じハッシュや配列に適用される全ての反復操作の間で共有されます。
従って、一つのハッシュや配列での C<each> の全ての使用は同じ反復位置を
進めます。
また、全ての C<each> は、同じハッシュまたはキーに対する
C<keys> や C<values> の使用によって、または
(リストではなく)ハッシュがリストコンテキストで参照されることによって、
反復子がリセットされることになります。
これは、C<each> を基にしたループをかなり不安定にします:
そのようなループが既にオブジェクトを部分的に通りぬけた反復子で行われたり、
ループ本体の実行中に誤って反復子の状態を壊すことは容易です。
ループを始める前に反復子を明示的にリセットするのは十分容易ですが、
ループ本体の間に実行しているかもしれない他の何かによって使われている
反復子の状態から、
ループによって使われている反復子の状態を分離する方法はありません。

=begin original

This extends to using C<each> on the result of an anonymous hash or
array constructor.  A new underlying array or hash is created each
time so each will always start iterating from scratch, eg:

=end original

これは、無名ハッシュや配列のコンストラクタの結果に
C<each> を使うように拡張します。
新しい基となる配列やハッシュは毎回作られるので、
それぞれは常に最初から反復します; 例:

  # loops forever
  while (my ($key, $value) = each %{ +{ a => 1 } }) {
      print "$key=$value\n";
  }

=begin original

To avoid these problems resulting from the hash-embedded iterator, use a
L<C<foreach>|perlsyn/"Foreach Loops"> loop rather than C<while>-C<each>.
As of Perl 5.36, you can iterate over both keys and values directly with
a multiple-value C<foreach> loop.

=end original

ハッシュが組み込まれた反復子によるこのような問題を避けるために、
C<while>-C<each> ではなく L<C<foreach>|perlsyn/"Foreach Loops"> ループを
使ってください。
Perl 5.36 から、複数値 C<foreach> を使ってキーと値の両方を直接
反復できます。

  # retrieves the keys one time for iteration
  # iteration is unaffected by any operations on %hash within
  foreach my $key (keys %hash) {
      my $value = $hash{$key};
      $hash{$key} = {keys => scalar keys %hash, outer => [%hash]};
      some_function_that_may_mess_with(\%hash, $key, $value);
      $hash{"new$key"} = delete $hash{$key};
  }

  # Perl 5.36+
  foreach my ($key, $value) (%{ +{ a => 1 } }) {
      print "$key=$value\n";
  }

=begin original

This prints out your environment like the L<printenv(1)> program,
but in a different order:

=end original

これは、L<printenv(1)> プログラムのように環境変数を表示しますが、
順序は異なっています:

    while (my ($key,$value) = each %ENV) {
        print "$key=$value\n";
    }

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<each> to take a scalar expression. This experiment has
been deemed unsuccessful, and was removed as of Perl 5.24.

=end original

Perl 5.14 から、C<each> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=begin original

As of Perl 5.18 you can use a bare C<each> in a C<while>
loop, which will set L<C<$_>|perlvar/$_> on every iteration.
If either an C<each> expression or an explicit assignment of an C<each>
expression to a scalar is used as a C<while>/C<for> condition, then
the condition actually tests for definedness of the expression's value,
not for its regular truth value.

=end original

Perl 5.18 から C<while> ループの中に裸の C<each> を書けます;
これは繰り返し毎に L<C<$_>|perlvar/$_> を設定します。
C<each> 式または C<each> 式からスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

    while (each %ENV) {
	print "$_=$ENV{$_}\n";
    }

=begin original

To avoid confusing would-be users of your code who are running earlier
versions of Perl with mysterious syntax errors, put this sort of thing at
the top of your file to signal that your code will work I<only> on Perls of
a recent vintage:

=end original

あなたのコードを以前のバージョンの Perl で実行したユーザーが不思議な
文法エラーで混乱することを避けるために、コードが最近のバージョンの Perl で
I<のみ> 動作することを示すためにファイルの先頭に以下のようなことを
書いてください:

    use v5.12;	# so keys/values/each work on arrays
    use v5.18;	# so each assigns to $_ in a lone while test

=begin original

See also L<C<keys>|/keys HASH>, L<C<values>|/values HASH>, and
L<C<sort>|/sort SUBNAME LIST>.

=end original

L<C<keys>|/keys HASH> や L<C<values>|/values HASH> や
L<C<sort>|/sort SUBNAME LIST> も参照してください。

=item eof FILEHANDLE
X<eof>
X<end of file>
X<end-of-file>

=item eof ()

=item eof

=for Pod::Functions test a filehandle for its end

=begin original

Returns 1 if the next read on FILEHANDLE will return end of file I<or> if
FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then C<ungetc>s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
C<eof(FILEHANDLE)> on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.

=end original

次に FILEHANDLE 上で読み込みを行なったときに、EOF が返されるときか、
I<または> FILEHANDLE がオープンされていないと、1 を返します。
FILEHANDLE は、値が実際のファイルハンドルを示す式であってもかまいません。
(この関数は、実際に文字を読み、C<ungetc> を行ないますので、
対話型の場合には有用ではありません。)
端末ファイルは EOF に達した後にさらに読み込んだり C<eof(FILEHANDLE)> を
呼び出したりしてはいけません。
そのようなことをすると、端末のようなファイルタイプは
EOF 状態を失ってしまうかもしれません。

=begin original

An C<eof> without an argument uses the last file
read.  Using C<eof()> with empty parentheses is
different.  It refers to the pseudo file formed from the files listed on
the command line and accessed via the C<< <> >> operator.  Since
C<< <> >> isn't explicitly opened, as a normal filehandle is, an
C<eof()> before C<< <> >> has been used will cause
L<C<@ARGV>|perlvar/@ARGV> to be examined to determine if input is
available.   Similarly, an C<eof()> after C<< <> >>
has returned end-of-file will assume you are processing another
L<C<@ARGV>|perlvar/@ARGV> list, and if you haven't set
L<C<@ARGV>|perlvar/@ARGV>, will read input from C<STDIN>; see
L<perlop/"I/O Operators">.

=end original

引数を省略した C<eof> は、最後に読み込みを行なった
ファイルを使います。
空の括弧をつけた C<eof()> は異なります。
これはコマンドラインのファイルリストで構成され、C<< <> >> 演算子経由で
アクセスされる擬似ファイルを示すために用いられます。
通常のファイルハンドルと違って C<< <> >> は明示的にオープンされないので、
C<< <> >> を使う前に C<eof()> を使うと、
入力が正常か確認するために L<C<@ARGV>|perlvar/@ARGV> がテストされます。
同様に、C<< <> >> が EOF を返した後の C<eof()> は、
他の L<C<@ARGV>|perlvar/@ARGV> リストを処理していると仮定し、もし
L<C<@ARGV>|perlvar/@ARGV> をセットしていないときは C<STDIN> から読み込みます;
L<perlop/"I/O Operators"> を参照してください。

=begin original

In a C<< while (<>) >> loop, C<eof> or C<eof(ARGV)>
can be used to detect the end of each file, whereas
C<eof()> will detect the end of the very last file
only.  Examples:

=end original

C<< while (<>) >> ループの中では、個々のファイルの終わりを調べるには、
C<eof> か C<eof(ARGV)> を用いるのに対して
C<eof()> は最後のファイルの終わりのみを調べます。
例:

    # reset line numbering on each input file
    while (<>) {
        next if /^\s*#/;  # skip comments
        print "$.\t$_";
    } continue {
        close ARGV if eof;  # Not eof()!
    }

    # insert dashes just before last line of last file
    while (<>) {
        if (eof()) {  # check for end of last file
            print "--------------\n";
        }
        print;
        last if eof();     # needed if we're reading from a terminal
    }

=begin original

Practical hint: you almost never need to use C<eof>
in Perl, because the input operators typically return L<C<undef>|/undef
EXPR> when they run out of data or encounter an error.

=end original

現実的なヒント: Perl で C<eof> が必要となることは、
ほとんどありません;
基本的には、データがなくなったときやエラーがあったときに、入力演算子が
L<C<undef>|/undef EXPR> を返してくれるからです。

=item eval EXPR
X<eval> X<try> X<catch> X<evaluate> X<parse> X<execute>
X<error, handling> X<exception, handling>

=item eval BLOCK

=item eval

=for Pod::Functions catch exceptions or compile and run code

=begin original

C<eval> in all its forms is used to execute a little Perl program,
trapping any errors encountered so they don't crash the calling program.

=end original

どの型式の C<eval> も、小さな Perl のプログラムであるかのように実行され、
遭遇した全てのエラーをトラップするので、呼び出したプログラムが
クラッシュすることはありません。

=begin original

Plain C<eval> with no argument is just C<eval EXPR>, where the
expression is understood to be contained in L<C<$_>|perlvar/$_>.  Thus
there are only two real C<eval> forms; the one with an EXPR is often
called "string eval".  In a string eval, the value of the expression
(which is itself determined within scalar context) is first parsed, and
if there were no errors, executed as a block within the lexical context
of the current Perl program.  This form is typically used to delay
parsing and subsequent execution of the text of EXPR until run time.
Note that the value is parsed every time the C<eval> executes.

=end original

引数なしの C<eval> は単に C<eval EXPR> で、式は L<C<$_>|perlvar/$_> に
含まれているものとして考えられます。
従って実際には二つだけの C<eval> 形式があります:
EXPR のものはしばしば「文字列 eval」(string eval) と呼ばれます。
「文字列 eval」では、
式の値(それ自身スカラコンテキストの中で決定されます)はまずパースされ、
エラーがなければ Perl プログラムのレキシカルコンテキストの中のブロックとして
実行されます。
この形は主に EXPR のテキストのパースと実行を実行時にまで
遅延させるのに用います。
返される値は C<eval> が実行されるごとにパースされることに注意してください。

=begin original

The other form is called "block eval".  It is less general than string
eval, but the code within the BLOCK is parsed only once (at the same
time the code surrounding the C<eval> itself was parsed) and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first, while also
providing the benefit of checking the code within BLOCK at compile time.
BLOCK is parsed and compiled just once.  Since errors are trapped, it
often is used to check if a given feature is available.

=end original

もう一つの型式は「ブロック eval」と呼ばれます。
これは文字列 eval ほど一般的ではありませんが、
BLOCK 内部のコードは一度だけパースされ (コードを
囲む C<eval> 自身がパースされるのと同じ時点です) 現在の
Perl プログラムのコンテキストで実行されます。
この形式は典型的には第一の形式より効率的に例外をトラップします;
また BLOCK 内部のコードはコンパイル時にチェックされるという利点を提供します。
BLOCK は一度だけパース及びコンパイルされます。
エラーはトラップされてるので、しばしば与えられた機能が利用可能かを
チェックするために使われます。

=begin original

In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may also be used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the
C<eval> itself.  See L<C<wantarray>|/wantarray> for more
on how the evaluation context can be determined.

=end original

どちらの形式でも、返される値はミニプログラムの内部で最後に評価された
表現の値です; サブルーチンと同様、return 文も使えます。
返り値として提供される表現は、C<eval> 自身のコンテキストに
依存して無効・スカラ・リストのいずれかのコンテキストで評価されます。
評価コンテキストの決定方法についての詳細は L<C<wantarray>|/wantarray> を
参照してください。

=begin original

If there is a syntax error or runtime error, or a L<C<die>|/die LIST>
statement is executed, C<eval> returns
L<C<undef>|/undef EXPR> in scalar context, or an empty list in list
context, and L<C<$@>|perlvar/$@> is set to the error message.  (Prior to
5.16, a bug caused L<C<undef>|/undef EXPR> to be returned in list
context for syntax errors, but not for runtime errors.) If there was no
error, L<C<$@>|perlvar/$@> is set to the empty string.  A control flow
operator like L<C<last>|/last LABEL> or L<C<goto>|/goto LABEL> can
bypass the setting of L<C<$@>|perlvar/$@>.  Beware that using
C<eval> neither silences Perl from printing warnings to
STDERR, nor does it stuff the text of warning messages into
L<C<$@>|perlvar/$@>.  To do either of those, you have to use the
L<C<$SIG{__WARN__}>|perlvar/%SIG> facility, or turn off warnings inside
the BLOCK or EXPR using S<C<no warnings 'all'>>.  See
L<C<warn>|/warn LIST>, L<perlvar>, and L<warnings>.

=end original

構文エラーや実行エラーが発生するか、L<C<die>|/die LIST> 文が実行されると、
C<eval> はスカラコンテキストでは L<C<undef>|/undef EXPR> が、
リストコンテキストでは空リストが設定され、
L<C<$@>|perlvar/$@> にエラーメッセージが設定されます。
(5.16 以前では、バグによって、リストコンテキストで構文エラーの時には
L<C<undef>|/undef EXPR> を返していましたが、実行エラーの時には
返していませんでした。)
エラーがなければ、L<C<$@>|perlvar/$@> は空文字列に設定されます。
L<C<last>|/last LABEL> や L<C<goto>|/goto LABEL> のようなフロー制御演算子は
L<C<$@>|perlvar/$@> の設定を回避できます。
C<eval> を、STDERR に警告メッセージを表示させない目的や、
警告メッセージを L<C<$@>|perlvar/$@> に格納する目的では使わないでください。
そのような用途では、L<C<$SIG{__WARN__}>|perlvar/%SIG> 機能を使うか、
S<C<no warnings 'all'>> を使って BLOCK か EXPR の内部での警告を
オフにする必要があります。
L<C<warn>|/warn LIST>, L<perlvar>, L<warnings> を参照してください。

=begin original

Note that, because C<eval> traps otherwise-fatal errors,
it is useful for determining whether a particular feature (such as
L<C<socket>|/socket SOCKET,DOMAIN,TYPE,PROTOCOL> or
L<C<symlink>|/symlink OLDFILE,NEWFILE>) is implemented.  It is also
Perl's exception-trapping mechanism, where the L<C<die>|/die LIST>
operator is used to raise exceptions.

=end original

C<eval> は、致命的エラーとなるようなものを
トラップすることができるので、
(L<C<socket>|/socket SOCKET,DOMAIN,TYPE,PROTOCOL> や
L<C<symlink>|/symlink OLDFILE,NEWFILE> といった) 特定の機能が
実装されているかを、
調べるために使うことができることに注意してください。
L<C<die>|/die LIST> 演算子が例外を発生させるものとすれば、これはまた、
Perl の例外捕捉機能と捉えることもできます。

=begin original

Before Perl 5.14, the assignment to L<C<$@>|perlvar/$@> occurred before
restoration
of localized variables, which means that for your code to run on older
versions, a temporary is required if you want to mask some, but not all
errors:

=end original

Perl 5.14 より前では、L<C<$@>|perlvar/$@> への代入はローカル化された変数の
復帰の前に起きるので、古いバージョンで実行される場合は、全てではなく一部だけの
エラーをマスクしたい場合には一時変数が必要です:

 # alter $@ on nefarious repugnancy only
 {
    my $e;
    {
      local $@; # protect existing $@
      eval { test_repugnancy() };
      # $@ =~ /nefarious/ and die $@; # Perl 5.14 and higher only
      $@ =~ /nefarious/ and $e = $@;
    }
    die $e if defined $e
 }

=begin original

There are some different considerations for each form:

=end original

それぞれの型式について、異なった考慮事項があります:

=over 4

=item String eval

(文字列 eval)

=begin original

Since the return value of EXPR is executed as a block within the lexical
context of the current Perl program, any outer lexical variables are
visible to it, and any package variable settings or subroutine and
format definitions remain afterwards.

=end original

EXPR の返り値は現在の Perl プログラムのレキシカルコンテキストの中で
実行されるので、外側のレキシカルスコープはそこから見え、
パッケージ変数設定やサブルーチンとフォーマット設定は後に残ります。

=begin original

Note that when C<BEGIN {}> blocks are embedded inside of an eval block
the contents of the block will be executed immediately and before the rest
of the eval code is executed. You can disable this entirely by

=end original

eval ブロック内に C<BEGIN {}> ブロックが組み込まれている場合、
ブロックの内容は直ちに、eval コードの残りの部分が実行される前に
実行されます。
これは次のようにして完全に向こうにすることができ:

   local ${^MAX_NESTED_EVAL_BEGIN_BLOCKS} = 0;
   eval $string;

=begin original

which will cause any embedded C<BEGIN> blocks in C<$string> to throw an
exception.

=end original

これは C<$string> の中の組み込みの C<BEGIN> ブロックで例外を引き起こします。

=over 4

=item Under the L<C<"unicode_eval"> feature|feature/The 'unicode_eval' and 'evalbytes' features>

=begin original

If this feature is enabled (which is the default under a C<use 5.16> or
higher declaration), Perl assumes that EXPR is a character string.
Any S<C<use utf8>> or S<C<no utf8>> declarations within
the string thus have no effect. Source filters are forbidden as well.
(C<unicode_strings>, however, can appear within the string.)

=end original

この機能が有効の場合(これは C<use 5.16> またはそれ以上が
宣言されている場合はデフォルトです)、
Perl は EXPR が文字の文字列であると仮定します。
従って文字列中の S<C<use utf8>> や S<C<no utf8>> 宣言は無効です。
ソースフィルタも禁止されます。
(しかし、C<unicode_strings> は文字列の中に現れます。)

=begin original

See also the L<C<evalbytes>|/evalbytes EXPR> operator, which works properly
with source filters.

=end original

ソースフィルタが適切に動作する
L<C<evalbytes>|/evalbytes EXPR> 演算子も参照してください。

=item Outside the C<"unicode_eval"> feature

=begin original

In this case, the behavior is problematic and is not so easily
described.  Here are two bugs that cannot easily be fixed without
breaking existing programs:

=end original

この場合、振る舞いには問題があり、それほど簡単には説明できません。
既存のプログラムを壊さずに簡単に修正することが出来ない二つのバグがあります:

=over 4

=item *

=begin original

Perl's internal storage of EXPR affects the behavior of the executed code.
For example:

=end original

Perl's internal storage of 
EXPR の Perl の内部ストーレージは実行されるコードの振る舞いに影響を与えます。
例えば:

    my $v = eval "use utf8; '$expr'";

=begin original

If $expr is C<"\xc4\x80"> (U+0100 in UTF-8), then the value stored in C<$v>
will depend on whether Perl stores $expr "upgraded" (cf. L<utf8>) or
not:

=end original

$expr が C<"\xc4\x80"> (U+0100 in UTF-8) の場合、C<$v> に保管される値は、
Perl が $expr を「昇格」(L<utf8> 参照)して保管するかどうかによります:

=over

=item * If upgraded, C<$v> will be C<"\xc4\x80"> (i.e., the
C<use utf8> has no effect.)

(昇格されると、C<$v> will be C<"\xc4\x80"> になります (つまり、C<use utf8> は無効です。))

=item * If non-upgraded, C<$v> will be C<"\x{100}">.

(昇格されないと、C<$v> は C<"\x{100}">です。)

=back

=begin original

This is undesirable since being
upgraded or not should not affect a string's behavior.

=end original

昇格するかどうかは文字列の振る舞いに影響を与えるべきではないので、
これは望ましくないです。

=item *

=begin original

Source filters activated within C<eval> leak out into whichever file
scope is currently being compiled.  To give an example with the CPAN module
L<Semi::Semicolons>:

=end original

C<eval> の中で有効にされたソースフィルタは、現在どちらのファイルスコープで
コンパイルされているかをリークさせます。
CPAN モジュール L<Semi::Semicolons> を使った例は:

 BEGIN { eval "use Semi::Semicolons; # not filtered" }
 # filtered here!

=begin original

L<C<evalbytes>|/evalbytes EXPR> fixes that to work the way one would
expect:

=end original

L<C<evalbytes>|/evalbytes EXPR> は、人が想定するだろう手法で動作するように
これを修正します:

 use feature "evalbytes";
 BEGIN { evalbytes "use Semi::Semicolons; # filtered" }
 # not filtered

=back

=back

=begin original

Problems can arise if the string expands a scalar containing a floating
point number.  That scalar can expand to letters, such as C<"NaN"> or
C<"Infinity">; or, within the scope of a L<C<use locale>|locale>, the
decimal point character may be something other than a dot (such as a
comma).  None of these are likely to parse as you are likely expecting.

=end original

文字列をが小数点を含むスカラを展開するときに問題が起こることがあります。
そのようなスカラは C<"NaN"> や C<"Infinity"> のような文字に
展開されることがあります; または、L<C<use locale>|locale> のスコープの中では、
小数点文字は (カンマのような) ドット以外の文字かもしれません。
これらはどれもあなたがおそらく予測しているようにはパースされません。

=begin original

You should be especially careful to remember what's being looked at
when:

=end original

以下のような場合に、何が調べられるかに特に注意しておくことが必要です:

    eval $x;        # CASE 1
    eval "$x";      # CASE 2

    eval '$x';      # CASE 3
    eval { $x };    # CASE 4

    eval "\$$x++";  # CASE 5
    $$x++;          # CASE 6

=begin original

Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C<'$x'>, which
does nothing but return the value of $x.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I<would> like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.

=end original

上記の CASE 1 と CASE 2 の動作は同一で、変数 $x 内の
コードを実行します。
(ただし、CASE 2 では、必要のないダブルクォートによって、
読む人が何が起こるか混乱することでしょう (何も起こりませんが)。)
同様に CASE 3 と CASE 4 の動作も等しく、$x の値を返す以外に
何もしない C<$x> というコードを実行します。
(純粋に見た目の問題で、CASE 4 が好まれますが、
実行時でなくコンパイル時にコンパイルされるという利点もあります)。
CASE 5 の場合は、通常ダブルクォートを使用 I<します>;
この状況を除けば、CASE 6 のように、単に
シンボリックリファレンスを使えば良いでしょう。

=begin original

An C<eval ''> executed within a subroutine defined
in the C<DB> package doesn't see the usual
surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it.  You don't normally need to worry about this unless
you are writing a Perl debugger.

=end original

C<DB> パッケージで定義されたサブルーチン内で C<eval ''> を実行すると、通常の
レキシカルスコープではなく、これを呼び出した最初の非 DB コード片の
スコープになります。
Perl デバッガを書いているのでない限り、普通はこれについて心配する必要は
ありません。

=begin original

The final semicolon, if any, may be omitted from the value of EXPR.

=end original

最後のセミコロンは、もしあれば、EXPR の値から省くことができます。

=item Block eval

=begin original

If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in
L<C<$@>|perlvar/$@>.
Examples:

=end original

実行するコードが変わらないのであれば、毎回多量の再コンパイルすることなしに、
実行時エラーのトラップを行なうために、
eval-BLOCK 形式を使うことができます。
エラーがあれば、やはり L<C<$@>|perlvar/$@> に返されます。
例:

    # make divide-by-zero nonfatal
    eval { $answer = $x / $y; }; warn $@ if $@;

    # same thing, but less efficient
    eval '$answer = $x / $y'; warn $@ if $@;

    # a compile-time error
    eval { $answer = }; # WRONG

    # a run-time error
    eval '$answer =';   # sets $@

=begin original

If you want to trap errors when loading an XS module, some problems with
the binary interface (such as Perl version skew) may be fatal even with
C<eval> unless C<$ENV{PERL_DL_NONLAZY}> is set.  See
L<perlrun|perlrun/PERL_DL_NONLAZY>.

=end original

XS モジュールのロード中のエラーをトラップしたいなら、
(Perl バージョンの違いのような) バイナリインターフェースに関する問題に
ついては C<$ENV{PERL_DL_NONLAZY}> がセットされていない
C<eval> でも致命的エラーになるかもしれません。
L<perlrun|perlrun/PERL_DL_NONLAZY> を参照してください。

=begin original

Using the C<eval {}> form as an exception trap in libraries does have some
issues.  Due to the current arguably broken state of C<__DIE__> hooks, you
may wish not to trigger any C<__DIE__> hooks that user code may have installed.
You can use the C<local $SIG{__DIE__}> construct for this purpose,
as this example shows:

=end original

C<eval{}> 形式をライブラリの例外を捕捉するために使うときには
問題があります。
現在の C<__DIE__> フックの状態はほぼ確実に壊れているという理由で、
ユーザーのコードが設定した C<__DIE__> フックを実行したくないかもしれません。
この目的には以下の例のように、C<local $SIG{__DIE__}> 構造が使えます。

    # a private exception trap for divide-by-zero
    eval { local $SIG{'__DIE__'}; $answer = $x / $y; };
    warn $@ if $@;

=begin original

This is especially significant, given that C<__DIE__> hooks can call
L<C<die>|/die LIST> again, which has the effect of changing their error
messages:

=end original

これは特に顕著です; 与えられた C<__DIE__> フックは L<C<die>|/die LIST> を
もう一度呼び出すことができ、これによってエラーメッセージを変える
効果があります:

    # __DIE__ hooks may modify error messages
    {
       local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
       eval { die "foo lives here" };
       print $@ if $@;                # prints "bar lives here"
    }

=begin original

Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.

=end original

これは距離の離れた行動であるため、この直感的でない振る舞いは
将来のリリースでは修正されるかもしれません。

=begin original

C<eval BLOCK> does I<not> count as a loop, so the loop control statements
L<C<next>|/next LABEL>, L<C<last>|/last LABEL>, or
L<C<redo>|/redo LABEL> cannot be used to leave or restart the block.

=end original

C<eval BLOCK> はループとして I<扱われません>; 従って、L<C<next>|/next LABEL>,
L<C<last>|/last LABEL>, L<C<redo>|/redo LABEL> といったループ制御文で
ブロックから離れたり再実行したりはできません。

=begin original

The final semicolon, if any, may be omitted from within the BLOCK.

=end original

最後のセミコロンは、もしあれば、BLOCK の中から削除されます。

=back

=item evalbytes EXPR
X<evalbytes>

=item evalbytes

=for Pod::Functions +evalbytes similar to string eval, but intend to parse a bytestream

=begin original

This function is similar to a L<string eval|/eval EXPR>, except it
always parses its argument (or L<C<$_>|perlvar/$_> if EXPR is omitted)
as a byte string. If the string contains any code points above 255, then
it cannot be a byte string, and the C<evalbytes> will fail with the error
stored in C<$@>.

=end original

この関数は L<文字列 eval|/eval EXPR> に似ていますが、引数(EXPR が
省略された場合はL<C<$_>|perlvar/$_>) を常にバイト単位のの文字列として
扱います。
文字列に 255 を超える符号位置が含まれている場合、バイト単位文字列に
することができないので、
C<evalbytes> は失敗し、エラーは C<$@> に保管されます。

=begin original

C<use utf8> and C<no utf8> within the string have their usual effect.

=end original

文字列中の C<use utf8> と C<no utf8> は通常の効果を持ちます。

=begin original

Source filters activated within the evaluated code apply to the code
itself.

=end original

eval されたコード内で有効になったソースフィルタはコード自体に適用されます。

=begin original

C<evalbytes> is available starting in Perl v5.16.  To
access it, you must say C<CORE::evalbytes>, but you can omit the
C<CORE::> if the
L<C<"evalbytes"> feature|feature/The 'unicode_eval' and 'evalbytes' features>
is enabled.  This is enabled automatically with a C<use v5.16> (or
higher) declaration in the current scope.

=end original

C<evalbytes> は Perl v5.16 から利用可能です。
これにアクセスするには C<CORE::evalbytes> とする必要がありますが、
L<C<"evalbytes"> 機能|feature/The 'unicode_eval' and 'evalbytes' features> が
有効なら C<CORE::> を省略できます。
これは現在のスコープで C<use v5.16> (またはそれ以上) 宣言があると
自動的に有効になります。

=item exec LIST
X<exec> X<execute>

=item exec PROGRAM LIST

=for Pod::Functions abandon this program to run another

=begin original

The C<exec> function executes a system command I<and never
returns>; use L<C<system>|/system LIST> instead of C<exec>
if you want it to return.  It fails and
returns false only if the command does not exist I<and> it is executed
directly instead of via your system's command shell (see below).

=end original

C<exec> 関数は、システムのコマンドを実行し、I<戻ってはきません>;
戻って欲しい場合には、C<exec> ではなく
L<C<system>|/system LIST> 関数を使ってください。
コマンドが存在せず、I<しかも> システムのコマンドシェル経由でなく
直接コマンドを実行しようとした場合にのみこの関数は失敗して偽を返します。

=begin original

Since it's a common mistake to use C<exec> instead of
L<C<system>|/system LIST>, Perl warns you if C<exec> is
called in void context and if there is a following statement that isn't
L<C<die>|/die LIST>, L<C<warn>|/warn LIST>, or L<C<exit>|/exit EXPR> (if
L<warnings> are enabled--but you always do that, right?).  If you
I<really> want to follow an C<exec> with some other
statement, you can use one of these styles to avoid the warning:

=end original

L<C<system>|/system LIST> の代わりに C<exec> を使うという
よくある間違いを防ぐために、C<exec> が無効コンテキストで
呼び出されて、引き続く文が L<C<die>|/die LIST>, L<C<warn>|/warn LIST>,
L<C<exit>|/exit EXPR> 以外の場合、Perl は警告を出します(L<warnings> が
有効の場合 -- でもいつもセットしてますよね?)。
もし I<本当に> C<exec> の後に他の文を書きたい場合、以下の
どちらかのスタイルを使うことで警告を回避できます:

    exec ('foo')   or print STDERR "couldn't exec foo: $!";
    { exec ('foo') }; print STDERR "couldn't exec foo: $!";

=begin original

If there is more than one argument in LIST, this calls L<execvp(3)> with the
arguments in LIST.  If there is only one element in LIST, the argument is
checked for shell metacharacters, and if there are any, the entire
argument is passed to the system's command shell for parsing (this is
C</bin/sh -c> on Unix platforms, but varies on other platforms).  If
there are no shell metacharacters in the argument, it is split into words
and passed directly to C<execvp>, which is more efficient.  Examples:

=end original

LIST に複数の引数がある場合は、LIST の引数を使って L<execvp(3)> を
呼び出します。
LIST に要素が一つのみの場合には、その引数からシェルのメタ文字をチェックし、
もしメタ文字があれば、引数全体をシステムのコマンドシェル(これはUnix では
C</bin/sh -c> ですが、システムによって異なります)に渡して解析させます。
シェルのメタ文字がなかった場合、引数は単語に分解されて直接 C<execvp> に
渡されます; この方がより効率的です。
例:

    exec '/bin/echo', 'Your arguments are: ', @ARGV;
    exec "sort $outfile | uniq";

=begin original

If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an "indirect object" (without a
comma) in front of the LIST, as in C<exec PROGRAM LIST>.  (This always
forces interpretation of the LIST as a multivalued list, even if there
is only a single scalar in the list.)  Example:

=end original

第一引数に指定するものを本当に実行したいが、実行するプログラムに対して別の
名前を教えたい場合には、C<exec PROGRAM LIST> のように、LIST の前に
「間接オブジェクト」(コンマなし) として実際に実行したいプログラムを
指定することができます。
(これによって、LIST に単一のスカラしかなくても、複数値のリストであるように、
LIST の解釈を行ないます。)
例:

    my $shell = '/bin/csh';
    exec $shell '-sh';    # pretend it's a login shell

=begin original

or, more directly,

=end original

あるいは、より直接的に、

    exec {'/bin/csh'} '-sh';  # pretend it's a login shell

=begin original

When the arguments get executed via the system shell, results are
subject to its quirks and capabilities.  See L<perlop/"`STRING`">
for details.

=end original

引数がシステムシェルで実行されるとき、結果はシェルの奇癖と能力によって
変わります。
詳細については L<perlop/"`STRING`"> を参照してください。

=begin original

Using an indirect object with C<exec> or
L<C<system>|/system LIST> is also more secure.  This usage (which also
works fine with L<C<system>|/system LIST>) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.  That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.

=end original

C<exec> や L<C<system>|/system LIST> で間接オブジェクトを
使うのもより安全です。
この使い方(L<C<system>|/system LIST> でも同様にうまく動きます)は、たとえ
引数が一つだけの場合も、複数の値を持つリストとして引数を解釈することを
強制します。
この方法で、シェルによるワイルドカード展開や、空白による単語の分割から
守られます。

    my @args = ( "echo surprise" );

    exec @args;               # subject to shell escapes
                                # if @args == 1
    exec { $args[0] } @args;  # safe even with one-arg list

=begin original

The first version, the one without the indirect object, ran the I<echo>
program, passing it C<"surprise"> as an argument.  The second version didn't;
it tried to run a program named I<"echo surprise">, didn't find it, and set
L<C<$?>|perlvar/$?> to a non-zero value indicating failure.

=end original

間接オブジェクトなしの一つ目のバージョンでは、I<echo> プログラムが実行され、
C<"surprise"> が引数として渡されます。
二つ目のバージョンでは違います; I<"echo surprise"> という名前の
プログラムを実行しようとして、見つからないので、失敗したことを示すために
L<C<$?>|perlvar/$?> に非 0 がセットされます。

=begin original

On Windows, only the C<exec PROGRAM LIST> indirect object syntax will
reliably avoid using the shell; C<exec LIST>, even with more than one
element, will fall back to the shell if the first spawn fails.

=end original

Windows では、C<exec PROGRAM LIST> 間接オブジェクト構文のみが、シェルを
使うのを回避するための信頼できる方法です; C<exec LIST> は、複数の要素が
あっても、最初の spawn が失敗したときにシェルに
フォールバックすることがあります。

=begin original

Perl attempts to flush all files opened for output before the exec,
but this may not be supported on some platforms (see L<perlport>).
To be safe, you may need to set L<C<$E<verbar>>|perlvar/$E<verbar>>
(C<$AUTOFLUSH> in L<English>) or call the C<autoflush> method of
L<C<IO::Handle>|IO::Handle/METHODS> on any open handles to avoid lost
output.

=end original

Perl は exec の前に出力用に開かれている全てのファイルを
フラッシュしようとしますが、これに対応していないプラットフォームもあります
(L<perlport> を参照してください)。
安全のためには、出力が重複するのを避けるために、全てのオープンしている
ハンドルに対して L<C<$E<verbar>>|perlvar/$E<verbar>>
(L<English> モジュールでは C<$AUTOFLUSH>) を設定するか、
L<C<IO::Handle>|IO::Handle/METHODS> モジュールの C<autoflush> メソッドを
呼ぶ必要があるかもしれません。

=begin original

Note that C<exec> will not call your C<END> blocks, nor
will it invoke C<DESTROY> methods on your objects.

=end original

C<exec> は C<END> ブロックや、オブジェクトの
C<DESTROY> メソッドを起動しないことに注意してください。

=begin original

Portability issues: L<perlport/exec>.

=end original

移植性の問題: L<perlport/exec>。

=item exists EXPR
X<exists> X<autovivification>

=for Pod::Functions test whether a hash key is present

=begin original

Given an expression that specifies an element of a hash, returns true if the
specified element in the hash has ever been initialized, even if the
corresponding value is undefined.

=end original

ハッシュ要素を示す表現が与えられ、指定された要素が、ハッシュに存在すれば、
たとえ対応する値が未定義でも真を返します。

    print "Exists\n"    if exists $hash{$key};
    print "Defined\n"   if defined $hash{$key};
    print "True\n"      if $hash{$key};

=begin original

exists may also be called on array elements, but its behavior is much less
obvious and is strongly tied to the use of L<C<delete>|/delete EXPR> on
arrays.

=end original

exists は配列の要素に対しても呼び出せますが、その振る舞いははるかに
不明確で、配列に対する L<C<delete>|/delete EXPR> の使用と強く
結びついています。

=begin original

B<WARNING:> Calling C<exists> on array values is
strongly discouraged.  The
notion of deleting or checking the existence of Perl array elements is not
conceptually coherent, and can lead to surprising behavior.

=end original

B<警告:> 配列の値に対して C<exists> を呼び出すことは強く
非推奨です。
Perl の配列要素を削除したり存在を調べたりする記法は概念的に一貫しておらず、
驚くべき振る舞いを引き起こすことがあります。

    print "Exists\n"    if exists $array[$index];
    print "Defined\n"   if defined $array[$index];
    print "True\n"      if $array[$index];

=begin original

A hash or array element can be true only if it's defined and defined only if
it exists, but the reverse doesn't necessarily hold true.

=end original

ハッシュまたは配列要素は、定義されているときにのみ真となり、
存在しているときにのみ定義されますが、逆は必ずしも真ではありません。

=begin original

Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.  Mentioning a subroutine name for exists or defined
does not count as declaring it.  Note that a subroutine that does not
exist may still be callable: its package may have an C<AUTOLOAD>
method that makes it spring into existence the first time that it is
called; see L<perlsub>.

=end original

引数としてサブルーチンの名前が指定された場合、
指定されたサブルーチンが宣言されていれば(たとえ未定義でも)
真を返します。
exists や defined のために言及されているサブルーチン名は
宣言としてのカウントに入りません。
存在しないサブルーチンでも呼び出し可能かもしれないことに注意してください:
パッケージが C<AUTOLOAD> メソッドを持っていて、最初に呼び出された時に
存在を作り出すかもしれません; L<perlsub> を参照してください。

    print "Exists\n"  if exists &subroutine;
    print "Defined\n" if defined &subroutine;

=begin original

Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:

=end original

最終的な操作がハッシュや配列の key による検索または
サブルーチン名である限りは、EXPR には任意の複雑な式を置くことができます:

    if (exists $ref->{A}->{B}->{$key})  { }
    if (exists $hash{A}{B}{$key})       { }

    if (exists $ref->{A}->{B}->[$ix])   { }
    if (exists $hash{A}{B}[$ix])        { }

    if (exists &{$ref->{A}{B}{$key}})   { }

=begin original

Although the most deeply nested array or hash element will not spring into
existence just because its existence was tested, any intervening ones will.
Thus C<< $ref->{"A"} >> and C<< $ref->{"A"}->{"B"} >> will spring
into existence due to the existence test for the C<$key> element above.
This happens anywhere the arrow operator is used, including even here:

=end original

最も深くネストした配列やハッシュの要素は、その存在をテストしただけでは
存在するようにはなりませんが、途中のものは存在するようになります。
従って C<< $ref->{"A"} >> と C<< $ref->{"A"}->{"B"} >> は上記の C<$key> の
存在をテストしたことによって存在するようになります。
これは、矢印演算子が使われるところでは、以下のようなものを含むどこででも
起こります。

    undef $ref;
    if (exists $ref->{"Some key"})    { }
    print $ref;  # prints HASH(0x80d3d5c)

=begin original

Use of a subroutine call, rather than a subroutine name, as an argument
to C<exists> is an error.

=end original

C<exists> の引数としてサブルーチン名でなくサブルーチン
呼び出しを使うと、エラーになります。

    exists &sub;    # OK
    exists &sub();  # Error

=item exit EXPR
X<exit> X<terminate> X<abort>

=item exit

=for Pod::Functions terminate this program

=begin original

Evaluates EXPR and exits immediately with that value.    Example:

=end original

EXPR を評価し、即座にその値を持って終了します。
例:

    my $ans = <STDIN>;
    exit 0 if $ans =~ /^[Xx]/;

=begin original

See also L<C<die>|/die LIST>.  If EXPR is omitted, exits with C<0>
status.  The only
universally recognized values for EXPR are C<0> for success and C<1>
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.  For example, exiting
69 (EX_UNAVAILABLE) from a I<sendmail> incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.

=end original

L<C<die>|/die LIST> も参照してください。
EXPR が省略された場合には、ステータスを C<0> として終了します。
EXPR の値として広く利用可能なのは C<0> が成功で C<1> が
エラーということだけです; その他の値は、 Perl が実行される環境によって異なる
解釈がされる可能性があります。
例えば、I<sendmail> 到着メールフィルタから 69 (EX_UNAVAILABLE) で終了すると
メーラーはアイテムを配達せずに差し戻しますが、
これはいつでも真ではありません。

=begin original

Don't use C<exit> to abort a subroutine if there's any
chance that someone might want to trap whatever error happened.  Use
L<C<die>|/die LIST> instead, which can be trapped by an
L<C<eval>|/eval EXPR>.

=end original

誰かが発生したエラーをトラップしようと考えている可能性がある場合は、
サブルーチンの中断に C<exit> を使わないでください。
代わりに L<C<eval>|/eval EXPR> でトラップできる L<C<die>|/die LIST> を
使ってください。

=begin original

The C<exit> function does not always exit immediately.  It
calls any defined C<END> routines first, but these C<END> routines may
not themselves abort the exit.  Likewise any object destructors that
need to be called are called before the real exit.  C<END> routines and
destructors can change the exit status by modifying L<C<$?>|perlvar/$?>.
If this is a problem, you can call
L<C<POSIX::_exit($status)>|POSIX/C<_exit>> to avoid C<END> and destructor
processing.  See L<perlmod> for details.

=end original

C<exit> 関数は常に直ちに終了するわけではありません。
まず、定義されている C<END> ルーチンを呼び出しますが、
C<END> ルーチン自身は exit を止められません。
同様に、呼び出す必要のあるオブジェクトデストラクタは
すべて、実際の終了前に呼び出されます。
C<END> ルーチンとデストラクタは L<C<$?>|perlvar/$?> を修正することで
終了コードを変更できます。
これが問題になる場合は、C<END> やデストラクタが実行されることを
防ぐために L<C<POSIX::_exit($status)>|POSIX/C<_exit>> を呼び出してください。
詳しくは L<perlmod> を参照してください。

=begin original

Portability issues: L<perlport/exit>.

=end original

移植性の問題: L<perlport/exit>。

=item exp EXPR
X<exp> X<exponential> X<antilog> X<antilogarithm> X<e>

=item exp

=for Pod::Functions raise I<e> to a power

=begin original

Returns I<e> (the natural logarithm base) to the power of EXPR.
If EXPR is omitted, gives C<exp($_)>.

=end original

I<e> (自然対数の底) の EXPR 乗を返します。
EXPR を省略した場合には、C<exp($_)> を返します。

=item fc EXPR
X<fc> X<foldcase> X<casefold> X<fold-case> X<case-fold>

=item fc

=for Pod::Functions +fc return casefolded version of a string

=begin original

Returns the casefolded version of EXPR.  This is the internal function
implementing the C<\F> escape in double-quoted strings.

=end original

EXPR の畳み込み版を返します。
これは、ダブルクォート文字列における、C<\F> エスケープを
実装する内部関数です。

=begin original

Casefolding is the process of mapping strings to a form where case
differences are erased; comparing two strings in their casefolded
form is effectively a way of asking if two strings are equal,
regardless of case.

=end original

畳み込みは大文字小文字の違いを消した形式に文字列をマッピングする処理です;
畳み込み形式で二つの文字列を比較するのは二つの文字列が大文字小文字に
関わらず等しいかどうかを比較する効率的な方法です。

=begin original

Roughly, if you ever found yourself writing this

=end original

おおよそ、自分自身で以下のように書いていたとしても

    lc($this) eq lc($that)    # Wrong!
        # or
    uc($this) eq uc($that)    # Also wrong!
        # or
    $this =~ /^\Q$that\E\z/i  # Right!

=begin original

Now you can write

=end original

今では以下のように書けます

    fc($this) eq fc($that)

=begin original

And get the correct results.

=end original

そして正しい結果を得られます。

=begin original

Perl only implements the full form of casefolding, but you can access
the simple folds using L<Unicode::UCD/B<casefold()>> and
L<Unicode::UCD/B<prop_invmap()>>.
For further information on casefolding, refer to
the Unicode Standard, specifically sections 3.13 C<Default Case Operations>,
4.2 C<Case-Normative>, and 5.18 C<Case Mappings>,
available at L<https://www.unicode.org/versions/latest/>, as well as the
Case Charts available at L<https://www.unicode.org/charts/case/>.

=end original

Perl は完全な形式の畳み込みのみを実装していますが、
L<Unicode::UCD/B<casefold()>> と L<Unicode::UCD/B<prop_invmap()>> を使って
単純なたたみ込みにアクセスできます。
畳み込みに関するさらなる情報については、
L<https://www.unicode.org/versions/latest/> で利用可能な Unicode 標準、特に
3.13 C<Default Case Operations>, 4.2 C<Case-Normative>, 5.18
C<Case Mappings> および、L<https://www.unicode.org/charts/case/> で
利用可能なケース表を参照してください。

=begin original

If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

=begin original

This function behaves the same way under various pragmas, such as within
L<S<C<"use feature 'unicode_strings">>|feature/The 'unicode_strings' feature>,
as L<C<lc>|/lc EXPR> does, with the single exception of
C<fc> of I<LATIN CAPITAL LETTER SHARP S> (U+1E9E) within the
scope of L<S<C<use locale>>|locale>.  The foldcase of this character
would normally be C<"ss">, but as explained in the L<C<lc>|/lc EXPR>
section, case
changes that cross the 255/256 boundary are problematic under locales,
and are hence prohibited.  Therefore, this function under locale returns
instead the string C<"\x{17F}\x{17F}">, which is the I<LATIN SMALL LETTER
LONG S>.  Since that character itself folds to C<"s">, the string of two
of them together should be equivalent to a single U+1E9E when foldcased.

=end original

この関数は、
L<S<C<"use feature 'unicode_strings">>|feature/The 'unicode_strings' feature>
のようなさまざまなプラグマの影響下では、L<C<lc>|/lc EXPR> と同様に
振る舞います;
但し、L<S<C<use locale>>|locale> のスコープ内での
I<LATIN CAPITAL LETTER SHARP S> (U+1E9E) の C<fc> は例外です。
この文字の畳み込み文字は普通は C<"ss"> ですが、L<C<lc>|/lc EXPR> の節で
説明しているように、ロケールの基での255/256 境界をまたぐ大文字小文字の変更は
問題があるので、禁止されています。
従って、ロケールの基ではこの関数は代わりに I<LATIN SMALL LETTER LONG S> である
C<"\x{17F}\x{17F}"> を返します。
この文字自体は C<"s"> の畳み込みなので、これら二つを合わせた文字列は
畳み込まれた場合は単一の U+1E9E と等価になります。

=begin original

While the Unicode Standard defines two additional forms of casefolding,
one for Turkic languages and one that never maps one character into multiple
characters, these are not provided by the Perl core.  However, the CPAN module
L<C<Unicode::Casing>|Unicode::Casing> may be used to provide an implementation.

=end original

Unicode 標準はさらに二つの畳み込み形式、一つはツルキ語、もう一つは決して
一つの文字が複数の文字にマッピングされないもの、を定義していますが、
これらは Perl コアでは提供されません。
しかし、CPAN モジュール L<C<Unicode::Casing>|Unicode::Casing> が実装を
提供しています。

=begin original

C<fc> is available only if the
L<C<"fc"> feature|feature/The 'fc' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"fc"> feature|feature/The 'fc' feature> is enabled automatically
with a C<use v5.16> (or higher) declaration in the current scope.

=end original

C<fc> は L<C<"fc"> 機能|feature/The 'fc' feature> が有効か
C<CORE::> が前置されたときにのみ利用可能です。
L<C<"fc"> 機能|feature/The 'fc' feature> は現在のスコープで
C<use v5.16> (またはそれ以上) が宣言されると自動的に有効になります。

=item fcntl FILEHANDLE,FUNCTION,SCALAR
X<fcntl>

=for Pod::Functions file control system call

=begin original

Implements the L<fcntl(2)> function.  You'll probably have to say

=end original

L<fcntl(2)> 関数を実装します。
正しい定数定義を得るために、まず

    use Fcntl;

=begin original

first to get the correct constant definitions.  Argument processing and
value returned work just like L<C<ioctl>|/ioctl
FILEHANDLE,FUNCTION,SCALAR> below.  For example:

=end original

と書くことが必要でしょう。
引数の処理と返り値については、下記の
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR> と同様に動作します。
例えば:

    use Fcntl;
    my $flags = fcntl($filehandle, F_GETFL, 0)
        or die "Can't fcntl F_GETFL: $!";

=begin original

You don't have to check for L<C<defined>|/defined EXPR> on the return
from C<fcntl>.  Like
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR>, it maps a C<0> return
from the system call into C<"0 but true"> in Perl.  This string is true
in boolean context and C<0> in numeric context.  It is also exempt from
the normal
L<C<Argument "..." isn't numeric>|perldiag/Argument "%s" isn't numeric%s>
L<warnings> on improper numeric conversions.

=end original

C<fcntl> からの返り値のチェックに
L<C<defined>|/defined EXPR> を使う必要はありません。
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR> と違って、これは
システムコールの結果が C<0> だった場合は C<"0 だが真"> を返します。
この文字列は真偽値コンテキストでは真となり、
数値コンテキストでは C<0> になります。
これはまた、不適切な数値変換に関する通常の
L<C<Argument "..." isn't numeric>|perldiag/Argument "%s" isn't numeric%s>
L<warnings> を回避します。

=begin original

Note that C<fcntl> raises an
exception if used on a machine that doesn't implement L<fcntl(2)>.  See
the L<Fcntl> module or your L<fcntl(2)> manpage to learn what functions
are available on your system.

=end original

L<fcntl(2)> が実装されていないマシンでは、
C<fcntl> は例外を
引き起こすことに注意してください。
システムでどの関数が利用可能かについては L<Fcntl> モジュールや
L<fcntl(2)> man ページを参照してください。

=begin original

Here's an example of setting a filehandle named C<$REMOTE> to be
non-blocking at the system level.  You'll have to negotiate
L<C<$E<verbar>>|perlvar/$E<verbar>> on your own, though.

=end original

これは C<$REMOTE> というファイルハンドルをシステムレベルで
非ブロックモードにセットする例です。
ただし、 L<C<$E<verbar>>|perlvar/$E<verbar>> を自分で管理しなければなりません。

    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

    my $flags = fcntl($REMOTE, F_GETFL, 0)
        or die "Can't get flags for the socket: $!\n";

    fcntl($REMOTE, F_SETFL, $flags | O_NONBLOCK)
        or die "Can't set flags for the socket: $!\n";

=begin original

Portability issues: L<perlport/fcntl>.

=end original

移植性の問題: L<perlport/fcntl>。

=item __FILE__
X<__FILE__>

=for Pod::Functions the name of the current source file

=begin original

A special token that returns the name of the file in which it occurs.
It can be altered by the mechanism described at
L<perlsyn/"Plain Old Comments (Not!)">.

=end original

これが書いてあるファイルの名前を返す特殊トークン。
L<perlsyn/"Plain Old Comments (Not!)"> で記述されている機構を使って
置き換えられます。

=item field VARNAME
X<field>

=for Pod::Functions declare a field variable of the current class

=begin original

Declares a new field variable within the current class.  Methods and
C<ADJUST> blocks of the class will have access to this variable as if it
was a lexical in scope at that point.

=end original

現在のクラス内に新しいフィールド変数を宣言します。
クラスのメソッドと C<ADJUST> ブロックは、この時点でのスコープ内の
レキシカル変数であるかのようにこれにアクセスできます。

=item fileno FILEHANDLE
X<fileno>

=item fileno DIRHANDLE

=for Pod::Functions return file descriptor from filehandle

=begin original

Returns the file descriptor for a filehandle or directory handle,
or undefined if the
filehandle is not open.  If there is no real file descriptor at the OS
level, as can happen with filehandles connected to memory objects via
L<C<open>|/open FILEHANDLE,MODE,EXPR> with a reference for the third
argument, -1 is returned.

=end original

ファイルハンドルやディレクトリハンドルに対するファイル記述子を返します;
ファイルハンドルがオープンしていない場合は未定義値を返します。
OS レベルで実際のファイル記述子がない(
L<C<open>|/open FILEHANDLE,MODE,EXPR> の第 3 引数にリファレンスを
指定してファイルハンドルがメモリオブジェクトと結びつけられたときに
起こります)場合、-1 が返されます。

=begin original

This is mainly useful for constructing bitmaps for
L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> and low-level POSIX
tty-handling operations.
If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.

=end original

これは主に L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> や低レベル
POSIX tty 操作に対する、ビットマップを構成するときに便利です。
FILEHANDLE が式であれば、
その値が間接ファイルハンドル(普通は名前)として使われます。

=begin original

You can use this to find out whether two handles refer to the
same underlying descriptor:

=end original

これを、二つのハンドルが同じ識別子を参照しているかどうかを見つけるのに
使えます:

    if (fileno($this) != -1 && fileno($this) == fileno($that)) {
        print "\$this and \$that are dups\n";
    } elsif (fileno($this) != -1 && fileno($that) != -1) {
        print "\$this and \$that have different " .
            "underlying file descriptors\n";
    } else {
        print "At least one of \$this and \$that does " .
            "not have a real file descriptor\n";
    }

=begin original

The behavior of C<fileno> on a directory handle
depends on the operating system.  On a system with L<dirfd(3)> or
similar, C<fileno> on a directory
handle returns the underlying file descriptor associated with the
handle; on systems with no such support, it returns the undefined value,
and sets L<C<$!>|perlvar/$!> (errno).

=end original

ディレクトリハンドルに対する C<fileno> の振る舞いは
オペレーティングシステムに依存します。
L<dirfd(3)> のようなものがあるシステムでは、ディレクトリハンドルに対する
C<fileno> はハンドルに関連付けられた基となる
ファイル記述子を返します;
そのような対応がないシステムでは、未定義値を返し、
L<C<$!>|perlvar/$!> (errno) を設定します。

=item flock FILEHANDLE,OPERATION
X<flock> X<lock> X<locking>

=for Pod::Functions lock an entire file with an advisory lock

=begin original

Calls L<flock(2)>, or an emulation of it, on FILEHANDLE.  Returns true
for success, false on failure.  Produces a fatal error if used on a
machine that doesn't implement L<flock(2)>, L<fcntl(2)> locking, or
L<lockf(3)>.  C<flock> is Perl's portable
file-locking interface, although it locks entire files only, not
records.

=end original

FILEHANDLE に対して L<flock(2)>、またはそのエミュレーションを呼び出します。
成功時には真を、失敗時には偽を返します。
L<flock(2)>, L<fcntl(2)> ロック, L<lockf(3)> のいずれかを実装していない
マシンで使うと、致命的エラーが発生します。
C<flock> は Perl の移植性のある
ファイルロックインターフェースです;
しかしレコードではなく、ファイル全体のみをロックします。

=begin original

Two potentially non-obvious but traditional L<C<flock>|/flock
FILEHANDLE,OPERATION> semantics are
that it waits indefinitely until the lock is granted, and that its locks
are B<merely advisory>.  Such discretionary locks are more flexible, but
offer fewer guarantees.  This means that programs that do not also use
C<flock> may modify files locked with
C<flock>.  See L<perlport>,
your port's specific documentation, and your system-specific local manpages
for details.  It's best to assume traditional behavior if you're writing
portable programs.  (But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
"features").  Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)

=end original

明白ではないものの、伝統的な L<C<flock>|/flock FILEHANDLE,OPERATION> の
動作としては、ロックが得られるまで
無限に待ち続けるものと、B<単に勧告的に> ロックするものの二つがあります。
このような自由裁量のロックはより柔軟ですが、保障されるものはより少ないです。
これは、C<flock> を使わないプログラムが
C<flock> でロックされたファイルを
書き換えるかもしれないことを意味します。
詳細については、L<perlport>、システム固有のドキュメント、システム固有の
ローカルの man ページを参照してください。
移植性のあるプログラムを書く場合は、伝統的な振る舞いを仮定するのが
ベストです。
(しかし移植性のないプログラムを書く場合は、自身のシステムの性癖(しばしば
「仕様」と呼ばれます)に合わせて書くことも完全に自由です。
盲目的に移植性に固執することで、あなたの作業を仕上げるのを邪魔するべきでは
ありません。)

=begin original

OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with
LOCK_NB.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the L<Fcntl> module,
either individually, or as a group using the C<:flock> tag.  LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.  If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX, then C<flock> returns
immediately rather than blocking waiting for the lock; check the return
status to see if you got it.

=end original

OPERATION は LOCK_SH, LOCK_EX, LOCK_UN のいずれかで、LOCK_NB と
組み合わされることもあります。
これらの定数は伝統的には 1, 2, 8, 4 の値を持ちますが、L<Fcntl> モジュールから
シンボル名を独立してインポートするか、C<:flock> タグを使うグループとして、
シンボル名をを使うことができます。
LOCK_SH は共有ロックを要求し、LOCK_EX は排他ロックを要求し、LOCK_UN は
前回要求したロックを開放します。
LOCK_NB と LOCK_SH か LOCK_EX がビット単位の論理和されると、
C<flock> は
ロックを取得するまで待つのではなく、すぐに返ります;
ロックが取得できたかどうかは返り値を調べます。

=begin original

To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE
before locking or unlocking it.

=end original

不一致の可能性を避けるために、Perl はファイルをロック、アンロックする前に
FILEHANDLE をフラッシュします。

=begin original

Note that the emulation built with L<lockf(3)> doesn't provide shared
locks, and it requires that FILEHANDLE be open with write intent.  These
are the semantics that L<lockf(3)> implements.  Most if not all systems
implement L<lockf(3)> in terms of L<fcntl(2)> locking, though, so the
differing semantics shouldn't bite too many people.

=end original

L<lockf(3)> で作成されたエミュレーションは共有ロックを提供せず、
FILEHANDLE が書き込みモードで開いていることを必要とすることに
注意してください。
これは L<lockf(3)> が実装している動作です。
しかし、全てではないにしてもほとんどのシステムでは L<fcntl(2)> を使って
L<lockf(3)> を実装しているので、異なった動作で多くの人々を混乱させることは
ないはずです。

=begin original

Note that the L<fcntl(2)> emulation of L<flock(3)> requires that FILEHANDLE
be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.

=end original

L<flock(3)> の L<fcntl(2)> エミュレーションは、 LOCK_SH を使うためには
FILEHANDLE を読み込みで開いている必要があり、LOCK_EX を使うためには
書き込みで開いている必要があることに注意してください。

=begin original

Note also that some versions of C<flock>
cannot lock things over the network; you would need to use the more
system-specific L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR> for
that.  If you like you can force Perl to ignore your system's L<flock(2)>
function, and so provide its own L<fcntl(2)>-based emulation, by passing
the switch C<-Ud_flock> to the F<Configure> program when you configure
and build a new Perl.

=end original

ネットワーク越しにはロックできない C<flock> も
あることに注意してください;
このためには、よりシステム依存な
L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR> を使う必要があります。
Perl にシステムの L<flock(2)> 関数を無視させ、自身の L<fcntl(2)> ベースの
エミュレーションを使う場合は、新しい Perl を設定およびビルドするときに
F<Configure> プログラムに C<-Ud_flock> オプションを渡してください。

=begin original

Here's a mailbox appender for BSD systems.

=end original

BSD システムでのメールボックスへの追加処理の例を示します。

    # import LOCK_* and SEEK_END constants
    use Fcntl qw(:flock SEEK_END);

    sub lock {
        my ($fh) = @_;
        flock($fh, LOCK_EX) or die "Cannot lock mailbox - $!\n";
        # and, in case we're running on a very old UNIX
        # variant without the modern O_APPEND semantics...
        seek($fh, 0, SEEK_END) or die "Cannot seek - $!\n";
    }

    sub unlock {
        my ($fh) = @_;
        flock($fh, LOCK_UN) or die "Cannot unlock mailbox - $!\n";
    }

    open(my $mbox, ">>", "/usr/spool/mail/$ENV{'USER'}")
        or die "Can't open mailbox: $!";

    lock($mbox);
    print $mbox $msg,"\n\n";
    unlock($mbox);

=begin original

On systems that support a real L<flock(2)>, locks are inherited across
L<C<fork>|/fork> calls, whereas those that must resort to the more
capricious L<fcntl(2)> function lose their locks, making it seriously
harder to write servers.

=end original

真の L<flock(2)> に対応しているシステムではロックは L<C<fork>|/fork> を通して
継承されるのに対して、より不安定な L<fcntl(2)> に頼らなければならない場合、
サーバを書くのは本当により難しくなります。

=begin original

See also L<DB_File> for other C<flock>
examples.

=end original

その他の C<flock> の例としては L<DB_File> も
参照してください。

=begin original

Portability issues: L<perlport/flock>.

=end original

移植性の問題: L<perlport/flock>。

=item fork
X<fork> X<child> X<parent>

=for Pod::Functions create a new process just like this one

=begin original

Does a L<fork(2)> system call to create a new process running the
same program at the same point.  It returns the child pid to the
parent process, C<0> to the child process, or L<C<undef>|/undef EXPR> if
the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
L<fork(2)>, great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.

=end original

同じプログラムの同じ地点から開始する新しいプロセスを作成するために
システムコール L<fork(2)> を行ないます。
親プロセスには、チャイルドプロセスの pid を、
チャイルドプロセスに C<0> を返しますが、
fork に失敗したときには、L<C<undef>|/undef EXPR>を返します。
ファイル記述子(および記述子に関連するロック)は共有され、
その他の全てはコピーされます。
L<fork(2)> に対応するほとんどのシステムでは、
これを極めて効率的にするために多大な努力が払われてきました
(例えば、データページへの copy-on-write テクノロジーなどです);
これはここ 20 年にわたるマルチタスクに関する主要なパラダイムとなっています。

=begin original

Perl attempts to flush all files opened for output before forking the
child process, but this may not be supported on some platforms (see
L<perlport>).  To be safe, you may need to set
L<C<$E<verbar>>|perlvar/$E<verbar>> (C<$AUTOFLUSH> in L<English>) or
call the C<autoflush> method of L<C<IO::Handle>|IO::Handle/METHODS> on
any open handles to avoid duplicate output.

=end original

Perl は子プロセスを fork する前に出力用にオープンしている全ての
ファイルをフラッシュしようとしますが、これに対応していないプラットフォームも
あります(L<perlport> を参照してください)。
安全のためには、出力が重複するのを避けるために、
全てのオープンしているハンドルに対して L<C<$E<verbar>>|perlvar/$E<verbar>>
(L<English> モジュールでは C<$AUTOFLUSH>) を設定するか、
L<C<IO::Handle>|IO::Handle/METHODS> モジュールの C<autoflush> メソッドを
呼ぶ必要があるかもしれません。

=begin original

If you C<fork> without ever waiting on your children, you will
accumulate zombies.  On some systems, you can avoid this by setting
L<C<$SIG{CHLD}>|perlvar/%SIG> to C<"IGNORE">.  See also L<perlipc> for
more examples of forking and reaping moribund children.

=end original

チャイルドプロセスの終了を待たずに、C<fork> を繰り返せば、
ゾンビをためこむことになります。
L<C<$SIG{CHLD}>|perlvar/%SIG> に C<"IGNORE"> を指定することでこれを
回避できるシステムもあります。
fork と消滅しかけている子プロセスを回収するための更なる例については
L<perlipc> も参照してください。

=begin original

Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to F</dev/null> if it's any issue.

=end original

fork した子プロセスが STDIN や STDOUT といったシステムファイル記述子を
継承する場合、(CGI スクリプトやリモートシェルといった
バックグラウンドジョブのような)リモートサーバは考え通りに
動かないであろうことに注意してください。
このような場合ではこれらを F</dev/null> として再オープンするべきです。

=begin original

On some platforms such as Windows, where the L<fork(2)> system call is
not available, Perl can be built to emulate C<fork> in the Perl
interpreter.  The emulation is designed, at the level of the Perl
program, to be as compatible as possible with the "Unix" L<fork(2)>.
However it has limitations that have to be considered in code intended
to be portable.  See L<perlfork> for more details.

=end original

Windows のような L<fork(2)> が利用不能なシステムでは、Perl は
C<fork> を Perl インタプリタでエミュレートします。
エミュレーションは Perl プログラムのレベルではできるだけ "Unix" L<fork(2)> と
互換性があるように設計されています。
しかしコードが移植性があると考えられるように制限があります。
さらなる詳細については L<perlfork> を参照してください。

=begin original

Portability issues: L<perlport/fork>.

=end original

移植性の問題: L<perlport/fork>。

=item format
X<format>

=for Pod::Functions declare a picture format with use by the write() function

=begin original

Declare a picture format for use by the L<C<write>|/write FILEHANDLE>
function.  For example:

=end original

L<C<write>|/write FILEHANDLE> 関数で使うピクチャーフォーマットを宣言します。
例えば:

    format Something =
        Test: @<<<<<<<< @||||| @>>>>>
              $str,     $%,    '$' . int($num)
    .

    $str = "widget";
    $num = $cost/$quantity;
    $~ = 'Something';
    write;

=begin original

See L<perlform> for many details and examples.

=end original

詳細と例については L<perlform> を参照してください。

=item formline PICTURE,LIST
X<formline>

=for Pod::Functions internal function used for formats

=begin original

This is an internal function used by C<format>s, though you
may call it, too.  It formats (see L<perlform>) a list of values
according to the contents of PICTURE, placing the output into the format
output accumulator, L<C<$^A>|perlvar/$^A> (or C<$ACCUMULATOR> in
L<English>).  Eventually, when a L<C<write>|/write FILEHANDLE> is done,
the contents of L<C<$^A>|perlvar/$^A> are written to some filehandle.
You could also read L<C<$^A>|perlvar/$^A> and then set
L<C<$^A>|perlvar/$^A> back to C<"">.  Note that a format typically does
one C<formline> per line of form, but the
C<formline> function itself doesn't care how
many newlines are embedded in the PICTURE.  This means that the C<~> and
C<~~> tokens treat the entire PICTURE as a single line.  You may
therefore need to use multiple formlines to implement a single record
format, just like the L<C<format>|/format> compiler.

=end original

これは、C<format> が使用する内部関数ですが、直接呼び出すことも
できます。
これは、PICTURE の内容にしたがって、LIST の値を整形し (L<perlform> を
参照してください)、結果をフォーマット出力アキュムレータL<C<$^A>|perlvar/$^A>
(L<English> モジュールでは C<$ACCUMULATOR>) に納めます。
最終的に、L<C<write>|/write FILEHANDLE> が実行されると、
L<C<$^A>|perlvar/$^A> の中身が、何らかのファイルハンドルに書き出されます。
また、自分で L<C<$^A>|perlvar/$^A> を読んで、L<C<$^A>|perlvar/$^A> の内容を
C<""> に戻してもかまいません。
format は通常、1 行ごとに C<formline> を
行ないますが、C<formline> 関数自身は、PICTURE の中に
いくつの改行が入っているかは、関係がありません。
これは、C<~> と C<~~>トークンは PICTURE 全体を一行として扱うことを意味します。
従って、1 レコードフォーマットを実装するためには
L<C<format>|/format> コンパイラのような複数 formline を使う必要があります。

=begin original

Be careful if you put double quotes around the picture, because an C<@>
character may be taken to mean the beginning of an array name.
C<formline> always returns true.  See
L<perlform> for other examples.

=end original

ダブルクォートで PICTURE を囲む場合には、C<@> という文字が
配列名の始まりと解釈されますので、注意してください。
C<formline> は常に真を返します。
その他の例については L<perlform> を参照してください。

=begin original

If you are trying to use this instead of L<C<write>|/write FILEHANDLE>
to capture the output, you may find it easier to open a filehandle to a
scalar (C<< open my $fh, ">", \$output >>) and write to that instead.

=end original

出力を捕捉するために L<C<write>|/write FILEHANDLE> の代わりにこれを
使おうとした場合、スカラにファイルハンドルを開いて
(C<< open my $fh, ">", \$output >>)、
代わりにここに出力する方が簡単であることに気付くでしょう。

=item getc FILEHANDLE
X<getc> X<getchar> X<character> X<file, read>

=item getc

=for Pod::Functions get the next character from the filehandle

=begin original

Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file or if there was an error (in
the latter case L<C<$!>|perlvar/$!> is set).  If FILEHANDLE is omitted,
reads from
STDIN.  This is not particularly efficient.  However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.  For that, try something more like:

=end original

FILEHANDLE につながれている入力ファイルから、次の一文字を返します;
ファイルの最後、またはエラーが発生した場合は、未定義値を返します
(後者の場合は L<C<$!>|perlvar/$!> がセットされます)。
FILEHANDLE が省略された場合には、STDIN から読み込みを行ないます。
これは特に効率的ではありません。
しかし、これはユーザーがリターンキーを押すのを待つことなく
一文字を読み込む用途には使えません。
そのような場合には、以下のようなものを試して見てください:

    if ($BSD_STYLE) {
        system "stty cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
        system "stty", '-icanon', 'eol', "\001";
    }

    my $key = getc(STDIN);

    if ($BSD_STYLE) {
        system "stty -cbreak </dev/tty >/dev/tty 2>&1";
    }
    else {
        system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL
    }
    print "\n";

=begin original

Determination of whether C<$BSD_STYLE> should be set is left as an
exercise to the reader.

=end original

C<$BSD_STYLE> をセットするべきかどうかを決定する方法については
読者への宿題として残しておきます。

=begin original

The L<C<POSIX::getattr>|POSIX/C<getattr>> function can do this more
portably on systems purporting POSIX compliance.  See also the
L<C<Term::ReadKey>|Term::ReadKey> module on CPAN.

=end original

L<C<POSIX::getattr>|POSIX/C<getattr>> 関数は POSIX 準拠を主張するシステムで
これをより移植性のある形で行います。
CPAN にある L<C<Term::ReadKey>|Term::ReadKey> モジュールも
参照してください。

=item getlogin
X<getlogin> X<login>

=for Pod::Functions return who logged in at this tty

=begin original

This implements the C library function of the same name, which on most
systems returns the current login from F</etc/utmp>, if any.  If it
returns the empty string, use L<C<getpwuid>|/getpwuid UID>.

=end original

これは同じ名前の C ライブラリ関数を実装していて、
多くのシステムでは、もしあれば、F</etc/utmp> から現在のログイン名を返します。
もし空文字列が返ってきた場合は、L<C<getpwuid>|/getpwuid UID> を
使ってください。

    my $login = getlogin || getpwuid($<) || "Kilroy";

=begin original

Do not consider C<getlogin> for authentication: it is not
as secure as L<C<getpwuid>|/getpwuid UID>.

=end original

C<getlogin> を認証に使ってはいけません: これは
L<C<getpwuid>|/getpwuid UID> のように安全ではありません。

=begin original

Portability issues: L<perlport/getlogin>.

=end original

移植性の問題: L<perlport/getlogin>。

=item getpeername SOCKET
X<getpeername> X<peer>

=for Pod::Functions find the other end of a socket connection

=begin original

Returns the packed sockaddr address of the other end of the SOCKET
connection.

=end original

SOCKET コネクションの向こう側のパックされた aockaddr アドレスを返します。

    use Socket;
    my $hersockaddr    = getpeername($sock);
    my ($port, $iaddr) = sockaddr_in($hersockaddr);
    my $herhostname    = gethostbyaddr($iaddr, AF_INET);
    my $herstraddr     = inet_ntoa($iaddr);

=item getpgrp PID
X<getpgrp> X<group>

=for Pod::Functions get process group

=begin original

Returns the current process group for the specified PID.  Use
a PID of C<0> to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement L<getpgrp(2)>.  If PID is omitted, returns the process
group of the current process.

=end original

指定された PID の現在のプロセスグループを返します。
PID に C<0> を与えるとカレントプロセスの指定となります。
L<getpgrp(2)> を実装していないマシンで実行した場合には、例外が発生します。
PID を省略するとカレントプロセスのプロセスグループを返します。

=begin original

Some very old machines may not support C<PID != 0> and will throw an
exception if C<PID != 0>.

=end original

非常に古いマシンの中には C<PID != 0> に対応しておらず、
C<PID != 0> の場合に例外を投げるものがあります。

=begin original

Portability issues: L<perlport/getpgrp>.

=end original

移植性の問題: L<perlport/getpgrp>。

=item getppid
X<getppid> X<parent> X<pid>

=for Pod::Functions get parent process ID

=begin original

Returns the process id of the parent process.

=end original

親プロセスのプロセス id を返します。

=begin original

Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work
around non-POSIX thread semantics the minority of Linux systems (and
Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation
has since been removed.  See the documentation for L<$$|perlvar/$$> for
details.

=end original

Linux ユーザーへの注意: v5.8.1 から v5.16.0 の間 Perl は
LinuxThreads という非 POSIX なスレッド文法を使っているマイナーな
Linux システム (および Debian GNU/kFreeBSD システム) に対応していました。
このエミュレーションは削除されました;
詳しくは L<$$|perlvar/$$> の文書を参照してください。

=begin original

Portability issues: L<perlport/getppid>.

=end original

移植性の問題: L<perlport/getppid>。

=item getpriority WHICH,WHO
X<getpriority> X<priority> X<nice>

=for Pod::Functions get current nice value

=begin original

Returns the current priority for a process, a process group, or a user.
(See L<getpriority(2)>.)  Will raise a fatal exception if used on a
machine that doesn't implement L<getpriority(2)>.

=end original

プロセス、プロセスグループ、ユーザに対する現在の優先度を返します。
(L<getpriority(2)> を参照してください。)
L<getpriority(2)> を実装していない
マシンで実行した場合には、致命的例外が発生します。

=begin original

C<WHICH> can be any of C<PRIO_PROCESS>, C<PRIO_PGRP> or C<PRIO_USER>
imported from L<POSIX/RESOURCE CONSTANTS>.

=end original

C<WHICH> は、L<POSIX/RESOURCE CONSTANTS> からインポートされた
C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER> のいずれかです。

=begin original

Portability issues: L<perlport/getpriority>.

=end original

移植性の問題: L<perlport/getpriority>。

=item getpwnam NAME
X<getpwnam> X<getgrnam> X<gethostbyname> X<getnetbyname> X<getprotobyname>
X<getpwuid> X<getgrgid> X<getservbyname> X<gethostbyaddr> X<getnetbyaddr>
X<getprotobynumber> X<getservbyport> X<getpwent> X<getgrent> X<gethostent>
X<getnetent> X<getprotoent> X<getservent> X<setpwent> X<setgrent> X<sethostent>
X<setnetent> X<setprotoent> X<setservent> X<endpwent> X<endgrent> X<endhostent>
X<endnetent> X<endprotoent> X<endservent>

=for Pod::Functions get passwd record given user login name

=item getgrnam NAME

=for Pod::Functions get group record given group name

=item gethostbyname NAME

=for Pod::Functions get host record given name

=item getnetbyname NAME

=for Pod::Functions get networks record given name

=item getprotobyname NAME

=for Pod::Functions get protocol record given name

=item getpwuid UID

=for Pod::Functions get passwd record given user ID

=item getgrgid GID

=for Pod::Functions get group record given group user ID

=item getservbyname NAME,PROTO

=for Pod::Functions get services record given its name

=item gethostbyaddr ADDR,ADDRTYPE

=for Pod::Functions get host record given its address

=item getnetbyaddr ADDR,ADDRTYPE

=for Pod::Functions get network record given its address

=item getprotobynumber NUMBER

=for Pod::Functions get protocol record numeric protocol

=item getservbyport PORT,PROTO

=for Pod::Functions get services record given numeric port

=item getpwent

=for Pod::Functions get next passwd record

=item getgrent

=for Pod::Functions get next group record

=item gethostent

=for Pod::Functions get next hosts record

=item getnetent

=for Pod::Functions get next networks record

=item getprotoent

=for Pod::Functions get next protocols record

=item getservent

=for Pod::Functions get next services record

=item setpwent

=for Pod::Functions prepare passwd file for use

=item setgrent

=for Pod::Functions prepare group file for use

=item sethostent STAYOPEN

=for Pod::Functions prepare hosts file for use

=item setnetent STAYOPEN

=for Pod::Functions prepare networks file for use

=item setprotoent STAYOPEN

=for Pod::Functions prepare protocols file for use

=item setservent STAYOPEN

=for Pod::Functions prepare services file for use

=item endpwent

=for Pod::Functions be done using passwd file

=item endgrent

=for Pod::Functions be done using group file

=item endhostent

=for Pod::Functions be done using hosts file

=item endnetent

=for Pod::Functions be done using networks file

=item endprotoent

=for Pod::Functions be done using protocols file

=item endservent

=for Pod::Functions be done using services file

=begin original

These routines are the same as their counterparts in the
system C library.  In list context, the return values from the
various get routines are as follows:

=end original

これらのルーチンは、システムの C ライブラリの同名の関数と同じです。
リストコンテキストでは、さまざまな
get ルーチンからの返り値は、次のようになります:

 #    0        1          2           3         4
 my ( $name,   $passwd,   $gid,       $members  ) = getgr*
 my ( $name,   $aliases,  $addrtype,  $net      ) = getnet*
 my ( $name,   $aliases,  $port,      $proto    ) = getserv*
 my ( $name,   $aliases,  $proto                ) = getproto*
 my ( $name,   $aliases,  $addrtype,  $length,  @addrs ) = gethost*
 my ( $name,   $passwd,   $uid,       $gid,     $quota,
    $comment,  $gcos,     $dir,       $shell,   $expire ) = getpw*
 #    5        6          7           8         9

=begin original

(If the entry doesn't exist, the return value is a single meaningless true
value.)

=end original

(エントリが存在しなければ、返り値は単一の意味のない真の値です。)

=begin original

The exact meaning of the $gcos field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.  Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the $gcos is tainted (see
L<perlsec>).  The $passwd and $shell, user's encrypted password and
login shell, are also tainted, for the same reason.

=end original

$gcos フィールドの正確な意味はさまざまですが、通常は(ログイン名ではなく)
ユーザーの実際の名前とユーザーに付随する情報を含みます。
但し、多くのシステムではユーザーがこの情報を変更できるので、この情報は
信頼できず、従って $gcos は汚染されます(L<perlsec> を参照してください)。
ユーザーの暗号化されたパスワードとログインシェルである $passwd と
$shell も、同様の理由で汚染されます。

=begin original

In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:

=end original

スカラコンテキストでは、*nam、*byname といった NAME で検索するもの以外は、
name を返し、NAME で検索するものは、何か別のものを返します。
(エントリが存在しなければ、未定義値が返ります。)
例えば:

    my $uid   = getpwnam($name);
    my $name  = getpwuid($num);
    my $name  = getpwent();
    my $gid   = getgrnam($name);
    my $name  = getgrgid($num);
    my $name  = getgrent();
    # etc.

=begin original

In I<getpw*()> the fields $quota, $comment, and $expire are special
in that they are unsupported on many systems.  If the
$quota is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the $comment field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the $quota
field may be $change or $age, fields that have to do with password
aging.  In some systems the $comment field may be $class.  The $expire
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult L<getpwnam(3)> and your system's
F<pwd.h> file.  You can also find out from within Perl what your
$quota and $comment fields mean and whether you have the $expire field
by using the L<C<Config>|Config> module and the values C<d_pwquota>, C<d_pwage>,
C<d_pwchange>, C<d_pwcomment>, and C<d_pwexpire>.  Shadow password
files are supported only if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the L<shadow(3)> functions as found in System V (this includes Solaris
and Linux).  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.

=end original

I<getpw*()> では、$quota, $comment, $expire フィールドは、
多くのシステムでは対応していないので特別な処理がされます。
$quota が非対応の場合、空のスカラになります。
対応している場合、通常はディスククォータの値が入ります。
$comment フィールドが非対応の場合、空のスカラになります。
対応している場合、通常はユーザーに関する管理上のコメントが入ります。
$quota フィールドはパスワードの寿命を示す $change や $age である
システムもあります。
$comment フィールドは $class であるシステムもあります。
$expire フィールドがある場合は、アカウントやパスワードが時間切れになる
期間が入ります。
動作させるシステムでのこれらのフィールドの有効性と正確な意味については、
L<getpwnam(3)> のドキュメントと F<pwd.h> ファイルを参照してください。
$quota と $comment フィールドが何を意味しているかと、$expire フィールドが
あるかどうかは、L<C<Config>|Config> モジュールを使って、C<d_pwquota>,
C<d_pwage>, C<d_pwchange>, C<d_pwcomment>, C<d_pwexpire> の値を
調べることによって Perl 自身で調べることも出来ます。
シャドウパスワードは、通常の C ライブラリルーチンを権限がある状態で
呼び出すことでシャドウ版が取得できるか、System V にあるような
(Solaris と Linux を含みます) L<shadow(3)> 関数があるといった、
直感的な方法で実装されている場合にのみ対応されます。
独占的なシャドウパスワード機能を実装しているシステムでは、
それに対応されることはないでしょう。

=begin original

The $members value returned by I<getgr*()> is a space-separated list of
the login names of the members of the group.

=end original

I<getgr*()> によって返る値 $members は、グループのメンバの
ログイン名をスペースで区切ったものです。

=begin original

For the I<gethost*()> functions, if the C<h_errno> variable is supported in
C, it will be returned to you via L<C<$?>|perlvar/$?> if the function
call fails.  The
C<@addrs> value returned by a successful call is a list of raw
addresses returned by the corresponding library call.  In the
Internet domain, each address is four bytes long; you can unpack it
by saying something like:

=end original

I<gethost*()> 関数では、C で C<h_errno> 変数がサポートされていれば、
関数呼出が失敗したときに、L<C<$?>|perlvar/$?> を通して、その値が返されます。
成功時に返される C<@addrs> 値は、対応するシステムコールが返す、
生のアドレスのリストです。
インターネットドメインでは、個々のアドレスは、4 バイト長です;
以下のようにして unpack することができます:

    my ($w,$x,$y,$z) = unpack('W4',$addr[0]);

=begin original

The Socket library makes this slightly easier:

=end original

Socket ライブラリを使うともう少し簡単になります。

    use Socket;
    my $iaddr = inet_aton("127.1"); # or whatever address
    my $name  = gethostbyaddr($iaddr, AF_INET);

    # or going the other way
    my $straddr = inet_ntoa($iaddr);

=begin original

In the opposite way, to resolve a hostname to the IP address
you can write this:

=end original

逆方向に、ホスト名から IP アドレスを解決するには以下のように書けます:

    use Socket;
    my $packed_ip = gethostbyname("www.perl.org");
    my $ip_address;
    if (defined $packed_ip) {
        $ip_address = inet_ntoa($packed_ip);
    }

=begin original

Make sure C<gethostbyname> is called in SCALAR
context and that its return value is checked for definedness.

=end original

C<gethostbyname> はスカラコンテキストで
呼び出すようにして、返り値が定義されているかを必ずチェックしてください。

=begin original

The C<getprotobynumber> function, even
though it only takes one argument, has the precedence of a list
operator, so beware:

=end original

C<getprotobynumber> 関数は、一つの引数しか
取らないにも関わらず、リスト演算子の優先順位を持ちます; 従って
注意してください:

    getprotobynumber $number eq 'icmp'   # WRONG
    getprotobynumber($number eq 'icmp')  # actually means this
    getprotobynumber($number) eq 'icmp'  # better this way

=begin original

If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided in standard
modules: L<C<File::stat>|File::stat>, L<C<Net::hostent>|Net::hostent>,
L<C<Net::netent>|Net::netent>, L<C<Net::protoent>|Net::protoent>,
L<C<Net::servent>|Net::servent>, L<C<Time::gmtime>|Time::gmtime>,
L<C<Time::localtime>|Time::localtime>, and
L<C<User::grent>|User::grent>.  These override the normal built-ins,
supplying versions that return objects with the appropriate names for
each field.  For example:

=end original

返り値のリストの何番目がどの要素かを覚えるのに疲れたなら、
名前ベースのインターフェースが標準モジュールで提供されています:
L<C<File::stat>|File::stat>, L<C<Net::hostent>|Net::hostent>,
L<C<Net::netent>|Net::netent>, L<C<Net::protoent>|Net::protoent>,
L<C<Net::servent>|Net::servent>, L<C<Time::gmtime>|Time::gmtime>,
L<C<Time::localtime>|Time::localtime>,
L<C<User::grent>|User::grent> です。
これらは通常の組み込みを上書きし、
それぞれのフィールドに適切な名前をつけたオブジェクトを返します。
例えば:

   use File::stat;
   use User::pwent;
   my $is_theirs = (stat($filename)->uid == getpwnam($whoever)->uid);

=begin original

Even though it looks as though they're the same method calls (uid),
they aren't, because a C<File::stat> object is different from
a C<User::pwent> object.

=end original

同じメソッド(uid)を呼び出しているように見えますが、違います;
なぜなら C<File::stat> オブジェクトは C<User::pwent> オブジェクトとは
異なるからです。

=begin original

Many of these functions are not safe in a multi-threaded environment
where more than one thread can be using them.  In particular, functions
like C<getpwent()> iterate per-process and not per-thread, so if two
threads are simultaneously iterating, neither will get all the records.

=end original

これらの関数の多くは、複数のスレッドがこれらを使うような
マルチスレッド環境では安全ではありません。
特に、
C<getpwent()> のような関数はスレッド単位ではなくプロセス単位で
反復するので、二つのスレッドが同時に反復すると、
どちらも全てのレコードを得られません。

=begin original

Some systems have thread-safe versions of some of the functions, such as
C<getpwnam_r()> instead of C<getpwnam()>.  There, Perl automatically and
invisibly substitutes the thread-safe version, without notice.  This
means that code that safely runs on some systems can fail on others that
lack the thread-safe versions.

=end original

一部のシステムは、
C<getpwnam()> の代わりの C<getpwnam_r()> のように、一部の関数について
スレッドセーフ版を持っています。
その場合、Perl は自動的かつ目に見えないように、通知なしで
スレッドセーフ版に置き換えます。
つまり、一部のシステムで安全に実行できるコードが
スレッドセーフ版のないその他のシステムでは失敗することがあるということです。

=begin original

Portability issues: L<perlport/getpwnam> to L<perlport/endservent>.

=end original

移植性の問題: L<perlport/getpwnam> から L<perlport/endservent>。

=item getsockname SOCKET
X<getsockname>

=for Pod::Functions retrieve the sockaddr for a given socket

=begin original

Returns the packed sockaddr address of this end of the SOCKET connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.

=end original

SOCKET 接続のこちら側の pack された sockaddr アドレスを返します;
複数の異なる IP から接続されるためにアドレスがわからない場合に使います。

    use Socket;
    my $mysockaddr = getsockname($sock);
    my ($port, $myaddr) = sockaddr_in($mysockaddr);
    printf "Connect to %s [%s]\n",
       scalar gethostbyaddr($myaddr, AF_INET),
       inet_ntoa($myaddr);

=item getsockopt SOCKET,LEVEL,OPTNAME
X<getsockopt>

=for Pod::Functions get socket options on a given socket

=begin original

Queries the option named OPTNAME associated with SOCKET at a given LEVEL.
Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
L<C<Socket>|Socket> module) will exist.  To query options at another
level the protocol number of the appropriate protocol controlling the
option should be supplied.  For example, to indicate that an option is
to be interpreted by the TCP protocol, LEVEL should be set to the
protocol number of TCP, which you can get using
L<C<getprotobyname>|/getprotobyname NAME>.

=end original

与えられた LEVEL で SOCKET に関連付けられた OPTNAME と言う名前のオプションを
問い合わせます。
オプションはソケットの種類に依存しした複数のプロトコルレベルに存在することも
ありますが、少なくとも最上位ソケットレベル SOL_SOCKET
(L<C<Socket>|Socket> モジュールで定義されています)は存在します。
その他のレベルのオプションを問い合わせるには、そのオプションを制御する
適切なプロトコルのプロトコル番号を指定します。
例えば、オプションが TCP プロトコルで解釈されるべきであることを示すためには、
LEVEL は L<C<getprotobyname>|/getprotobyname NAME> で得られる TCP の
プロトコル番号を設定します。

=begin original

The function returns a packed string representing the requested socket
option, or L<C<undef>|/undef EXPR> on error, with the reason for the
error placed in L<C<$!>|perlvar/$!>.  Just what is in the packed string
depends on LEVEL and OPTNAME; consult L<getsockopt(2)> for details.  A
common case is that the option is an integer, in which case the result
is a packed integer, which you can decode using
L<C<unpack>|/unpack TEMPLATE,EXPR> with the C<i> (or C<I>) format.

=end original

この関数は、要求されたソケットオプションの pack された文字列表現か、
あるいはエラーの場合は L<C<undef>|/undef EXPR> を返し、エラーの理由は
L<C<$!>|perlvar/$!> にあります。
pack された文字列の中身は LEVEL と OPTNAME に依存します;
詳細については L<getsockopt(2)> を確認してください。
一般的な場合はオプションが整数の場合で、この場合結果は
L<C<unpack>|/unpack TEMPLATE,EXPR> の C<i>
(あるいは C<I>)フォーマットでデコードできる pack された整数です。

=begin original

Here's an example to test whether Nagle's algorithm is enabled on a socket:

=end original

あるソケットで Nagle のアルゴリズム有効かどうかを調べる例です:

    use Socket qw(:all);

    defined(my $tcp = getprotobyname("tcp"))
        or die "Could not determine the protocol number for tcp";
    # my $tcp = IPPROTO_TCP; # Alternative
    my $packed = getsockopt($socket, $tcp, TCP_NODELAY)
        or die "getsockopt TCP_NODELAY: $!";
    my $nodelay = unpack("I", $packed);
    print "Nagle's algorithm is turned ",
           $nodelay ? "off\n" : "on\n";

=begin original

Portability issues: L<perlport/getsockopt>.

=end original

移植性の問題: L<perlport/getsockopt>。

=item glob EXPR
X<glob> X<wildcard> X<filename, expansion> X<expand>

=item glob

=for Pod::Functions expand filenames using wildcards

=begin original

In list context, returns a (possibly empty) list of filename expansions on
the value of EXPR such as the Unix shell Bash would do. In
scalar context, glob iterates through such filename expansions, returning
L<C<undef>|/undef EXPR> when the list is exhausted. If EXPR is omitted,
L<C<$_>|perlvar/$_> is used.

=end original

リストコンテキストでは、
EXPR の値を、Unix シェルの Bash が行なうように
ファイル名の展開を行なった結果のリスト(空かもしれません)を返します。
スカラコンテキストでは、glob はこのようなファイル名展開を繰り返し、
リストがなくなったら L<C<undef>|/undef EXPR> を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> が使われます。

    # List context
    my @txt_files  = glob("*.txt");
    my @perl_files = glob("*.pl *.pm");

    # Scalar context
    while (my $file = glob("*.mp3")) {
        # Do stuff
    }

=begin original

Glob also supports an alternate syntax using C<< < >> C<< > >> as
delimiters. While this syntax is supported, it is recommended that you
use C<glob> instead as it is more readable and searchable.

=end original

glob はまた区切り文字として C<< < >> C<< > >> を使うもう一つの文法に
対応しています。
この文法は対応していますが、可読性と検索性がより高いので、代わりに
C<glob> を使うことを勧めます。

    my @txt_files  = <"*.txt">;

=begin original

If you need case insensitive file globbing that can be achieved using the
C<:nocase> parameter of the L<C<bsd_glob>|File::Glob/C<bsd_glob>> module.

=end original

大文字小文字を区別するファイルグロブが必要な場合、
L<C<bsd_glob>|File::Glob/C<bsd_glob>> モジュールの C<:nocase> 引数を
使うことで達成できます:

    use File::Glob qw(:globally :nocase);

	my @txt = glob("readme*"); # README readme.txt Readme.md

=begin original

Note that C<glob> splits its arguments on whitespace and
treats
each segment as separate pattern.  As such, C<glob("*.c *.h")>
matches all files with a F<.c> or F<.h> extension.  The expression
C<glob(".* *")> matches all files in the current working directory.
If you want to glob filenames that might contain whitespace, you'll
have to use extra quotes around the spacey filename to protect it.
For example, to glob filenames that have an C<e> followed by a space
followed by an C<f>, use one of:

=end original

C<glob> は引数を空白で分割して、それぞれを分割された
パターンとして扱います。
従って、C<glob("*.c *.h")> は F<.c> または F<.h> 拡張子を持つ全てのファイルに
マッチングします。
式 C<glob(".* *")> はカレントワーキングディレクトリの全てのファイルに
マッチングします。
空白を含んでいるかも知れないファイル名をグロブしたい場合、それを守るために
空白入りファイル名の周りに追加のクォートを使う必要があります。
例えば、C<e> の後に空白、その後に C<f> というファイル名をグロブするには
以下の一つを使います:

    my @spacies = <"*e f*">;
    my @spacies = glob('"*e f*"');
    my @spacies = glob(q("*e f*"));

=begin original

If you had to get a variable through, you could do this:

=end original

変数を通す必要があった場合、以下のようにできました:

    my @spacies = glob("'*${var}e f*'");
    my @spacies = glob(qq("*${var}e f*"));

=begin original

If non-empty braces are the only wildcard characters used in the
C<glob>, no filenames are matched, but potentially many
strings are returned.  For example, this produces nine strings, one for
each pairing of fruits and colors:

=end original

空でない中かっこが C<glob> で使われている唯一の
ワイルドカード文字列の場合、ファイル名とはマッチングせず、
可能性のある文字列が返されます。
例えば、これは 9 個の文字列を生成し、それぞれは果物と色の組み合わせに
なります:

    my @many = glob("{apple,tomato,cherry}={green,yellow,red}");

=begin original

This operator is implemented using the standard C<File::Glob> extension.
See L<C<bsd_glob>|File::Glob/C<bsd_glob>> for details, including
L<C<bsd_glob>|File::Glob/C<bsd_glob>>, which does not treat whitespace
as a pattern separator.

=end original

この演算子は標準の C<File::Glob> 拡張を使って
実装されています。
空白をパターンのセパレータとして扱わない
L<C<bsd_glob>|File::Glob/C<bsd_glob>> を含めた
詳細は L<C<bsd_glob>|File::Glob/C<bsd_glob>> を参照してください。

=begin original

If a C<glob> expression is used as the condition of a C<while> or C<for>
loop, then it will be implicitly assigned to C<$_>.  If either a C<glob>
expression or an explicit assignment of a C<glob> expression to a scalar
is used as a C<while>/C<for> condition, then the condition actually
tests for definedness of the expression's value, not for its regular
truth value.

=end original

C<glob> 式が C<while> や C<for> ループの条件として使われた場合、
これは暗黙に C<$_> に代入されます。
C<glob> 式または C<glob> 式からスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

=begin original

Internal implementation details:

=end original

内部実装の詳細:

=begin original

This is the internal function implementing the C<< <*.c> >> operator,
but you can use it directly. The C<< <*.c> >> operator is discussed in
more detail in L<perlop/"I/O Operators">.

=end original

これは、C<< <*.c> >> 演算子を実装する内部関数ですが、
直接使用することもできます。
C<< <*.c> >>演算子については
L<perlop/"I/O Operators"> でより詳細に議論しています。

=begin original

Portability issues: L<perlport/glob>.

=end original

移植性の問題: L<perlport/glob>。

=item gmtime EXPR
X<gmtime> X<UTC> X<Greenwich>

=item gmtime

=for Pod::Functions convert UNIX time into record or string using Greenwich time

=begin original

Works just like L<C<localtime>|/localtime EXPR>, but the returned values
are localized for the standard Greenwich time zone.

=end original

L<C<localtime>|/localtime EXPR> と同様に働きますが、返り値はグリニッジ標準時に
ローカライズされています。

=begin original

Note: When called in list context, $isdst, the last value
returned by gmtime, is always C<0>.  There is no
Daylight Saving Time in GMT.

=end original

注意: リストコンテキストで呼び出した時、gmtime が返す末尾の値である
$isdst は常に C<0> です。
GMT には夏時間はありません。

=begin original

Portability issues: L<perlport/gmtime>.

=end original

移植性の問題: L<perlport/gmtime>。

=item goto LABEL
X<goto> X<jump> X<jmp>

=item goto EXPR

=item goto &NAME

=for Pod::Functions create spaghetti code

=begin original

C<goto> transfers execution to a specified point in the program. Unlike a
function call, execution does not return to C<goto>.

=end original

C<goto> はプログラムの指定された場所に実行を移します。
関数呼び出しと異なり、実行は C<goto> に戻りません。

=begin original

The C<goto LABEL> form finds the statement labeled with LABEL and
resumes execution there.  It can't be used to get out of a block or
subroutine given to L<C<sort>|/sort SUBNAME LIST>.  It can be used to go
almost anywhere else within the dynamic scope, including out of
subroutines, but it's usually better to use some other construct such as
L<C<last>|/last LABEL> or L<C<die>|/die LIST>.  The author of Perl has
never felt the need to use this form of C<goto> (in Perl,
that is; C is another matter).  (The difference is that C does not offer
named loops combined with loop control.  Perl does, and this replaces
most structured uses of C<goto> in other languages.)

=end original

C<goto LABEL> の形式は、LABEL というラベルの付いた文を
探して、そこへ実行を移すものです。
L<C<sort>|/sort SUBNAME LIST> で与えられたブロックやサブルーチンから外へ
出ることはできません。
これ以外は、サブルーチンの外を含む、動的スコープ内の
ほとんどすべての場所へ行くために使用できますが、普通は、
L<C<last>|/last LABEL> や L<C<die>|/die LIST> といった別の構造を使った方が
良いでしょう。
Perl の作者はこの形式の C<goto> を使う必要を感じたことは、
1 度もありません (Perl では; C は別のお話です)。
(違いは、C にはループ制御と結びついた名前つきのループがないことです。
Perl にはあり、これが他の言語でのほとんどの構造的な C<goto> の
使用法を置き換えます。)

=begin original

The C<goto EXPR> form expects to evaluate C<EXPR> to a code reference or
a label name.  If it evaluates to a code reference, it will be handled
like C<goto &NAME>, below.  This is especially useful for implementing
tail recursion via C<goto __SUB__>.

=end original

C<goto EXPR> の形式は、C<EXPR> をコードリファレンスまたはラベル名として
評価することを想定します。
コードリファレンスとして評価する場合、後述する C<goto &NAME> のように
扱います。
これは特に、C<goto __SUB__> による末尾再帰の実装に有用です。

=begin original

If the expression evaluates to a label name, its scope will be resolved
dynamically.  This allows for computed C<goto>s per
FORTRAN, but isn't necessarily recommended if you're optimizing for
maintainability:

=end original

式がラベル名に評価される場合、このスコープは動的に解決されます。
これにより FORTRAN のような算術 C<goto> が可能になりますが、
保守性を重視するならお勧めしません。

    goto ("FOO", "BAR", "GLARCH")[$i];

=begin original

As shown in this example, C<goto EXPR> is exempt from the "looks like a
function" rule.  A pair of parentheses following it does not (necessarily)
delimit its argument.  C<goto("NE")."XT"> is equivalent to C<goto NEXT>.
Also, unlike most named operators, this has the same precedence as
assignment.

=end original

この例で示したように、C<goto EXPR> は「関数のように見える」ルールから
除外されます。
これに引き続くかっこの組は引数の区切りとは(必ずしも)なりません。
C<goto("NE")."XT"> は C<goto NEXT> と等価です。
また、ほとんどの名前付き演算子と異なり、これは代入と同じ優先順位を持ちます。

=begin original

Use of C<goto LABEL> or C<goto EXPR> to jump into a construct is
deprecated and will issue a warning; it will become a fatal error in
Perl 5.42. While still available, it may not be used to
go into any construct that requires initialization, such as a
subroutine, a C<foreach> loop, or a C<given>
block.  In general, it may not be used to jump into the parameter
of a binary or list operator, but it may be used to jump into the
I<first> parameter of a binary operator.  (The C<=>
assignment operator's "first" operand is its right-hand
operand.)  It also can't be used to go into a
construct that is optimized away.

=end original

構造の中に飛び込むために C<goto LABEL> や C<goto EXPR> を使うことは
非推奨で、警告が発生します; これは Perl 5.42 で致命的エラーになります。
まだ利用可能ではありますが、
サブルーチンや C<foreach> ループや C<given> ブロックのような、
初期化が必要な構造の中に入るために使うことは出来ません。
一般的に、2 項演算子やリスト演算子の引数に飛び込むことはできませんが、
2 項演算子の I<最初の> 引数に飛び込むために使われていました。
(C<=> 代入演算子の「最初の」オペランドはその右オペランドです。)
また、最適化してなくなってしまった構造の中へ入るために使うことも出来ません。

=begin original

The C<goto &NAME> form is quite different from the other forms of
C<goto>.  In fact, it isn't a goto in the normal sense at
all, and doesn't have the stigma associated with other gotos.  Instead,
it exits the current subroutine (losing any changes set by
L<C<local>|/local EXPR>) and immediately calls in its place the named
subroutine using the current value of L<C<@_>|perlvar/@_>.  This is used
by C<AUTOLOAD> subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to L<C<@_>|perlvar/@_> in the current
subroutine are propagated to the other subroutine.) After the
C<goto>, not even L<C<caller>|/caller EXPR> will be able
to tell that this routine was called first.

=end original

C<goto &NAME> の形式は、その他の C<goto> の形式とはかなり
異なったものです。
実際、これは普通の感覚でいうところのどこかへ行くものでは全くなく、
他の goto が持つ不名誉を持っていません。
現在のサブルーチンを終了し (L<C<local>|/local EXPR> による変更は失われます)、
直ちに現在の L<C<@_>|perlvar/@_> の値を使って指定された名前のサブルーチンを
呼び出します。
これは、C<AUTOLOAD> サブルーチンが別のサブルーチンをロードして、
その別のサブルーチンが最初に呼ばれたようにするために使われます
(ただし、現在のサブルーチンで L<C<@_>|perlvar/@_> を修正した場合には、
その別のサブルーチンに伝えられます)。
C<goto> のあとは、L<C<caller>|/caller EXPR> でさえも、現在の
サブルーチンが最初に呼び出されたと言うことができません。

=begin original

NAME needn't be the name of a subroutine; it can be a scalar variable
containing a code reference or a block that evaluates to a code
reference.

=end original

NAME はサブルーチンの名前である必要はありません; コードリファレンスを
含むスカラ値や、コードリファレンスと評価されるブロックでも構いません。

=item grep BLOCK LIST
X<grep>

=item grep EXPR,LIST

=for Pod::Functions locate elements in a list test true against a given criterion

=begin original

This is similar in spirit to, but not the same as, L<grep(1)> and its
relatives.  In particular, it is not limited to using regular expressions.

=end original

これは L<grep(1)> とその親類と同じようなものですが、同じではありません。
特に、正規表現の使用に制限されません。

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
L<C<$_>|perlvar/$_> to each element) and returns the list value
consisting of those
elements for which the expression evaluated to true.  In scalar
context, returns the number of times the expression was true.

=end original

LIST の個々の要素に対して、BLOCK か EXPR を評価し
(L<C<$_>|perlvar/$_> は、ローカルに個々の要素が設定されます) 、
その要素のうち、評価した式が真となったものからなるリスト値が返されます。
スカラコンテキストでは、式が真となった回数を返します。

    my @foo = grep(!/^#/, @bar);    # weed out comments

=begin original

or equivalently,

=end original

あるいは等価な例として:

    my @foo = grep {!/^#/} @bar;    # weed out comments

=begin original

Note that L<C<$_>|perlvar/$_> is an alias to the list value, so it can
be used to
modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.  That is, modifying an
element of a list returned by grep (for example, in a C<foreach>,
L<C<map>|/map BLOCK LIST> or another C<grep>)
actually modifies the element in the original list.
This is usually something to be avoided when writing clear code.

=end original

L<C<$_>|perlvar/$_> は、LIST の値へのエイリアスですので、LIST の要素を
変更するために使うことができます。
これは、便利でサポートされていますが、
LIST の要素が変数でないと、おかしな結果になります。
同様に、grep は元のリストへのエイリアスを返します; for ループの
インデックス変数がリスト要素のエイリアスであるのと同様です。
つまり、grep で返されたリストの要素を
(C<foreach>, L<C<map>|/map BLOCK LIST>, または他の
C<grep> で)修正すると元のリストの要素が変更されます。
これはきれいなコードを書くときには普通は回避されます。

=begin original

See also C<map> for a list composed of the results of
the BLOCK or EXPR.

=end original

BLOCK や EXPR の結果をリストの形にしたい場合は C<map> を
参照してください。

=item hex EXPR
X<hex> X<hexadecimal>

=item hex

=for Pod::Functions convert a hexadecimal string to a number

=begin original

Interprets EXPR as a hex string and returns the corresponding numeric value.
If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

EXPR を 16 進数の文字列と解釈して、対応する数値を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

    print hex '0xAf'; # prints '175'
    print hex 'aF';   # same
    $valid_input =~ /\A(?:0?[xX])?(?:_?[0-9a-fA-F])*\z/

=begin original

A hex string consists of hex digits and an optional C<0x> or C<x> prefix.
Each hex digit may be preceded by a single underscore, which will be ignored.
Any other character triggers a warning and causes the rest of the string
to be ignored (even leading whitespace, unlike L<C<oct>|/oct EXPR>).
Only integers can be represented, and integer overflow triggers a warning.

=end original

16 進文字列は 16 進数と、オプションの C<0x> または C<x> 接頭辞からなります。
それぞれの 16 進数は一つの下線を前に置くことができ、これは無視されます。
その他の文字は警告を引き起こし、(例え先頭の空白でも、L<C<oct>|/oct EXPR> と
異なり)文字列の残りの部分は無視されます。
整数のみを表現でき、整数オーバーフローは警告を引き起こします。

=begin original

To convert strings that might start with any of C<0>, C<0x>, or C<0b>,
see L<C<oct>|/oct EXPR>.  To present something as hex, look into
L<C<printf>|/printf FILEHANDLE FORMAT, LIST>,
L<C<sprintf>|/sprintf FORMAT, LIST>, and
L<C<unpack>|/unpack TEMPLATE,EXPR>.

=end original

C<0>, C<0x>, C<0b> のいずれかで始まるかもしれない文字列を変換するには、
L<C<oct>|/oct EXPR> を参照してください。
何かを 16 進で表現したい場合は、L<C<printf>|/printf FILEHANDLE FORMAT, LIST>,
L<C<sprintf>|/sprintf FORMAT, LIST>, L<C<unpack>|/unpack TEMPLATE,EXPR> を
参照してください。

=item import LIST
X<import>

=for Pod::Functions patch a module's namespace into your own

=begin original

There is no builtin C<import> function.  It is just an
ordinary method (subroutine) defined (or inherited) by modules that wish
to export names to another module.  The
L<C<use>|/use Module VERSION LIST> function calls the
C<import> method for the package used.  See also
L<C<use>|/use Module VERSION LIST>, L<perlmod>, and L<Exporter>.

=end original

組み込みの C<import> 関数というものはありません。
これは単に、別のモジュールに名前をエクスポートしたいモジュールが
定義した(または継承した)、通常のメソッド(サブルーチン)です。
L<C<use>|/use Module VERSION LIST> 関数はパッケージを使う時に
C<import> メソッドを呼び出します。
L<C<use>|/use Module VERSION LIST>, L<perlmod>, L<Exporter> も
参照してください。

=item index STR,SUBSTR,POSITION
X<index> X<indexOf> X<InStr>

=item index STR,SUBSTR

=for Pod::Functions find a substring within a string

=begin original

The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.
It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.  If POSITION is omitted, starts searching from the
beginning of the string.  POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.  POSITION and the return value are based at zero.
If the substring is not found, C<index>
returns -1.

=end original

index 関数は ある文字列をもうひとつの文字列から検索しますが、
完全正規表現パターンマッチのワイルドカード的な振る舞いはしません。
STR の中の POSITION の位置以降で、最初に SUBSTR が見つかった位置を返します。
POSITION が省略された場合には、STR の最初から探し始めます。
POSITION が文字列の先頭より前、あるいは末尾より後ろを指定した場合は、
それぞれ先頭と末尾を指定されたものとして扱われます。
POSITION と返り値のベースは、0 です。
SUBSTR が見つからなかった場合には、C<index> は
-1 が返されます。

=begin original

Find characters or strings:

=end original

文字や文字列を探すには:

    index("Perl is great", "P");     # Returns 0
    index("Perl is great", "g");     # Returns 8
    index("Perl is great", "great"); # Also returns 8

=begin original

Attempting to find something not there:

=end original

ないものを探そうとすると:

    index("Perl is great", "Z");     # Returns -1 (not found)

=begin original

Using an offset to find the I<second> occurrence:

=end original

I<2 番目> の出現位置を探すためにオフセットを使うと:

    index("Perl is great", "e", 5);  # Returns 10

=item int EXPR
X<int> X<integer> X<truncate> X<trunc> X<floor>

=item int

=for Pod::Functions get the integer portion of a number

=begin original

Returns the integer portion of EXPR.  If EXPR is omitted, uses
L<C<$_>|perlvar/$_>.
You should not use this function for rounding: one because it truncates
towards C<0>, and two because machine representations of floating-point
numbers can sometimes produce counterintuitive results.  For example,
C<int(-6.725/0.025)> produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.  Usually,
the L<C<sprintf>|/sprintf FORMAT, LIST>,
L<C<printf>|/printf FILEHANDLE FORMAT, LIST>, or the
L<C<POSIX::floor>|POSIX/C<floor>> and L<C<POSIX::ceil>|POSIX/C<ceil>>
functions will serve you better than will L<C<int>|/int EXPR>.
Moreover, C<int 'Inf'> produces Inf (see
L<perldata/Special floating point: infinity (Inf) and not-a-number (NaN)>
for explanation), but so do all the alternative methods mentioned above.

=end original

EXPR の整数部を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。
この関数を丸めのために使うべきではありません: 第一の理由として C<0> の
方向への切捨てを行うから、第二の理由として浮動小数点数の機械表現は時々直感に
反した結果を生み出すからです。
たとえば、C<int(-6.725/0.025)> は正しい結果である -269 ではなく -268 を
返します: これは実際には -268.99999999999994315658 というような値に
なっているからです。
通常、L<C<sprintf>|/sprintf FORMAT, LIST>,
L<C<printf>|/printf FILEHANDLE FORMAT, LIST>,
L<C<POSIX::floor>|POSIX/C<floor>>, L<C<POSIX::ceil>|POSIX/C<ceil>> の方が
L<C<int>|/int EXPR> より便利です。
さらに、C<int 'Inf'> は Inf を生成します
(L<perldata/Special floating point: infinity (Inf) and not-a-number (NaN)> に
説明があります)が、前述の全ての代替法も同様です。

=item ioctl FILEHANDLE,FUNCTION,SCALAR
X<ioctl>

=for Pod::Functions system-dependent device control system call

=begin original

Implements the L<ioctl(2)> function.  You'll probably first have to say

=end original

L<ioctl(2)> 関数を実装します。
正しい関数の定義を得るために、おそらく最初に

    require "sys/ioctl.ph";  # probably in
                             # $Config{archlib}/sys/ioctl.ph

=begin original

to get the correct function definitions.  If F<sys/ioctl.ph> doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as F<< <sys/ioctl.h> >>.
(There is a Perl script called B<h2ph> that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION; a C pointer to the string value of SCALAR
will be passed as the third argument of the actual
C<ioctl> call.  (If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
true, add a C<0> to the scalar before using it.)  The
L<C<pack>|/pack TEMPLATE,LIST> and L<C<unpack>|/unpack TEMPLATE,EXPR>
functions may be needed to manipulate the values of structures used by
C<ioctl>.

=end original

としなくてはならないでしょう。
F<sys/ioctl.ph> がないか、間違った定義をしている場合には、
F<< <sys/ioctl.h> >>のような C のヘッダファイルをもとに、
自分で作らなければなりません。
(Perl の配布キットに入っている B<h2ph> という Perl スクリプトが
これを手助けしてくれるでしょうが、これは自明ではありません。)
FOUNCTION に応じて SCALAR が読み書きされます;
SCALAR の文字列値へのポインタが、実際の
C<ioctl> コールの
3 番目の引数として渡されます。
(SCALAR が文字列値を持っておらず、数値を持っている場合には、
文字列値へのポインタの代わりに、その値が渡されます。
このことを保証するためには、使用する前に SCALAR にC<0> を足してください。)
C<ioctl> で使われる構造体の値を
操作するには、L<C<pack>|/pack TEMPLATE,LIST> 関数と
L<C<unpack>|/unpack TEMPLATE,EXPR> 関数が必要となるでしょう。

=begin original

The return value of C<ioctl> (and
L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR>) is as follows:

=end original

C<ioctl>
(と L<C<fcntl>|/fcntl FILEHANDLE,FUNCTION,SCALAR>) の返り値は、
以下のようになります:

=begin original

    if OS returns:      then Perl returns:
        -1               undefined value
         0              string "0 but true"
    anything else           that number

=end original

    OS が返した値:      Perl が返す値:
        -1               未定義値
         0               「0 だが真」の文字列
    その他                  その値そのもの

=begin original

Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:

=end original

つまり Perl は、成功時に「真」、失敗時に「偽」を返す
ことになり、OS が実際に返した値も、以下のように簡単に知ることができます。

    my $retval = ioctl(...) || -1;
    printf "System returned %d\n", $retval;

=begin original

The special string C<"0 but true"> is exempt from
L<C<Argument "..." isn't numeric>|perldiag/Argument "%s" isn't numeric%s>
L<warnings> on improper numeric conversions.

=end original

特別な文字列 C<"0 だが真"> は、不適切な数値変換に関する
L<C<Argument "..." isn't numeric>|perldiag/Argument "%s" isn't numeric%s>
L<warnings> 警告を回避します。

=begin original

Portability issues: L<perlport/ioctl>.

=end original

移植性の問題: L<perlport/ioctl>。

=item join EXPR,LIST
X<join>

=for Pod::Functions join a list into a string using a separator

=begin original

Joins the separate strings of LIST into a single string with fields
separated by the value of EXPR, and returns that new string.  Example:

=end original

LIST の個別の文字列を、EXPR の値で区切って
1 つの文字列につなげ、その文字列を返します。
例:

   my $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

=begin original

Beware that unlike L<C<split>|/split E<sol>PATTERNE<sol>,EXPR,LIMIT>,
C<join> doesn't take a pattern as its first argument.
Compare L<C<split>|/split E<sol>PATTERNE<sol>,EXPR,LIMIT>.

=end original

L<C<split>|/split E<sol>PATTERNE<sol>,EXPR,LIMIT> と違って、
C<join> は最初の引数にパターンは取れないことに
注意してください。
L<C<split>|/split E<sol>PATTERNE<sol>,EXPR,LIMIT> と比較してください。

=item keys HASH
X<keys> X<key>

=item keys ARRAY

=for Pod::Functions retrieve list of indices from a hash or array

=begin original

Called in list context, returns a list consisting of all the keys of the
named hash, or in Perl 5.12 or later, the indices of an array.  Perl
releases prior to 5.12 will produce a syntax error if you try to use an
array argument.  In scalar context, returns the number of keys or indices.

=end original

リストコンテキストで呼び出されると、指定したハッシュのすべてのキー、あるいは
Perl 5.12 以降では、配列のインデックスからなるリストを返します。
5.12 より前の Perl は配列引数を使おうとすると文法エラーを出力します。
スカラコンテキストでは、キーやインデックスの数を返します。

=begin original

Array entries are returned lowest index first.

=end original

配列エントリはインデックスの小さいものから順に返されます。

=begin original

Hash entries are returned in an apparently random order.  The actual random
order is specific to a given hash; the exact same series of operations
on two hashes may result in a different order for each hash.  Any insertion
into the hash may change the order, as will any deletion, with the exception
that the most recent key returned by L<C<each>|/each HASH> or
C<keys> may be deleted without changing the order.  So
long as a given hash is unmodified you may rely on
C<keys>, L<C<values>|/values HASH> and L<C<each>|/each
HASH> to repeatedly return the same order
as each other.  See L<perlsec/"Algorithmic Complexity Attacks"> for
details on why hash order is randomized.  Aside from the guarantees
provided here, the exact details of Perl's hash algorithm and the hash
traversal order are subject to change in any release of Perl.  Tied hashes
may behave differently to Perl's hashes with respect to changes in order on
insertion and deletion of items.

=end original

ハッシュ要素は見かけ上、ランダムな順序で返されます。
実際のランダムな順序はハッシュに固有です; 二つのハッシュに全く同じ一連の
操作を行っても、ハッシュによって異なった順序になります。
ハッシュへの挿入によって順序が変わることがあります; 削除も同様ですが、
L<C<each>|/each HASH> または C<keys> によって返されたもっとも
最近のキーは順序を変えることなく削除できます。
ハッシュが変更されない限り、C<keys>, L<C<values>|/values HASH>,
L<C<each>|/each HASH> が繰り返し同じ順序で返すことに依存してもかまいません。
なぜハッシュの順序がランダム化されているかの詳細については
L<perlsec/"Algorithmic Complexity Attacks"> を参照してください。
ここで保証したことを除いて、Perl のハッシュアルゴリズムとハッシュ横断順序の
正確な詳細は Perl のリリースによって変更される可能性があります。
tie されたハッシュは、アイテムの挿入と削除の順序に関して Perl のハッシュと
異なった振る舞いをします。

=begin original

As a side effect, calling C<keys> resets the internal
iterator of the HASH or ARRAY (see L<C<each>|/each HASH>) before
yielding the keys.  In
particular, calling C<keys> in void context resets the
iterator with no other overhead.

=end original

副作用として、C<keys> の呼び出しは、
キーを取り出す前に HASH や ARRAY の反復子を
初期化します (L<C<each>|/each HASH> を参照してください)。
特に、無効コンテキストで C<keys> を呼び出すと
オーバーヘッドなしで反復子を初期化します。

=begin original

Here is yet another way to print your environment:

=end original

環境変数を表示する別の例です:

    my @keys = keys %ENV;
    my @values = values %ENV;
    while (@keys) {
        print pop(@keys), '=', pop(@values), "\n";
    }

=begin original

or how about sorted by key:

=end original

key でソートしてもいいでしょう:

    foreach my $key (sort(keys %ENV)) {
        print $key, '=', $ENV{$key}, "\n";
    }

=begin original

The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.  Compare
L<C<values>|/values HASH>.

=end original

返される値はハッシュにある元のキーのコピーなので、
これを変更しても元のハッシュには影響を与えません。
L<C<values>|/values HASH> と比較してください。

=begin original

To sort a hash by value, you'll need to use a
L<C<sort>|/sort SUBNAME LIST> function.  Here's a descending numeric
sort of a hash by its values:

=end original

ハッシュを値でソートするためには、L<C<sort>|/sort SUBNAME LIST> 関数を使う
必要があります。
以下ではハッシュの値を数値の降順でソートしています:

    foreach my $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
        printf "%4d %s\n", $hash{$key}, $key;
    }

=begin original

Used as an lvalue on a hash, C<keys> allows you to increase the
number of hash buckets
allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say

=end original

ハッシュに対して左辺値として使うことで、C<keys> を使うことで与えられたハッシュに
割り当てられたハッシュ表の大きさを増やすことができます。
これによって、ハッシュが大きくなっていくなっていくときの
効率の測定ができます。
(これは大きい値を $#array に代入することで配列を予め拡張することに
似ています。)
以下のようにすると:

    keys %hash = 200;

=begin original

then C<%hash> will have at least 200 buckets allocated for it--256 of them,
in fact, since it rounds up to the next power of two.  These
buckets will be retained even if you do C<%hash = ()>, use C<undef
%hash> if you want to free the storage while C<%hash> is still in scope.
You can't shrink the number of buckets allocated for the hash using
C<keys> in this way (but you needn't worry about doing
this by accident, as trying has no effect).

=end original

C<%hash> は少なくとも 200 の大きさの表が割り当てられます --
実際には 2 のべき乗に切り上げられるので、256 が割り当てられます。
この表はたとえ C<%hash = ()> としても残るので、
もし C<%hash> がスコープにいるうちにこの領域を開放したい場合は
C<undef %hash> を使います。
この方法で C<keys> を使うことで、表の大きさを小さくすることは
できません
(間違えてそのようなことをしても何も起きないので気にすることはありません)。

=begin original

C<keys @array> in an lvalue context is a syntax error.

=end original

左辺値コンテキストでの C<keys @array> は文法エラーとなります。

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<keys> to take a scalar expression. This experiment has
been deemed unsuccessful, and was removed as of Perl 5.24.

=end original

Perl 5.14 から、C<keys> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=begin original

To avoid confusing would-be users of your code who are running earlier
versions of Perl with mysterious syntax errors, put this sort of thing at
the top of your file to signal that your code will work I<only> on Perls of
a recent vintage:

=end original

あなたのコードを以前のバージョンの Perl で実行したユーザーが不思議な
文法エラーで混乱することを避けるために、コードが最近のバージョンの Perl で
I<のみ> 動作することを示すためにファイルの先頭に以下のようなことを
書いてください:

    use v5.12;	# so keys/values/each work on arrays

=begin original

See also L<C<each>|/each HASH>, L<C<values>|/values HASH>, and
L<C<sort>|/sort SUBNAME LIST>.

=end original

L<C<each>|/each HASH>, L<C<values>|/values HASH>,
L<C<sort>|/sort SUBNAME LIST> も参照してください。

=item kill SIGNAL, LIST

=item kill SIGNAL
X<kill> X<signal>

=for Pod::Functions send a signal to a process or process group

=begin original

Sends a signal to a list of processes.  Returns the number of arguments
that were successfully used to signal (which is not necessarily the same
as the number of processes actually killed, e.g. where a process group is
killed).

=end original

プロセスのリストにシグナルを送ります。
シグナル送信に使われた引数の数を返します
(例えばプロセスグループが kill された場合のように、実際に kill された
プロセスの数と同じとは限りません)。

    my $cnt = kill 'HUP', $child1, $child2;
    kill 'KILL', @goners;

=begin original

SIGNAL may be either a signal name (a string) or a signal number.  A signal
name may start with a C<SIG> prefix, thus C<FOO> and C<SIGFOO> refer to the
same signal.  The string form of SIGNAL is recommended for portability because
the same signal may have different numbers in different operating systems.

=end original

SIGNAL はシグナル名(文字列)かシグナル番号のどちらかです。
シグナル名は C<SIG> 接頭辞で始まることがあるので、C<FOO> と C<SIGFOO> は同じ
シグナルを意味します。
移植性から文字列形式の SIGNAL が推奨されます; 同じシグナルが異なった
オペレーティングシステムでは異なった番号になることがあるからです。

=begin original

A list of signal names supported by the current platform can be found in
C<$Config{sig_name}>, which is provided by the L<C<Config>|Config>
module.  See L<Config> for more details.

=end original

現在のプラットフォームが対応しているシグナル名の一覧は、L<C<Config>|Config>
モジュールによって提供される C<$Config{sig_name}> にあります。
さらなる詳細については L<Config> を参照してください。

=begin original

A negative signal name is the same as a negative signal number, killing process
groups instead of processes.  For example, C<kill '-KILL', $pgrp> and
C<kill -9, $pgrp> will send C<SIGKILL> to
the entire process group specified.  That
means you usually want to use positive not negative signals.

=end original

負のシグナル名は負のシグナル番号と同じで、
プロセスではなくプロセスグループに対して kill を行ないます。
たとえば、C<kill '-KILL', $pgrp> と C<kill -9, $pgrp> は指定された
プロセスグループ全体に C<SIGKILL> を送ります。
すなわち、通常は、負のシグナルは用いず、正のシグナルを使うことになります。

=begin original

If SIGNAL is either the number 0 or the string C<ZERO> (or C<SIGZERO>),
no signal is sent to the process, but C<kill>
checks whether it's I<possible> to send a signal to it
(that means, to be brief, that the process is owned by the same user, or we are
the super-user).  This is useful to check that a child process is still
alive (even if only as a zombie) and hasn't changed its UID.  See
L<perlport> for notes on the portability of this construct.

=end original

SIGNAL が数値 0 か文字列 C<ZERO> (または C<SIGZERO> の場合、プロセスに
シグナルは送られませんが、C<kill> は、
シグナルを送ることが I<可能> かどうかを調べます (これは、簡単に言うと、
プロセスが同じユーザーに所有されているか、自分がスーパーユーザーであることを
意味します)。
これは子プロセスが(ゾンビとしてだけでも)まだ生きていて、 UID が
変わっていないことを調べる時に有用です。
この構成の移植性に関する注意については L<perlport> を参照してください。

=begin original

The behavior of kill when a I<PROCESS> number is zero or negative depends on
the operating system.  For example, on POSIX-conforming systems, zero will
signal the current process group, -1 will signal all processes, and any
other negative PROCESS number will act as a negative signal number and
kill the entire process group specified.

=end original

I<PROCESS> 番号が 0 あるいは負数の場合の kill の振る舞いは
オペレーティングシステムに依存します。
例えば、POSIX 準拠のシステムでは、0 は現在のプロセスグループにシグナルを送り、
-1 は全てのプロセスにシグナルを送り、それ以外の負数の PROCESS 番号は
負数のシグナル番号として動作し、指定されたプロセスグループ全体を kill します。

=begin original

If both the SIGNAL and the PROCESS are negative, the results are undefined.
A warning may be produced in a future version.

=end original

SIGNAL と PROCESS の両方が負数の場合、結果は未定義です。
将来のバージョンでは警告が出るかも知れません。

=begin original

See L<perlipc/"Signals"> for more details.

=end original

詳細は L<perlipc/"Signals"> を参照してください。

=begin original

On some platforms such as Windows where the L<fork(2)> system call is not
available, Perl can be built to emulate L<C<fork>|/fork> at the
interpreter level.
This emulation has limitations related to kill that have to be considered,
for code running on Windows and in code intended to be portable.

=end original

Windows のような L<fork(2)> が利用不能なシステムでは、Perl は
L<C<fork>|/fork> をインタプリタレベルでエミュレートします。
エミュレーションは kill に関連して、コードが Windows で実行されて
しかしコードが移植性があると考えられるように制限があります。

=begin original

See L<perlfork> for more details.

=end original

さらなる詳細については L<perlfork> を参照してください。

=begin original

If there is no I<LIST> of processes, no signal is sent, and the return
value is 0.  This form is sometimes used, however, because it causes
tainting checks to be run, if your perl support taint checks.  But see
L<perlsec/Laundering and Detecting Tainted Data>.

=end original

処理する I<LIST> がない場合、シグナルは送られず、返り値は 0 です。
しかし、この形式は時々使われます; perl が汚染チェックに対応している場合、
実行するために汚染チェックを引き起こすからです。
しかし L<perlsec/Laundering and Detecting Tainted Data> を参照してください。

=begin original

Portability issues: L<perlport/kill>.

=end original

移植性の問題: L<perlport/kill>。

=item last LABEL
X<last> X<break>

=item last EXPR

=item last

=for Pod::Functions exit a block prematurely

=begin original

The C<last> command is like the C<break> statement in C
(as used in
loops); it immediately exits the loop in question.  If the LABEL is
omitted, the command refers to the innermost enclosing
loop.  The C<last EXPR> form, available starting in Perl
5.18.0, allows a label name to be computed at run time,
and is otherwise identical to C<last LABEL>.  The
L<C<continue>|/continue BLOCK> block, if any, is not executed:

=end original

C<last> コマンドは、(ループ内で使った) C の C<break> 文と
同じようなもので、LABEL で指定されるループを即座に抜けます。
LABEL が省略されると、コマンドは一番内側のループを参照します。
Perl 5.18.0 から利用可能な C<last EXPR> 形式では、実行時に計算される
ラベル名を使えます; それ以外は C<last LABEL> と同一です。
L<C<continue>|/continue BLOCK> ブロックがあっても実行されません:

    LINE: while (<STDIN>) {
        last LINE if /^$/;  # exit when done with header
        #...
    }

=begin original

C<last> cannot return a value from a block that typically
returns a value, such as C<eval {}>, C<sub {}>, or C<do {}>. It will perform
its flow control behavior, which precludes any return value. It should not be
used to exit a L<C<grep>|/grep BLOCK LIST> or L<C<map>|/map BLOCK LIST>
operation.

=end original

C<last> は C<eval {}>, C<sub {}>, C<do {}> といった
典型的には値を返すブロックから値を返せません。
これは、返り値を不可能にするフロー制御の振る舞いを実行します。
L<C<grep>|/grep BLOCK LIST> や L<C<map>|/map BLOCK LIST> 操作を終了するのに
使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<last> can be used to effect
an early exit out of such a block.

=end original

ブロック自身は一回だけ実行されるループと文法的に同一であることに
注意してください。
従って、C<last> でそのようなブロックを途中で
抜け出すことができます。

=begin original

See also L<C<continue>|/continue BLOCK> for an illustration of how
C<last>, L<C<next>|/next LABEL>, and
L<C<redo>|/redo LABEL> work.

=end original

C<last>, L<C<next>|/next LABEL>, L<C<redo>|/redo LABEL> が
どのように働くかについては L<C<continue>|/continue BLOCK> も参照してください。

=begin original

Unlike most named operators, this has the same precedence as assignment.
It is also exempt from the looks-like-a-function rule, so
C<last ("foo")."bar"> will cause "bar" to be part of the argument to
C<last>.

=end original

ほとんどの名前付き演算子と異なり、これは代入と同じ優先順位を持ちます。
また、関数のように見えるものの規則からも免れるので、C<last ("foo")."bar"> と
すると "bar" は C<last> への引数の一部となります。

=item lc EXPR
X<lc> X<lowercase>

=item lc

=for Pod::Functions return lower-case version of a string

=begin original

Returns a lowercased version of EXPR.  If EXPR is omitted, uses
L<C<$_>|perlvar/$_>.

=end original

EXPR を小文字に変換したものを返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

    my $str = lc("Perl is GREAT"); # "perl is great"

=begin original

What gets returned depends on several factors:

=end original

返り値として得られるものは色々な要素に依存します:

=over

=item If C<use bytes> is in effect:

(C<use bytes> が有効の場合)

=begin original

The results follow ASCII rules.  Only the characters C<A-Z> change,
to C<a-z> respectively.

=end original

結果は ASCII の規則に従います。
C<A-Z> のみが変換され、それぞれ C<a-z> になります。

=item Otherwise, if C<use locale> for C<LC_CTYPE> is in effect:

(それ以外の場合で、C<LC_CTYPE> に対して C<use locale> が有効の場合)

=begin original

Respects current C<LC_CTYPE> locale for code points < 256; and uses Unicode
rules for the remaining code points (this last can only happen if
the UTF8 flag is also set).  See L<perllocale>.

=end original

符号位置 < 256 に対しては現在の C<LC_CTYPE> ロケールに従います; そして
残りの符号位置に付いては Unicode の規則を使います (これは UTF8 フラグも
設定されている場合にのみ起こります)。
L<perllocale> を参照してください。

=begin original

Starting in v5.20, Perl uses full Unicode rules if the locale is
UTF-8.  Otherwise, there is a deficiency in this scheme, which is that
case changes that cross the 255/256
boundary are not well-defined.  For example, the lower case of LATIN CAPITAL
LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII
platforms).   But under C<use locale> (prior to v5.20 or not a UTF-8
locale), the lower case of U+1E9E is
itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the
current locale, and Perl has no way of knowing if that character even
exists in the locale, much less what code point it is.  Perl returns
a result that is above 255 (almost always the input character unchanged),
for all instances (and there aren't many) where the 255/256 boundary
would otherwise be crossed; and starting in v5.22, it raises a
L<locale|perldiag/Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".> warning.

=end original

v5.20 から、ロケールが UTF-8 の場合は Perl は完全な Unicode の規則を使います。
さもなければ、この手法には、255/266 の境界をまたぐ大文字小文字の変換は
未定義であるという欠点があります。
例えば、Unicode での LATIN CAPITAL LETTER SHARP S (U+1E9E) の小文字は
(ASCII プラットフォームでは) U+00DF です。
しかし C<use locale> が有効(v5.20 より前か、UTF-8 ロケール以外)なら、U+1E9E の
小文字は自分自身です; なぜなら 0xDF は現在のロケールでは
LATIN SMALL LETTER SHARP S ではなく、Perl は例えこのロケールに文字が
存在するかどうかを知る方法がなく、ましてどの符号位置かを知る方法が
ないからです。
Perl は 255/256 境界をまたぐ全ての(多くはありません)実体については
(ほとんど常に入力文字を変更せずに)256 以上の値を返します;
そして v5.22 から
L<locale|perldiag/Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".>
警告を出力します。

=item Otherwise, If EXPR has the UTF8 flag set:

(その他の場合で、EXPR に UTF8 フラグがセットされている場合)

=begin original

Unicode rules are used for the case change.

=end original

大文字小文字変換には Unicode の規則が使われます。

=item Otherwise, if C<use feature 'unicode_strings'> or C<use locale ':not_characters'> is in effect:

(それ以外の場合で、C<use feature 'unicode_strings'> か C<use locale ':not_characters'> が有効の場合)

=begin original

Unicode rules are used for the case change.

=end original

大文字小文字変換には Unicode の規則が使われます。

=item Otherwise:

(それ以外の場合)

=begin original

ASCII rules are used for the case change.  The lowercase of any character
outside the ASCII range is the character itself.

=end original

大文字小文字変換には ASCII の規則が使われます。
ASCII の範囲外の文字の「小文字」はその文字自身です。

=back

=begin original

B<Note:> This is the internal function implementing the
L<C<\L>|perlop/"Quote and Quote-like Operators"> escape in double-quoted
strings.

=end original

B<注意:> これは、ダブルクォート文字列における、
L<C<\L>|perlop/"Quote and Quote-like Operators"> エスケープを実装する
内部関数です。

    my $str = "Perl is \LGREAT\E"; # "Perl is great"

=item lcfirst EXPR
X<lcfirst> X<lowercase>

=item lcfirst

=for Pod::Functions return a string with just the next letter in lower case

=begin original

Returns the value of EXPR with the first character lowercased.  This
is the internal function implementing the C<\l> escape in
double-quoted strings.

=end original

最初の文字だけを小文字にした、EXPR を返します。
これは、ダブルクォート文字列における、C<\l> エスケープを
実装する内部関数です。

=begin original

If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

=begin original

This function behaves the same way under various pragmas, such as in a locale,
as L<C<lc>|/lc EXPR> does.

=end original

この関数は、ロケールのようなさまざまなプラグマの影響下では、
L<C<lc>|/lc EXPR> と同様に振る舞います。

=item length EXPR
X<length> X<size>

=item length

=for Pod::Functions return the number of characters in a string

=begin original

Returns the length in I<characters> of the value of EXPR.  If EXPR is
omitted, returns the length of L<C<$_>|perlvar/$_>.  If EXPR is
undefined, returns L<C<undef>|/undef EXPR>.

=end original

EXPR の値の I<文字> の長さを返します。
EXPR が省略されたときには、L<C<$_>|perlvar/$_> の長さを返します。
EXPR が未定義値の場合、L<C<undef>|/undef EXPR> を返します。

=begin original

This function cannot be used on an entire array or hash to find out how
many elements these have.  For that, use C<scalar @array> and C<scalar keys
%hash>, respectively.

=end original

この関数は配列やハッシュ全体に対してどれだけの要素を含んでいるかを
調べるためには使えません。
そのような用途には、それぞれ C<scalar @array> と C<scalar keys %hash> を
利用してください。

=begin original

Like all Perl character operations, L<C<length>|/length EXPR> normally
deals in logical
characters, not physical bytes.  For how many bytes a string encoded as
UTF-8 would take up, use C<length(Encode::encode('UTF-8', EXPR))>
(you'll have to C<use Encode> first).  See L<Encode> and L<perlunicode>.

=end original

全ての Perl の文字操作と同様、L<C<length>|/length EXPR> は通常物理的な
バイトではなく論理文字を扱います。
UTF-8 でエンコードされた文字列が何バイトかを知るには、
C<length(Encode::encode('UTF-8', EXPR))> を使ってください (先に
C<use Encode> する必要があります)。
L<Encode> と L<perlunicode> を参照してください。

=item __LINE__
X<__LINE__>

=for Pod::Functions the current source line number

=begin original

A special token that compiles to the current line number.
It can be altered by the mechanism described at
L<perlsyn/"Plain Old Comments (Not!)">.

=end original

現在の行番号にコンパイルされる特殊トークン。
L<perlsyn/"Plain Old Comments (Not!)"> で記述されている機構を使って
置き換えられます。

=item link OLDFILE,NEWFILE
X<link>

=for Pod::Functions create a hard link in the filesystem

=begin original

Creates a new filename linked to the old filename.  Returns true for
success, false otherwise.

=end original

OLDFILE にリンクされた、新しいファイル NEWFILE を作ります。
成功時には真を、さもなければ偽を返します。

=begin original

Portability issues: L<perlport/link>.

=end original

移植性の問題: L<perlport/link>。

=item listen SOCKET,QUEUESIZE
X<listen>

=for Pod::Functions register your socket as a server

=begin original

Does the same thing that the L<listen(2)> system call does.  Returns true if
it succeeded, false otherwise.  See the example in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

L<listen(2)> システムコールと同じことをします。
成功時には真を、さもなければ偽を返します。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=item local EXPR
X<local>

=for Pod::Functions create a temporary value for a global variable (dynamic scoping)

=begin original

You really probably want to be using L<C<my>|/my VARLIST> instead,
because C<local> isn't what most people think of as
"local".  See L<perlsub/"Private Variables via my()"> for details.

=end original

あなたはが本当に望んでいるのは L<C<my>|/my VARLIST> の方でしょう;
C<local> はほとんどの人々が「ローカル」と考えるものと
違うからです。
詳しくは L<perlsub/"Private Variables via my()"> を参照してください。

=begin original

A local modifies the listed variables to be local to the enclosing
block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See L<perlsub/"Temporary Values via local()">
for details, including issues with tied arrays and hashes.

=end original

"local" はリストアップされた変数を、囲っているブロック、
ファイル、eval の中で、ローカルなものにします。
複数の値を指定する場合は、リストはかっこで囲まなければなりません。
tie した配列とハッシュに関する事項を含む詳細については
L<perlsub/"Temporary Values via local()"> を参照してください。

=begin original

Like L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>, and
L<C<our>|/our VARLIST>, C<local> can operate on a variable
anywhere it appears in an expression (aside from interpolation in strings).
Unlike the other declarations, the effect of C<local> happens
at runtime, and so it will apply to additional uses of the same variable
executed after the declaration, even within the same statement. Note that
this does not include uses within an expression assigned to the variable
when it is localized, because the assigned expression is evaluated before
the localization.

=end original

L<C<my>|/my VARLIST>、L<C<state>|/state VARLIST>、
L<C<our>|/our VARLIST> と同様に、C<local> は、
(文字列内の置換を除いて) 式内の任意の場所で変数を操作できます。
他の宣言とは異なり、C<local> の効果は実行時に発生するため、
同じ文内であっても、宣言後に実行される同じ変数の追加の
使用に適用されます。
これには、変数がローカル化されるときに変数に代入された
式の中での使用は含まれないことに注意してください;
代入式はローカル化の前に評価されるからです。

    package main;
    our $x = 2;
    {
      foo($x, local $x = $x + 1, $x); # foo() receives (2, 3, 3)
      # $main::x is 3 within the call to foo()
    }
    foo($x); # foo() receives (2) and $main::x is 2

=begin original

The C<delete local EXPR> construct can also be used to localize the deletion
of array/hash elements to the current block.
See L<perlsub/"Localized deletion of elements of composite types">.

=end original

C<delete local EXPR> 構文は、配列/ハッシュの要素の削除を現在の
ブロックにローカル化するためにも使われていました。
L<perlsub/"Localized deletion of elements of composite types"> を
参照してください。

=item localtime EXPR
X<localtime> X<ctime>

=item localtime

=for Pod::Functions convert UNIX time into record or string using local time

=begin original

Converts a time as returned by the time function to a 9-element list
with the time analyzed for the local time zone.  If EXPR is omitted,
C<localtime> uses the current time (as returned by
L<C<time>|/time>).

=end original

time 関数が返す時刻を、ローカルなタイムゾーンで測った時刻として、
9 要素の配列に変換します。
EXPR が省略されると、C<localtime> は
(L<C<time>|/time> によって返される) 現在時刻を使います。

=begin original

Typically used as follows:

=end original

普通は、以下のようにして使います:

    #     0    1    2     3     4    5     6     7     8
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);

=begin original

All list elements are numeric and come straight out of the C C<struct
tm>.  C<$sec>, C<$min>, and C<$hour> are the seconds, minutes, and hours
of the specified time.

=end original

すべてのリスト要素は数値で、C の C<struct tm> 構造体から
直接持ってきます。
C<$sec>, C<$min>, C<$hour> は指定された時刻の秒、分、時です。

=begin original

C<$mday> is the day of the month in the range C<1..31> (i.e. 1-based).  C<$mon>
is the month in the range C<0..11> (i.e. 0-based), with 0 indicating January
and 11 indicating December.  This makes it easy to get a month name from a
list:

=end original

C<$mday> は C<1..31> の範囲(つまり 1 起点) の、月の何日目かです。
C<$mon> は月の値です; 月の値は C<0..11>
(つまり 0 起点)で、0 が 1 月、11 が 12 月です。
これにより、リストから月の名前を得るのが簡単になります:

    my @abbr = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
    print "$abbr[$mon] $mday";
    # $mon=9, $mday=18 gives "Oct 18"

=begin original

C<$year> contains the number of years since 1900 (e.g. C<129> for 2029).

=end original

C<$year> は 1900 年からの年数を持ちます(例えば、C<129> は 2029 年です)。

=begin original

C<$wday> is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.  C<$yday> is the day of the year, in the range C<0..364>
(or C<0..365> in leap years.)

=end original

C<$wday> は曜日で、0 が日曜日、3 が水曜日です。
C<$yday> はその年の何日目かで、C<0..364> の値を取ります
(うるう年は C<0..365> です。)

=begin original

C<$isdst> is true if the specified time occurs when Daylight Saving
Time is in effect, false otherwise.

=end original

C<$isdst> は指定された時刻で夏時間が有効の場合は真、そうでなければ偽です。

=begin original

To get a human-readable date/time string, use L<POSIX/C<strftime>>:

=end original

人間可読な日付/時刻文字列を得るには、L<POSIX/C<strftime>> を使います:

    use POSIX qw(strftime);
    my @now = localtime;
    my $now_string = strftime "%Y-%m-%d %H:%M:%S", @now;
    # e.g. "2025-11-29 15:19:02"

=begin original

To get just the year, you can use either L<POSIX/C<strftime>>:

=end original

単に年を得るには、L<POSIX/C<strftime>> を使うか:

    use POSIX qw(strftime);
    # full year:
    my $year = strftime "%Y", localtime;
    # just the last two digits of the year:
    my $ar = strftime "%y", localtime;

=begin original

... or manual arithmetic:

=end original

…自力で計算します:

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                            localtime;
    # full year:
    $year += 1900;
    # just the last two digits of the year:
    my $ar = sprintf("%02d", $year % 100);

=begin original

In scalar context, C<localtime> returns the
L<ctime(3)> value:

=end original

スカラコンテキストでは、C<localtime> は L<ctime(3)> の値を
返します:

    my $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"

=begin original

This scalar value is always in English, and is B<not> locale-dependent.
To get similar but locale-dependent date strings, try for example:

=end original

このスカラ値は常に英語で、ロケール依存では B<ありません>。
似たような、しかしロケール依存の日付文字列がほしい場合は、
以下の例を試してください:

    use POSIX qw(strftime);
    my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
    # or for GMT formatted appropriately for your locale:
    my $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

=begin original

C<$now_string> will be formatted according to the current LC_TIME locale
the program or thread is running in.  See L<perllocale> for how to set
up and change that locale.  Note that C<%a> and C<%b>, the short forms
of the day of the week and the month of the year, may not necessarily be
three characters wide.

=end original

C<$now_string> はプログラムやスレッドが実行されている現在の LC_TIME ロケールに
従ってフォーマットされます。
このロケールの設定と変更の方法については L<perllocale> を参照してください。
曜日と月の短い表現である C<%a> と C<%b> は、3 文字とは限らないことに
注意してください。

=begin original

The L<Time::gmtime> and L<Time::localtime> modules provide a convenient,
by-name access mechanism to the L<C<gmtime>|/gmtime EXPR> and
C<localtime> functions, respectively.

=end original

L<Time::gmtime> モジュールと L<Time::localtime> モジュールは、それぞれ
L<C<gmtime>|/gmtime EXPR> 関数と C<localtime> 関数に、
名前でアクセスする機構を提供する便利なモジュールです。

=begin original

For a comprehensive date and time representation look at the
L<DateTime> module on CPAN.

=end original

包括的な日付と時刻の表現については、CPAN の L<DateTime> モジュールを
参照してください。

=begin original

For GMT instead of local time use the L<C<gmtime>|/gmtime EXPR> builtin.

=end original

ローカル時刻ではなく GMT がほしい場合は L<C<gmtime>|/gmtime EXPR> 組み込み
関数を使ってください。

=begin original

See also the L<C<Time::Local>|Time::Local> module (for converting
seconds, minutes, hours, and such back to the integer value returned by
L<C<time>|/time>), and the L<POSIX> module's
L<C<mktime>|POSIX/C<mktime>> function.

=end original

また、(秒、分、時などの形から、L<C<time>|/time> が返す値である
1970 年 1 月 1 日の真夜中からの秒数に変換する)
L<C<Time::Local>|Time::Local> モジュール及び L<POSIX> モジュールで提供される
L<C<mktime>|POSIX/C<mktime>> 関数も参照してください。

=begin original

Portability issues: L<perlport/localtime>.

=end original

移植性の問題: L<perlport/localtime>。

=item lock THING
X<lock>

=for Pod::Functions +5.005 get a thread lock on a variable, subroutine, or method

=begin original

This function places an advisory lock on a shared variable or referenced
object contained in I<THING> until the lock goes out of scope.

=end original

この関数は I<THING> が含む共有変数またはリファレンスされたオブジェクトに、
スコープから出るまでアドバイサリロックを掛けます．

=begin original

The value returned is the scalar itself, if the argument is a scalar, or a
reference, if the argument is a hash, array or subroutine.

=end original

返される値は、引数がスカラならそのスカラ自身、引数がハッシュ、配列、
サブルーチンならリファレンスです。

=begin original

C<lock> is a "weak keyword"; this means that if you've
defined a function
by this name (before any calls to it), that function will be called
instead.  If you are not under C<use threads::shared> this does nothing.
See L<threads::shared>.

=end original

C<lock> は「弱いキーワード」です; もしユーザーが(呼び出し前に)
この名前で関数を定義すると、定義された関数の方が呼び出されます。
C<use threads::shared> の影響下でない場合は、これは何もしません。
L<threads::shared> を参照してください。

=item log EXPR
X<log> X<logarithm> X<e> X<ln> X<base>

=item log

=for Pod::Functions retrieve the natural logarithm for a number

=begin original

Returns the natural logarithm (base I<e>) of EXPR.  If EXPR is omitted,
returns the log of L<C<$_>|perlvar/$_>.  To get the
log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:

=end original

EXPR の (I<e> を底とする) 自然対数を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> の対数を返します。
底の異なる対数を求めるためには、基礎代数を利用してください:
ある数の N を底とする対数は、その数の自然対数を N の自然対数で割ったものです。
例えば:

    sub log10 {
        my $n = shift;
        return log($n)/log(10);
    }

=begin original

See also L<C<exp>|/exp EXPR> for the inverse operation.

=end original

逆操作については L<C<exp>|/exp EXPR> を参照してください。

=item lstat FILEHANDLE
X<lstat>

=item lstat EXPR

=item lstat DIRHANDLE

=item lstat

=for Pod::Functions stat a symbolic link

=begin original

Does the same thing as the L<C<stat>|/stat FILEHANDLE> function
(including setting the special C<_> filehandle) but stats a symbolic
link instead of the file the symbolic link points to.  If symbolic links
are unimplemented on your system, a normal L<C<stat>|/stat FILEHANDLE>
is done.  For much more detailed information, please see the
documentation for L<C<stat>|/stat FILEHANDLE>.

=end original

(特別なファイルハンドルである C<_> の設定を含めて)
L<C<stat>|/stat FILEHANDLE> 関数と同じことをしますが、シンボリックリンクが
指しているファイルではなく、シンボリックリンク自体の stat をとります。
シンボリックリンクがシステムに実装されていないと、通常の
L<C<stat>|/stat FILEHANDLE> が行なわれます。
さらにより詳細な情報については、L<C<stat>|/stat FILEHANDLE> の文書を
参照してください。

=begin original

If EXPR is omitted, stats L<C<$_>|perlvar/$_>.

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> の stat をとります。

=begin original

Portability issues: L<perlport/lstat>.

=end original

移植性の問題: L<perlport/lstat>。

=item m//

=for Pod::Functions match a string with a regular expression pattern

=begin original

The match operator.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

マッチ演算子です。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item map BLOCK LIST
X<map>

=item map EXPR,LIST

=for Pod::Functions apply a change to a list to get back a new list with the changes

=begin original

Evaluates the BLOCK or EXPR for each element of LIST (locally setting
L<C<$_>|perlvar/$_> to each element) and composes a list of the results of
each such evaluation.  Each element of LIST may produce zero, one, or more
elements in the generated list, so the number of elements in the generated
list may differ from that in LIST.  In scalar context, returns the total
number of elements so generated.  In list context, returns the generated list.

=end original

LIST の個々の要素に対して、BLOCK か EXPR を評価し
(L<C<$_>|perlvar/$_> は、ローカルに個々の要素が設定されます) 、
それぞれの評価結果からなるリストを作ります。
LIST の個々の要素によって作られる、生成されたリストの要素数は、
0 個の場合もあれば、複数の場合もあるので、
生成されたリストの要素数は LIST の要素数と異なるかも知れません。
スカラコンテキストでは、生成された要素の数を返します。
リストコンテキストでは、生成されたリストを返します。

    my @chars = map(chr, @numbers);

=begin original

translates a list of numbers to the corresponding characters.

=end original

は、数のリストを対応する文字に変換します。

    my @squares = map { $_ * $_ } @numbers;

=begin original

translates a list of numbers to their squared values.

=end original

これは数値のリストを、その 2 乗に変換します。

    my @squares = map { $_ > 5 ? ($_ * $_) : () } @numbers;

=begin original

shows that number of returned elements can differ from the number of
input elements.  To omit an element, return an empty list ().
This could also be achieved by writing

=end original

のように、返された要素の数が入力要素の数と異なる場合もあります。
要素を省略するには、空リスト () を返します。
これは以下のように書くことでも達成できて

    my @squares = map { $_ * $_ } grep { $_ > 5 } @numbers;

=begin original

which makes the intention more clear.

=end original

この方が目的がよりはっきりします。

=begin original

Map always returns a list, which can be
assigned to a hash such that the elements
become key/value pairs.  See L<perldata> for more details.

=end original

map は常にリストを返し、要素がキー/値の組になるようなハッシュに
代入できます。
さらなる詳細については L<perldata> を参照してください。

    my %hash = map { get_a_key_for($_) => $_ } @array;

=begin original

is just a funny way to write

=end original

は以下のものをちょっと変わった書き方で書いたものです。

    my %hash;
    foreach (@array) {
        $hash{get_a_key_for($_)} = $_;
    }

=begin original

Note that L<C<$_>|perlvar/$_> is an alias to the list value, so it can
be used to modify the elements of the LIST.  While this is useful and
supported, it can cause bizarre results if the elements of LIST are not
variables.  Using a regular C<foreach> loop for this purpose would be
clearer in most cases.  See also L<C<grep>|/grep BLOCK LIST> for a
list composed of those items of the original list for which the BLOCK
or EXPR evaluates to true.

=end original

L<C<$_>|perlvar/$_> は、LIST の値へのエイリアスですので、LIST の要素を
変更するために使うことができます。
これは、便利でサポートされていますが、
LIST の要素が変数でないと、おかしな結果になります。
この目的には通常の C<foreach> ループを使うことで、ほとんどの場合は
より明確になります。
BLOCK や EXPR が真になる元のリストの要素からなるリストについては、
L<C<grep>|/grep BLOCK LIST> も参照してください。

=begin original

C<{> starts both hash references and blocks, so C<map { ...> could be either
the start of map BLOCK LIST or map EXPR, LIST.  Because Perl doesn't look
ahead for the closing C<}> it has to take a guess at which it's dealing with
based on what it finds just after the
C<{>.  Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the C<}> and
encounters the missing (or unexpected) comma.  The syntax error will be
reported close to the C<}>, but you'll need to change something near the C<{>
such as using a unary C<+> or semicolon to give Perl some help:

=end original

C<{> はハッシュリファレンスとブロックの両方の開始文字なので、
C<map { ...> は map BLOCK LIST の場合と map EXPR, LIST の場合があります。
Perl は終了文字の C<}> を先読みしないので、C<{> の直後の文字を見て
どちらとして扱うかを推測します。
通常この推測は正しいですが、もし間違った場合は、C<}> まで読み込んで
カンマが足りない(または多い)ことがわかるまで、何かがおかしいことに
気付きません。
C<}> の近くで文法エラーが出ますが、Perl を助けるために単項の C<+> や
セミコロンを使うというように、C<{> の近くの何かを変更する必要があります。

 my %hash = map {  "\L$_" => 1  } @array # perl guesses EXPR. wrong
 my %hash = map { +"\L$_" => 1  } @array # perl guesses BLOCK. right
 my %hash = map {; "\L$_" => 1  } @array # this also works
 my %hash = map { ("\L$_" => 1) } @array # as does this
 my %hash = map {  lc($_) => 1  } @array # and this.
 my %hash = map +( lc($_) => 1 ), @array # this is EXPR and works!

 my %hash = map  ( lc($_), 1 ),   @array # evaluates to (1, @array)

=begin original

or to force an anon hash constructor use C<+{>:

=end original

または C<+{> を使って無名ハッシュコンストラクタを強制します:

    my @hashes = map +{ lc($_) => 1 }, @array # EXPR, so needs
                                              # comma at end

=begin original

to get a list of anonymous hashes each with only one entry apiece.

=end original

こうするとそれぞれ 1 要素だけの無名ハッシュのリストを得られます。

=item method NAME BLOCK
X<method>

=item method NAME : ATTRS BLOCK

=for Pod::Functions declare a method of a class

=begin original

Creates a new named method in the scope of the class that it appears within.
This is only valid inside a L<C<class>|/class NAMESPACE> declaration.

=end original

これがあるクラス内のスコープに新しく名前付きのメソッドを作成します。
これは L<C<class>|/class NAMESPACE> 宣言の中でのみ有効です。

=item mkdir FILENAME,MODE
X<mkdir> X<md> X<directory, create>

=item mkdir FILENAME

=item mkdir

=for Pod::Functions create a directory

=begin original

Creates the directory specified by FILENAME, with permissions
specified by MODE (as modified by L<C<umask>|/umask EXPR>).  If it
succeeds it returns true; otherwise it returns false and sets
L<C<$!>|perlvar/$!> (errno).
MODE defaults to 0777 if omitted, and FILENAME defaults
to L<C<$_>|perlvar/$_> if omitted.

=end original

FILENAME で指定したディレクトリを、MODE で指定した許可モード(を
L<C<umask>|/umask EXPR> で修正したもの) で作成します。
成功時には真を返します; さもなければ偽を返して
L<C<$!>|perlvar/$!> (errno) を設定します。
MODE を省略すると、0777 とみなし、
FILENAME を省略すると、L<C<$_>|perlvar/$_> を使います。

=begin original

In general, it is better to create directories with a permissive MODE
and let the user modify that with their L<C<umask>|/umask EXPR> than it
is to supply
a restrictive MODE and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The documentation for
L<C<umask>|/umask EXPR> discusses the choice of MODE in more detail.
If bits in MODE other than the permission bits are set, the result may
be implementation defined, per POSIX 1003.1-2008.

=end original

一般的に、制限された MODE を使ってユーザーがより寛容にする方法を
与えないより、寛容な MODE でディレクトリを作り、ユーザーが自身の
L<C<umask>|/umask EXPR> で修正するようにした方がよいです。
例外は、(例えばメールファイルのような)プライベートに保つべきファイルや
ディレクトリを書く場合です。
L<C<umask>|/umask EXPR> の文書で、MODE の選択に関して詳細に議論しています。
MODE の中の許可モードビット以外のビットを設定した場合、
結果は POSIX 1003.1-2008 のように実装依存です。

=begin original

Note that according to the POSIX 1003.1-1996 the FILENAME may have any
number of trailing slashes.  Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.

=end original

POSIX 1003.1-1996 によれば、FILENAME には末尾に任意の数のスラッシュを
つけることができます。
このようには動かない OS やファイルシステムもあるので、Perl はみんなが
幸せになれるように、自動的に末尾のスラッシュを削除します。

=begin original

To recursively create a directory structure, look at
the L<C<make_path>|File::Path/make_path( $dir1, $dir2, .... )> function
of the L<File::Path> module.

=end original

ディレクトリ構造を再帰的に作成するには、L<File::Path> モジュールの
L<C<make_path>|File::Path/make_path( $dir1, $dir2, .... )> 関数を
参照してください。

=item msgctl ID,CMD,ARG
X<msgctl>

=for Pod::Functions SysV IPC message control operations

=begin original

Calls the System V IPC function L<msgctl(2)>.  You'll probably have to say

=end original

System V IPC 関数 L<msgctl(2)> を呼び出します。
正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<msqid_ds>
structure.  Returns like L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR>:
the undefined value for error, C<"0 but true"> for zero, or the actual
return value otherwise.  See also L<perlipc/"SysV IPC"> and the
documentation for L<C<IPC::SysV>|IPC::SysV> and
L<C<IPC::Semaphore>|IPC::Semaphore>.

=end original

と書くことが必要でしょう。
CMD が C<IPC_STAT> であれば、ARG は返される C<msqid_ds> 構造体を
納める変数でなければなりません。
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR> と同じように、エラー時には
未定義値、ゼロのときは C<"0 but true">、それ以外なら、その値そのものを
返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Semaphore>|IPC::Semaphore> の文書も参照してください。

=begin original

Portability issues: L<perlport/msgctl>.

=end original

移植性の問題: L<perlport/msgctl>。

=item msgget KEY,FLAGS
X<msgget>

=for Pod::Functions get SysV IPC message queue

=begin original

Calls the System V IPC function L<msgget(2)>.  Returns the message queue
id, or L<C<undef>|/undef EXPR> on error.  See also L<perlipc/"SysV IPC">
and the documentation for L<C<IPC::SysV>|IPC::SysV> and
L<C<IPC::Msg>|IPC::Msg>.

=end original

System V IPC 関数 L<msgget(2)> を呼び出します。
メッセージキューの ID か、エラー時には L<C<undef>|/undef EXPR> を返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Msg>|IPC::Msg> の文書も参照してください。

=begin original

Portability issues: L<perlport/msgget>.

=end original

移植性の問題: L<perlport/msgget>。

=item msgrcv ID,VAR,SIZE,TYPE,FLAGS
X<msgrcv>

=for Pod::Functions receive a SysV IPC message from a message queue

=begin original

Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.  Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.  This packing may be opened with C<unpack("l! a*")>.
Taints the variable.  Returns true if successful, false
on error.  See also L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV> and L<C<IPC::Msg>|IPC::Msg>.

=end original

System V IPC 関数 msgrcv を呼び出し、メッセージキュー ID から、
変数 VAR に最大メッセージ長 SIZE のメッセージを受信します。
メッセージが受信された時、ネイティブな long 整数のメッセージタイプが
VAR の先頭となり、実際のメッセージが続きます。
このパッキングは C<unpack("l! a*")> で展開できます。
変数は汚染されます。
成功時には真を、エラー時には偽を返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Msg>|IPC::Msg> の文書も参照してください。

=begin original

Portability issues: L<perlport/msgrcv>.

=end original

移植性の問題: L<perlport/msgrcv>。

=item msgsnd ID,MSG,FLAGS
X<msgsnd>

=for Pod::Functions send a SysV IPC message to a message queue

=begin original

Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.  MSG must begin with the native long integer message
type, followed by the message itself.  This kind of packing can be achieved
with C<pack("l! a*", $type, $message)>.  Returns true if successful,
false on error.  See also L<perlipc/"SysV IPC"> and the documentation
for L<C<IPC::SysV>|IPC::SysV> and L<C<IPC::Msg>|IPC::Msg>.

=end original

System V IPC 関数 msgsnd を呼び出し、メッセージキュー ID に
メッセージ MSG を送信します。
MSG の先頭は、ネイティブな long 整数のメッセージタイプでなければならず、
メッセージ本体が続きます。
これは、C<pack("l! a*", $type, $message)> として生成できます。
成功時には真を、エラー時には偽を返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Msg>|IPC::Msg> の文書も参照してください。

=begin original

Portability issues: L<perlport/msgsnd>.

=end original

移植性の問題: L<perlport/msgsnd>。

=item my VARLIST
X<my>

=item my TYPE VARLIST

=item my VARLIST : ATTRS

=item my TYPE VARLIST : ATTRS

=for Pod::Functions declare and assign a local variable (lexical scoping)

=begin original

A C<my> declares the listed variables to be local
(lexically) to the enclosing block, file, or L<C<eval>|/eval EXPR>.  If
more than one variable is listed, the list must be placed in
parentheses.

=end original

C<my> はリストアップされた変数を、囲っているブロック、ファイル、
L<C<eval>|/eval EXPR> の中でローカルな (レキシカルな) ものにします。
複数の変数を指定する場合は、リストはかっこで囲まなければなりません。

=begin original

Note that with a parenthesised list, L<C<undef>|/undef EXPR> can be used
as a dummy placeholder, for example to skip assignment of initial
values:

=end original

かっこで囲まれたリストでは、L<C<undef>|/undef EXPR> は、例えば初期値の代入を
飛ばすために、ダミーのプレースホルダとして使えることに注意してください:

    my ( undef, $min, $hour ) = localtime;

=begin original

Like L<C<state>|/state VARLIST>, L<C<local>|/local EXPR>, and
L<C<our>|/our VARLIST>, C<my> can operate on a variable
anywhere it appears in an expression (aside from interpolation in strings).
The declaration will not apply to additional uses of the same variable until
the next statement. This means additional uses of that variable within the
same statement will act as they would have before that declaration occurred,
or result in a strict 'vars' error, as appropriate.

=end original

L<C<state>|/state VARLIST>, L<C<local>|/local EXPR>,
L<C<our>|/our VARLIST> と同様に、C<my> は、
(文字列内の置換を除いて) 式内の任意の場所で変数を操作できます。
この宣言は、次の文まで、同じ変数の追加使用には適用されません。
つまり、同じ文内でその変数を追加使用すると、適切に、
その宣言が行われる前と同じように動作するか、
strict 'vars' エラーが発生します。

    package main;
    our $x = 2;
    foo($x, my $x = $x + 1, $x); # foo() receives (2, 3, 2)
    foo($x, $main::x);           # foo() receives (3, 2)

=begin original

Redeclaring a variable in the same scope or statement will "shadow" the
previous declaration, creating a new instance and preventing access to
the previous one. This is usually undesired and, if warnings are enabled,
will result in a warning in the C<shadow> category.

=end original

同じスコープや文で変数を再宣言すると、以前の宣言を「隠し」、
新しい実体を作って、以前の実体にアクセスできなくなります。
これは普通は望まれているものではなく、警告が有効なら、
C<shadow> カテゴリの警告が出ます。

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE may be a bareword, a constant declared
with L<C<use constant>|constant>, or L<C<__PACKAGE__>|/__PACKAGE__>.  It
is
currently bound to the use of the L<fields> pragma,
and attributes are handled using the L<attributes> pragma, or starting
from Perl 5.8.0 also via the L<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details.

=end original

TYPE と ATTRS の正確な文法とインターフェースは今でも進化しています。
TYPE は、裸の単語、L<C<use constant>|constant> で宣言された定数、
L<C<__PACKAGE__>|/__PACKAGE__> のいずれかです。
現在のところ、TYPE は L<fields> プラグマの使用と結び付けられていて、
属性は L<attributes> プラグマか、Perl 5.8.0 からは
L<Attribute::Handlers> モジュールと結び付けられています。
詳しくは L<perlsub/"Private Variables via my()"> を参照してください。

=item next LABEL
X<next> X<continue>

=item next EXPR

=item next

=for Pod::Functions iterate a block prematurely

=begin original

The C<next> command is like the C<continue> statement in
C; it starts the next iteration of the loop:

=end original

C<next> コマンドは、C での C<continue> 文のようなもので、
ループの次の繰り返しを開始します:

    LINE: while (<STDIN>) {
        next LINE if /^#/;  # discard comments
        #...
    }

=begin original

Note that if there were a L<C<continue>|/continue BLOCK> block on the
above, it would get
executed even on discarded lines.  If LABEL is omitted, the command
refers to the innermost enclosing loop.  The C<next EXPR> form, available
as of Perl 5.18.0, allows a label name to be computed at run time, being
otherwise identical to C<next LABEL>.

=end original

L<C<continue>|/continue BLOCK> ブロックが存在すれば、たとえ捨てられる行に
あっても、それが実行されます。
LABEL が省略されると、コマンドは一番内側のループを参照します。
Perl 5.18.0 から利用可能な C<next EXPR> 形式では、実行時に計算される
ラベル名が使えます; それ以外は C<next LABEL> と同一です。

=begin original

C<next> cannot return a value from a block that typically
returns a value, such as C<eval {}>, C<sub {}>, or C<do {}>. It will perform
its flow control behavior, which precludes any return value. It should not be
used to exit a L<C<grep>|/grep BLOCK LIST> or L<C<map>|/map BLOCK LIST>
operation.

=end original

C<next> は C<eval {}>, C<sub {}>, C<do {}> といった
典型的には値を返すブロックから値を返せません。
これは、返り値を不可能にするフロー制御の振る舞いを実行します。
L<C<grep>|/grep BLOCK LIST> や L<C<map>|/map BLOCK LIST> 操作を終了するのに
使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<next> will exit such a block
early.

=end original

ブロック自身は一回だけ実行されるループと文法的に同一であることに
注意してください。
従って、C<next> はそのようなブロックから早く抜けるのに使えます。

=begin original

See also L<C<continue>|/continue BLOCK> for an illustration of how
L<C<last>|/last LABEL>, C<next>, and
L<C<redo>|/redo LABEL> work.

=end original

L<C<last>|/last LABEL>, C<next>, L<C<redo>|/redo LABEL> が
どのように働くかについては L<C<continue>|/continue BLOCK> も参照してください。

=begin original

Unlike most named operators, this has the same precedence as assignment.
It is also exempt from the looks-like-a-function rule, so
C<next ("foo")."bar"> will cause "bar" to be part of the argument to
C<next>.

=end original

ほとんどの名前付き演算子と異なり、これは代入と同じ優先順位を持ちます。
また、関数のように見えるものの規則からも免れるので、C<next ("foo")."bar"> と
すると "bar" は C<next> への引数の一部となります。

=item no MODULE VERSION LIST
X<no declarations>
X<unimporting>

=item no MODULE VERSION

=item no MODULE LIST

=item no MODULE

=item no VERSION

=for Pod::Functions unimport some module symbols or semantics at compile time

=begin original

See the L<C<use>|/use Module VERSION LIST> function, of which
C<no> is the opposite.

=end original

L<C<use>|/use Module VERSION LIST> 関数を参照してください;
C<no> は、その逆を行なうものです。

=item oct EXPR
X<oct> X<octal> X<hex> X<hexadecimal> X<binary> X<bin>

=item oct

=for Pod::Functions convert a string to an octal number

=begin original

Interprets EXPR as an octal string and returns the corresponding
value.  An octal string consists of octal digits and, as of Perl 5.33.5,
an optional C<0o> or C<o> prefix.  Each octal digit may be preceded by
a single underscore, which will be ignored.
(If EXPR happens to start off with C<0x> or C<x>, interprets it as a
hex string.  If EXPR starts off with C<0b> or C<b>, it is interpreted as a
binary string.  Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in standard
Perl notation:

=end original

EXPR を 8 進数文字列と解釈して、対応する値を返します。
8 進数文字列は、8 進文字と、Perl 5.33.5 からはオプションの
C<0o> または C<o> 接頭辞からなります。
各 8 進文字の前には一つの下線を置くことができ、これは無視されます。
(EXPR が C<0x> か C<x> で始まるときには、16 進数文字列と解釈します。
EXPR が C<0b> か C<b> で始まるときは、2 進数文字列と解釈します。
どの場合でも、先頭の空白は無視されます。)
以下の例は、標準的な Perl の記法での
10 進数、2 進数、8 進数、16 進数を扱います:

    $val = oct($val) if $val =~ /^0/;

=begin original

If EXPR is omitted, uses L<C<$_>|perlvar/$_>.   To go the other way
(produce a number in octal), use L<C<sprintf>|/sprintf FORMAT, LIST> or
L<C<printf>|/printf FILEHANDLE FORMAT, LIST>:

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。
(8 進数を扱う)その他の方法をとしては L<C<sprintf>|/sprintf FORMAT, LIST> や
L<C<printf>|/printf FILEHANDLE FORMAT, LIST> があります:

    my $dec_perms = (stat("filename"))[2] & 07777;
    my $oct_perm_str = sprintf "%o", $perms;

=begin original

The C<oct> function is commonly used when a string such as
C<644> needs
to be converted into a file mode, for example.  Although Perl
automatically converts strings into numbers as needed, this automatic
conversion assumes base 10.

=end original

C<oct> 関数は例えば、C<644> といった文字列をファイルモードに
変換する時によく使います。
Perl は必要に応じて自動的に文字列を数値に変換しますが、
この自動変換は十進数を仮定します。

=begin original

Leading white space is ignored without warning, as too are any trailing
non-digits, such as a decimal point (C<oct> only handles
non-negative integers, not negative integers or floating point).

=end original

先頭の空白や、末尾の(小数点のような)非数字は警告なしに無視されます
(C<oct> は非負整数のみを扱えます; 負の整数や小数は扱えません)。


=item open FILEHANDLE,MODE,EXPR
X<open> X<pipe> X<file, open> X<fopen>

=item open FILEHANDLE,MODE,EXPR,LIST

=item open FILEHANDLE,MODE,REFERENCE

=item open FILEHANDLE,EXPR

=item open FILEHANDLE

=for Pod::Functions open a file, pipe, or descriptor

=begin original

Associates an internal FILEHANDLE with the external file specified by
EXPR. That filehandle will subsequently allow you to perform
I/O operations on that file, such as reading from it or writing to it.

=end original

内部の FILEHANDLE を、EXPR で指定された外部ファイルに関連付けます。
このファイルハンドルはその後、読んだり書いたりといったそのファイルへの
I/O 操作をできるようにします。

=begin original

Instead of a filename, you may specify an external command
(plus an optional argument list) or a scalar reference, in order to open
filehandles on commands or in-memory scalars, respectively.

=end original

ファイル名の代わりに、コマンドやメモリ内スカラへのファイルハンドルを
開くために、外部コマンド (とオプションの引数リスト) やスカラリファレンスを
指定できます。

=begin original

A thorough reference to C<open> follows. For a gentler introduction to
the basics of C<open>, see also the L<perlopentut> manual page.

=end original

C<open> の完全なリファレンスは後述します。
C<open> の基本に関するより親切な導入に関しては、
L<perlopentut> man ページも参照してください。

=over

=item Working with files

=begin original

Most often, C<open> gets invoked with three arguments: the required
FILEHANDLE (usually an empty scalar variable), followed by MODE (usually
a literal describing the I/O mode the filehandle will use), and then the
filename  that the new filehandle will refer to.

=end original

ほとんどの場合、C<open> は 3 引数で起動されます:
必須の FILEHANDLE (通常は空のスカラ変数), 引き続いて MODE (通常は
ファイルハンドルを使う I/O モードを記述するリテラル)、
それから新しいファイルハンドルが参照するファイル名です。

=over

=item Simple examples

(単純な例)

=begin original

Reading from a file:

=end original

ファイルからの読み込み:

    open(my $fh, "<", "input.txt")
        or die "Can't open < input.txt: $!";

    # Process every line in input.txt
    while (my $line = readline($fh)) {
        #
        # ... do something interesting with $line here ...
        #
    }

=begin original

or writing to one:

=end original

そして書き込み:

    open(my $fh, ">", "output.txt")
        or die "Can't open > output.txt: $!";

    print $fh "This line gets printed into output.txt.\n";

=begin original

For a summary of common filehandle operations such as these, see
L<perlintro/Files and I/O>.

=end original

このような基本的なファイルハンドル操作の要約については、
L<perlintro/Files and I/O> を参照してください。

=item About filehandles

(ファイルハンドルについて)

=begin original

The first argument to C<open>, labeled FILEHANDLE in this reference, is
usually a scalar variable. (Exceptions exist, described in "Other
considerations", below.) If the call to C<open> succeeds, then the
expression provided as FILEHANDLE will get assigned an open
I<filehandle>. That filehandle provides an internal reference to the
specified external file, conveniently stored in a Perl variable, and
ready for I/O operations such as reading and writing.

=end original

このリファレンスでは FILEHANDLE というラベルが付いている、
C<open> の最初の引数は、通常はスカラ変数です。
(例外があります; 後述する "Other considerations" で記述されます。)
C<open> の呼び出しが成功すると、
FILEHANDLE として提供された式には、
開いた I<ファイルハンドル> が代入されます。
このファイルハンドルは指定された外部ファイルへの内部参照を提供し、
好都合なように Perl 変数に保管し、読み書きのような I/O 操作の準備をします。

=item About modes

(モードについて)

=begin original

When calling C<open> with three or more arguments, the second argument
-- labeled MODE here -- defines the I<open mode>. MODE is usually a
literal string comprising special characters that define the intended
I/O role of the filehandle being created: whether it's read-only, or
read-and-write, and so on.

=end original

3 引数以上で C<open> を呼び出すとき、
2 番目の引数 -- ここでは MODE -- は I<開くモード> を定義します。
MODE は普通、作られるファイルハンドルが意図している I/O の役割 (読み込み専用、
読み書き、など)を定義する特別な文字で構成されるリテラルな文字列です。

=begin original

If MODE is C<< < >>, the file is opened for input (read-only).
If MODE is C<< > >>, the file is opened for output, with existing files
first being truncated ("clobbered") and nonexisting files newly created.
If MODE is C<<< >> >>>, the file is opened for appending, again being
created if necessary.

=end original

MODE が C<< < >> の場合、ファイルは入力用(読み込み専用)に開かれます。
MODE が C<< > >> の場合、ファイルは出力用に開かれ、既にファイルが
ある場合は切り詰められ(上書きされ)、ない場合は新しく作られます。
MODE が C<<< >> >>> の場合、ファイルは追加用に開かれ、やはり必要なら
作成されます。

=begin original

You can put a C<+> in front of the C<< > >> or C<< < >> to
indicate that you want both read and write access to the file; thus
C<< +< >> is almost always preferred for read/write updates--the
C<< +> >> mode would clobber the file first.  You can't usually use
either read-write mode for updating textfiles, since they have
variable-length records.  See the B<-i> switch in
L<perlrun|perlrun/-i[extension]> for a better approach.  The file is
created with permissions of C<0666> modified by the process's
L<C<umask>|/umask EXPR> value.

=end original

ファイルに読み込みアクセスと書き込みアクセスの両方をしたいことを示すために、
C<< > >> や C<< < >> の前に C<+> を付けることができます:
従って、ほとんど常に C<< +< >> が読み書き更新のために使われます --
C<< +> >> モードはまずファイルを上書きします。
普通はこれらの読み書きモードをテキストファイルの更新のためには使えません;
なぜなら可変長のレコードで構成されているからです。
よりよい手法については L<perlrun|perlrun/-i[extension]> の
B<-i> オプションを参照してください。
ファイルは C<0666> をプロセスの L<C<umask>|/umask EXPR> 値で修正した
パーミッションで作成されます。

=begin original

These various prefixes correspond to the L<fopen(3)> modes of C<r>,
C<r+>, C<w>, C<w+>, C<a>, and C<a+>.

=end original

これらの様々な前置詞は L<fopen(3)> の C<r>, C<r+>,
C<w>, C<w+>, C<a>, C<a+> のモードに対応します。

=begin original

More examples of different modes in action:

=end original

実用的な異なったモードに関する更なる例:

 # Open a file for concatenation
 open(my $log, ">>", "/usr/spool/news/twitlog")
     or warn "Couldn't open log file; discarding input";

 # Open a file for reading and writing
 open(my $dbase, "+<", "dbase.mine")
     or die "Can't open 'dbase.mine' for update: $!";

=item Checking the return value

(返り値をチェックする)

=begin original

Open returns nonzero on success, the undefined value otherwise.  If the
C<open> involved a pipe, the return value happens to be the pid of the
subprocess.

=end original

open は、成功時にはゼロ以外を返し、失敗時には未定義値を返します。
パイプに関る C<open> のときには、返り値は
サブプロセスの pid となります。

=begin original

When opening a file, it's seldom a good idea to continue if the request
failed, so C<open> is frequently used with L<C<die>|/die LIST>. Even if
you want your code to do something other than C<die> on a failed open,
you should still always check the return value from opening a file.

=end original

ファイルを開く時、開くのに失敗した時に通常の処理を続けるのは普通は悪い
考えなので、C<open> はしばしば
L<C<die>|/die LIST> と結び付けられて使われます。
開くときに失敗したときに L<C<die>|/die LIST> 意外の何かを
したい場合でも、ファイルを開いた時の返り値を常にチェックするべきです。

=back

=item Specifying I/O layers in MODE

(MODE で I/O 層を指定する)

=begin original

You can use the three-argument form of open to specify
I/O layers (sometimes referred to as "disciplines") to apply to the new
filehandle. These affect how the input and output are processed (see
L<open> and
L<PerlIO> for more details).  For example:

=end original

新しいファイルハンドルに適用する
I/O 層(「ディシプリン」とも呼ばれます)を指定するために
open の 3 引数形式を使えます。
これらはどのように入出力が処理されるかに影響を与えます
(詳細については L<open> と L<PerlIO> を参照してください)。
例えば:

    # loads PerlIO::encoding automatically
    open(my $fh, "<:encoding(UTF-8)", $filename)
        || die "Can't open UTF-8 encoded $filename: $!";

=begin original

This opens the UTF8-encoded file containing Unicode characters;
see L<perluniintro>.  Note that if layers are specified in the
three-argument form, then default layers stored in
L<C<${^OPEN}>|perlvar/${^OPEN}>
(usually set by the L<open> pragma or the switch C<-CioD>) are ignored.
Those layers will also be ignored if you specify a colon with no name
following it.  In that case the default layer for the operating system
(:raw on Unix, :crlf on Windows) is used.

=end original

これは、Unicode 文字を含む UTF8 エンコードされたファイルを開きます;
L<perluniintro> を参照してください。
3 引数形式で層を指定すると、L<C<${^OPEN}>|perlvar/${^OPEN}>
(通常は L<open> プラグマか C<-CioD> オプションでセットされます) に
保存されたデフォルト層は無視されることに注意してください。
これらの層は、名前なしでコロンを指定した場合にも無視されます。
この場合 OS のデフォルトの層 (Unix では :raw、Windows では :crlf) が
使われます。

=begin original

On some systems (in general, DOS- and Windows-based systems)
L<C<binmode>|/binmode FILEHANDLE, LAYER> is necessary when you're not
working with a text file.  For the sake of portability it is a good idea
always to use it when appropriate, and never to use it when it isn't
appropriate.  Also, people can set their I/O to be by default
UTF8-encoded Unicode, not bytes.

=end original

テキストファイルでないものを扱う場合に
L<C<binmode>|/binmode FILEHANDLE, LAYER> が必要な
システムもあります(一般的には DOS と Windows ベースのシステムです)。
移植性のために、適切なときには常にこれを使い、適切でないときには
決して使わないというのは良い考えです。
また、デフォルトとして I/O を bytes ではなく UTF-8 エンコードされた
Unicode にセットすることも出来ます。

=item Using C<undef> for temporary files

(一時ファイルとして C<undef> を使う)

=begin original

As a special case the three-argument form with a read/write mode and the third
argument being L<C<undef>|/undef EXPR>:

=end original

特別な場合として、3 引数の形で読み書きモードで 3 番目の引数が
L<C<undef>|/undef EXPR> の場合:

    open(my $tmp, "+>", undef) or die ...

=begin original

opens a filehandle to a newly created empty anonymous temporary file.
(This happens under any mode, which makes C<< +> >> the only useful and
sensible mode to use.)  You will need to
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> to do the reading.

=end original

新しく作成した空の無名一時ファイルとしてファイルハンドルを開きます。
(これはどのモードでも起こりますが、C<< +> >> のみが有用で意味があります。)
読み込みを行うためには L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> が
必要です。

=item Opening a filehandle into an in-memory scalar

(ファイルハンドルをメモリ内スカラに開く)

=begin original

You can open filehandles directly to Perl scalars instead of a file or
other resource external to the program. To do so, provide a reference to
that scalar as the third argument to C<open>, like so:

=end original

ファイルやその他のプログラムから見ての外部リソースではなく、
Perl スカラに対して直接ファイルハンドルを開くことができます。
そうするためには、次のように、C<open> の 3 番目の引数としてその
スカラへのリファレンスを提供します:

 open(my $memory, ">", \$var)
     or die "Can't open memory file: $!";
 print $memory "foo!\n";    # output will appear in $var

=begin original

To (re)open C<STDOUT> or C<STDERR> as an in-memory file, close it first:

=end original

C<STDOUT> や C<STDERR> を「オンメモリの」ファイルとして
再び開きたい場合は、先にそれを閉じます:

    close STDOUT;
    open(STDOUT, ">", \$variable)
	or die "Can't open STDOUT: $!";

=begin original

The scalars for in-memory files are treated as octet strings: unless
the file is being opened with truncation the scalar may not contain
any code points over 0xFF.

=end original

オンメモリファイルのためのスカラはオクテット文字列として扱われます:
ファイルが切り詰められて開かれない限り、
スカラは 0xFF を超える符号位置を含みません。

=begin original

Opening in-memory files I<can> fail for a variety of reasons.  As with
any other C<open>, check the return value for success.

=end original

オンメモリファイルを開くのは様々な理由で失敗する I<ことがあります>。
その他の C<open> と同様、成功したかを返り値でチェックしてください。

=begin original

I<Technical note>: This feature works only when Perl is built with
PerlIO -- the default, except with older (pre-5.16) Perl installations
that were configured to not include it (e.g. via C<Configure
-Uuseperlio>). You can see whether your Perl was built with PerlIO by
running C<perl -V:useperlio>.  If it says C<'define'>, you have PerlIO;
otherwise you don't.

=end original

I<技術ノート>: この機能は Perl が PerlIO を使ってビルドされている
場合にのみ動作します; これは (C<Configure -Uuseperlio> によって)
これを含まないように設定されていた古い (5.16 より前の) Perl でない限り、
デフォルトです。
Perl が PerlIO つきでビルドされているかどうかを確認するには、
C<perl -V:useperlio> を見ます。
これが C<'define'> なら PerlIO を使っています;
そうでなければ使っていません。

=begin original

See L<perliol> for detailed info on PerlIO.

=end original

PerlIO に関する詳しい情報については L<perliol> を参照してください。

=item Opening a filehandle into a command

(ファイルハンドルをコマンドに開く)

=begin original

If MODE is C<|->, then the filename is
interpreted as a command to which output is to be piped, and if MODE
is C<-|>, the filename is interpreted as a command that pipes
output to us.  In the two-argument (and one-argument) form, one should
replace dash (C<->) with the command.
See L<perlipc/"Using open() for IPC"> for more examples of this.
(You are not allowed to C<open> to a command
that pipes both in I<and> out, but see L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication with Another Process"> for
alternatives.)

=end original

MODE が C<|-> の場合、ファイル名は出力がパイプされるコマンドとして
解釈され、MODE が C<-|> の場合、ファイル名は出力がこちらに
パイプされるコマンドとして解釈されます。
2 引数(と 1 引数) の形式ではハイフン(C<->)をコマンドの代わりに使えます。
これに関するさらなる例については L<perlipc/"Using open() for IPC"> を
参照してください。
(C<open> を入出力 I<両用> にパイプすることは
出来ませんが、代替案としては L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication with Another Process"> を
参照してください。)

 open(my $article_fh, "-|", "caesar <$article")  # decrypt
                                                 # article
     or die "Can't start caesar: $!";

 open(my $article_fh, "caesar <$article |")      # ditto
     or die "Can't start caesar: $!";

 open(my $out_fh, "|-", "sort >Tmp$$")    # $$ is our process id
     or die "Can't start sort: $!";

=begin original

In the form of pipe opens taking three or more arguments, if LIST is specified
(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.  The meaning of
C<open> with more than three arguments for
non-pipe modes is not yet defined, but experimental "layers" may give
extra LIST arguments meaning.

=end original

パイプでの三つ以上の引数の形式では、LIST (コマンド名の後の追加の引数) が
指定されると、プラットフォームが対応していれば、LIST は起動される
コマンドへの引数となります。
パイプモードではない C<open> での
三つ以上の引数の意味はまだ未定義ですが、実験的な「層」は
追加の LIST 引数の意味を与えます。

=begin original

If you open a pipe on the command C<-> (that is, specify either C<|-> or C<-|>
with the one- or two-argument forms of
C<open>), an implicit L<C<fork>|/fork> is done,
so C<open> returns twice: in the parent process
it returns the pid
of the child process, and in the child process it returns (a defined) C<0>.
Use C<defined($pid)> or C<//> to determine whether the open was successful.

=end original

(1 引数 または 2 引数の形の C<open> で
(C<-|> や C<|-> とすることで) C<-> というコマンドにパイプを開くと、
暗黙の L<C<fork>|/fork> が行なわれるので、
C<open> は 2 回返ります;
親プロセスには子プロセスの pid が返され、子プロセスには (定義された) C<0> が
返されます。
open が成功したかどうかを調べるには、C<defined($pid)> または C<//> を
使います。

=begin original

For example, use either

=end original

例えば、以下の二つ

   my $child_pid = open(my $from_kid, "-|")
        // die "Can't fork: $!";

=begin original

or

=end original

または

   my $child_pid = open(my $to_kid,   "|-")
        // die "Can't fork: $!";

=begin original

followed by

=end original

を使って、後で以下のようにします。

    if ($child_pid) {
	# am the parent:
	# either write $to_kid or else read $from_kid
	...
       waitpid $child_pid, 0;
    } else {
	# am the child; use STDIN/STDOUT normally
	...
	exit;
    }

=begin original

The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.

=end original

親プロセスでは、このファイルハンドルは通常通りに動作しますが、行なわれる
入出力は、子プロセスの STDIN/STDOUT にパイプされます。
子プロセス側では、そのファイルハンドルは開かれず、入出力は新しい STDOUT か
STDIN に対して行なわれます。
これは、setuid で実行して、シェルコマンドのメタ文字を
検索させたくないような場合に、パイプコマンドの起動の仕方を
制御したいとき、普通のパイプの open と同じように使います。

=begin original

The following blocks are more or less equivalent:

=end original

以下の組み合わせは、だいたい同じものです:

    open(my $fh, "|tr '[a-z]' '[A-Z]'");
    open(my $fh, "|-", "tr '[a-z]' '[A-Z]'");
    open(my $fh, "|-") || exec 'tr', '[a-z]', '[A-Z]';
    open(my $fh, "|-", "tr", '[a-z]', '[A-Z]');

    open(my $fh, "cat -n '$file'|");
    open(my $fh, "-|", "cat -n '$file'");
    open(my $fh, "-|") || exec "cat", "-n", $file;
    open(my $fh, "-|", "cat", "-n", $file);

=begin original

The last two examples in each block show the pipe as "list form", which
is not yet supported on all platforms. (If your platform has a real
L<C<fork>|/fork>, such as Linux and macOS, you can use the list form; it
also works on Windows with Perl 5.22 or later.) You would want to use
the list form of the pipe so you can pass literal arguments to the
command without risk of the shell interpreting any shell metacharacters
in them. However, this also bars you from opening pipes to commands that
intentionally contain shell metacharacters, such as:

=end original

それぞれのブロックの末尾二つの例ではパイプを「リスト形式」にしていますが、
これはまだ全てのプラットフォームで対応しているわけではなりません。
(もし実行しているプラットフォームで本当の
L<C<fork>|/fork> があれば(Linux や
MacOS X なら)リスト形式が使えます; Perl 5.22 以降では Windows でも
動作します。)
パイプのリスト形式を使うことで、コマンドへのリテラルな引数を、
シェルのメタ文字をシェルが解釈するリスクなしに渡すことができます。
しかし、これは以下のように意図的にシェルメタ文字を含むコマンドをパイプとして
開くことを妨げます:

    open(my $fh, "|cat -n | expand -4 | lpr")
    	|| die "Can't open pipeline to lpr: $!";

=begin original

See L<perlipc/"Safe Pipe Opens"> for more examples of this.

=end original

これに関する更なる例については L<perlipc/"Safe Pipe Opens"> を
参照してください。

=item Duping filehandles

(ハンドルの複製)

=begin original

You may also, in the Bourne shell tradition, specify an EXPR beginning
with C<< >& >>, in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as in L<dup(2)>) and opened.  You may use C<&> after C<< > >>,
C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>, and C<< +< >>.
The mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents
of IO buffers.)  If you use the three-argument
form, then you can pass either a
number, the name of a filehandle, or the normal "reference to a glob".

=end original

Bourne シェルの慣例にしたがって、EXPR の先頭に C<< >& >>
を付けると、EXPR の残りの文字列をファイルハンドル名
(数字であれば、ファイル記述子) と解釈して、それを (L<dup(2)> によって)
複製してオープンします。
C<&> は、C<< > >>, C<<< >> >>>, C<< < >>, C<< +> >>, C<<< +>> >>>,
C<< +< >>というモード指定に付けることができます。
指定するモード指定は、もとのファイルハンドルのモードと
合っていないといけません。
(ファイルハンドルの複製は既に存在する IO バッファの内容に含めません。)
3 引数形式を使う場合は、数値を渡すか、ファイルハンドルの名前を渡すか、
通常の「グロブへのリファレンス」を渡します。

=begin original

Here is a script that saves, redirects, and restores C<STDOUT> and
C<STDERR> using various methods:

=end original

C<STDOUT> と C<STDERR> 保存し、リダイレクトし、元に戻すスクリプトを示します:

    #!/usr/bin/perl
    open(my $oldout, ">&STDOUT")
        or die "Can't dup STDOUT: $!";
    open(OLDERR,     ">&", \*STDERR)
        or die "Can't dup STDERR: $!";

    open(STDOUT, '>', "foo.out")
        or die "Can't redirect STDOUT: $!";
    open(STDERR, ">&STDOUT")
        or die "Can't dup STDOUT: $!";

    select STDERR; $| = 1;  # make unbuffered
    select STDOUT; $| = 1;  # make unbuffered

    print STDOUT "stdout 1\n";  # this works for
    print STDERR "stderr 1\n";  # subprocesses too

    open(STDOUT, ">&", $oldout)
        or die "Can't dup \$oldout: $!";
    open(STDERR, ">&OLDERR")
        or die "Can't dup OLDERR: $!";

    print STDOUT "stdout 2\n";
    print STDERR "stderr 2\n";

=begin original

If you specify C<< '<&=X' >>, where C<X> is a file descriptor number
or a filehandle, then Perl will do an equivalent of C's L<fdopen(3)> of
that file descriptor (and not call L<dup(2)>); this is more
parsimonious of file descriptors.  For example:

=end original

C<X> をファイル記述子の番号かファイルハンドルとして、
C<< '<&=X' >> と指定すると、Perl はそのファイル記述子に対する
C の L<fdopen(3)> と同じことを行ないます(そして L<dup(2)> は呼び出しません);
これはファイル記述子をより節約します。
例えば:

    # open for input, reusing the fileno of $fd
    open(my $fh, "<&=", $fd)

=begin original

or

=end original

または

    open(my $fh, "<&=$fd")

=begin original

or

=end original

または

    # open for append, using the fileno of $oldfh
    open(my $fh, ">>&=", $oldfh)

=begin original

Being parsimonious on filehandles is also useful (besides being
parsimonious) for example when something is dependent on file
descriptors, like for example locking using
L<C<flock>|/flock FILEHANDLE,OPERATION>.  If you do just
C<< open(my $A, ">>&", $B) >>, the filehandle C<$A> will not have the
same file descriptor as C<$B>, and therefore C<flock($A)> will not
C<flock($B)> nor vice versa.  But with C<< open(my $A, ">>&=", $B) >>,
the filehandles will share the same underlying system file descriptor.

=end original

ファイルハンドルを倹約することは、(倹約できること以外に)何かが
ファイル記述子に依存している場合、例えば
L<C<flock>|/flock FILEHANDLE,OPERATION> を使った
ファイルロックといった場合に有用です。
C<< open(my $A, ">>&", $B) >> とすると、ファイルハンドル C<$A> は C<$B> と同じ
ファイル記述子にはならないので、C<flock($A)> と C<flock($B)> は別々になります。
しかし C<< open(my $A, ">>&=", $B) >> ではファイルハンドルは基礎となるシステムの
同じファイル記述子を共有します。

=begin original

Note that under Perls older than 5.8.0, Perl uses the standard C library's'
L<fdopen(3)> to implement the C<=> functionality.  On many Unix systems,
L<fdopen(3)> fails when file descriptors exceed a certain value, typically 255.
For Perls 5.8.0 and later, PerlIO is (most often) the default.

=end original

5.8.0 より前の Perl の場合、C<=> 機能の実装は
標準 C ライブラリの L<fdopen(3)> を使っています。
多くの Unix システムでは、L<fdopen(3)> はファイル記述子がある値
(典型的には 255)を超えた場合に失敗することが知られています。
5.8.0 以降の Perl では、(ほぼ確実に) PerlIO がデフォルトです。

=item Legacy usage

(古い使い方)

=begin original

This section describes ways to call C<open> outside of best practices;
you may encounter these uses in older code. Perl does not consider their
use deprecated, exactly, but neither is it recommended in new code, for
the sake of clarity and readability.

=end original

この節では、ベストプラクティスではない C<open> の呼び出し方について
記述します; より古いコードでこれらが使われているのに遭遇するかもしれません。
厳密には、Perl はこれらの仕様を廃止予定にはしていませんが、
明瞭性と可読性のために、新しいコードには薦めません。

=over

=item Specifying mode and filename as a single argument

(モードとファイル名を一つの引数で指定する)

=begin original

In the one- and two-argument forms of the call, the mode and filename
should be concatenated (in that order), preferably separated by white
space.  You can--but shouldn't--omit the mode in these forms when that mode
is C<< < >>.  It is safe to use the two-argument form of
C<open> if the filename argument is a known literal.

=end original

1 引数 と 2 引数の形式ではモードとファイル名は(この順番で)
結合されます(空白によって分割されているかもしれません)。
この形式で、モードが C<< '<' >> の場合はモードを省略できます (が、
するべきではありません)。
ファイル引数が既知のリテラルの場合、2 引数形式の
C<open> は安全です。

 open(my $dbase, "+<dbase.mine")          # ditto
     or die "Can't open 'dbase.mine' for update: $!";

=begin original

In the two-argument (and one-argument) form, opening C<< <- >>
or C<-> opens STDIN and opening C<< >- >> opens STDOUT.

=end original

2 引数(と 1 引数)で C<< <- >> か C<-> を open すると STDIN が
オープンされ、C<< >- >> を open すると STDOUT がオープンされます。

=begin original

New code should favor the three-argument form of C<open> over this older
form. Declaring the mode and the filename as two distinct arguments
avoids any confusion between the two.

=end original

新しいコードでは、このより古い形式ではなく、3 引数形式の C<open> を
使うべきです。
モードとファイル名を異なった二つの引数として指定することで、
二つの間の混乱を避けられます。

=item Assigning a filehandle to a bareword

(ファイルハンドルを裸の単語に代入する)

=begin original

An older style is to use a bareword as the filehandle, as

=end original

より古いスタイルは、次のように、ファイルハンドルとして裸の単語を使います

    open(FH, "<", "input.txt")
       or die "Can't open < input.txt: $!";

=begin original

Then you can use C<FH> as the filehandle, in C<< close FH >> and C<<
<FH> >> and so on.  Note that it's a global variable, so this form is
not recommended when dealing with filehandles other than Perl's built-in ones
(e.g. STDOUT and STDIN).  In fact, using a bareword for the filehandle is
an error when the
L<C<"bareword_filehandles"> feature|feature/"The 'bareword_filehandles' feature">
has been disabled.  This feature is disabled automatically when in the
scope of C<use v5.36.0> or later.

=end original

それから C<FH> を、C<< close FH >> や C<< <FH> >> などのように、
ファイルハンドルとして使えます。
これはグローバル変数なので、Perl の組み込みのもの (例えば STDOUT と STDIN)
以外では非推奨であることに注意してください。
実際、
L<C<"bareword_filehandles"> 機能|feature/"The 'bareword_filehandles' feature">
が無効になっている場合は
ファイルハンドルに裸の単語を使うことはエラーです。
この機能は、C<use v5.36.0> 以降のスコープ内では自動的に
無効になっています。

=item Calling C<open> with one argument via global variables

(グローバル変数を使って C<open> を 1 引数で呼び出す)

=begin original

As a shortcut, a one-argument call takes the filename from the global
scalar variable of the same name as the bareword filehandle:

=end original

短縮版として、1 引数呼び出しでは、ファイル名を、裸の単語の
ファイルハンドルと同じ名前のグローバルなスカラ変数から取ります:

    $ARTICLE = 100;
    open(ARTICLE)
        or die "Can't find article $ARTICLE: $!\n";

=begin original

Here C<$ARTICLE> must be a global scalar variable in the same package
as the filehandle - not one declared with L<C<my>|/my VARLIST> or
L<C<state>|/state VARLIST>.

=end original

ここで C<$ARTICLE> はファイルハンドルと同じパッケージのグローバル
(パッケージ)スカラ変数でなければなりません -
L<C<my>|/my VARLIST> や L<C<state>|/state VARLIST> で宣言された
変数ではありません。

=back

=item Other considerations

(その他の考慮点)

=over

=item Automatic filehandle closure

(自動的にファイルハンドルを閉じる)

=begin original

The filehandle will be closed when its reference count reaches zero. If
it is a lexically scoped variable declared with L<C<my>|/my VARLIST>,
that usually means the end of the enclosing scope.  However, this
automatic close does not check for errors, so it is better to explicitly
close filehandles, especially those used for writing:

=end original

ファイルハンドルは、参照カウントが 0 になったときに閉じられます。
これが L<C<my>|/my VARLIST> で宣言されたレキシカルスコープを持つ変数の場合、
普通は囲まれたスコープの終わりを意味します。
しかし、この自動閉じはエラーをチェックしないので、特に書き込み用の場合は、
明示的にファイルハンドルを閉じる方がよいです。

    close($handle)
       || warn "close failed: $!";

=item Automatic pipe flushing

(パイプの自動フラッシュ)

=begin original

Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set L<C<$E<verbar>>|perlvar/$E<verbar>> (C<$AUTOFLUSH> in L<English>)
or call the C<autoflush> method of L<C<IO::Handle>|IO::Handle/METHODS>
on any open handles.

=end original

Perl は書き込み用に開いている全てのファイルに対して
fork を行う前にフラッシュしようとしますが、これに対応していない
プラットフォームもあります(L<perlport> を参照してください)。
安全のために、L<C<$E<verbar>>|perlvar/$E<verbar>> (L<English> モジュールでは
C<$AUTOFLUSH>) をセットするか、全ての開いているハンドルに対して
L<C<IO::Handle>|IO::Handle/METHODS> の C<autoflush> メソッドを
呼び出す必要があるかもしれません。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor as determined by the value
of L<C<$^F>|perlvar/$^F>.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは L<C<$^F>|perlvar/$^F> の値で決定される、新しくオープンされた
ファイル記述子に対してセットされます。
L<perlvar/$^F> を参照してください。

=begin original

Closing any piped filehandle causes the parent process to wait for the
child to finish, then returns the status value in L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.

=end original

パイプのファイルハンドルを close することで、親プロセスは、子プロセスの終了を
待ち、それから L<C<$?>|perlvar/$?> と
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> にステータス値を
返します。

=item Direct versus by-reference assignment of filehandles

(ファイルハンドルの直接代入とリファレンスによる代入)

=begin original

If FILEHANDLE -- the first argument in a call to C<open> -- is an
undefined scalar variable (or array or hash element), a new filehandle
is autovivified, meaning that the variable is assigned a reference to a
newly allocated anonymous filehandle.  Otherwise if FILEHANDLE is an
expression, its value is the real filehandle.  (This is considered a
symbolic reference, so C<use strict "refs"> should I<not> be in effect.)

=end original

FILEHANDLE (C<open> を呼び出すときの最初の引数) が未定義のスカラ変数
(または配列かハッシュの要素)の場合、
新しいファイルハンドルが自動有効化され、その変数は新しく割り当てられた
無名ファイルハンドルへのリファレンスが代入されます。
さもなければ、もし FILEHANDLE が式なら、その値を求めている実際の
ファイルハンドルの名前として使います。
(これはシンボリックリファレンスとして扱われるので、
C<use strict "refs"> の影響を I<受けません>。)

=item Whitespace and special characters in the filename argument

(ファイル名引数の空白と特殊文字)

=begin original

The filename passed to the one- and two-argument forms of
C<open> will
have leading and trailing whitespace deleted and normal
redirection characters honored.  This property, known as "magic open",
can often be used to good effect.  A user could specify a filename of
F<"rsh cat file |">, or you could change certain filenames as needed:

=end original

1 引数 と 2 引数の形の C<open> に渡された
ファイル名は、はじめと終わりの空白が取り除かれ、通常のリダイレクト文字列を
受け付けます。
この機能は "magic open" として知られていますが、普通いい効果をもたらします。
ユーザーは F<"rsh cat file |"> といったファイル名を指定できますし、
特定のファイル名を必要に応じて変更できます。

    $filename =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
    open(my $fh, $filename)
        or die "Can't open $filename: $!";

=begin original

Use the three-argument form to open a file with arbitrary weird characters in it,

=end original

妙な文字が含まれているようなファイル名をオープンするには、
3 引数の形を使います。

    open(my $fh, "<", $file)
    	|| die "Can't open $file: $!";

=begin original

otherwise it's necessary to protect any leading and trailing whitespace:

=end original

あるいは、次のようにして、最初と最後の空白を保護します:

    $file =~ s#^(\s)#./$1#;
    open(my $fh, "< $file\0")
    	|| die "Can't open $file: $!";

=begin original

(this may not work on some bizarre filesystems).  One should
conscientiously choose between the I<magic> and I<three-argument> form
of C<open>:

=end original

(これは奇妙なファイルシステムでは動作しないかもしれません)。
C<open> の I<magic> と I<3 引数> 形式を誠実に
選択するべきです。

    open(my $in, $ARGV[0]) || die "Can't open $ARGV[0]: $!";

=begin original

will allow the user to specify an argument of the form C<"rsh cat file |">,
but will not work on a filename that happens to have a trailing space, while

=end original

とするとユーザーは C<"rsh cat file |"> という形の引数を指定できますが、
末尾にスペースがついてしまったファイル名では動作しません; 一方:

    open(my $in, "<", $ARGV[0])
    	|| die "Can't open $ARGV[0]: $!";

=begin original

will have exactly the opposite restrictions. (However, some shells
support the syntax C<< perl your_program.pl <( rsh cat file ) >>, which
produces a filename that can be opened normally.)

=end original

はまったく逆の制限があります。
(しかし、一部のシェルは C<< perl your_program.pl <( rsh cat file ) >> という
文法に対応していて、普通に開くことが出来るファイル名を出力します。)

=item Invoking C-style C<open>

(C 形式の C<open> の起動)

=begin original

If you want a "real" C L<open(2)>, then you should use the
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> function, which involves
no such magic (but uses different filemodes than Perl
C<open>, which corresponds to C L<fopen(3)>).
This is another way to protect your filenames from interpretation.  For
example:

=end original

もし「本当の」C 言語の L<open(2)> が必要なら、このような副作用のない
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> 関数を使うべきです
(ただし、C の L<fopen(3)> に対応する Perl の
C<open> とは違うファイルモードを持ちます)。
これはファイル名を解釈から守るもう一つの方法です。
例えば:

    use IO::Handle;
    sysopen(my $fh, $path, O_RDWR|O_CREAT|O_EXCL)
        or die "Can't open $path: $!";
    $fh->autoflush(1);
    print $fh "stuff $$\n";
    seek($fh, 0, 0);
    print "File contains: ", readline($fh);

=begin original

See L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> for some details about
mixing reading and writing.

=end original

読み書きを混ぜる場合の詳細については
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE> を参照してください。

=item Portability issues

(移植性の問題)

=begin original

See L<perlport/open>.

=end original

L<perlport/open> を参照してください。

=back

=back

=item opendir DIRHANDLE,EXPR
X<opendir>

=for Pod::Functions open a directory

=begin original

Opens a directory named EXPR for processing by
L<C<readdir>|/readdir DIRHANDLE>, L<C<telldir>|/telldir DIRHANDLE>,
L<C<seekdir>|/seekdir DIRHANDLE,POS>,
L<C<rewinddir>|/rewinddir DIRHANDLE>, and
L<C<closedir>|/closedir DIRHANDLE>.  Returns true if successful.
DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.  If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle; that is, it's autovivified.
Dirhandles are the same objects as filehandles; an I/O object can only
be open as one of these handle types at once.

=end original

L<C<readdir>|/readdir DIRHANDLE>、L<C<telldir>|/telldir DIRHANDLE>、
L<C<seekdir>|/seekdir DIRHANDLE,POS>、L<C<rewinddir>|/rewinddir DIRHANDLE>、
L<C<closedir>|/closedir DIRHANDLE> で処理するために、EXPR で指定された名前の
ディレクトリをオープンします。
成功時には真を返します。
DIRHANDLE は間接ディレクトリハンドルとして使える値(普通は実際のディレクトリ
ハンドルの名前)となる式でも構いません。
DIRHANDLE が未定義のスカラ値(または配列かハッシュの要素)の場合、その変数は
新しい無名ディレクトリハンドルへのリファレンスが代入されます; つまり、
自動有効化されます。
ディレクトリハンドルはファイルハンドルと同じオブジェクトです;
一つの I/O オブジェクトは同時にこれらのハンドル型のどちらかとしてのみ
開くことができます。

=begin original

See the example at L<C<readdir>|/readdir DIRHANDLE>.

=end original

L<C<readdir>|/readdir DIRHANDLE> の例を参照してください。

=item ord EXPR
X<ord> X<encoding>

=item ord

=for Pod::Functions find a character's code point

=begin original

Returns the code point of the first character of EXPR.
If EXPR is an empty string, returns 0.  If EXPR is omitted, uses
L<C<$_>|perlvar/$_>.
(Note I<character>, not byte.)

=end original

EXPR の最初の文字の符号位置を返します。
EXPR が空文字列の場合は、0 を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。
(バイトではなく I<文字> であることに注意してください。)

=begin original

For the reverse, see L<C<chr>|/chr NUMBER>.
See L<perlunicode> for more about Unicode.

=end original

逆のことをするには L<C<chr>|/chr NUMBER> を参照してください。
Unicode については L<perlunicode> を参照してください。

=item our VARLIST
X<our> X<global>

=item our TYPE VARLIST

=item our VARLIST : ATTRS

=item our TYPE VARLIST : ATTRS

=for Pod::Functions +5.6.0 declare and assign a package variable (lexical scoping)

=begin original

C<our> makes a lexical alias to a package (i.e. global)
variable of the same name in the current package for use within the
current lexical scope.

=end original

C<our> は単純名を、現在のレキシカルスコープ内で使うために、
現在のパッケージの同じ名前のパッケージ(つまりグローバルな)変数への
レキシカルな別名を作ります。

=begin original

C<our> has the same scoping rules as
L<C<my>|/my VARLIST> or L<C<state>|/state VARLIST>, meaning that it is
only valid within a lexical scope.  Unlike L<C<my>|/my VARLIST> and
L<C<state>|/state VARLIST>, which both declare new (lexical) variables,
C<our> only creates an alias to an existing variable: a
package variable of the same name.

=end original

C<our> は L<C<my>|/my VARLIST> や
L<C<state>|/state VARLIST> と同じスコープルールを持ちます; つまり
レキシカルスコープの中でだけ有効です。
新しい(レキシカル)変数を宣言する L<C<my>|/my VARLIST> や
L<C<state>|/state VARLIST> と異なり、C<our> は既に
存在する変数への別名を作るだけです: 同じ名前のパッケージ変数です。

=begin original

This means that when C<use strict 'vars'> is in effect, L<C<our>|/our
VARLIST> lets you use a package variable without qualifying it with the
package name, but only within the lexical scope of the
C<our> declaration.  This applies immediately--even
within the same statement.

=end original

つまり、C<use strict 'vars'> が有効の場合は、L<C<our>|/our VARLIST> を
使うことで、
パッケージ変数をパッケージ名で修飾することなく使うことができますが、
C<our> 宣言のレキシカルスコープ内だけということです。
これは(たとえ同じ文の中でも)直ちに適用されます。

    package Foo;
    use v5.36;  # which implies "use strict;"

    $Foo::foo = 23;

    {
        our $foo;   # alias to $Foo::foo
        print $foo; # prints 23
    }

    print $Foo::foo; # prints 23

    print $foo; # ERROR: requires explicit package name

=begin original

This works even if the package variable has not been used before, as
package variables spring into existence when first used.

=end original

これはパッケージ変数がまだ使われていなくても動作します; パッケージ変数は、
最初に使われた時にひょっこり現れるからです。

    package Foo;
    use v5.36;

    our $foo = 23;   # just like $Foo::foo = 23

    print $Foo::foo; # prints 23

=begin original

Because the variable becomes legal immediately under C<use strict 'vars'>, so
long as there is no variable with that name already in scope, you can then
reference the package variable again even within the same statement.

=end original

変数は C<use strict 'vars'> の基で直ちに正当になるので、
スコープ内に同じ名前の変数がない限り、
たとえ同じ文の中でもパッケージ変数を再び参照できます。

    package Foo;
    use v5.36;

    my  $foo = $foo; # error, undeclared $foo on right-hand side
    our $foo = $foo; # no errors

=begin original

If more than one variable is listed, the list must be placed
in parentheses.

=end original

複数の変数を指定する場合は、リストはかっこで囲まなければなりません。

    our($bar, $baz);

=begin original

Like L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>, and
L<C<local>|/local EXPR>, C<our> can operate on a variable
anywhere it appears in an expression (aside from interpolation in strings).
The declaration will not apply to additional uses of the same variable until
the next statement. This means additional uses of that variable within the
same statement will act as they would have before that declaration occurred,
with the exception that it will still satisfy strict 'vars' and interpret that
variable as the newly aliased package variable if it was not yet declared in
that scope.

=end original

L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>,
L<C<local>|/local EXPR> と同様に、C<our> は、
(文字列内の置換を除いて) 式内の任意の場所で変数を操作できます。
この宣言は、次の文まで、同じ変数の追加使用には適用されません。
つまり、同じ文内でその変数を追加使用すると、
その宣言が行われる前と同じように動作します。
ただし、そのスコープでまだ宣言されていない場合は、
strict 'vars' を満たし、その変数を新たにエイリアスされた
パッケージ変数として解釈します。

    package main;
    my $x = 2;
    foo($x, our $x = $x + 1, $x); # foo() receives (2, 3, 2)
    foo($x, our $z = 5, $z);      # foo() receives (3, 5, 5)

=begin original

An C<our> declaration declares an alias for a package
variable that will be visible
across its entire lexical scope, even across package boundaries.  The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.  This means the following
behavior holds:

=end original

C<our> 宣言はレキシカルスコープ全体に対して (たとえ
パッケージ境界を越えていても)見える、パッケージ変数への別名を宣言します。
この変数が入るパッケージは宣言した時点で定義され、
使用した時点ではありません。
これにより、以下のような振る舞いになります:

    package Foo;
    our $bar;      # declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    print $bar;    # prints 20, as it refers to $Foo::bar

=begin original

Multiple C<our> declarations with the same name in the
same lexical
scope are allowed if they are in different packages.  If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple L<C<my>|/my VARLIST> declarations.  Unlike
a second L<C<my>|/my VARLIST> declaration, which will bind the name to a
fresh variable, a second C<our> declaration in the same
package, in the same scope, is merely redundant.

=end original

同じレキシカルスコープでも、パッケージが異なっていれば、同じ名前で複数の
C<our> 宣言ができます。
同じパッケージになっていると、警告が出力されるようになっていれば
複数の L<C<my>|/my VARLIST> 宣言がある場合と同じように警告が出力されます。
新しい変数を名前に割り当てることになる 2 回目の L<C<my>|/my VARLIST> 宣言と
違って、同じパッケージの同じスコープで 2 回
C<our> 宣言するのは単に冗長です。

    use warnings;
    package Foo;
    our $bar;      # declares $Foo::bar for rest of lexical scope
    $bar = 20;

    package Bar;
    our $bar = 30; # declares $Bar::bar for rest of lexical scope
    print $bar;    # prints 30

    our $bar;      # emits warning but has no other effect
    print $bar;    # still prints 30

=begin original

An C<our> declaration may also have a list of attributes
associated with it.

=end original

C<our> 宣言には、それと結び付けられる属性のリストを
持つこともあります。

=begin original

The exact semantics and interface of TYPE and ATTRS are still
evolving.  TYPE is currently bound to the use of the L<fields> pragma,
and attributes are handled using the L<attributes> pragma, or, starting
from Perl 5.8.0, also via the L<Attribute::Handlers> module.  See
L<perlsub/"Private Variables via my()"> for details.

=end original

TYPE と ATTRS の正確な文法とインターフェースは今でも進化しています。
現在のところ、TYPE は L<fields> プラグマの使用と結び付けられていて、
属性は L<attributes> プラグマか、Perl 5.8.0 からは
L<Attribute::Handlers> モジュールと結び付けられています。
詳しくは L<perlsub/"Private Variables via my()"> を参照してください。

=begin original

Note that with a parenthesised list, L<C<undef>|/undef EXPR> can be used
as a dummy placeholder, for example to skip assignment of initial
values:

=end original

かっこで囲まれたリストでは、L<C<undef>|/undef EXPR> は、例えば初期値の代入を
飛ばすために、ダミーのプレースホルダとして使えることに注意してください:

    our ( undef, $min, $hour ) = localtime;

=begin original

C<our> creates a lexically scoped alias to the package
variable of the same name, and as such differs from L<C<use vars>|vars>,
which allows use of an unqualified name I<only> within the affected
package, without consideration for scopes.

=end original

C<our> は同じ名前のパッケージ変数への、レキシカルスコープの別名を作るので、
L<C<use vars>|vars> とは異なります; これはスコープを
考慮せずに、影響するパッケージの内側 I<のみ> で完全修飾されていない
名前を使えるようにします。

=item pack TEMPLATE,LIST
X<pack>

=for Pod::Functions convert a list into a binary representation

=begin original

Takes a LIST of values and converts it into a string using the rules
given by the TEMPLATE.  The resulting string is the concatenation of
the converted values.  Typically, each converted value looks
like its machine-level representation.  For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a string that's 4 characters long.

=end original

LIST の値を TEMPLATE で与えられたルールを用いて文字列に変換します。
結果の文字列は変換した値を連結したものです。
典型的には、それぞれの変換された値はマシンレベルの表現のように見えます。
例えば、32-bit マシンでは、整数は 4 バイトで表現されるので、
Perl では 4 文字の文字列で表現されます。

=begin original

See L<perlpacktut> for an introduction to this function.

=end original

この関数の説明については L<perlpacktut> を参照してください。

=begin original

The TEMPLATE is a sequence of characters that give the order and type
of values, as follows:

=end original

TEMPLATE は、以下のような値の型と順番を指定する文字を並べたものです:

=begin original

    a  A string with arbitrary binary data, will be null padded.
    A  A text (ASCII) string, will be space padded.
    Z  A null-terminated (ASCIZ) string, will be null padded.

=end original

    a  任意のバイナリデータを含む文字列、ヌル文字で埋める。
    A  テキスト (ASCII) 文字列、スペース文字で埋める。
    Z  ヌル文字終端 (ASCIZ) 文字列、ヌル文字で埋める。

=begin original

    b  A bit string (ascending bit order inside each byte,
       like vec()).
    B  A bit string (descending bit order inside each byte).
    h  A hex string (low nybble first).
    H  A hex string (high nybble first).

=end original

    b  ビット列 (バイトごとに昇ビット順、vec() と同じ)。
    B  ビット列 (バイトごとに降ビット順)。
    h  16 進数文字列 (低位ニブルが先)。
    H  16 進数文字列 (高位ニブルが先)。

=begin original

    c  A signed char (8-bit) value.
    C  An unsigned char (octet) value.
    W  An unsigned char value (can be greater than 255).

=end original

    c  signed char (8 ビット) 値。
    C  unsigned char (オクテット) 値。
    W  unsigned char 値 (255 より大きいかもしれません)。

=begin original

    s  A signed short (16-bit) value.
    S  An unsigned short value.

=end original

    s  signed short (16 ビット) 値。
    S  unsigned short 値。

=begin original

    l  A signed long (32-bit) value.
    L  An unsigned long value.

=end original

    l  signed long (32 ビット) 値。
    L  unsigned long 値。

=begin original

    q  A signed quad (64-bit) value.
    Q  An unsigned quad value.
         (Quads are available only if your system supports 64-bit
          integer values _and_ if Perl has been compiled to support
          those.  Raises an exception otherwise.)

=end original

    q  符号付き 64 ビット整数。
    Q  符号なし 64 ビット整数。
      (64 ビット整数は、システムが 64 ビット整数に対応していて、かつ Perl が
       64 ビット整数対応としてコンパイルされている場合にのみ使用可能です。
           それ以外の場合は例外が発生します。)

=begin original

    i  A signed integer value.
    I  An unsigned integer value.
         (This 'integer' is _at_least_ 32 bits wide.  Its exact
          size depends on what a local C compiler calls 'int'.)

=end original

    i  signed int 値。
    I  unsigned int 値。
       (ここでの 'integer' は 「最低」 32 ビット幅です。正確なサイズは
        ローカルの C コンパイラの 'int' のサイズに依存します。)

=begin original

    n  An unsigned short (16-bit) in "network" (big-endian) order.
    N  An unsigned long (32-bit) in "network" (big-endian) order.
    v  An unsigned short (16-bit) in "VAX" (little-endian) order.
    V  An unsigned long (32-bit) in "VAX" (little-endian) order.

=end original

    n  "network" 順序 (ビッグエンディアン) の unsigned short (16 ビット)。
    N  "network" 順序 (ビッグエンディアン) の unsigned long (32 ビット)。
    v  "VAX" 順序 (リトルエンディアン) の unsigned short (16 ビット)。
    V  "VAX" 順序 (リトルエンディアン) の unsigned long (32 ビット)。

=begin original

    j  A Perl internal signed integer value (IV).
    J  A Perl internal unsigned integer value (UV).

=end original

    j  Perl 内部符号付き整数 (IV)。
    J  Perl 内部符号なし整数 (UV)。

=begin original

    f  A single-precision float in native format.
    d  A double-precision float in native format.

=end original

    f  機種依存の単精度浮動小数点数。
    d  機種依存の倍精度浮動小数点数。

=begin original

    F  A Perl internal floating-point value (NV) in native format
    D  A float of long-double precision in native format.
         (Long doubles are available only if your system supports
          long double values. Raises an exception otherwise.
          Note that there are different long double formats.)

=end original

    F  ネイティブフォーマットの Perl 内部浮動小数点数 (NV)
    D  ネイティブフォーマットの長い倍精度浮動小数点数(long double)。
      (long double は、システムが long double に対応している場合にのみ
          使用可能です。それ以外の場合は例外が発生します。
          long double 型式の場合は異なることに注意してください。)

=begin original

    p  A pointer to a null-terminated string.
    P  A pointer to a structure (fixed-length string).

=end original

    p  ヌル文字で終端する文字列へのポインタ。
    P  構造体 (固定長文字列) へのポインタ。

=begin original

    u  A uuencoded string.
    U  A Unicode character number.  Encodes to a character in char-
       acter mode and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in
       byte mode.  Also on EBCDIC platforms, the character number will
       be the native EBCDIC value for character numbers below 256.
       This allows most programs using this feature to not have to
       care which type of platform they are running on.


=end original

    u  uuencode 文字列。
    U  Unicode 文字番号。文字モードでは文字に、バイトモードなら UTF-8 に
       (EBCDIC システムでは UTF-EBCDIC に)エンコードされます。
       また EBCDIC プラットフォームでは、文字番号が 256 より下の場合は
       EBCDIC にネイティブな値です。
       これにより、この機能を使うほとんどのプログラムで、どの種類の
       プラットフォームで実行されるかを気にする必要がなくなります。

=begin original

    w  A BER compressed integer (not an ASN.1 BER, see perlpacktut
       for details).  Its bytes represent an unsigned integer in
       base 128, most significant digit first, with as few digits
       as possible.  Bit eight (the high bit) is set on each byte
       except the last.

=end original

    w  A BER 圧縮変数(ASN.1 BER ではありません; 詳細については perlpacktut を
       参照してください)。このバイト列はできるだけ少ない桁数で表現された
       128 を基とした符号なし整数で、最上位ビットから順に並びます。
       最後のバイト以外の各バイトのビット 8 (上位ビット) がセットされます。

=begin original

    x  A null byte (a.k.a. ASCII NUL, "\000", chr(0))
    X  Back up a byte.
    @  Null-fill or truncate to absolute position, counted from the
       start of the innermost ()-group.
    .  Null-fill or truncate to absolute position specified by
       the value.
    (  Start of a ()-group.

=end original

    x  ヌル文字 (つまり ASCII NUL, "\000", chr(0))
    X  1 文字後退。
    @  一番内側の () の組の開始位置から数えて、絶対位置までヌル文字で
       埋めるか切り詰める。
    .  値で指定した絶対位置までヌル文字で埋めるか切り詰める。
    (  () の組の開始。

=begin original

One or more modifiers below may optionally follow certain letters in the
TEMPLATE (the second column lists letters for which the modifier is valid):

=end original

以下に示す一つまたは複数の修飾子を、TEMPLATE の文字のいくつかにオプションで
付けることができます(表の 2 列目は、その修飾子が有効な文字です):

=begin original

    !   sSlLiI     Forces native (short, long, int) sizes instead
                   of fixed (16-/32-bit) sizes.

=end original

    !   sSlLiI     固定の(16/32 ビット)サイズではなく、ネイティブな
                   (short, long, int)サイズを強制する。

=begin original

    !   xX         Make x and X act as alignment commands.

=end original

    !   xX         x と X をアライメントコマンドとして振舞わせる。

=begin original

    !   nNvV       Treat integers as signed instead of unsigned.

=end original

    !   nNvV       整数を符号なしではなく符号付きとして扱わせる。

=begin original

    !   @.         Specify position as byte offset in the internal
                   representation of the packed string.  Efficient
                   but dangerous.

=end original

    !   @.         pack された内部表現のバイトオフセットとして位置を指定する。
                   効率的ですが危険です。

=begin original

    >   sSiIlLqQ   Force big-endian byte-order on the type.
        jJfFdDpP   (The "big end" touches the construct.)

=end original

    >   sSiIlLqQ   これらの型のバイト順をビッグエンディアンに強制します。
        jJfFdDpP   (「大きい端」が構造に触れています。)

=begin original

    <   sSiIlLqQ   Force little-endian byte-order on the type.
        jJfFdDpP   (The "little end" touches the construct.)

=end original

    <   sSiIlLqQ   これらの型のバイト順をリトルエンディアンに強制します。
        jJfFdDpP   (「小さい端」が構造に触れています。)

=begin original

The C<< > >> and C<< < >> modifiers can also be used on C<()> groups
to force a particular byte-order on all components in that group,
including all its subgroups.

=end original

C<< > >> と C<< < >> の修飾子は C<()>-グループでも使えます;
この場合はそのグループと全ての副グループ内の全ての要素を特定のバイト順に
強制します。

=begin comment

Larry recalls that the hex and bit string formats (H, h, B, b) were added to
pack for processing data from NASA's Magellan probe.  Magellan was in an
elliptical orbit, using the antenna for the radar mapping when close to
Venus and for communicating data back to Earth for the rest of the orbit.
There were two transmission units, but one of these failed, and then the
other developed a fault whereby it would randomly flip the sense of all the
bits. It was easy to automatically detect complete records with the correct
sense, and complete records with all the bits flipped. However, this didn't
recover the records where the sense flipped midway. A colleague of Larry's
was able to pretty much eyeball where the records flipped, so they wrote an
editor named kybble (a pun on the dog food Kibbles 'n Bits) to enable him to
manually correct the records and recover the data. For this purpose pack
gained the hex and bit string format specifiers.

git shows that they were added to perl 3.0 in patch #44 (Jan 1991, commit
27e2fb84680b9cc1), but the patch description makes no mention of their
addition, let alone the story behind them.

=end comment

=begin original

The following rules apply:

=end original

以下の条件が適用されます:

=over

=item *

=begin original

Each letter may optionally be followed by a number indicating the repeat
count.  A numeric repeat count may optionally be enclosed in brackets, as
in C<pack("C[80]", @arr)>.  The repeat count gobbles that many values from
the LIST when used with all format types other than C<a>, C<A>, C<Z>, C<b>,
C<B>, C<h>, C<H>, C<@>, C<.>, C<x>, C<X>, and C<P>, where it means
something else, described below.  Supplying a C<*> for the repeat count
instead of a number means to use however many items are left, except for:

=end original

これらの文字の後には、繰り返し数を示す数字を付けることができます。
数値の繰り返し数は C<pack "C[80]", @arr> のように大かっこで
囲むこともできます。
C<a>, C<A>, C<Z>, C<b>, C<B>, C<h>, C<H>, C<@>, C<.>, C<x>, C<X>, C<P>
以外の全ての型では、LIST から繰り返し数の値を取り出して使います。
繰り返し数に C<*> を指定すると、以下の例外を除いて、
その時点で残っているすべての要素を意味します。

=over

=item *

=begin original

C<@>, C<x>, and C<X>, where it is equivalent to C<0>.

=end original

C<@>, C<x>, C<X> では C<0> と等価です。

=item *

=begin original

<.>, where it means relative to the start of the string.

=end original

<.> では文字列の先頭からの相対位置を意味します。

=item *

=begin original

C<u>, where it is equivalent to 1 (or 45, which here is equivalent).

=end original

C<u> では 1 (あるいはここでは 45 でも等価です) と等価です。

=back

=begin original

One can replace a numeric repeat count with a template letter enclosed in
brackets to use the packed byte length of the bracketed template for the
repeat count.

=end original

このテンプレートでパックされたバイト長を繰り返し数として使うために、
大かっこで囲まれたテンプレートで数値の繰り返し数を置き換えることが
できます。

=begin original

For example, the template C<x[L]> skips as many bytes as in a packed long,
and the template C<"$t X[$t] $t"> unpacks twice whatever $t (when
variable-expanded) unpacks.  If the template in brackets contains alignment
commands (such as C<x![d]>), its packed length is calculated as if the
start of the template had the maximal possible alignment.

=end original

例えば、テンプレート C<x[L]> は long でパックされたバイト数分だけスキップし、
テンプレート C<"$t X[$t] $t"> は $t (変数展開された場合)を
unpack したものの 2 倍を unpack します。
(C<x![d]> のように) 大かっこにアライメントコマンドが含まれている場合、
パックされた長さは、テンプレートの先頭で最大限可能なアライメントを
持っているものとして計算されます。

=begin original

When used with C<Z>, a C<*> as the repeat count is guaranteed to add a
trailing null byte, so the resulting string is always one byte longer than
the byte length of the item itself.

=end original

C<Z> で、繰り返し数として C<*> が使われた場合、末尾にヌルバイトが
保証されるので、結果の文字列は常にアイテム自身のバイト長よりも 1 バイト
長くなります。

=begin original

When used with C<@>, the repeat count represents an offset from the start
of the innermost C<()> group.

=end original

C<@> で使うと、繰り返し数は一番内側の C<()> グループの先頭からのオフセットを
表現します。

=begin original

When used with C<.>, the repeat count determines the starting position to
calculate the value offset as follows:

=end original

C<.> で使われると、繰り返し数は以下のようにして、
値のオフセットを計算するための開始位置を決定するために使われます。

=over

=item *

=begin original

If the repeat count is C<0>, it's relative to the current position.

=end original

繰り返し数が C<0> なら、現在位置からの相対位置となります。

=item *

=begin original

If the repeat count is C<*>, the offset is relative to the start of the
packed string.

=end original

繰り返し数が C<*> なら、オフセットは pack された文字列の先頭からの
相対位置です。

=item *

=begin original

And if it's an integer I<n>, the offset is relative to the start of the
I<n>th innermost C<( )> group, or to the start of the string if I<n> is
bigger then the group level.

=end original

そして整数 I<n> なら、オフセットは一番内側から I<n> 番目の C<( )> グループの
先頭、あるいは I<n> がグループレベルより大きい場合は文字列の先頭からの
相対位置です。

=back

=begin original

The repeat count for C<u> is interpreted as the maximal number of bytes
to encode per line of output, with 0, 1 and 2 replaced by 45.  The repeat
count should not be more than 65.

=end original

C<u> での繰り返し回数は、出力行毎に最大何バイトまでをエンコードするかを
示します; 0, 1, 2 は 45 として扱われます。
繰り返し数は 65 を超えてはなりません。

=item *

=begin original

The C<a>, C<A>, and C<Z> types gobble just one value, but pack it as a
string of length count, padding with nulls or spaces as needed.  When
unpacking, C<A> strips trailing whitespace and nulls, C<Z> strips everything
after the first null, and C<a> returns data with no stripping at all.

=end original

C<a>, C<A>, C<Z> という型を使うと、値を一つだけ取り出して使いますが、
繰り返し数で示す長さの文字列となるように、必要に応じてヌル文字か
スペース文字を付け足します。
unpack するとき、C<A> は後続の空白やヌル文字を取り除きます; C<Z> は最初の
ヌル文字以降の全てを取り除きます; C<a> はデータを取り除くことなく
そのまま返します。

=begin original

If the value to pack is too long, the result is truncated.  If it's too
long and an explicit count is provided, C<Z> packs only C<$count-1> bytes,
followed by a null byte.  Thus C<Z> always packs a trailing null, except
when the count is 0.

=end original

pack する値が長すぎる場合、結果は切り詰められます。
長すぎてかつ明示的に個数が指定されている場合、
C<Z> は C<$count-1> バイトまで pack し、その後にヌルバイトがつきます。
従って、C<Z> は、繰り返し数が 0 の場合を除いて、常に末尾にヌルバイトが
つきます。

=item *

=begin original

Likewise, the C<b> and C<B> formats pack a string that's that many bits long.
Each such format generates 1 bit of the result.  These are typically followed
by a repeat count like C<B8> or C<B64>.

=end original

同様に、C<b> や C<B> は、繰り返し数で示すビット長のビット列に pack します。
これらの各文字は結果の 1 ビットを生成します。
これらは典型的には C<B8> や C<B64> のような繰り返しカウントが引き続きます。

=begin original

Each result bit is based on the least-significant bit of the corresponding
input character, i.e., on C<ord($char)%2>.  In particular, characters C<"0">
and C<"1"> generate bits 0 and 1, as do characters C<"\000"> and C<"\001">.

=end original

結果ビットのそれぞれは対応する入力文字の最下位ビットを基にします
(つまり C<ord($char)%2>)。
特に、文字 C<"0"> と C<"1"> は文字 C<"\000"> と C<"\001"> と同様に、
ビット 0 と 1 を生成します。

=begin original

Starting from the beginning of the input string, each 8-tuple
of characters is converted to 1 character of output.  With format C<b>,
the first character of the 8-tuple determines the least-significant bit of a
character; with format C<B>, it determines the most-significant bit of
a character.

=end original

pack() の入力文字列の先頭から始めて、8 タプル毎に 1 文字の出力に変換されます。
C<b> フォーマットでは 8 タプルの最初の文字が出力の最下位ビットとなります;
C<B> フォーマットでは出力の最上位ビットとなります。

=begin original

If the length of the input string is not evenly divisible by 8, the
remainder is packed as if the input string were padded by null characters
at the end.  Similarly during unpacking, "extra" bits are ignored.

=end original

もし入力文字列の長さが 8 で割り切れない場合、余りの部分は入力文字列の
最後にヌル文字がパッディングされているものとしてパックされます。
同様に、unpack 中は「余分な」ビットは無視されます。

=begin original

If the input string is longer than needed, remaining characters are ignored.

=end original

入力文字列が必要な分よりも長い場合、余分な文字は無視されます。

=begin original

A C<*> for the repeat count uses all characters of the input field.
On unpacking, bits are converted to a string of C<0>s and C<1>s.

=end original

繰り返し数として C<*> が指定されると、入力フィールドの全ての文字が使われます。
unpack 時にはビット列は C<0> と C<1> の文字列に変換されます。

=item *

=begin original

The C<h> and C<H> formats pack a string that many nybbles (4-bit groups,
representable as hexadecimal digits, C<"0".."9"> C<"a".."f">) long.

=end original

C<h> や C<H> は、多ニブル長(16 進文字である C<"0".."9"> C<"a".."f"> で
表現可能な 4 ビットグループ)のニブル列に pack します。

=begin original

For each such format, C<pack> generates 4 bits of result.
With non-alphabetical characters, the result is based on the 4 least-significant
bits of the input character, i.e., on C<ord($char)%16>.  In particular,
characters C<"0"> and C<"1"> generate nybbles 0 and 1, as do bytes
C<"\000"> and C<"\001">.  For characters C<"a".."f"> and C<"A".."F">, the result
is compatible with the usual hexadecimal digits, so that C<"a"> and
C<"A"> both generate the nybble C<0xA==10>.  Use only these specific hex
characters with this format.

=end original

このようなフォーマット文字のそれぞれについて、C<pack> は
結果の 4 ビットを生成します。
英字でない文字の場合、結果は入力文字の下位 4 ビットを
基にします(つまり  C<ord($char)%16>)。
特に、文字 C<"0"> と C<"1"> はバイト C<"\000"> と C<"\001"> と同様に
ニブル 0 と 1 を生成します。
文字 C<"a".."f"> と C<"A".."F"> の場合は結果は通常の 16 進数と同じ結果に
なるので、C<"a"> と C<"A"> はどちらも ニブル C<0xa==10> を生成します。
これらの 16 進文字はこの特定のフォーマットでだけ使ってください。

=begin original

Starting from the beginning of the template to
C<pack>, each pair
of characters is converted to 1 character of output.  With format C<h>, the
first character of the pair determines the least-significant nybble of the
output character; with format C<H>, it determines the most-significant
nybble.

=end original

L<C<pack>|/pack TEMPLATE,LIST> のテンプレートの先頭から始めて、2 文字毎に
1 文字の出力に変換されます。
C<h> フォーマットでは 1 文字目が出力の最下位ニブルとなり、
C<H> フォーマットでは出力の最上位ニブルとなります。

=begin original

If the length of the input string is not even, it behaves as if padded by
a null character at the end.  Similarly, "extra" nybbles are ignored during
unpacking.

=end original

入力文字列の長さが偶数でない場合、最後にヌル文字でパッディングされて
いるかのように振る舞います。
同様に、unpack 中は「余分な」ニブルは無視されます。

=begin original

If the input string is longer than needed, extra characters are ignored.

=end original

入力文字列が必要な分より長い場合、余分な部分は無視されます。

=begin original

A C<*> for the repeat count uses all characters of the input field.  For
L<C<unpack>|/unpack TEMPLATE,EXPR>, nybbles are converted to a string of
hexadecimal digits.

=end original

繰り返し数として C<*> が指定されると、入力フィールドの全ての文字が使われます。
L<C<unpack>|/unpack TEMPLATE,EXPR> 時にはニブルは 16 進数の文字列に
変換されます。

=item *

=begin original

The C<p> format packs a pointer to a null-terminated string.  You are
responsible for ensuring that the string is not a temporary value, as that
could potentially get deallocated before you got around to using the packed
result.  The C<P> format packs a pointer to a structure of the size indicated
by the length.  A null pointer is created if the corresponding value for
C<p> or C<P> is L<C<undef>|/undef EXPR>; similarly with
L<C<unpack>|/unpack TEMPLATE,EXPR>, where a null pointer unpacks into
L<C<undef>|/undef EXPR>.

=end original

C<p> は、ヌル文字終端文字列へのポインタを pack します。
文字列が一時的な値でない(つまり pack された結果を使う前に文字列が
解放されない) ことに責任を持つ必要があります。
C<P> は、指定した長さの構造体へのポインタを pack します。
C<p> または C<P> に対応する値が L<C<undef>|/undef EXPR> だった場合、
ヌルポインタが作成されます; ヌルポインタが L<C<undef>|/undef EXPR> に
unpack される L<C<unpack>|/unpack TEMPLATE,EXPR> と同様です。

=begin original

If your system has a strange pointer size--meaning a pointer is neither as
big as an int nor as big as a long--it may not be possible to pack or
unpack pointers in big- or little-endian byte order.  Attempting to do
so raises an exception.

=end original

システムのポインタが変わったサイズの場合--つまり、int の大きさでも
long の大きさでもない場合--ポインタをビッグエンディアンやリトルエンディアンの
バイト順で pack や unpack することはできません。
そうしようとすると例外が発生します。

=item *

=begin original

The C</> template character allows packing and unpacking of a sequence of
items where the packed structure contains a packed item count followed by
the packed items themselves.  This is useful when the structure you're
unpacking has encoded the sizes or repeat counts for some of its fields
within the structure itself as separate fields.

=end original

C</> テンプレート文字は、アイテムの数の後にアイテムそのものが入っている形の
アイテム列を pack 及び unpack します。
これは、unpack したい構造体が、サイズや繰り返し数が構造体自身の中に
独立したフィールドとしてエンコードされている場合に有効です。

=begin original

For C<pack>, you write
I<length-item>C</>I<sequence-item>, and the
I<length-item> describes how the length value is packed.  Formats likely
to be of most use are integer-packing ones like C<n> for Java strings,
C<w> for ASN.1 or SNMP, and C<N> for Sun XDR.

=end original

C<pack> では I<length-item>C</>I<string-item> の
形になり、
I<length-item> は長さの値がどのように pack されているかを指定します。
もっともよく使われるのは Java 文字列 のための C<n>、ASN.1 や SNMP のための
C<w>、Sun XDR のための C<N> といった整数型です。

=begin original

For C<pack>, I<sequence-item> may have a repeat
count, in which case
the minimum of that and the number of available items is used as the argument
for I<length-item>.  If it has no repeat count or uses a '*', the number
of available items is used.

=end original

C<pack> では、I<sequence-item> は繰り返し数を
持つことがあり、その場合はその最小値と利用可能なアイテムの数は
I<length-item> のための引数として使われます。
繰り返し数がなかったり、'*' を使うと、利用可能なアイテムの数が使われます。

=begin original

For L<C<unpack>|/unpack TEMPLATE,EXPR>, an internal stack of integer
arguments unpacked so far is
used.  You write C</>I<sequence-item> and the repeat count is obtained by
popping off the last element from the stack.  The I<sequence-item> must not
have a repeat count.

=end original

L<C<unpack>|/unpack TEMPLATE,EXPR> では、今まで unpack した数値引数の
内部スタックが使われます。
C</>I<sequence-item> と書いて、繰り返し数はスタックから最後の要素を
取り出すことで得ます。
I<sequence-item> は繰り返し数を持っていてはいけません。

=begin original

If I<sequence-item> refers to a string type (C<"A">, C<"a">, or C<"Z">),
the I<length-item> is the string length, not the number of strings.  With
an explicit repeat count for pack, the packed string is adjusted to that
length.  For example:

=end original

I<sequence-item> が文字列型 (C<"A">, C<"a">, C<"Z">) を参照している場合、
I<length-item> は文字列の数ではなく、文字列の長さです。
pack で明示的な繰り返し数があると、pack された文字列は与えられた
長さに調整されます。
例えば:

    This code:                              gives this result:

    unpack("W/a", "\004Gurusamy")           ("Guru")
    unpack("a3/A A*", "007 Bond  J ")       (" Bond", "J")
    unpack("a3 x2 /A A*", "007: Bond, J.")  ("Bond, J", ".")

    pack("n/a* w/a", "hi,", "world")        "\000\003hi,\005world"
    pack("a/W2", ord("a") .. ord("z"))      "2ab"

=begin original

The I<length-item> is not returned explicitly from
L<C<unpack>|/unpack TEMPLATE,EXPR>.

=end original

I<length-item> は L<C<unpack>|/unpack TEMPLATE,EXPR> から明示的には
返されません。

=begin original

Supplying a count to the I<length-item> format letter is only useful with
C<A>, C<a>, or C<Z>.  Packing with a I<length-item> of C<a> or C<Z> may
introduce C<"\000"> characters, which Perl does not regard as legal in
numeric strings.

=end original

I<length-item> 文字に繰り返し数をつけるのは、
文字が C<A>, C<a>, C<Z> でない限りは有用ではありません。
C<a> や C<Z> を I<length-item> として pack すると C<"\000"> 文字が
出力されることがあり、Perl はこれを有効な数値文字列として認識しません。

=item *

=begin original

The integer types C<s>, C<S>, C<l>, and C<L> may be
followed by a C<!> modifier to specify native shorts or
longs.  As shown in the example above, a bare C<l> means
exactly 32 bits, although the native C<long> as seen by the local C compiler
may be larger.  This is mainly an issue on 64-bit platforms.  You can
see whether using C<!> makes any difference this way:

=end original

C<s>, C<S>, C<l>, C<L> の整数タイプに引き続いて C<!> 修飾子を
つけることで、ネイティブの short や long を指定できます。
上述のように、C<l> は正確に 32 ビットですが、ネイティブな
(ローカルな C コンパイラによる)C<long> はもっと大きいかもしれません。
これは主に 64 ビットプラットフォームで意味があります。
C<!> を使うことによって違いがあるかどうかは以下のようにして調べられます:

    printf "format s is %d, s! is %d\n",
        length pack("s"), length pack("s!");

    printf "format l is %d, l! is %d\n",
        length pack("l"), length pack("l!");

=begin original

C<i!> and C<I!> are also allowed, but only for completeness' sake:
they are identical to C<i> and C<I>.

=end original

C<i!> と C<I!> も動作しますが、単に完全性のためだけです;
これは C<i> 及び C<I> と同じです。

=begin original

The actual sizes (in bytes) of native shorts, ints, longs, and long
longs on the platform where Perl was built are also available from
the command line:

=end original

Perl がビルドされたプラットフォームでの short, int, long, long long の
実際の(バイト数での)サイズはコマンドラインから:

    $ perl -V:{short,int,long{,long}}size
    shortsize='2';
    intsize='4';
    longsize='4';
    longlongsize='8';

=begin original

or programmatically via the L<C<Config>|Config> module:

=end original

あるいは L<C<Config>|Config> モジュールからプログラムで:

    use Config;
    print $Config{shortsize},    "\n";
    print $Config{intsize},      "\n";
    print $Config{longsize},     "\n";
    print $Config{longlongsize}, "\n";

=begin original

C<$Config{longlongsize}> is undefined on systems without
long long support.

=end original

システムが long long に対応していない場合は C<$Config{longlongsize}> は
未定義値になります。

=item *

=begin original

The integer formats C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, and C<J> are
inherently non-portable between processors and operating systems because
they obey native byteorder and endianness.  For example, a 4-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged in and
handled by the CPU registers) into bytes as

=end original

整数フォーマット C<s>, C<S>, C<i>, C<I>, C<l>, C<L>, C<j>, C<J> は
ネイティブなバイト順序とエンディアンに従っているため、
本質的にプロセッサ間や OS 間で移植性がありません。
例えば 4 バイトの整数 0x12345678 (10 進数では 305419896) は
内部では(CPU レジスタによって変換され扱われる形では)
以下のようなバイト列に並べられます:

    0x12 0x34 0x56 0x78  # big-endian
    0x78 0x56 0x34 0x12  # little-endian

=begin original

Basically, Intel and VAX CPUs are little-endian, while everybody else,
including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are
big-endian.  Alpha and MIPS can be either: Digital/Compaq uses (well, used)
them in little-endian mode, but SGI/Cray uses them in big-endian mode.

=end original

基本的に、Intel と VAX の CPU はリトルエンディアンです; 一方、
Motorola m68k/88k, PPC, Sparc, HP PA, Power, Cray などを含むその他の全ては
ビッグエンディアンです。
Alpha と MIPS は両方ともあります: Digital/Compaq はリトルエンディアンモードで
使っています (えーと、いました) が、SGI/Cray はビッグエンディアンモードで
使っています。

=begin original

The names I<big-endian> and I<little-endian> are comic references to the
egg-eating habits of the little-endian Lilliputians and the big-endian
Blefuscudians from the classic Jonathan Swift satire, I<Gulliver's Travels>.
This entered computer lingo via the paper "On Holy Wars and a Plea for
Peace" by Danny Cohen, USC/ISI IEN 137, April 1, 1980.

=end original

I<ビッグエンディアン> と I<リトルエンディアン> の名前は、
ジョナサン=スウィフトによる風刺小説の古典 I<ガリバー旅行記> での、卵を
小さい方からむくリリパット国と大きい方からむくブレフスキュ国から
取られています。
"On Holy Wars and a Plea for Peace" by Danny Cohen, USC/ISI IEN 137,
April 1, 1980 の文書からコンピュータ用語として取り入れられました。

=begin original

Some systems may have even weirder byte orders such as

=end original

以下のような、さらに変わったバイト順序を持つシステムもあるかもしれません:

    0x56 0x78 0x12 0x34
    0x34 0x12 0x78 0x56

=begin original

These are called mid-endian, middle-endian, mixed-endian, or just weird.

=end original

これらは mid-endian, middle-endian, mixed-endian あるいは単におかしなものと
呼ばれます。

=begin original

You can determine your system endianness with this incantation:

=end original

システムの設定は以下のようにして調べられます:

    printf("%#02x ", $_) for unpack("W*", pack("L", 0x12345678));

=begin original

The byteorder on the platform where Perl was built is also available
via L<Config>:

=end original

Perl がビルドされたプラットフォームでのバイト順序は
L<Config> 経由か:

    use Config;
    print "$Config{byteorder}\n";

=begin original

or from the command line:

=end original

あるいはコマンドラインで:

    $ perl -V:byteorder

=begin original

Byteorders C<"1234"> and C<"12345678"> are little-endian; C<"4321">
and C<"87654321"> are big-endian.  Systems with multiarchitecture binaries
will have C<"ffff">, signifying that static information doesn't work,
one must use runtime probing.

=end original

C<"1234"> と C<"12345678"> はリトルエンディアンです;
C<"4321"> と C<"87654321"> はビッグエンディアンです。
マルチアーキテクチャバイナリを持つシステムは
C<"ffff"> となります; これは静的な情報は動作せず、実行時調査を使う必要が
あることを示します。

=begin original

For portably packed integers, either use the formats C<n>, C<N>, C<v>,
and C<V> or else use the C<< > >> and C<< < >> modifiers described
immediately below.  See also L<perlport>.

=end original

移植性のあるパック化された整数がほしい場合は、
C<n>, C<N>, C<v>, C<V> フォーマットを使うか、
直後で説明する C<< > >> と C<< < >> の修飾子が使えます。
L<perlport> も参照してください。

=item *

=begin original

Also floating point numbers have endianness.  Usually (but not always)
this agrees with the integer endianness.  Even though most platforms
these days use the IEEE 754 binary format, there are differences,
especially if the long doubles are involved.  You can see the
C<Config> variables C<doublekind> and C<longdblkind> (also C<doublesize>,
C<longdblsize>): the "kind" values are enums, unlike C<byteorder>.

=end original

また、浮動小数点数にもエンディアンがあります。
通常は(但し常にではありません)これは整数のエンディアンと同じです。
最近のほとんどのプラットフォームが IEEE 754 バイナリ形式を使っているにも
関わらず、(特に long double 関連で) 相違点があります。
C<Config> 変数 C<doublekind> と C<longdblkind> (および C<doublesize>,
C<longdblsize>) を参照できます: "kind" 値は C<byteorder> と異なり、
順序値です。

=begin original

Portability-wise the best option is probably to keep to the IEEE 754
64-bit doubles, and of agreed-upon endianness.  Another possibility
is the C<"%a">) format of L<C<printf>|/printf FILEHANDLE FORMAT, LIST>.

=end original

移植性を考慮した最良の選択肢はおそらく、IEEE 754 64-bit double と同意した
エンディアンを維持することです。
もう一つの可能性は L<C<printf>|/printf FILEHANDLE FORMAT, LIST> の
C<"%a"> 型式です。

=item *

=begin original

Starting with Perl 5.10.0, integer and floating-point formats, along with
the C<p> and C<P> formats and C<()> groups, may all be followed by the
C<< > >> or C<< < >> endianness modifiers to respectively enforce big-
or little-endian byte-order.  These modifiers are especially useful
given how C<n>, C<N>, C<v>, and C<V> don't cover signed integers,
64-bit integers, or floating-point values.

=end original

Perl 5.10.0 から、C<p> と C<P> フォーマットや C<()> グループと同様、
全ての整数と浮動小数点数のフォーマットは、C<< > >> や C<< < >> の
エンディアン修飾子をつけることで、それぞれ
ビッグエンディアンとリトルエンディアンに強制させることができます。
C<n>, C<N>, C<v>, C<V> は符号付き整数、64 ビット整数、浮動小数点数に
対応していないので、これは特に有用です。

=begin original

Here are some concerns to keep in mind when using an endianness modifier:

=end original

エンディアン修飾子を使うときに心に留めておくべきことを記します:

=over

=item *

=begin original

Exchanging signed integers between different platforms works only
when all platforms store them in the same format.  Most platforms store
signed integers in two's-complement notation, so usually this is not an issue.

=end original

異なったプラットフォームで符号付き整数を交換することは、全ての
プラットフォームで同じフォーマットで保存されている場合にのみうまくいきます。
ほとんどのプラットフォームでは符号付き整数は 2 の補数記法で保存するので、
普通はこれは問題になりません。

=item *

=begin original

The C<< > >> or C<< < >> modifiers can only be used on floating-point
formats on big- or little-endian machines.  Otherwise, attempting to
use them raises an exception.

=end original

C<< > >> や C<< < >> の修飾子はビッグエンディアンやリトルエンディアンの
マシンでの浮動小数点フォーマットでのみ使えます。
それ以外では、そのようなことをすると例外が発生します。

=item *

=begin original

Forcing big- or little-endian byte-order on floating-point values for
data exchange can work only if all platforms use the same
binary representation such as IEEE floating-point.  Even if all
platforms are using IEEE, there may still be subtle differences.  Being able
to use C<< > >> or C<< < >> on floating-point values can be useful,
but also dangerous if you don't know exactly what you're doing.
It is not a general way to portably store floating-point values.

=end original

データ交換のために浮動小数点数のバイト順をビッグエンディアンかリトル
エンディアンに強制することは、全てのプラットフォームが
IEEE 浮動小数点フォーマットのような同じバイナリ表現の場合にのみ
うまくいきます。
たとえ全てのプラットフォームが IEEE を使っていても、そこには微妙な違いが
あるかもしれません。
浮動小数点数に C<< > >> や C<< < >> が使えることは便利な場合がありますが、
もし自分が何をしているかを正確に理解していなければ、危険です。
移植性のある浮動小数点数の保存のための一般的な方法はありません。

=item *

=begin original

When using C<< > >> or C<< < >> on a C<()> group, this affects
all types inside the group that accept byte-order modifiers,
including all subgroups.  It is silently ignored for all other
types.  You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.

=end original

C<()> グループで C<< > >> や C<< < >> を使うと、これは、副グループを
含む全ての型のうち、バイト順修飾子を受け入れる全てのものに影響与えます。
その他の型については沈黙のうちに無視されます。
既にバイト順接尾辞を持っているグループ内のバイト順を上書きすることは
できません。

=back

=item *

=begin original

Real numbers (floats and doubles) are in native machine format only.
Due to the multiplicity of floating-point formats and the lack of a
standard "network" representation for them, no facility for interchange has been
made.  This means that packed floating-point data written on one machine
may not be readable on another, even if both use IEEE floating-point
arithmetic (because the endianness of the memory representation is not part
of the IEEE spec).  See also L<perlport>.

=end original

実数 (float と double) は、機種依存のフォーマットしかありません。
いろんな浮動小数点数のフォーマットが在り、標準的な "network" 表現といったものが
ないため、データ交換のための機能は用意してありません。
つまり、あるマシンで pack した浮動小数点数は、別のマシンでは
読めないかもしれないということです; たとえ双方で IEEE フォーマットの
浮動小数点数演算を行なっていてもです (IEEE の仕様では、メモリ表現上の
バイト順序までは、規定されていないからです)。
L<perlport> も参照してください。

=begin original

If you know I<exactly> what you're doing, you can use the C<< > >> or C<< < >>
modifiers to force big- or little-endian byte-order on floating-point values.

=end original

もし何をしようとしているのかを I<正確に> 理解しているなら、浮動小数点数の
バイト順をビッグエンディアンやリトルエンディアンに強制するために、
C<< > >> と C<< < >> の修飾子が使えます。

=begin original

Because Perl uses doubles (or long doubles, if configured) internally for
all numeric calculation, converting from double into float and thence
to double again loses precision, so C<unpack("f", pack("f", $foo)>)
will not in general equal $foo.

=end original

Perl では、すべての数値演算のために、内部的に double (または設定によっては
long double) を使用しているので、double から float へ変換し、それから再び
double に戻すと精度が落ちることになり、C<unpack("f", pack("f", $foo)>) は、
一般には $foo と同じではありません。

=item *

=begin original

Pack and unpack can operate in two modes: character mode (C<C0> mode) where
the packed string is processed per character, and UTF-8 byte mode (C<U0> mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte-by-byte basis.  Character mode is the default
unless the format string starts with C<U>.  You
can always switch mode mid-format with an explicit
C<C0> or C<U0> in the format.  This mode remains in effect until the next
mode change, or until the end of the C<()> group it (directly) applies to.

=end original

pack と unpack は二つのモードで操作します: pack された文字列を文字単位で
処理する文字モード (C<C0> モード) と、pack された文字列を、バイト毎に、
その UTF-8 エンコードされた形式で処理するUTF-8 モード (C<U0> モード) です。
文字モードはフォーマット文字列が C<U> で始まっていない限りはデフォルトです。
モードはフォーマット中に明示的に C<C0> または C<U0> と書くことでいつでも
切り替えられます。
モードは次のモードに切り替えられるか、(直接)適用された C<()> グループが
終了するまで有効です。

=begin original

Using C<C0> to get Unicode characters while using C<U0> to get I<non>-Unicode
bytes is not necessarily obvious.   Probably only the first of these
is what you want:

=end original

Unicode 文字を取得するのに C<C0> を使い、I<非> Unicode バイトを取得するのに
C<U0> を使うというのは必ずしも明白ではありません。
おそらく、これらのうち最初のものだけが望みのものでしょう:

    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' |
      perl -CS -ne 'printf "%v04X\n", $_ for unpack("C0A*", $_)'
    03B1.03C9
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' |
      perl -CS -ne 'printf "%v02X\n", $_ for unpack("U0A*", $_)'
    CE.B1.CF.89
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' |
      perl -C0 -ne 'printf "%v02X\n", $_ for unpack("C0A*", $_)'
    CE.B1.CF.89
    $ perl -CS -E 'say "\x{3B1}\x{3C9}"' |
      perl -C0 -ne 'printf "%v02X\n", $_ for unpack("U0A*", $_)'
    C3.8E.C2.B1.C3.8F.C2.89

=begin original

Those examples also illustrate that you should not try to use
C<pack>/L<C<unpack>|/unpack TEMPLATE,EXPR> as a
substitute for the L<Encode> module.

=end original

これらの例は、C<pack>/L<C<unpack>|/unpack TEMPLATE,EXPR> を
L<Encode> モジュールの代わりとして
使おうとするべきではないということも示しています。

=item *

=begin original

You must yourself do any alignment or padding by inserting, for example,
enough C<"x">es while packing.  There is no way for
C<pack> and L<C<unpack>|/unpack TEMPLATE,EXPR>
to know where characters are going to or coming from, so they
handle their output and input as flat sequences of characters.

=end original

pack するときに、例えば十分な数の C<"x"> を挿入することによって
アライメントやパッディングを行うのは全て自分でしなければなりません。
C<pack> や L<C<unpack>|/unpack TEMPLATE,EXPR> は、
文字列がどこへ行くかやどこから来たかを 
知る方法はないので、出力と入力をフラットな文字列として扱います。

=item *

=begin original

A C<()> group is a sub-TEMPLATE enclosed in parentheses.  A group may
take a repeat count either as postfix, or for
L<C<unpack>|/unpack TEMPLATE,EXPR>, also via the C</>
template character.  Within each repetition of a group, positioning with
C<@> starts over at 0.  Therefore, the result of

=end original

C<()> のグループはかっこで囲われた副テンプレートです。
グループは繰り返し数を取ることができます; 接尾辞によるか、
L<C<unpack>|/unpack TEMPLATE,EXPR> の場合は C</> テンプレート文字によります。
グループの繰り返し毎に、C<@> の位置は 0 になります。
従って、以下の結果は:

    # note: single quotes around the template string to prevent
    # array interpolation of @1, @2, @3
    pack('@1A((@2A)@3A)', qw[X Y Z])

=begin original

is the string C<"\0X\0\0YZ">.

=end original

文字列 C<"\0X\0\0YZ"> です。

=item *

=begin original

C<x> and C<X> accept the C<!> modifier to act as alignment commands: they
jump forward or back to the closest position aligned at a multiple of C<count>
characters.  For example, to C<pack> or
L<C<unpack>|/unpack TEMPLATE,EXPR> a C structure like

=end original

C<x> と C<X> にはアライメントコマンドとして C<!> 修飾子を付けることができます:
これは C<count> 文字の倍数のアライメントとなる、もっとも近い位置に移動します。
例えば、以下のような C 構造体を C<pack> または
L<C<unpack>|/unpack TEMPLATE,EXPR> するには

    struct {
        char   c;    /* one signed, 8-bit character */
        double d;
        char   cc[2];
    }

=begin original

one may need to use the template C<c x![d] d c[2]>.  This assumes that
doubles must be aligned to the size of double.

=end original

C<W x![d] d W[2]> というテンプレートを使う必要があるかもしれません。
これは double が double のサイズでアライメントされていることを
仮定しています。

=begin original

For alignment commands, a C<count> of 0 is equivalent to a C<count> of 1;
both are no-ops.

=end original

アライメントコマンドに対しては、C<count> に 0 を指定するのは
C<count> に 1 を指定するのと等価です; どちらも何もしません。

=item *

=begin original

C<n>, C<N>, C<v> and C<V> accept the C<!> modifier to
represent signed 16-/32-bit integers in big-/little-endian order.
This is portable only when all platforms sharing packed data use the
same binary representation for signed integers; for example, when all
platforms use two's-complement representation.

=end original

C<n>, C<N>, C<v>, C<V> はビッグ/リトルエンディアンの順序で符号付き 16 または
32 ビット整数で表現するための C<!> 修飾子を受け入れます。
これは pack されたデータを共有する全てのプラットフォームが
符号付き整数について同じバイナリ表現を使う場合にのみ移植性があります;
例えば、全てのプラットフォームで 2 の補数表現を使う場合です。

=item *

=begin original

Comments can be embedded in a TEMPLATE using C<#> through the end of line.
White space can separate pack codes from each other, but modifiers and
repeat counts must follow immediately.  Breaking complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibility and maintainability of pack/unpack formats as C</x> can
for complicated pattern matches.

=end original

TEMPLATE の中の C<#> から行末まではコメントです。
空白は pack コードをそれぞれ分けるために使えますが、修飾子と
繰り返し数は直後に置かなければなりません。
複雑なテンプレートを個々の行単位の要素に分解して適切に注釈をつけると、
複雑なパターンマッチングに対する C</x> と同じぐらい、pack/unpack
フォーマットの読みやすさと保守性が向上します。

=item *

=begin original

If TEMPLATE requires more arguments than C<pack>
is given, C<pack>
assumes additional C<""> arguments.  If TEMPLATE requires fewer arguments
than given, extra arguments are ignored.

=end original

TEMPLATE が要求する引数の数が L<C<pack>|/pack TEMPLATE,LIST> が実際に
与えている数より多い場合、
L<C<pack>|/pack TEMPLATE,LIST> は追加の C<""> 引数があるものと仮定します。
TEMPLATE が要求する引数の数の方が少ない場合、余分の引数は無視されます。

=item *

=begin original

Attempting to pack the special floating point values C<Inf> and C<NaN>
(infinity, also in negative, and not-a-number) into packed integer values
(like C<"L">) is a fatal error.  The reason for this is that there simply
isn't any sensible mapping for these special values into integers.

=end original

特殊浮動小数点値 C<Inf> と C<NaN>
((負を含む)無限と非数) を (C<"L"> のような) 整数値に pack しようとすると
致命的エラーとなります。
この理由は、単に特殊値を整数に割り当てられないからです。

=back

=begin original

Examples:

=end original

例:

    $foo = pack("WWWW",65,66,67,68);
    # foo eq "ABCD"
    $foo = pack("W4",65,66,67,68);
    # same thing
    $foo = pack("W4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters.
    $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # same thing with Unicode circled letters.  You don't get the
    # UTF-8 bytes because the U at the start of the format caused
    # a switch to U0-mode, so the UTF-8 bytes get joined into
    # characters
    $foo = pack("C0U4",0x24b6,0x24b7,0x24b8,0x24b9);
    # foo eq "\xe2\x92\xb6\xe2\x92\xb7\xe2\x92\xb8\xe2\x92\xb9"
    # This is the UTF-8 encoding of the string in the
    # previous example

    $foo = pack("ccxxcc",65,66,67,68);
    # foo eq "AB\0\0CD"

    # NOTE: The examples above featuring "W" and "c" are true
    # only on ASCII and ASCII-derived systems such as ISO Latin 1
    # and UTF-8.  On EBCDIC systems, the first example would be
    #      $foo = pack("WWWW",193,194,195,196);

    $foo = pack("s2",1,2);
    # "\001\000\002\000" on little-endian
    # "\000\001\000\002" on big-endian

    $foo = pack("a4","abcd","x","y","z");
    # "abcd"

    $foo = pack("aaaa","abcd","x","y","z");
    # "axyz"

    $foo = pack("a14","abcdefg");
    # "abcdefg\0\0\0\0\0\0\0"

    $foo = pack("i9pl", gmtime);
    # a real struct tm (on my system anyway)

    $utmp_template = "Z8 Z8 Z16 L";
    $utmp = pack($utmp_template, @utmp1);
    # a struct utmp (BSDish)

    @utmp2 = unpack($utmp_template, $utmp);
    # "@utmp1" eq "@utmp2"

    sub bintodec {
        unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
    }

    $foo = pack('sx2l', 12, 34);
    # short 12, two zero bytes padding, long 34
    $bar = pack('s@4l', 12, 34);
    # short 12, zero fill to position 4, long 34
    # $foo eq $bar
    $baz = pack('s.l', 12, 4, 34);
    # short 12, zero fill to position 4, long 34

    $foo = pack('nN', 42, 4711);
    # pack big-endian 16- and 32-bit unsigned integers
    $foo = pack('S>L>', 42, 4711);
    # exactly the same
    $foo = pack('s<l<', -42, 4711);
    # pack little-endian 16- and 32-bit signed integers
    $foo = pack('(sl)<', -42, 4711);
    # exactly the same

=begin original

The same template may generally also be used in
L<C<unpack>|/unpack TEMPLATE,EXPR>.

=end original

一般的には、同じテンプレートが L<C<unpack>|/unpack TEMPLATE,EXPR> でも
使用できます。

=item package NAMESPACE

=item package NAMESPACE VERSION
X<package> X<module> X<namespace> X<version>

=item package NAMESPACE BLOCK

=item package NAMESPACE VERSION BLOCK
X<package> X<module> X<namespace> X<version>

=for Pod::Functions declare a separate global namespace

=begin original

Declares the BLOCK or the rest of the compilation unit as being in the
given namespace.  The scope of the package declaration is either the
supplied code BLOCK or, in the absence of a BLOCK, from the declaration
itself through the end of current scope (the enclosing block, file, or
L<C<eval>|/eval EXPR>).  That is, the forms without a BLOCK are
operative through the end of the current scope, just like the
L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>, and
L<C<our>|/our VARLIST> operators.  All unqualified dynamic identifiers
in this scope will be in the given namespace, except where overridden by
another C<package> declaration or
when they're one of the special identifiers that qualify into C<main::>,
like C<STDOUT>, C<ARGV>, C<ENV>, and the punctuation variables.

=end original

BLOCK や残りのコンパイル単位を与えられた名前空間として宣言します。
パッケージ宣言のスコープは BLOCK か、BLOCK がないばあいは宣言自身から
現在のスコープの末尾 (閉じたブロック、ファイル、L<C<eval>|/eval EXPR>) です。
つまり、BLOCK なしの形式は、L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>,
L<C<our>|/our VARLIST> 演算子と同様に現在のスコープの末尾にまで作用します。
このスコープ内の、全ての完全修飾されていない動的識別子は、他の
C<package> 宣言によって上書きされるか、
C<STDOUT>, C<ARGV>, C<ENV> や句読点変数のように C<main::> に
割り当てられる特殊変数でない限り、指定された
名前空間になります。

=begin original

A package statement affects dynamic variables only, including those
you've used L<C<local>|/local EXPR> on, but I<not> lexically-scoped
variables, which are created with L<C<my>|/my VARLIST>,
L<C<state>|/state VARLIST>, or L<C<our>|/our VARLIST>.  Typically it
would be the first declaration in a file included by
L<C<require>|/require VERSION> or L<C<use>|/use Module VERSION LIST>.
You can switch into a
package in more than one place, since this only determines which default
symbol table the compiler uses for the rest of that block.  You can refer to
identifiers in other packages than the current one by prefixing the identifier
with the package name and a double colon, as in C<$SomePack::var>
or C<ThatPack::INPUT_HANDLE>.  If package name is omitted, the C<main>
package is assumed.  That is, C<$::sail> is equivalent to
C<$main::sail> (as well as to C<$main'sail>, still seen in ancient
code, mostly from Perl 4).

=end original

package 文は動的変数にのみ影響します(L<C<local>|/local EXPR> で使ったものも
含みます)が、L<C<my>|/my VARLIST>, L<C<state>|/state VARLIST>, 
L<C<our>|/our VARLIST> のいずれかで作成された
レキシカルなスコープの変数には I<影響しません>。
典型的にはこれは L<C<require>|/require VERSION> や
L<C<use>|/use Module VERSION LIST> 演算子でインクルードされるファイルの
最初に宣言されます。
パッケージを複数の場所で切り替えることができます;
なぜならこれは単にコンパイラがこのブロックの残りに対してどの
シンボルテーブルを使うかにのみ影響するからです。
他のパッケージの識別子は、C<$SomePack::var> や
C<ThatPack::INPUT_HANDLE> のように、識別子にパッケージ名と
コロン二つをつけることで参照できます。
パッケージ名が省略された場合、C<main> パッケージが仮定されます。
つまり、C<$::sail> は C<$main::sail> と等価です(ほとんどは Perl 4 からの、
古いコードでは C<$main'sail> もまだ見られます)。

=begin original

If VERSION is provided, C<package> sets the
C<$VERSION> variable in the given
namespace to a L<version> object with the VERSION provided.  VERSION must be a
"strict" style version number as defined by the L<version> module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v-string with a leading 'v' character and at least three
components.  You should set C<$VERSION> only once per package.

=end original

VERSION が指定されると、C<package> は与えられた
名前空間の C<$VERSION> 変数に、
指定された VERSION の L<version> オブジェクトをセットします。
VERSION は L<version> で定義されている「厳密な」形式のバージョン番号で
なければなりません: 指数のない正の 10 進数 (整数か 10 進小数) か、
さもなければ先頭に 'v' の文字が付いて、少なくとも三つの部分から
構成されるドット付き 10 進v-文字列です。
C<$VERSION> はパッケージ毎に 1 回だけセットするべきです。

=begin original

See L<perlmod/"Packages"> for more information about packages, modules,
and classes.  See L<perlsub> for other scoping issues.

=end original

パッケージ、モジュール、クラスに関するさらなる情報については
L<perlmod/"Packages"> を参照してください。
その他のスコープに関する話題については L<perlsub> を参照してください。

=item __PACKAGE__
X<__PACKAGE__>

=for Pod::Functions +5.004 the current package

=begin original

A special token that returns the name of the package in which it occurs.

=end original

これが書いてあるパッケージの名前を返す特殊トークン。

=item __CLASS__
X<__CLASS__>

=for Pod::Functions the class name of the current instance.

=begin original

Invoked within a L<C<method>|/method NAME BLOCK>, or similar location, such as
a field initializer expression, this token returns the name of the class of
the invoking instance.  Essentially it is equivalent to C<ref($self)> except
that it can additionally be used in a field initializer to gain access to
class methods, before the instance is fully constructed.

=end original

このトークンは、L<C<method>|/method NAME BLOCK> 内、または
フィールド初期化式などのような場所で呼び出されると、
呼び出し側インスタンスのクラスの名前を返します。
基本的には C<ref($self)> と等価ですが、インスタンスが完全に
構築される前に、フィールド初期化子で追加的に使って
クラスメソッドにアクセスできる点が異なります。

    use feature 'class';

    class Example1 {
	field $f = __CLASS__->default_f;

	sub default_f { 10 }
    }

=begin original

In a basic class, this value will be the same as
C<__PACKAGE__>.  The distinction can be seen when a subclass
is constructed; it will give the class name of the instance being constructed,
rather than just the package name that the actual code belongs to.

=end original

基底クラスでは、この値は C<__PACKAGE__> と同じになります。
サブクラスが構築されると違いが見られます;
実際のコードが属するパッケージ名でなく、
構築されるインスタンスのクラス名が与えられます。

    class Example2 :isa(Example1) {
	sub default_f { 20 }
    }

    my $obj = Example2->new;
    # The $f field now has the value 20

=item pipe READHANDLE,WRITEHANDLE
X<pipe>

=for Pod::Functions open a pair of connected filehandles

=begin original

Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
IO buffering, so you may need to set L<C<$E<verbar>>|perlvar/$E<verbar>>
to flush your WRITEHANDLE after each command, depending on the
application.

=end original

対応するシステムコールと同じように、接続されたパイプのペアを開きます。
パイプでプロセスをループにするときには、よほど気を付けないと、
デッドロックが起こり得ます。
さらに、Perl のパイプでは、IO のバッファリングを使ので、
アプリケーションによっては、コマンドごとに WRITEHANDLE を
フラッシュするように、L<C<$E<verbar>>|perlvar/$E<verbar>> を設定することが
必要になるかもしれません。

=begin original

Returns true on success.

=end original

成功時には真を返します。

=begin original

See L<IPC::Open2>, L<IPC::Open3>, and
L<perlipc/"Bidirectional Communication with Another Process">
for examples of such things.

=end original

これらに関する例については、L<IPC::Open2>, L<IPC::Open3>,
L<perlipc/"Bidirectional Communication with Another Process"> を
参照してください。

=begin original

On systems that support a close-on-exec flag on files, that flag is set
on all newly opened file descriptors whose
L<C<fileno>|/fileno FILEHANDLE>s are I<higher> than the current value of
L<C<$^F>|perlvar/$^F> (by default 2 for C<STDERR>).  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
新しくオープンされたファイル記述子のうち、
L<C<fileno>|/fileno FILEHANDLE> が現在の L<C<$^F>|perlvar/$^F> の値
(デフォルトでは C<STDERR> の 2)
I<よりも大きい> ものに対してフラグがセットされます。
L<perlvar/$^F> を参照してください。

=item pop ARRAY
X<pop> X<stack>

=item pop

=for Pod::Functions remove the last element from an array and return it

=begin original

Removes and returns the B<last> element of the array, shortening the array by
one element.

=end original

配列の B<最後の> 値を削除して返し、配列の大きさを 1 だけ小さくします。

    my @arr  = ('cat', 'dog', 'mouse');
    my $item = pop(@arr); # 'mouse'

    # @arr is now ('cat', 'dog')

=begin original

Returns C<undef> if the array is empty.

=end original

配列が空なら C<undef> を返します。

=begin original

B<Note:> C<pop> may also return C<undef> if the last element in the array
is C<undef>.

=end original

B<注意:> C<pop> は、配列の最後の要素が C<undef> の場合も C<undef> を
返します。

    my @arr  = ('one', 'two', undef);
    my $item = pop(@arr); # undef

=begin original

If ARRAY is omitted, C<pop> operates on the L<C<@ARGV>|perlvar/@ARGV> array
in the main program, but the L<C<@_>|perlvar/@_> array in subroutines. C<pop>
will operate on the C<@ARGV> array in C<eval STRING>, C<BEGIN {}>, C<INIT {}>,
C<CHECK {}> blocks.

=end original

ARRAY が省略されると、C<pop> は、メインプログラムでは
L<C<@ARGV>|perlvar/@ARGV> が使われますが、
サブルーチンでは L<C<@_>|perlvar/@_> が使われます。
C<pop> は C<eval STRING>, C<BEGIN {}>, C<INIT {}>,
C<CHECK {}> ブロックの中で C<@ARGV> を操作します。

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<pop> to take a
scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<pop> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=item pos SCALAR
X<pos> X<match, position>

=item pos

=for Pod::Functions find or set the offset for the last/next m//g search

=begin original

Returns the offset of where the last C<m//g> search left off for the
variable in question (L<C<$_>|perlvar/$_> is used when the variable is not
specified).  This offset is in characters unless the
(no-longer-recommended) L<C<use bytes>|bytes> pragma is in effect, in
which case the offset is in bytes.  Note that 0 is a valid match offset.
L<C<undef>|/undef EXPR> indicates
that the search position is reset (usually due to match failure, but
can also be because no match has yet been run on the scalar).

=end original

対象の変数に対して、前回の C<m//g> が終了した場所の
オフセットを返します(変数が指定されなかった場合は L<C<$_>|perlvar/$_> が
使われます)。
オフセットは、(もはや勧められない) L<C<use bytes>|bytes> プラグマが有効の
場合(この場合はバイト単位です)を除いて、文字単位です。
0 は有効なマッチオフセットであることに注意してください。
L<C<undef>|/undef EXPR> は検索位置がリセットされることを意味します (通常は
マッチ失敗が原因ですが、このスカラ値にまだマッチングが
行われていないためかもしれません)。

=begin original

C<pos> directly accesses the location used by the regexp
engine to store the offset, so assigning to C<pos> will
change that offset, and so will also influence the C<\G> zero-width
assertion in regular expressions.  Both of these effects take place for
the next match, so you can't affect the position with
C<pos> during the current match, such as in
C<(?{pos() = 5})> or C<s//pos() = 5/e>.

=end original

C<pos> は正規表現エンジンがオフセットを保存するために使う場所を
直接アクセスするので、C<pos> への代入はオフセットを変更し、
そのような変更は正規表現における C<\G> ゼロ幅アサートにも影響を与えます。
これらの効果の両方は次のマッチングのために行われるので、
C<(?{pos() = 5})> や C<s//pos() = 5/e> のように現在のマッチング中の
C<pos> の位置には影響を与えません。

=begin original

Setting C<pos> also resets the I<matched with
zero-length> flag, described
under L<perlre/"Repeated Patterns Matching a Zero-length Substring">.

=end original

C<pos> を設定すると、
L<perlre/"Repeated Patterns Matching a Zero-length Substring"> に
記述されている、I<長さ 0 でマッチング> フラグもリセットされます。

=begin original

Because a failed C<m//gc> match doesn't reset the offset, the return
from C<pos> won't change either in this case.  See
L<perlre> and L<perlop>.

=end original

C<m//gc> マッチに失敗してもオフセットはリセットしないので、
C<pos> からの返り値はどちらの場合も変更されません。
L<perlre> と L<perlop> を参照してください。

=item print FILEHANDLE LIST
X<print>

=item print FILEHANDLE

=item print LIST

=item print

=for Pod::Functions output a list to a filehandle

=begin original

Prints a string or a list of strings.  Returns true if successful.
FILEHANDLE may be a scalar variable containing the name of or a reference
to the filehandle, thus introducing one level of indirection.  (NOTE: If
FILEHANDLE is a variable and the next token is a term, it may be
misinterpreted as an operator unless you interpose a C<+> or put
parentheses around the arguments.)  If FILEHANDLE is omitted, prints to the
last selected (see L<C<select>|/select FILEHANDLE>) output handle.  If
LIST is omitted, prints L<C<$_>|perlvar/$_> to the currently selected
output handle.  To use FILEHANDLE alone to print the content of
L<C<$_>|perlvar/$_> to it, you must use a bareword filehandle like
C<FH>, not an indirect one like C<$fh>.  To set the default output handle
to something other than STDOUT, use the select operation.

=end original

文字列か文字列のリストを出力します。
成功時には真を返します。
FILEHANDLE は、ファイルハンドル名またはそのリファレンスが
入っているスカラ変数名でもよいので、一段階の間接指定が行なえます。
(注: FILEHANDLE に変数を使い、次のトークンが「項」のときには、
間に C<+> を置くか、引数の前後を括弧で括らなければ、
誤って解釈されることがあります。)
FILEHANDLE を省略した場合には、最後に選択された
(L<C<select>|/select FILEHANDLE> 参照) 出力チャネルに出力します。
LIST を省略すると、L<C<$_>|perlvar/$_> が現在選択されている出力ハンドルに
出力されます。
L<C<$_>|perlvar/$_> の内容を表示するために FILEHANDLE のみを使用するには、
C<$fh> のような間接ファイルハンドルではなく、C<FH> のような裸の単語の
ファイルハンドルを使わなければなりません。
デフォルトの出力チャネルを STDOUT 以外にするには、select 演算子を
使ってください。

=begin original

The current value of L<C<$,>|perlvar/$,> (if any) is printed between
each LIST item.  The current value of L<C<$\>|perlvar/$\> (if any) is
printed after the entire LIST has been printed.  Because print takes a
LIST, anything in the LIST is evaluated in list context, including any
subroutines whose return lists you pass to
C<print>.  Be careful not to follow the print
keyword with a left
parenthesis unless you want the corresponding right parenthesis to
terminate the arguments to the print; put parentheses around all arguments
(or interpose a C<+>, but that doesn't look as good).

=end original

L<C<$,>|perlvar/$,> の値が(もしあれば)各 LIST 要素の間に出力されます。
LIST 全体が出力された後、(もしあれば) L<C<$\>|perlvar/$\> の現在の値が
出力されます。
print の引数は LIST なので、LIST の中のものは、すべてリストコンテキストで
評価されます; C<print> に渡した、リストを返す
サブルーチンも含みます。
また、すべての引数を括弧で括るのでなければ、print というキーワードの
次に開き括弧を書いてはいけません; すべての引数を括弧で括ってください
(あるいは "print" と引数の間に C<+> を書きますが、これはあまり
よくありません)。

=begin original

If you're storing handles in an array or hash, or in general whenever
you're using any expression more complex than a bareword handle or a plain,
unsubscripted scalar variable to retrieve it, you will have to use a block
returning the filehandle value instead, in which case the LIST may not be
omitted:

=end original

もし FILESHANDLE を配列、ハッシュあるいは一般的には裸の単語のハンドルや
普通のスカラ変数よりも複雑な表現を使っている場合、代わりにその値を返す
ブロックを使う必要があります; この場合 LIST は省略できません:

    print { $files[$i] } "stuff\n";
    print { $OK ? *STDOUT : *STDERR } "stuff\n";

=begin original

Printing to a closed pipe or socket will generate a SIGPIPE signal.  See
L<perlipc> for more on signal handling.

=end original

閉じたパイプやソケットに print すると SIGPIPE シグナルが生成されます。
さらなるシグナル操作については L<perlipc> を参照してください。

=item printf FILEHANDLE FORMAT, LIST
X<printf>

=item printf FILEHANDLE

=item printf FORMAT, LIST

=item printf

=for Pod::Functions output a formatted list to a filehandle

=begin original

Equivalent to C<print FILEHANDLE sprintf(FORMAT, LIST)>, except that
L<C<$\>|perlvar/$\> (the output record separator) is not appended.  The
FORMAT and the LIST are actually parsed as a single list.  The first
argument of the list will be interpreted as the
L<C<printf>|/printf FILEHANDLE FORMAT, LIST> format.  This means that
C<printf(@_)> will use C<$_[0]> as the format.  See
L<sprintf|/sprintf FORMAT, LIST> for an explanation of the format
argument.  If C<use locale> (including C<use locale ':not_characters'>)
is in effect and L<C<POSIX::setlocale>|POSIX/C<setlocale>> has been
called, the character used for the decimal separator in formatted
floating-point numbers is affected by the C<LC_NUMERIC> locale setting.
See L<perllocale> and L<POSIX>.

=end original

L<C<$\>|perlvar/$\>(出力レコードセパレータ)を追加しないことを除けば、
C<print FILEHANDLE sprintf(FORMAT, LIST)> と等価です。
FORMAT と LIST は実際には単一のリストとしてパースされます。
リストの最初の要素は、L<C<printf>|/printf FILEHANDLE FORMAT, LIST>
フォーマットと解釈されます。
これは、C<printf(@_)> はフォーマットとして C<$_[0]> を使うということです。
フォーマット引数の説明については L<sprintf|/sprintf FORMAT, LIST> を
参照してください。
(C<use locale ':not_characters'> を含む) C<use locale> が有効で、
L<C<POSIX::setlocale>|POSIX/C<setlocale>> が呼び出されていれば、
小数点に使われる文字は C<LC_NUMERIC> ロケール設定の影響を受けます。
L<perllocale> と L<POSIX> を参照してください。

=begin original

For historical reasons, if you omit the list, L<C<$_>|perlvar/$_> is
used as the format;
to use FILEHANDLE without a list, you must use a bareword filehandle like
C<FH>, not an indirect one like C<$fh>.  However, this will rarely do what
you want; if L<C<$_>|perlvar/$_> contains formatting codes, they will be
replaced with the empty string and a warning will be emitted if
L<warnings> are enabled.  Just use L<C<print>|/print FILEHANDLE LIST> if
you want to print the contents of L<C<$_>|perlvar/$_>.

=end original

歴史的な理由により、リストを省略すると、フォーマットとして
L<C<$_>|perlvar/$_> が使われます;
リストなしで FILEHANDLE を使用するには、C<$fh> のような
間接ファイルハンドルではなく、C<FH> のような裸の単語の
ファイルハンドルを使わなければなりません。
しかし、これがあなたが求めていることをすることはまれです;
L<C<$_>|perlvar/$_> がフォーマッティングコードの場合、空文字列に置き換えられ、
L<warnings> が有効なら警告が出力されます。
L<C<$_>|perlvar/$_> の内容を表示したい場合は、単に
L<C<print>|/print FILEHANDLE LIST> を使ってください。

=begin original

Don't fall into the trap of using a
C<printf> when a simple
L<C<print>|/print FILEHANDLE LIST> would do.  The
L<C<print>|/print FILEHANDLE LIST> is more efficient and less error
prone.

=end original

単純な L<C<print>|/print FILEHANDLE LIST> を使うべきところで
C<printf> を使ってしまう
罠にかからないようにしてください。
L<C<print>|/print FILEHANDLE LIST> はより効率的で、間違いが起こりにくいです。

=item prototype FUNCTION
X<prototype>

=item prototype

=for Pod::Functions +5.002 get the prototype (if any) of a subroutine

=begin original

Returns the prototype of a function as a string (or
L<C<undef>|/undef EXPR> if the
function has no prototype).  FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.  If FUNCTION is omitted,
L<C<$_>|perlvar/$_> is used.

=end original

関数のプロトタイプを文字列として返します(関数にプロトタイプがない場合は
L<C<undef>|/undef EXPR> を返します)。
FUNCTION はプロトタイプを得たい関数の名前、またはリファレンスです。
FUNCTION が省略された場合、L<C<$_>|perlvar/$_> が使われます。

=begin original

If FUNCTION is a string starting with C<CORE::>, the rest is taken as a
name for a Perl builtin.  If the builtin's arguments
cannot be adequately expressed by a prototype
(such as L<C<system>|/system LIST>), C<prototype>
returns L<C<undef>|/undef EXPR>, because the builtin
does not really behave like a Perl function.  Otherwise, the string
describing the equivalent prototype is returned.

=end original

FUNCTION が C<CORE::> で始まっている場合、残りは Perl ビルドインの名前として
扱われます。
このビルドインの引数が(L<C<system>|/system LIST> のように)プロトタイプとして
適切に記述できない場合、C<prototype> は
L<C<undef>|/undef EXPR> を返します;
なぜならビルドインは実際に Perl 関数のように振舞わないからです。
それ以外では、等価なプロトタイプを表現した文字列が返されます。

=item push ARRAY,LIST
X<push> X<stack>

=for Pod::Functions append one or more elements to an array

=begin original

Adds one or more items to the B<end> of an array.

=end original

一つまたは複数の要素を配列の B<末尾に> 追加します。

	my @animals = ("cat");
	push(@animals, "mouse"); # ("cat", "mouse")

	my @colors = ("red");
	push(@colors, ("blue", "green")); # ("red", "blue", "green")

=begin original

Returns the number of elements in the array following the completed
C<push>.

=end original

C<push> の処理終了後の配列の要素数を返します。

	my $color_count = push(@colors, ("yellow", "purple"));

	say "There are $color_count colors in the updated array";

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<push> to take a
scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<push> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=item q/STRING/

=for Pod::Functions singly quote a string

=item qq/STRING/

=for Pod::Functions doubly quote a string

=item qw/STRING/

=for Pod::Functions quote a list of words

=item qx/STRING/

=for Pod::Functions backquote quote a string

=begin original

Generalized quotes.  See L<perlop/"Quote-Like Operators">.

=end original

汎用のクォートです。
L<perlop/"Quote-Like Operators"> を参照してください。

=item qr/STRING/

=for Pod::Functions +5.005 compile pattern

=begin original

Regexp-like quote.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

正規表現風のクォートです。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item quotemeta EXPR
X<quotemeta> X<metacharacter>

=item quotemeta

=for Pod::Functions quote regular expression magic characters

=begin original

Returns the value of EXPR with all the ASCII non-"word"
characters backslashed.  (That is, all ASCII characters not matching
C</[A-Za-z_0-9]/> will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the C<\Q> escape in double-quoted strings.
(See below for the behavior on non-ASCII code points.)

=end original

EXPR の中のすべての ASCII 非英数字キャラクタをバックスラッシュで
エスケープしたものを返します。
(つまり、C</[A-Za-z_0-9]/> にマッチしない全ての ASCII 文字の前には
ロケールに関わらずバックスラッシュが前置されます。)
これは、ダブルクォート文字列での C<\Q> エスケープを実装するための
内部関数です。
(非 ASCII 符号位置での振る舞いについては以下を参照してください。)

=begin original

If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

=begin original

The motivation behind this is to make all characters in EXPR match their
literal selves.  Otherwise any metacharacters in it could trigger
their "magic" matching behaviors.  The characters this function has been
applied to are said to be "quoted" or "escaped".

=end original

これの裏側にある動機は、EXPR の全ての文字がリテラルなそれ自身に
マッチングするようにすることです。
さもなければ、この中のメタ文字がその「マジカルな」マッチングの振る舞いを
引き起こす可能性があります。
この関数が適用された文字は、「クォートされた」(quoted)または
「エスケープされた」(escaped)と呼ばれます。

=begin original

quotemeta (and C<\Q> ... C<\E>) are useful when interpolating strings into
regular expressions, because by default an interpolated variable will be
considered a mini-regular expression.  For example:

=end original

クォートメタ (と C<\Q> ... C<\E>) は、文字列を正規表現に展開するのに
便利です; なぜなら、デフォルトでは展開された変数は小さな正規表現として
扱われるからです。
例えば:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    $sentence =~ s{$substring}{big bad wolf};

=begin original

Will cause C<$sentence> to become C<'The big bad wolf jumped over...'>.

=end original

とすると、C<$sentence> は C<'The big bad wolf jumped over...'> になります。

=begin original

On the other hand:

=end original

一方:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    $sentence =~ s{\Q$substring\E}{big bad wolf};

=begin original

Or:

=end original

あるいは:

    my $sentence = 'The quick brown fox jumped over the lazy dog';
    my $substring = 'quick.*?fox';
    my $quoted_substring = quotemeta($substring);
    $sentence =~ s{$quoted_substring}{big bad wolf};

=begin original

Will both leave the sentence as is.
Normally, when accepting literal string input from the user,
C<quotemeta> or C<\Q> must be used.

=end original

とすると、両方ともそのままです。
普通は、ユーザーからのリテラルな文字列入力を受け付ける場合は、
必ず C<quotemeta> か C<\Q> を使わなければなりません。

=begin original

Beware that if you put literal backslashes (those not inside
interpolated variables) between C<\Q> and C<\E>, double-quotish
backslash interpolation may lead to confusing results.  If you
I<need> to use literal backslashes within C<\Q...\E>,
consult L<perlop/"Gory details of parsing quoted constructs">.

=end original

リテラルな逆スラッシュ (変数置換の中でないもの) を C<\Q> と C<\E> の間に
置くと、ダブルクォート風逆スラッシュ変数置換は混乱した結果を
引き起こすことがあることに注意してください。
C<\Q...\E> の中でリテラルな逆スラッシュを使うことが I<必要> なら、
L<perlop/"Gory details of parsing quoted constructs"> を参照してください。

=begin original

Because the result of S<C<"\Q I<STRING> \E">> has all metacharacters
quoted, there is no way to insert a literal C<$> or C<@> inside a
C<\Q\E> pair.  If protected by C<\>, C<$> will be quoted to become
C<"\\\$">; if not, it is interpreted as the start of an interpolated
scalar.

=end original

S<C<"\Q I<STRING> \E">> の結果では全てのメタ文字がクォートされているので、
C<\Q\E> の組の中にリテラルな C<$> や C<@> を挿入する方法はありません。
C<\> で保護すると、C<$> は C<"\\\$"> になってクォートされます;
保護しないと、変数展開されるスカラの開始として解釈されます。

=begin original

In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded
strings, but not quoted in UTF-8 strings.

=end original

Perl v5.14 では、全ての非 ASCII 文字は非 UTF-8 エンコードされた
文字列ではクォートされませんが、UTF-8 文字列ではクォートされます。

=begin original

Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for
quoting non-ASCII characters; the quoting of ASCII characters is
unchanged.

=end original

Perl v5.16 から、Perl は非 ASCII 文字をクォートするのに Unicode で
定義された戦略を採用しました; ASCII 文字のクォートは変わりません。

=begin original

Also unchanged is the quoting of non-UTF-8 strings when outside the
scope of a
L<C<use feature 'unicode_strings'>|feature/The 'unicode_strings' feature>,
which is to quote all
characters in the upper Latin1 range.  This provides complete backwards
compatibility for old programs which do not use Unicode.  (Note that
C<unicode_strings> is automatically enabled within the scope of a
S<C<use v5.12>> or greater.)

=end original

また、
L<C<use feature 'unicode_strings'>|feature/The 'unicode_strings' feature> の
範囲外で非 UTF-8 文字列をクォートするのも変わりません; 上位の Latin1 の範囲の
全ての文字をクォートします。
これは Unicode を使わない古いプログラムに対して完全な後方互換性を提供します。
(C<unicode_strings> は S<C<use v5.12>> またはそれ以上のスコープでは
自動的に有効になることに注意してください。)

=begin original

Within the scope of L<C<use locale>|locale>, all non-ASCII Latin1 code
points
are quoted whether the string is encoded as UTF-8 or not.  As mentioned
above, locale does not affect the quoting of ASCII-range characters.
This protects against those locales where characters such as C<"|"> are
considered to be word characters.

=end original

L<C<use locale>|locale> スコープの内側では、全ての非 ASCII Latin1 符号位置は
文字列が UTF-8 でエンコードされているかどうかに関わらずクォートされます。
上述のように、ロケールは ASCII の範囲の文字のクォートに影響を与えません。
これは C<"|"> のような文字が単語文字として考えられるロケールから守ります。

=begin original

Otherwise, Perl quotes non-ASCII characters using an adaptation from
Unicode (see L<https://www.unicode.org/reports/tr31/>).
The only code points that are quoted are those that have any of the
Unicode properties:  Pattern_Syntax, Pattern_White_Space, White_Space,
Default_Ignorable_Code_Point, or General_Category=Control.

=end original

さもなければ、Perl は Unicode からの本版を使って非 ASCII 文字をクォートします
(L<https://www.unicode.org/reports/tr31/> 参照)。
クォートされる符号位置は以下のどれかの Unicode を特性を持つものだけです:
Pattern_Syntax, Pattern_White_Space, White_Space,
Default_Ignorable_Code_Point, or General_Category=Control。

=begin original

Of these properties, the two important ones are Pattern_Syntax and
Pattern_White_Space.  They have been set up by Unicode for exactly this
purpose of deciding which characters in a regular expression pattern
should be quoted.  No character that can be in an identifier has these
properties.

=end original

これらの特性の中で、重要な二つは Pattern_Syntax と Pattern_White_Space です。
これらはまさに正規表現中パターン中のどの文字をクォートするべきかを
決定するという目的のために Unicode によって設定されています。
識別子になる文字はこれらの特性はありません。

=begin original

Perl promises, that if we ever add regular expression pattern
metacharacters to the dozen already defined
(C<\ E<verbar> ( ) [ { ^ $ * + ? .>), that we will only use ones that have the
Pattern_Syntax property.  Perl also promises, that if we ever add
characters that are considered to be white space in regular expressions
(currently mostly affected by C</x>), they will all have the
Pattern_White_Space property.

=end original

Perl は、正規表現メタ文字として既に定義されている
(C<\ E<verbar> ( ) [ { ^ $ * + ? .>) ものに追加するときは、
Pattern_Syntax 特性を持つものだけを使うことを約束します。
Perl はまた、(現在の所ほとんどは C</x> よって影響される)正規表現中で空白と
考えられる文字に追加するときは、Pattern_White_Space 特性を
持つものであることを約束します。

=begin original

Unicode promises that the set of code points that have these two
properties will never change, so something that is not quoted in v5.16
will never need to be quoted in any future Perl release.  (Not all the
code points that match Pattern_Syntax have actually had characters
assigned to them; so there is room to grow, but they are quoted
whether assigned or not.  Perl, of course, would never use an
unassigned code point as an actual metacharacter.)

=end original

Unicode はこれら二つの特性を持つ符号位置の集合が決して変わらないことを
約束しているので、v5.16 でクォートされないものは将来の Perl リリースでも
クォートする必要はありません。
(Pattern_Syntax にマッチングする全ての符号位置が実際に割り当てられている
文字を持っているわけではありません; したがって拡張する余地がありますが、
割り当てられているかどうかに関わらずクォートされます。
Perl はもちろん割り当てられていない符号位置を実際のメタ文字として使うことは
ありません。)

=begin original

Quoting characters that have the other 3 properties is done to enhance
the readability of the regular expression and not because they actually
need to be quoted for regular expression purposes (characters with the
White_Space property are likely to be indistinguishable on the page or
screen from those with the Pattern_White_Space property; and the other
two properties contain non-printing characters).

=end original

その他の 3 特性を持つ文字のクォートは正規表現の可読性を向上させるために
行われ、実際には正規表現の目的でクォートする必要があるからではありません
(White_Space 特性を持つ文字は表示上は Pattern_White_Space 特性を持つ文字と
おそらく区別が付かないでしょう; そして残りの
二つの特性は非表示文字を含んでいます).

=item rand EXPR
X<rand> X<random>

=item rand

=for Pod::Functions retrieve the next pseudorandom number

=begin original

Returns a random fractional number greater than or equal to C<0> and B<less>
than the value of EXPR.  (EXPR should be positive.)  If EXPR is
omitted, the value C<1> is used.

=end original

C<0> 以上 EXPR の値 B<未満> の小数の乱数値を返します。
(EXPR は正の数である必要があります。)
EXPR が省略されると、C<1> が使われます。

    my $num1 = rand();        # Random float at least 0 and below 1
    my $num2 = rand(7);       # Random float at least 0 and below 7
    my $num3 = int(rand(10)); # Random integer at least 0 and below 10

=begin original

B<Notes:>

=end original

B<注意:>

=over

=item *

=begin original

Calling C<rand> automatically calls L<C<srand>|/srand EXPR> unless
srand has already been called.

=end original

C<rand> を呼び出すと、srand が既に呼ばれている場合以外は、自動的に
L<C<srand>|/srand EXPR> 関数を呼び出します。

=item *

=begin original

Currently EXPR with the value C<0> is special-cased as C<1>. This was
undocumented before Perl 5.8.0 and is subject to change in future versions of
Perl.

=end original

現在のところ、EXPR に値 C<0> をセットすると C<1> として特別扱いされます。
これは Perl 5.8.0 以前には文書化されておらず、将来のバージョンの perl では
変更される可能性があります。

=item *

=begin original

As of Perl v5.20.0 C<rand()> uses the C<drand48> pseudorandom number generator
to generate random numbers. As a PRNG C<drand48> should be sufficient for most
non-cryptographic needs. If you need cryptographic random numbers check CPAN
for crypto safe alternatives.

=end original

Perl v5.20.0 から、C<rand()> は乱数の生成に C<drand48> 疑似乱数生成器を
使います。
疑似乱数生成器として、C<drand48> はほとんどの非暗号的な用途に対して
充分です。
暗号的乱数が必要な場合は、暗号的に安全な代替案について CPAN を
チェックしてください。

=back

=over

=item B<Security:>

=begin original

B<C<rand> is not cryptographically secure.  You should not rely
on it in security-sensitive situations.>  As of this writing, a
number of third-party CPAN modules offer random number generators
intended by their authors to be cryptographically secure,
including:

=end original

B<C<rand> は暗号学的に安全ではありません。
セキュリティ的に重要な状況でこれに頼るべきではありません。>
これを書いている時点で、いくつかのサードパーティ CPAN モジュールが
作者によって暗号学的に安全であることを目的とした乱数生成器を
提供しています:

=back

=over

=item * L<Crypt::URandom>

=item * L<Crypt::PRNG>

=back

=item read FILEHANDLE,SCALAR,LENGTH,OFFSET
X<read> X<file, read>

=item read FILEHANDLE,SCALAR,LENGTH

=for Pod::Functions fixed-length buffered input from a filehandle

=begin original

Attempts to read LENGTH I<characters> of data into variable SCALAR
from the specified FILEHANDLE.  Returns the number of characters
actually read, C<0> at end of file, or undef if there was an error (in
the latter case L<C<$!>|perlvar/$!> is also set).  SCALAR will be grown
or shrunk
so that the last character actually read is the last character of the
scalar after the read.

=end original

指定した FILEHANDLE から、変数 SCALAR に LENGTH I<文字> のデータを
読み込みます。
実際に読み込まれた文字数、ファイル終端の場合は C<0>、エラーの場合は undef の
いずれかを返します (後者の場合、L<C<$!>|perlvar/$!> もセットされます)。
SCALAR は伸び縮みするので、読み込み後は、実際に読み込んだ最後の文字がスカラの
最後の文字になります。

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET を指定すると、文字列の先頭以外の場所から読み込みを行なえます。
OFFSET に負の値を指定すると、文字列の最後から逆向きに何文字目かで
位置を指定します。
OFFSET が正の値で、SCALAR の長さよりも大きかった場合、文字列は読み込みの結果が
追加される前に、必要なサイズまで C<"\0"> のバイトでパッディングされます。

    open(my $FH, "<", "input.txt") or die("Cannot open file: $!");

    my $buf = "";
    my $num = 0;

    # Read 32 bytes
    $num = read($FH, $buf, 32);

    # Read 16 bytes into position 1024 of $buf
    $num = read($FH, $buf, 16, 1024);

=begin original

The call is implemented in terms of either Perl's or your system's native
L<fread(3)> library function, via the L<PerlIO> layers applied to the
handle.  To get a true L<read(2)> system call, see
L<sysread|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>.

=end original

この関数は、Perl か システムの L<fread(3)> ライブラリ関数を使って、
ハンドルに適用されている L<PerlIO> 層経由で実装されています。
本当の L<read(2)> システムコールを利用するには、
L<sysread|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> を参照してください。

=begin original

Note the I<characters>: depending on the status of the filehandle,
either (8-bit) bytes or characters are read.  By default, all
filehandles operate on bytes, but for example if the filehandle has
been opened with the C<:utf8> I/O layer (see
L<C<open>|/open FILEHANDLE,MODE,EXPR>, and the L<open>
pragma), the I/O will operate on UTF8-encoded Unicode
characters, not bytes.  Similarly for the C<:encoding> layer:
in that case pretty much any characters can be read.

=end original

I<文字> に関する注意: ファイルハンドルの状態によって、(8 ビットの) バイトか
文字が読み込まれます。
デフォルトでは全てのファイルハンドルはバイトを処理しますが、
例えばファイルハンドルが C<:utf8> I/O 層
(L<C<open>|/open FILEHANDLE,MODE,EXPR>, L<open> プラグマを参照してください) で
開かれた場合、I/O はバイトではなく、
UTF8 エンコードされた Unicode 文字を操作します。
C<:encoding> 層も同様です:
この場合、ほとんど大体全ての文字が読み込めます。

=item readdir DIRHANDLE
X<readdir>

=for Pod::Functions get a directory from a directory handle

=begin original

Returns the next directory entry for a directory opened by
L<C<opendir>|/opendir DIRHANDLE,EXPR>.
If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns the undefined value in
scalar context and the empty list in list context.

=end original

L<C<opendir>|/opendir DIRHANDLE,EXPR> でオープンしたディレクトリで、次の
ディレクトリエントリを返します。
リストコンテキストで用いると、そのディレクトリの残りのエントリを、すべて
返します。
エントリが残っていない場合には、スカラコンテキストでは未定義値を、
リストコンテキストでは空リストを返します。

=begin original

If you're planning to filetest the return values out of a
C<readdir>, you'd better prepend the directory in
question.  Otherwise, because we didn't L<C<chdir>|/chdir EXPR> there,
it would have been testing the wrong file.

=end original

C<readdir> の返り値をファイルテストに使おうと
計画しているなら、頭にディレクトリをつける必要があります。
さもなければ、ここでは L<C<chdir>|/chdir EXPR> はしないので、
間違ったファイルをテストしてしまうことになるでしょう。

    opendir(my $dh, $some_dir) || die "Can't opendir $some_dir: $!";
    my @dots = grep { /^\./ && -f "$some_dir/$_" } readdir($dh);
    closedir $dh;

=begin original

As of Perl 5.12 you can use a bare C<readdir> in a
C<while> loop, which will set L<C<$_>|perlvar/$_> on every iteration.
If either a C<readdir> expression or an explicit assignment of a
C<readdir> expression to a scalar is used as a C<while>/C<for> condition,
then the condition actually tests for definedness of the expression's
value, not for its regular truth value.

=end original

Perl 5.12 から裸の C<readdir> を C<while> で
使うことができ、この場合繰り返し毎に L<C<$_>|perlvar/$_> にセットされます。
C<readdir> 式または C<readdir> 式からスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

    opendir(my $dh, $some_dir) || die "Can't open $some_dir: $!";
    while (readdir $dh) {
        print "$some_dir/$_\n";
    }
    closedir $dh;

=begin original

To avoid confusing would-be users of your code who are running earlier
versions of Perl with mysterious failures, put this sort of thing at the
top of your file to signal that your code will work I<only> on Perls of a
recent vintage:

=end original

あなたのコードを以前のバージョンの Perl で実行したユーザーが不思議な
失敗で混乱することを避けるために、コードが最近のバージョンの Perl で
I<のみ> 動作することを示すためにファイルの先頭に以下のようなことを
書いてください:

    use v5.12; # so readdir assigns to $_ in a lone while test

=item readline EXPR

=item readline
X<readline> X<gets> X<fgets>

=for Pod::Functions fetch a record from a file

=begin original

Reads from the filehandle whose typeglob is contained in EXPR (or from
C<*ARGV> if EXPR is not provided).  In scalar context, each call reads and
returns the next line until end-of-file is reached, whereupon the
subsequent call returns L<C<undef>|/undef EXPR>.  In list context, reads
until end-of-file is reached and returns a list of lines.  Note that the
notion of "line" used here is whatever you may have defined with
L<C<$E<sol>>|perlvar/$E<sol>> (or C<$INPUT_RECORD_SEPARATOR> in
L<English>).  See L<perlvar/"$/">.

=end original

型グロブが EXPR (EXPR がない場合は C<*ARGV>) に含まれている
ファイルハンドルから読み込みます。
スカラコンテキストでは、呼び出し毎に一行読み込んで返します; ファイルの
最後まで読み込んだら、以後の呼び出しでは L<C<undef>|/undef EXPR> を返します。
リストコンテキストでは、ファイルの最後まで読み込んで、行のリストを返します。
ここでの「行」とは、L<C<$E<sol>>|perlvar/$E<sol>> (または
L<English> モジュールでは C<$INPUT_RECORD_SEPARATOR>) で
定義されることに注意してください。
L<perlvar/"$/"> を参照してください。

=begin original

When L<C<$E<sol>>|perlvar/$E<sol>> is set to L<C<undef>|/undef EXPR>,
when C<readline> is in scalar context (i.e., file
slurp mode), and when an empty file is read, it returns C<''> the first
time, followed by L<C<undef>|/undef EXPR> subsequently.

=end original

L<C<$E<sol>>|perlvar/$E<sol>> に L<C<undef>|/undef EXPR> を設定した場合は、
C<readline> はスカラコンテキスト (つまりファイル吸い込み
モード)となり、空のファイルを読み込んだ場合は、最初は C<''> を返し、
それ以降は L<C<undef>|/undef EXPR> を返します。

=begin original

This is the internal function implementing the C<< <EXPR> >>
operator, but you can use it directly.  The C<< <EXPR> >>
operator is discussed in more detail in L<perlop/"I/O Operators">.

=end original

これは C<< <EXPR> >> 演算子を実装している内部関数ですが、
直接使うこともできます。
C<< <EXPR> >> 演算子についてのさらなる詳細については
L<perlop/"I/O Operators"> で議論されています。

    my $line = <STDIN>;
    my $line = readline(STDIN);    # same thing

=begin original

If C<readline> encounters an operating system error,
L<C<$!>|perlvar/$!> will be set with the corresponding error message.
It can be helpful to check L<C<$!>|perlvar/$!> when you are reading from
filehandles you don't trust, such as a tty or a socket.  The following
example uses the operator form of C<readline> and dies
if the result is not defined.

=end original

C<readline> が OS のシステムエラーになると、
L<C<$!>|perlvar/$!> に対応するエラーメッセージがセットされます。
tty やソケットといった、信頼できないファイルハンドルから読み込む時には
L<C<$!>|perlvar/$!> をチェックするのが助けになります。
以下の例は演算子の形の C<readline> を使っており、結果が
未定義の場合は die します。

    while ( ! eof($fh) ) {
        defined( $_ = readline $fh ) or die "readline failed: $!";
        ...
    }

=begin original

Note that you can't handle C<readline> errors
that way with the C<ARGV> filehandle.  In that case, you have to open
each element of L<C<@ARGV>|perlvar/@ARGV> yourself since
L<C<eof>|/eof FILEHANDLE> handles C<ARGV> differently.

=end original

C<readline> のエラーは C<ARGV> ファイルハンドルの方法では
扱えないことに注意してください。
この場合、L<C<eof>|/eof FILEHANDLE> は C<ARGV> を異なった方法で扱うので、
L<C<@ARGV>|perlvar/@ARGV> のそれぞれの要素を自分でオープンする必要があります。

    foreach my $arg (@ARGV) {
        open(my $fh, $arg) or warn "Can't open $arg: $!";

        while ( ! eof($fh) ) {
            defined( $_ = readline $fh )
                or die "readline failed for $arg: $!";
            ...
        }
    }

=begin original

Like the C<< <EXPR> >> operator, if a C<readline> expression is
used as the condition of a C<while> or C<for> loop, then it will be
implicitly assigned to C<$_>.  If either a C<readline> expression or
an explicit assignment of a C<readline> expression to a scalar is used
as a C<while>/C<for> condition, then the condition actually tests for
definedness of the expression's value, not for its regular truth value.

=end original

C<< <EXPR> >> 演算子と同様、
C<readline> 式が C<while> や C<for> ループの条件として使われた場合、
これは暗黙に C<$_> に代入されます。
C<readline> 式または C<readline> 式からスカラへの明示的な代入が
C<while>/C<for> の条件部として使われた場合、
条件は通常の真の値かどうかではなく、式の値が定義されているかどうかを
テストします。

=item readlink EXPR
X<readlink>

=item readlink

=for Pod::Functions determine where a symbolic link is pointing

=begin original

Returns the value of a symbolic link, if symbolic links are
implemented.  If not, raises an exception.  If there is a system
error, returns the undefined value and sets L<C<$!>|perlvar/$!> (errno).
If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

シンボリックリンクが実装されていれば、シンボリックリンクの値を返します。
実装されていないときには、例外が発生します。
何らかのシステムエラーが検出されると、未定義値を返し、
L<C<$!>|perlvar/$!> (errno) を設定します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

=begin original

Portability issues: L<perlport/readlink>.

=end original

移植性の問題: L<perlport/readlink>。

=item readpipe EXPR

=item readpipe
X<readpipe>

=for Pod::Functions execute a system command and collect standard output

=begin original

EXPR is executed as a system command.
The collected standard output of the command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines with L<C<$E<sol>>|perlvar/$E<sol>> (or
C<$INPUT_RECORD_SEPARATOR> in L<English>)).
This is the internal function implementing the C<qx/EXPR/>
operator, but you can use it directly.  The C<qx/EXPR/>
operator is discussed in more detail in L<perlop/"C<qx/I<STRING>/>">.
If EXPR is omitted, uses L<C<$_>|perlvar/$_>.

=end original

EXPR がシステムコマンドとして実行されます。
コマンドの標準出力の内容が返されます。
スカラコンテキストでは、単一の(内部的に複数行の)文字列を返します。
リストコンテキストでは、行のリストを返します
(但し、行は L<C<$E<sol>>|perlvar/$E<sol>> (または L<English> モジュールでは
C<$INPUT_RECORD_SEPARATOR> で定義されます)。
これは C<qx/EXPR/> 演算子を実装する内部関数ですが、直接使うことも出来ます。
C<qx/EXPR/> 演算子は L<perlop/"C<qx/I<STRING>/>"> でより詳細に
述べられています。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

=item recv SOCKET,SCALAR,LENGTH,FLAGS
X<recv>

=for Pod::Functions receive a message over a Socket

=begin original

Receives a message on a socket.  Attempts to receive LENGTH characters
of data into variable SCALAR from the specified SOCKET filehandle.
SCALAR will be grown or shrunk to the length actually read.  Takes the
same flags as the system call of the same name.  Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.  If there's an error, returns the undefined value.
This call is actually implemented in terms of the L<recvfrom(2)> system call.
See L<perlipc/"UDP: Message Passing"> for examples.

=end original

ソケット上のメッセージを受信します。
指定されたファイルハンドル SOCKET から、変数 SCALAR に
LENGTH 文字のデータを読み込もうとします。
SCALAR は、実際に読まれた長さによって、大きくなったり、小さくなったりします。
同名のシステムコールと同じフラグが指定できます。
SOCKET のプロトコルが対応していれば、送信側のアドレスを返します。
エラー発生時には、未定義値を返します。
実際には、C の L<recvfrom(2)> を呼びます。
例については L<perlipc/"UDP: Message Passing"> を参照してください。

=begin original

Note that if the socket has been marked as C<:utf8>, C<recv> will
throw an exception.  The C<:encoding(...)> layer implicitly introduces
the C<:utf8> layer.  See L<C<binmode>|/binmode FILEHANDLE, LAYER>.

=end original

ソケットが C<:utf8> としてマークされている場合、
C<recv> は例外を投げることに注意してください。
C<:encoding(...)> 層は暗黙に C<:utf8> 層を導入します。
L<C<binmode>|/binmode FILEHANDLE, LAYER> を参照してください。

=item redo LABEL
X<redo>

=item redo EXPR

=item redo

=for Pod::Functions start this loop iteration over again

=begin original

The C<redo> command restarts the loop block without
evaluating the conditional again.  The L<C<continue>|/continue BLOCK>
block, if any, is not executed.  If
the LABEL is omitted, the command refers to the innermost enclosing
loop.  The C<redo EXPR> form, available starting in Perl 5.18.0, allows a
label name to be computed at run time, and is otherwise identical to C<redo
LABEL>.  Programs that want to lie to themselves about what was just input
normally use this command:

=end original

C<redo> コマンドは、条件を再評価しないで、ループブロックの
始めからもう一度実行を開始します。
L<C<continue>|/continue BLOCK> ブロックがあっても、実行されません。
LABEL が省略されると、コマンドは一番内側のループを参照します。
Perl 5.18.0 から利用可能な C<redo EXPR> 形式では、実行時に計算されるラベル名が
使えます; それ以外は C<redo LABEL> と同一です。
このコマンドは通常、自分への入力を欺くために使用します:

    # a simpleminded Pascal comment stripper
    # (warning: assumes no { or } in strings)
    LINE: while (<STDIN>) {
        while (s|({.*}.*){.*}|$1 |) {}
        s|{.*}| |;
        if (s|{.*| |) {
            my $front = $_;
            while (<STDIN>) {
                if (/}/) {  # end of comment?
                    s|^|$front\{|;
                    redo LINE;
                }
            }
        }
        print;
    }

=begin original

C<redo> cannot return a value from a block that typically
returns a value, such as C<eval {}>, C<sub {}>, or C<do {}>. It will perform
its flow control behavior, which precludes any return value. It should not be
used to exit a L<C<grep>|/grep BLOCK LIST> or L<C<map>|/map BLOCK LIST>
operation.

=end original

C<redo> は C<eval {}>, C<sub {}>, C<do {}> といった
典型的には値を返すブロックから値を返せません。
これは、返り値を不可能にするフロー制御の振る舞いを実行します。
L<C<grep>|/grep BLOCK LIST> や L<C<map>|/map BLOCK LIST> 操作を終了するのに
使うべきではありません。

=begin original

Note that a block by itself is semantically identical to a loop
that executes once.  Thus C<redo> inside such a block
will effectively turn it into a looping construct.

=end original

ブロック自身は一回だけ実行されるループと文法的に同一であることに
注意してください。
従って、ブロックの中で C<redo> を使うことで効果的に
ループ構造に変換します。

=begin original

See also L<C<continue>|/continue BLOCK> for an illustration of how
L<C<last>|/last LABEL>, L<C<next>|/next LABEL>, and
C<redo> work.

=end original

L<C<last>|/last LABEL>, L<C<next>|/next LABEL>, C<redo> が
どのように働くかについては L<C<continue>|/continue BLOCK> も参照してください。

=begin original

Unlike most named operators, this has the same precedence as assignment.
It is also exempt from the looks-like-a-function rule, so
C<redo ("foo")."bar"> will cause "bar" to be part of the argument to
C<redo>.

=end original

ほとんどの名前付き演算子と異なり、これは代入と同じ優先順位を持ちます。
また、関数のように見えるものの規則からも免れるので、C<redo ("foo")."bar"> と
すると "bar" は C<redo> への引数の一部となります。

=item ref EXPR
X<ref> X<reference>

=item ref

=for Pod::Functions find out the type of thing being referenced

=begin original

Examines the value of EXPR, expecting it to be a reference, and returns
a string giving information about the reference and the type of referent.
If EXPR is not specified, L<C<$_>|perlvar/$_> will be used.

=end original

リファレンスと想定される EXPR の値を調べて、
そのリファレンスとリファレンス先の型に関する情報を表す
文字列を返します。
EXPR が指定されていない場合、L<C<$_>|perlvar/$_> が使われます。

=begin original

If the operand is not a reference, then the empty string will be returned.
An empty string will only be returned in this situation.  C<ref> is often
useful to just test whether a value is a reference, which can be done
by comparing the result to the empty string.  It is a common mistake
to use the result of C<ref> directly as a truth value: this goes wrong
because C<0> (which is false) can be returned for a reference.

=end original

オペランドがリファレンスでない場合、空文字列が返されます。
空文字列はこの場合にのみ返されます。
結果を空文字列を比較することでできるので、
C<ref> は単にある値がリファレンスかどうかを調べるのにしばしば有用です。
C<ref> の結果を直接真の値として使うのは良くある誤りです:
リファレンスの場合に (偽である) C<0> が返されることがあるので、
これは誤りです。

=begin original

If the operand is a reference to a blessed object, then the name of
the class into which the referent is blessed will be returned.  C<ref>
doesn't care what the physical type of the referent is; blessing takes
precedence over such concerns.  Beware that exact comparison of C<ref>
results against a class name doesn't perform a class membership test:
a class's members also include objects blessed into subclasses, for
which C<ref> will return the name of the subclass.  Also beware that
class names can clash with the built-in type names (described below).
Use L<the C<isa> method|UNIVERSAL/C<< $obj->isa( TYPE ) >>> to test
class membership of a class name or blessed object, after ensuring it
is one of these things.  Alternatively, the
L<C<isa> operator|perlop/"Class Instance Operator"> can test class
membership without checking blessedness first.

=end original

オペランドが bless されたオブジェクトへのリファレンスの場合、
リファレンス先が bless されているクラス名が返されます。
C<ref> はリファレンス先の物理的な種類については気にしません;
bless されているかがそのような関心より優先されます。
C<ref> の結果とクラス名の正確な比較は、クラスの所属のテストを
実行しないことに注意してください:
C<ref> がサブクラスの名前を返す場合、
あるクラスのメンバはサブクラスに bless されているオブジェクトを
含んでいます。
クラス名は(後述する)組み込みの型名と衝突するかもしれないことにも
注意してください。
クラスの所属メンバか bless されたオブジェクトかを
(これらのどちらかであることを確認した後) テストするには、
L<C<isa> メソッド|UNIVERSAL/C<<
$obj->isa( TYPE ) >>> を使ってください。
あるいは、
L<C<isa> 演算子|perlop/"Class Instance Operator"> は、
最初に bless されているかを確認することなくクラスメンバをテストできます。

=begin original

If the operand is a reference to an unblessed object, then the return
value indicates the type of object.  If the unblessed referent is not
a scalar, then the return value will be one of the strings C<ARRAY>,
C<HASH>, C<CODE>, C<FORMAT>, or C<IO>, indicating only which kind of
object it is.  If the unblessed referent is a scalar, then the return
value will be one of the strings C<SCALAR>, C<VSTRING>, C<REF>, C<GLOB>,
C<LVALUE>, or C<REGEXP>, depending on the kind of value the scalar
currently has.   But note that C<qr//> scalars are created already
blessed, so C<ref qr/.../> will likely return C<Regexp>.  Beware that
these built-in type names can also be used as
class names, so C<ref> returning one of these names doesn't unambiguously
indicate that the referent is of the kind to which the name refers.

=end original

オペランドが bless されていないオブジェクトへのリファレンスの場合、
返り値はオブジェクトの型を示します。
bless されていないリファレンス先がスカラではない場合、
返り値はオブジェクトの種類を示す、
C<ARRAY>, C<HASH>, C<CODE>, C<FORMAT>, C<IO> のいずれかの文字列です。
bless されていないリファレンス先がスカラの場合、
返り値はそのスカラが現在保持している種類に依存して、
C<SCALAR>, C<VSTRING>, C<REF>, C<GLOB>, C<LVALUE>, C<REGEXP> の
いずれかの文字列です。
しかし、C<qr//> は既に bless されて作成されるので、
C<ref qr/.../> はおそらく C<Regexp> を返すことに注意してください。
これらの組み込み型名はまたクラス名として使われることができるので、
C<ref> がこれらの名前の一つを返すことは、
明らかにリファレンス先がその名前が示している種類のものであることを
示しているわけではないことに注意してください。

=begin original

The ambiguity between built-in type names and class names may limit the
utility of C<ref>, but in practice, such clashes rarely occur unless
intentionally engineered.  For unambiguous information, use
L<builtin/blessed> for information about blessing, and L<builtin/reftype>
for information about physical types.  But beware that the physical type
returned by C<reftype> does not indicate how a blessed object is meant to
be used, and the appropriate dereference operations for an object
(whether to access the blessed structure directly, or via an L<overload>)
will be described by the documentation for the object class.

=end original

組み込み型とクラス名の間の曖昧さは C<ref> の有用性を制限しているかも
しれませんが、実際には、故意に企んだものでない限り、このようなクラスが
現れることはまれです。
曖昧でない情報のためには、bless に関する情報については L<builtin/blessed> を、
物理的な型の情報については L<builtin/reftype> を使ってください。
しかし、C<reftype> によって返された物理型は、bless されたオブジェクトが
どのように使われることを意味しているかを示しておらず、
(bless された構造に直接アクセスするか L<overload> 経由かに拘わらず)
オブジェクトに対する特有のデリファレンスは、オブジェクトクラスの
文書によって記述されていることに注意してください。

=begin original

See also L<perlref> and L<perlobj>.

=end original

L<perlref> と L<perlobj> も参照してください。

=item rename OLDNAME,NEWNAME
X<rename> X<move> X<mv> X<ren>

=for Pod::Functions change a filename

=begin original

Changes the name of a file; an existing file NEWNAME will be
clobbered.  Returns true for success; on failure returns false and sets
L<C<$!>|perlvar/$!>.

=end original

ファイルの名前を変更します; NEWNAME というファイルが既に存在した場合、
上書きされるかもしれません。
成功時には真を返します; 失敗時には偽を返し、
L<C<$!>|perlvar/$!> を設定します。

=begin original

Behavior of this function varies wildly depending on your system
implementation.  For example, it will usually not work across file system
boundaries, even though the system I<mv> command sometimes compensates
for this.  Other restrictions include whether it works on directories,
open files, or pre-existing files.  Check L<perlport> and either the
L<rename(2)> manpage or equivalent system documentation for details.

=end original

この関数の振る舞いはシステムの実装に大きく依存して異なります。
例えば、普通はファイルシステムにまたがってパス名を付け替えることはできません;
システムの I<mv> がこれを補完している場合でもそうです。
その他の制限には、ディレクトリ、オープンしているファイル、既に存在している
ファイルに対して使えるか、といったことを含みます。
詳しくは、L<perlport> および L<rename(2)> man ページあるいは同様の
システムドキュメントを参照してください。

=begin original

For a platform independent L<C<move>|File::Copy/move> function look at
the L<File::Copy> module.

=end original

プラットフォームに依存しない L<C<move>|File::Copy/move> 関数については
L<File::Copy> モジュールを参照してください。

=begin original

Portability issues: L<perlport/rename>.

=end original

移植性の問題: L<perlport/rename>。

=item require VERSION
X<require>

=item require EXPR

=item require

=for Pod::Functions load in external functions from a library at runtime

=begin original

Demands a version of Perl specified by VERSION, or demands some semantics
specified by EXPR or by L<C<$_>|perlvar/$_> if EXPR is not supplied.

=end original

VERSION で指定される Perl のバージョンを要求するか、
EXPR (省略時には L<C<$_>|perlvar/$_>) によって指定されるいくつかの動作を
要求します。

=begin original

VERSION may be either a literal such as v5.24.1, which will be
compared to L<C<$^V>|perlvar/$^V> (or C<$PERL_VERSION> in L<English>),
or a numeric argument of the form 5.024001, which will be compared to
L<C<$]>|perlvar/$]>. An exception is raised if VERSION is greater than
the version of the current Perl interpreter.  Compare with
L<C<use>|/use Module VERSION LIST>, which can do a similar check at
compile time.

=end original

VERSION は、v5.24.1 のようなリテラル
(L<C<$^V>|perlvar/$^V> (または L<English> モジュールでは
C<$PERL_VERSION>) と比較されます) か、
5.024001 の数値形式(L<C<$]>|perlvar/$]> と比較されます)で指定します。
VERSION が Perl の現在のバージョンより大きいと、例外が発生します。
L<C<use>|/use Module VERSION LIST> と似ていますが、これはコンパイル時に
チェックされます。

=begin original

Specifying VERSION as a numeric argument of the form 5.024001 should
generally be avoided as older less readable syntax compared to
v5.24.1. Before perl 5.8.0 (released in 2002), the more verbose numeric
form was the only supported syntax, which is why you might see it in
older code.

=end original

VERSION に 5.024001 の形の数値引数を指定することは一般的には避けるべきです;
v5.24.1 に比べてより古く読みにくい文法だからです。
(2002 年にリリースされた) perl 5.8.0 より前では、より冗長な
数値形式が唯一対応している文法でした; これが古いコードでこれを
見るかも知れない理由です。

=begin original

    require v5.24.1;    # run time version check
    require 5.24.1;     # ditto
    require 5.024_001;  # ditto; older syntax compatible
                          with perl 5.6

=end original

    require v5.24.1;    # 実行時バージョンチェック
    require 5.24.1;     # 同様
    require 5.024_001;  # 同様; perl 5.6 と互換性のある古い文法

=begin original

Otherwise, C<require> demands that a library file be
included if it hasn't already been included.  The file is included via
the do-FILE mechanism, which is essentially just a variety of
L<C<eval>|/eval EXPR> with the
caveat that lexical variables in the invoking script will be invisible
to the included code.  If it were implemented in pure Perl, it
would have semantics similar to the following:

=end original

それ以外の場合には、C<require> は、既に
読み込まれていないときに読み込むライブラリファイルを要求するものとなります。
そのファイルは、基本的には L<C<eval>|/eval EXPR> の一種である、
do-FILE によって読み込まれますが、起動したスクリプトのレキシカル変数は
読み込まれたコードから見えないという欠点があります。
ピュア Perl で実装した場合、意味的には、次のようなサブルーチンと
同じようなものです:

    use Carp 'croak';
    use version;

    sub require {
        my ($filename) = @_;
        if ( my $version = eval { version->parse($filename) } ) {
            if ( $version > $^V ) {
               my $vn = $version->normal;
               croak "Perl $vn required--this is only $^V, stopped";
            }
            return 1;
        }

        if (exists $INC{$filename}) {
            return 1 if $INC{$filename};
            croak "Compilation failed in require";
        }

        local $INC;
        # this type of loop lets a hook overwrite $INC if they wish
        for($INC = 0; $INC < @INC; $INC++) {
            my $prefix = $INC[$INC];
            if (!defined $prefix) {
                next;
            }
            if (ref $prefix) {
                #... do other stuff - see text below ....
            }
            # (see text below about possible appending of .pmc
            # suffix to $filename)
            my $realfilename = "$prefix/$filename";
            next if ! -e $realfilename || -d _ || -b _;
            $INC{$filename} = $realfilename;
            my $result = do($realfilename);
                         # but run in caller's namespace

            if (!defined $result) {
                $INC{$filename} = undef;
                croak $@ ? "$@Compilation failed in require"
                         : "Can't locate $filename: $!\n";
            }
            if (!$result) {
                delete $INC{$filename};
                croak "$filename did not return true value";
            }
            $! = 0;
            return $result;
        }
        croak "Can't locate $filename in \@INC ...";
    }

=begin original

Note that the file will not be included twice under the same specified
name.

=end original

ファイルは、同じ名前で 2 回読み込まれることはないことに注意してください。

=begin original

Historically the file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with C<1;> unless you're sure it'll return true
otherwise.  But it's better just to put the C<1;>, in case you add more
statements. As of 5.37.6 this requirement may be avoided by enabling
the 'module_true' feature, which is enabled by default in modern
version bundles. Thus code with C<use v5.37;> no longer needs to concern
itself with this issue. See L<feature> for more details. Note that this
affects the compilation unit within which the feature is used, and using
it before requiring a module will not change the behavior of existing
modules that do not themselves also use it.

=end original

歴史的に、初期化コードの実行がうまくいったことを示すために、ファイルは真を
返さなければならないので、真を返すようになっている自信がある場合を除いては、
ファイルの最後に C<1;> と書くのが習慣です。
しかし、実行文を追加するような場合に備えて、C<1;> と書いておいた方が良いです。
5.37.6 から、この要求は最近の機能の束ではデフォルトで有効になっている
'module_true' 機能を有効にすることで避けることができます。
従って C<use v5.37;> のあるコードは、もはやこの問題を考慮する必要は
ありません。
さらなる詳細については L<feature> を参照してください。
これはこの機能が使われているコンパイルユニットに影響を与え、
モジュールを require する前にこれを使うと、自分自身でこれを使っていない
既存のモジュールの振る舞いは変更しないことに注意してください。

=begin original

If EXPR is a bareword, C<require> assumes a F<.pm>
extension and replaces C<::> with C</> in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace, however it will autovivify
the stash for the required module.

=end original

EXPR が裸の単語であるときには、標準モジュールのロードを簡単にするように、
C<require> は拡張子が F<.pm> であり、C<::> を C</> に
変えたものがファイル名であると仮定します。
この形式のモジュールロードは、名前空間を変更してしまう危険はありませんが、
要求されたモジュールのためのスタッシュが自動有効化されます。

=begin original

In other words, if you try this:

=end original

言い換えると、以下のようにすると:

        require Foo::Bar;     # a splendid bareword

=begin original

The require function will actually look for the F<Foo/Bar.pm> file in the
directories specified in the L<C<@INC>|perlvar/@INC> array, and it will
autovivify the C<Foo::Bar::> stash at compile time.

=end original

require 関数は L<C<@INC>|perlvar/@INC> 配列で指定されたディレクトリにある
F<Foo/Bar.pm> ファイルを探し、コンパイル時に
C<Foo::Bar::> のスタッシュを自動有効化します。

=begin original

But if you try this:

=end original

しかし、以下のようにすると:

        my $class = 'Foo::Bar';
        require $class;       # $class is not a bareword
    #or
        require "Foo::Bar";   # not a bareword because of the ""

=begin original

The require function will look for the F<Foo::Bar> file in the
L<C<@INC>|perlvar/@INC>  array and
will complain about not finding F<Foo::Bar> there.  In this case you can do:

=end original

require 関数は L<C<@INC>|perlvar/@INC> 配列の F<Foo::Bar> ファイルを探し、
おそらくそこに F<Foo::Bar> がないと文句をいうことになるでしょう。
このような場合には、以下のように:

        eval "require $class";

=begin original

or you could do

=end original

あるいは次のようにも出来ます

        require "Foo/Bar.pm";

=begin original

Neither of these forms will autovivify any stashes at compile time and
only have run time effects.

=end original

これらのどちらもコンパイル時にスタッシュを自動有効化せず、
実行時の効果のみを持ちます。

=begin original

Now that you understand how C<require> looks for
files with a bareword argument, there is a little extra functionality
going on behind the scenes.  Before C<require> looks
for a F<.pm> extension, it will first look for a similar filename with a
F<.pmc> extension.  If this file is found, it will be loaded in place of
any file ending in a F<.pm> extension. This applies to both the explicit
C<require "Foo/Bar.pm";> form and the C<require Foo::Bar;> form.

=end original

引数が裸の単語の場合、C<require> がどのようにファイルを
探すかを理解してください; 水面下でちょっとした追加の機能があります。
C<require> が拡張子 F<.pm> のファイルを探す前に、まず
拡張子 F<.pmc> を持つファイルを探します。
このファイルが見つかると、このファイルが拡張子 F<.pm> の代わりに
読み込まれます。
これは明示的な C<require "Foo/Bar.pm";> 形式と C<require Foo::Bar;> 形式の
両方に適用されます。

=begin original

You can also insert hooks into the import facility by putting Perl
coderefs or objects directly into the L<C<@INC>|perlvar/@INC> array.
There are two types of hooks, INC filters, and INCDIR hooks, and there
are three forms of representing a hook: subroutine references, array
references, and blessed objects.

=end original

L<C<@INC>|perlvar/@INC> 配列に直接コードリファレンスやオブジェクトを
入れることで、インポート機能にフックを挿入できます。
INC フィルタと INCDIR フックの 2 種類のフックがあり、
フックの表現方法は 3 種類あります: サブルーチンリファレンス、
配列リファレンス、bless されたオブジェクトです。

=begin original

Subroutine references are the simplest case.  When the inclusion system
walks through L<C<@INC>|perlvar/@INC> and encounters a subroutine, unless
this subroutine is blessed and supports an INCDIR hook this
subroutine will be assumed to be an INC hook will be called with two
parameters, the first a reference to itself, and the second the name of
the file to be included (e.g., F<Foo/Bar.pm>).  The subroutine should
return either nothing or else a list of up to four values in the
following order:

=end original

サブルーチンへのリファレンスは一番単純な場合です。
インクルード機能が L<C<@INC>|perlvar/@INC> を走査してサブルーチンに
出会った場合、
このサブルーチンが bless されていて INCDIR フックに対応していない限り、
このサブルーチンは二つの引数と共に呼び出される INC フックであると
仮定されます;
一つ目は自身へのリファレンス、二つ目はインクルードされるファイル名
(F<Foo/Bar.pm> など)です。
サブルーチンは何も返さないか、以下の順で最大四つの値のリストを返します。

=over

=item 1

=begin original

A reference to a scalar, containing any initial source code to prepend to
the file or generator output.

=end original

ファイルやジェネレータの出力の前に追加される初期化ソースコードを含む
スカラへのリファレンス。

=item 2

=begin original

A filehandle, from which the file will be read.

=end original

ファイルが読み込まれるファイルハンドル。 

=item 3

=begin original

A reference to a subroutine.  If there is no filehandle (previous item),
then this subroutine is expected to generate one line of source code per
call, writing the line into L<C<$_>|perlvar/$_> and returning 1, then
finally at end of file returning 0.  If there is a filehandle, then the
subroutine will be called to act as a simple source filter, with the
line as read in L<C<$_>|perlvar/$_>.
Again, return 1 for each valid line, and 0 after all lines have been
returned.
For historical reasons the subroutine will receive a meaningless argument
(in fact always the numeric value zero) as C<$_[0]>.

=end original

サブルーチンへのリファレンス。
(一つ前のアイテムである)ファイルハンドルがない場合、サブルーチンは呼び出し毎に
一行のソースコードを生成し、その行を L<C<$_>|perlvar/$_> に書き込んで 1 を
返し、それから最終的にファイル終端で 0 を返すものと想定されます。
ファイルハンドルがある場合、サブルーチンは単純なソースフィルタとして
振舞うように呼び出され、行は L<C<$_>|perlvar/$_> から読み込まれます。
再び、有効な行ごとに 1 を返し、全ての行を返した後では 0 を返します。
歴史的な理由により、サブルーチンは C<$_[0]> として意味のない引数
(実際には常に数値 0) を受け取ります。

=item 4

=begin original

Optional state for the subroutine.  The state is passed in as C<$_[1]>.

=end original

サブルーチンのための状態(オプション)。
状態は C<$_[1]> として渡されます。

=back

=begin original

C<AUTOLOAD> cannot be used to resolve the C<INCDIR> method, C<INC> is
checked first, and C<AUTOLOAD> would resolve that.

=end original

C<AUTOLOAD> は C<INCDIR> メソッドを解決するのには使えません;
C<INC> が最初にチェックされ、そして C<AUTOLOAD> がそれを解決します。

=begin original

If an empty list, L<C<undef>|/undef EXPR>, or nothing that matches the
first 3 values above is returned, then C<require>
looks at the remaining elements of L<C<@INC>|perlvar/@INC>.
Note that this filehandle must be a real filehandle (strictly a typeglob
or reference to a typeglob, whether blessed or unblessed); tied filehandles
will be ignored and processing will stop there.

=end original

空リスト、L<C<undef>|/undef EXPR>、または上記の最初の三つの値のどれとも
一致しないものが返されると、C<require> は
L<C<@INC>|perlvar/@INC> の残りの要素を見ます。
このファイルハンドルは実際のファイルハンドル(厳密には型グロブ、型グロブへの
リファレンス、bless されているかに関わらず)でなければなりません;
tie されたファイルハンドルは無視され、返り値の処理はそこで停止します。

=begin original

If the hook is an object, it should provide an C<INC> or C<INCDIR>
method that will be called as above, the first parameter being the
object itself. If it does not provide either method, and the object is
not CODE ref then an exception will be thrown, otherwise it will simply
be executed like an unblessed CODE ref would. Note that you must fully
qualify the method name when you declare an C<INC> sub (unlike the
C<INCDIR> sub), as the unqualified symbol C<INC> is always forced into
package C<main>.  Here is a typical code layout for an C<INC> hook:

=end original

フックがオブジェクトの場合、C<INC> か C<INCDIR> メソッドを提供している
必要があります;
それが、最初の引数をオブジェクト自身として上述のように呼び出されます。
どちらのメソッドも提供されず、オブジェクトが CODE リファレンスでない場合は
例外が発生し、さもなければ
単に bless されていない CODE リファレンスのように実行されます。
修飾されていない C<INC> シンボルは常にパッケージ C<main> に強制されるため、
C<INC> サブルーチンを宣言する場合は、
(C<INCDIR> サブルーチンと異なり) 
完全修飾しなければならないことに注意してください。
以下は C<INC> フックの典型的なコードレイアウトです:

    # In Foo.pm
    package Foo;
    sub new { ... }
    sub Foo::INC {
        my ($self, $filename) = @_;
        ...
    }

    # In the main program
    push @INC, Foo->new(...);

=begin original

If the hook is an array reference, its first element must be a
subroutine reference or an object as described above. When the first
element is an object that supports an C<INC> or C<INCDIR> method then
the method will be called with the object as the first argument, the
filename requested as the second, and the hook array reference as
the third. When the first element is a subroutine then it will be
called with the array as the first argument, and the filename as the
second, no third parameter will be passed in. In both forms you can
modify the contents of the array to provide state between calls, or
whatever you like.

=end original

フックが配列のリファレンスの場合、その最初の要素は前述の通り、
サブルーチンリファレンスかオブジェクトでなければなりません。
最初の要素がC<INC> か C<INCDIR> メソッドに対応したオブジェクトの場合、
最初の引数をオブジェクト、2 番目を要求されたファイル名、3 番目を
フックの配列リファレンスとして、このメソッドが呼び出されます。
最初の要素がサブルーチンの場合、最初の引数を配列、
2 番目をファイル名、3 番目はなしでこれが呼び出されます。
両方の形式で、呼び出しの間の状態を提供したり、あるいは
好きな理由で、配列の内容を変更できます。

=begin original

In other words, you can write:

=end original

言い換えると、以下のように書けます:

    push @INC, \&my_sub;
    sub my_sub {
        my ($coderef, $filename) = @_;  # $coderef is \&my_sub
        ...
    }

=begin original

or:

=end original

または:

    push @INC, [ \&my_sub, $x, $y, ... ];
    sub my_sub {
        my ($arrayref, $filename) = @_;
        # Retrieve $x, $y, ...
        my (undef, @parameters) = @$arrayref;
        ...
    }

=begin original

or:

=end original

または:

    push @INC, [ HookObj->new(), $x, $y, ... ];
    sub HookObj::INC {
        my ($self, $filename, $arrayref)= @_;
        my (undef, @parameters) = @$arrayref;
        ...
    }

=begin original

These hooks are also permitted to set the L<C<%INC>|perlvar/%INC> entry
corresponding to the files they have loaded.  See L<perlvar/%INC>.
Should an C<INC> hook not do this then perl will set the C<%INC> entry
to be the hook reference itself.

=end original

これらのフックは、読み込まれるファイルに対応する
L<C<%INC>|perlvar/%INC> エントリをセットすることも許可します。
L<perlvar/%INC> を参照してください。
C<INC> フックがこれをしない場合、perl は C<%INC> エントリに
フックリファレンス自身を設定します。

=begin original

A hook may also be used to rewrite the C<@INC> array. While this might
sound strange, there are situations where it can be very useful to do
this. Such hooks usually just return undef and do not mix filtering and
C<@INC> modifications. While in older versions of perl having a hook
modify C<@INC> was fraught with issues and could even result in
segfaults or assert failures, as of 5.37.7 the logic has been made much
more robust and the hook now has control over the loop iteration if it
wishes to do so.

=end original

フックは C<@INC> 配列を書き換えるために使うこともできます。
これは奇妙に聞こえるかもしれませんが、これを行うことが非常に
有用な状況があります。
このようなフックは通常 undef を返すだけで、フィルタリングと
C<@INC> の修正を混合しません。
古いバージョンの perl では、フック修正 C<@INC> を持つことは
問題をはらんでおり、セグメンテーションフォルトやアサート失敗を
引き起こす可能性さえありましたが、5.37.7 の時点で、ロジックは
はるかに堅牢になり、フックは望むならループの反復を
制御できるようになりました。

=begin original

There is a now a facility to control the iterator for the C<@INC> array
traversal that is performed during require. The C<$INC> variable will be
initialized with the index of the currently executing hook. Once the
hook returns the next slot in C<@INC> that will be checked will be the
integer successor of value in C<$INC> (or -1 if it is undef). For example
the following code

=end original

require 中に実行される、C<@INC> 配列探索の反復子を
制御する機能が追加されました。
C<$INC> 変数は、現在実行中のフックのインデックスで初期化されます。
フックから返ると、チェックされる C<@INC> の次のスロットは、
C<$INC> の値の整数の次の値になります(undef の場合は -1 になります)。
たとえば、次のコードは

    push @INC, sub {
        splice @INC, $INC, 1; # remove this hook from @INC
        unshift @INC, sub { warn "A" };
        undef $INC; # reset the $INC iterator so we
                    # execute the newly installed sub
                    # immediately.
    };

=begin original

would install a sub into C<@INC> that when executed as a hook (by for
instance a require of a file that does not exist), the hook will splice
itself out of C<@INC>, and add a new sub to the front that will warn
whenever someone does a require operation that requires an C<@INC>
search, and then immediately execute that hook.

=end original

これは C<@INC> にサブルーチンをインストールし、
(例えば、存在しないファイルの require によって)フックとして実行されると、
フックは C<@INC> から自分自身を切り出し、誰かが C<@INC> 検索を
必要とする require 操作をしたときに警告し、すぐにそのフックを
実行する新しいサブルーチンを先頭に追加します。

=begin original

Prior to 5.37.7, there was no way to cause perl to use the newly
installed hook immediately, or to inspect any changed items in C<@INC> to
the left of the iterator, and so the warning would only be generated on
the second call to require. In more recent perl the presence of the last
statement which undefines C<$INC> will cause perl to restart the
traversal of the C<@INC> array at the beginning and execute the newly
installed sub immediately.

=end original

traverse
5.37.7 より前のバージョンでは、perl が新しくインストールされた
フックをすぐに使ったり、反復子の左側にある C<@INC> の
変更された項目を検査したりする方法がなかったため、警告は
2 番目の呼び出しでのみ生成されていました。
最近の perl では、C<$INC> をを未定義にした最後の文が
存在すると、perl は C<@INC> 配列の検査をを最初からやり直し、
新しくインストールされたサブルーチンをすぐに実行します。

=begin original

Whatever value C<$INC> held, if any, will be restored at the end of the
require. Any changes made to C<$INC> during the lifetime of the hook
will be unrolled after the hook exits, and its value only has meaning
immediately after execution of the hook, thus setting C<$INC> to some
value prior to executing a C<require> will have no effect on how the
require executes at all.

=end original

C<$INC> が保持していた値は、もしあれば、require の最後に復元されます。
フックの存続期間中に C<$INC> に加えられた変更は、フックが終了した
後に巻き戻され、その値はフックの実行直後にのみ意味を持つので、
C<require> を実行する前に C<$INC> を何らかの値に
設定しても、require の実行方法にはまったく影響しません。

=begin original

As of 5.37.7 C<@INC> values of undef will be silently ignored.

=end original

5.37.7 から、C<@INC> 内の未定義値は暗黙に無視されます。

=begin original

The function C<require()> is difficult to wrap properly. Many modules
consult the stack to find information about their caller, and injecting
a new stack frame by wrapping C<require()> often breaks things.
Nevertheless it can be very helpful to have the ability to perform
actions before and after a C<require>, for instance for trace utilities
like C<Devel::TraceUse> or to measure time to load and the memory
consumption of the require graph. Because of the difficulties in safely
creating a C<require()> wrapper in 5.37.10 we introduced a new mechanism.

=end original

C<require()> 関数を適切にラップするのは困難です。
多くのモジュールは呼び出し元に関する情報を見つけるためにスタックを参照し、
C<require()> をラップすることによる新しいスタックフレームの注入は、
しばしば問題を起こします。
それにも拘わらず、C<require> の前後にアクションを実行できる機能を
持つことは非常に便利です;
たとえば、C<Devel::TraceUse> のようなトレースユーティリティや、
require グラフのロード時間とメモリ消費を測定する機能などです。
C<require()> ラッパーを安全に作成することが
困難であったため、5.37.10 で新しいメカニズムを導入しました。

=begin original

As of 5.37.10, prior to any other actions it performs, C<require> will
check if C<${^HOOK}{require__before}> contains a coderef, and if it does
it will be called with the filename form of the item being loaded. The hook
may modify C<$_[0]> to load a different filename, or it may throw a fatal
exception to cause the require to fail, which will be treated as though the
required code itself had thrown an exception.

=end original

5.37.10 以降では、他のアクションが実行される前に、C<require> は
C<${^HOOK}{require__before}> にコードリファレンスが
含まれているかどうかをチェックし、含まれている場合は、
それは読み込まれる要素のファイル名形式で呼び出されます。
フックは別のファイル名をロードするために C<$_[0]> を変更することも、
require を失敗させるために致命的な例外を投げることもできます;
これはしかし、要求されたコード自体が例外を投げたたかのように扱われます。

=begin original

The C<${^HOOK}{require__before}> hook may return a code reference, in
which case the code reference will be executed (in an eval with the
filename as a parameter) after the require completes. It will be executed
regardless of how the compilation completed, and even if the require
throws a fatal exception.  The function may consult C<%INC> to determine
if the require failed or not.  For instance the following code will print
some diagnostics before and after every C<require> statement.  The
example also includes logic to chain the signal, so that multiple
signals can cooperate. Well behaved C<${^HOOK}{require__before}>
handlers should always take this into account.

=end original

C<${^HOOK}{require__before}> フックはコード参照を返すことがあります;
この場合、コード参照は require が完了した後に
(ファイル名を引数とした eval の中で) 実行されます。
コンパイルがどのように完了したかに関係なく、たとえ require が
致命的な例外を投げた場合でも実行されます。
関数は、require が失敗したかどうかを判断するために C<%INC> を参照します。
たとえば次のコードは、すべての C<require> ステートメントの
前後に診断を出力します。
この例には、複数のシグナルが連携できるようにシグナルを
チェーンするロジックも含まれています。
正しく振る舞う C<${^HOOK}{require__before}> ハンドラは、
常にこのことを考慮に入れる必要があります。

    {
        use Scalar::Util qw(reftype);
        my $old_hook = ${^HOOK}{require__before};
        local ${^HOOK}{require__before} = sub {
            my ($name) = @_;
            my $old_hook_ret;
            $old_hook_ret = $old_hook->($name) if $old_hook;
            warn "Requiring: $name\n";
            return sub {
                $old_hook_ret->() if ref($old_hook_ret)
                                  && reftype($old_hook_ret) eq "CODE";
                warn sprintf "Finished requiring %s: %s\n",
                        $name, $INC{$name} ? "loaded" :"failed";
            };
        };
        require Whatever;
    }

=begin original

This hook executes for ALL C<require> statements, unlike C<INC> and
C<INCDIR> hooks, which are only executed for relative file names, and it
executes first before any other special behaviour inside of require.
Note that the initial hook in C<${^HOOK}{require__before}> is *not*
executed inside of an eval, and throwing an exception will stop further
processing, but the after hook it may return is executed inside of an
eval, and any exceptions it throws will be silently ignored.  This is
because it executes inside of the scope cleanup logic that is triggered
after the require completes, and an exception at this time would not
stop the module from being loaded, etc.

=end original

このフックは、相対ファイル名に対してのみ実行される C<INC> フックや
C<INCDIR> フックとは異なり、すべての C<require> 文に対して
実行され、require 内の他の特別な振る舞いよりも先に実行されます。
C<${^HOOK}{require__before}> の初期のフックは、eval 内では
実行*されない*ことに注意してください;
例外を投げると、その後の処理は停止しますが、返る可能性のある
after フックは eval 内で実行され、投げられた例外は静かに
無視されます。
これは、require が完了した後にトリガされるスコープクリーンアップ
ロジック内で実行され、この時点で例外が発生してもモジュールの
読み込みなどは停止しないためです。

=begin original

There is a similar hook that fires after require completes,
C<${^HOOK}{require__after}>, which will be called after each require statement
completes, either via an exception or successfully. It will be called with
the filename of the most recently executed require statement. It is executed
in an eval, and will not in any way affect execution.

=end original

require が完了した後に起動する同様のフック C<${^HOOK}{require__after}> が
あります; これは、各 require 文が完了した後に、例外または正常終了の
いずれかによって呼び出されます。
最後に実行された require 文のファイル名を使って呼び出されます。
これは eval で実行され、実行には影響しません。

=begin original

For a yet-more-powerful import facility built around C<require>, see
L<C<use>|/use Module VERSION LIST> and L<perlmod>.

=end original

C<require> 関連で構築されている、より強力な import 機能については、
この文書の L<C<use>|/use Module VERSION LIST> の項と、
L<perlmod> を参照してください。

=item reset EXPR
X<reset>

=item reset

=for Pod::Functions clear all variables of a given name

=begin original

Generally used in a L<C<continue>|/continue BLOCK> block at the end of a
loop to clear variables and reset C<m?pattern?> searches so that they
work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables (scalars, arrays, and hashes)
in the current package beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (C<m?pattern?>) are reset to match again.
Only resets variables or searches in the current package.  Always returns
1.  Examples:

=end original

通常、ループの最後に、変数をクリアし、C<m?pattern?> 検索を再び動作するように
リセットするため、L<C<continue>|/continue BLOCK> ブロックで使われます。
EXPR は、文字を並べたもの (範囲を指定するのに、ハイフンが使えます) と
解釈されます。
名前がその文字のいずれかで始まる、現在のパッケージの全ての変数
(スカラ、配列、ハッシュ)は、
最初の状態にリセットされます。
EXPR を省略すると、1 回検索 (C<m?pattern?>) を再びマッチするように
リセットできます。
カレントパッケージの変数もしくは検索だけがリセットされます。
常に 1 を返します。
例:

    reset 'X';      # reset all X variables
    reset 'a-z';    # reset lower case variables
    reset;          # just reset m?one-time? searches

=begin original

Resetting C<"A-Z"> is not recommended because you'll wipe out your
L<C<@ARGV>|perlvar/@ARGV> and L<C<@INC>|perlvar/@INC> arrays and your
L<C<%ENV>|perlvar/%ENV> hash.

=end original

reset C<"A-Z"> とすると、L<C<@ARGV>|perlvar/@ARGV>,
L<C<@INC>|perlvar/@INC> 配列や L<C<%ENV>|perlvar/%ENV> ハッシュも
なくなってしまうので、止めた方が良いでしょう。

=begin original

Resets only package variables; lexical variables are unaffected, but
they clean themselves up on scope exit anyway, so you'll probably want
to use them instead.  See L<C<my>|/my VARLIST>.

=end original

パッケージ変数だけがリセットされます; レキシカル変数は影響を受けませんが、
スコープから外れれば自動的に綺麗になるので、これからはこちらを
使うようにした方がよいでしょう。
L<C<my>|/my VARLIST> を参照してください。

=item return EXPR
X<return>

=item return

=for Pod::Functions get out of a function early

=begin original

Returns from a subroutine, L<C<eval>|/eval EXPR>,
L<C<do FILE>|/do EXPR>, L<C<sort>|/sort SUBNAME LIST> block or regex
eval block (but not a L<C<grep>|/grep BLOCK LIST>,
L<C<map>|/map BLOCK LIST>, or L<C<do BLOCK>|/do BLOCK> block) with the value
given in EXPR.  Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see
L<C<wantarray>|/wantarray>).  If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in void context.

=end original

サブルーチン, L<C<eval>|/eval EXPR>, L<C<do FILE>|/do EXPR>,
L<C<sort>|/sort SUBNAME LIST> ブロックまたは正規表現 eval ブロック
(但し L<C<grep>|/grep BLOCK LIST>,
L<C<map>|/map BLOCK LIST>, L<C<do BLOCK>|/do BLOCK> ブロックではない) から
EXPR で与えられた値をもって、リターンします。
EXPR の評価は、返り値がどのように使われるかによってリスト、スカラ、
無効コンテキストになります; またコンテキストは実行毎に変わります
(L<C<wantarray>|/wantarray> を参照してください)。
EXPR が指定されなかった場合は、リストコンテキストでは空リストを、
スカラコンテキストでは未定義値を返します; そして(もちろん)
無効コンテキストでは何も返しません。

=begin original

(In the absence of an explicit C<return>, a subroutine,
L<C<eval>|/eval EXPR>,
or L<C<do FILE>|/do EXPR> automatically returns the value of the last expression
evaluated.)

=end original

(サブルーチン, L<C<eval>|/eval EXPR>, L<C<do FILE>|/do EXPR> に明示的に
C<return> がなければ、最後に評価された値で、
自動的にリターンします。)

=begin original

Unlike most named operators, this is also exempt from the
looks-like-a-function rule, so C<return ("foo")."bar"> will
cause C<"bar"> to be part of the argument to C<return>.

=end original

ほとんどの名前付き演算子と異なり、関数のように見えるものの規則からも
免れるので、C<return ("foo")."bar"> とすると C<"bar"> は
C<return> への引数の一部となります。

=item reverse LIST
X<reverse> X<rev> X<invert>

=for Pod::Functions flip a string or a list

=begin original

In list context, returns a list value consisting of the elements
of LIST in the opposite order.  In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.

=end original

リストコンテキストでは、LIST を構成する要素を逆順に並べた
リスト値を返します。
スカラコンテキストでは、LIST の要素を連結して、
全ての文字を逆順にした文字列を返します。

    print join(", ", reverse "world", "Hello"); # Hello, world

    print scalar reverse "dlrow ,", "olleH";    # Hello, world

=begin original

Used without arguments in scalar context, C<reverse>
reverses L<C<$_>|perlvar/$_>.

=end original

スカラコンテキストで引数なしで使うと、C<reverse> は
L<C<$_>|perlvar/$_> を逆順にします。

    $_ = "dlrow ,olleH";
    print reverse;                         # No output, list context
    print scalar reverse;                  # Hello, world

=begin original

Note that reversing an array to itself (as in C<@a = reverse @a>) will
preserve non-existent elements whenever possible; i.e., for non-magical
arrays or for tied arrays with C<EXISTS> and C<DELETE> methods.

=end original

(C<@a = reverse @a> のように) 反転した配列を自分自身に代入すると、
存在しない要素は可能なら(つまりマジカルでない配列や
C<EXISTS> と C<DELETE> メソッドがある tie された配列)
いつでも保存されることに注意してください。

=begin original

This operator is also handy for inverting a hash, although there are some
caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.

=end original

この演算子はハッシュの逆順にするのにも便利ですが、いくつかの弱点があります。
元のハッシュで値が重複していると、それらのうち一つだけが
逆順になったハッシュのキーとして表現されます。
また、これは一つのハッシュをほどいて完全に新しいハッシュを作るので、
DBM ファイルからのような大きなハッシュでは少し時間がかかります。

    my %by_name = reverse %by_address;  # Invert the hash

=item rewinddir DIRHANDLE
X<rewinddir>

=for Pod::Functions reset directory handle

=begin original

Sets the current position to the beginning of the directory for the
L<C<readdir>|/readdir DIRHANDLE> routine on DIRHANDLE.

=end original

DIRHANDLE に対する L<C<readdir>|/readdir DIRHANDLE> ルーチンの現在位置を
ディレクトリの最初に設定します。

=begin original

Portability issues: L<perlport/rewinddir>.

=end original

移植性の問題: L<perlport/rewinddir>。

=item rindex STR,SUBSTR,POSITION
X<rindex>

=item rindex STR,SUBSTR

=for Pod::Functions right-to-left substring search

=begin original

Works just like L<C<index>|/index STR,SUBSTR,POSITION> except that it
returns the position of the I<last>
occurrence of SUBSTR in STR.  If POSITION is specified, returns the
last occurrence beginning at or before that position.

=end original

STR 中で I<最後に> 見つかった SUBSTR の位置を返すことを除いて、
L<C<index>|/index STR,SUBSTR,POSITION> と同じように動作します。
POSITION を指定すると、その位置から始まるか、その位置より前の、
最後の位置を返します。

=item rmdir FILENAME
X<rmdir> X<rd> X<directory, remove>

=item rmdir

=for Pod::Functions remove a directory

=begin original

Deletes the directory specified by FILENAME if that directory is
empty.  If it succeeds it returns true; otherwise it returns false and
sets L<C<$!>|perlvar/$!> (errno).  If FILENAME is omitted, uses
L<C<$_>|perlvar/$_>.

=end original

FILENAME で指定したディレクトリが空であれば、
そのディレクトリを削除します。
成功時には真を返します; さもなければ偽を返して L<C<$!>|perlvar/$!>
(errno) を設定します。
FILENAME を省略した場合には、L<C<$_>|perlvar/$_> を使用します。

=begin original

To remove a directory tree recursively (C<rm -rf> on Unix) look at
the L<C<rmtree>|File::Path/rmtree( $dir )> function of the L<File::Path>
module.

=end original

ディレクトリツリーを再帰的に削除したい (Unix での C<rm -rf>) 場合、
L<File::Path> モジュールの L<C<rmtree>|File::Path/rmtree( $dir )> 関数を
参照してください。

=item s///

=for Pod::Functions replace a pattern with a string

=begin original

The substitution operator.  See L<perlop/"Regexp Quote-Like Operators">.

=end original

置換演算子。
L<perlop/"Regexp Quote-Like Operators"> を参照してください。

=item say FILEHANDLE LIST
X<say>

=item say FILEHANDLE

=item say LIST

=item say

=for Pod::Functions +say output a list to a filehandle, appending a newline

=begin original

Just like L<C<print>|/print FILEHANDLE LIST>, but implicitly appends a
newline at the end of the LIST instead of any value L<C<$\>|perlvar/$\>
might have.  To use FILEHANDLE without a LIST to
print the contents of L<C<$_>|perlvar/$_> to it, you must use a bareword
filehandle like C<FH>, not an indirect one like C<$fh>.

=end original

L<C<print>|/print FILEHANDLE LIST> と同様ですが、
L<C<$\>|perlvar/$\> の値の代わりに LIST の末尾に
改行が暗黙に追加されます。
L<C<$_>|perlvar/$_> の内容を表示するために LIST なしで FILEHANDLE を
使用するには、C<$fh> のような間接ファイルハンドルではなく、C<FH> のような
裸の単語のファイルハンドルを使わなければなりません。

=begin original

C<say> is available only if the
L<C<"say"> feature|feature/The 'say' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"say"> feature|feature/The 'say' feature> is enabled automatically
with a C<use v5.10> (or higher) declaration in the current scope.

=end original

C<say> は
L<C<"say"> 機能|feature/The 'say' feature> が有効か C<CORE::> が
前置されたときにのみ利用可能です。
L<C<"say"> 機能|feature/The 'say' feature> は現在のスコープで
C<use v5.10> (またはそれ以上) が宣言されると自動的に有効になります。

=item scalar EXPR
X<scalar> X<context>

=for Pod::Functions force a scalar context

=begin original

Forces EXPR to be interpreted in scalar context and returns the value
of EXPR.

=end original

EXPR を強制的にスカラコンテキストで解釈されるようにして、
EXPR の値を返します。

    my @counts = ( scalar @a, scalar @b, scalar @c );

=begin original

There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.  If you really wanted to do so, however, you could use
the construction C<@{[ (some expression) ]}>, but usually a simple
C<(some expression)> suffices.

=end original

式を強制的にリストコンテキストで解釈させるようにする演算子はありません;
理論的には不要だからです。
それでも、もしそうしたいのなら、C<@{[ (some expression) ]}> という構造を
使えます; しかし、普通は単に C<(some expression)> とすれば十分です。

=begin original

Because C<scalar> is a unary operator, if you
accidentally use a
parenthesized list for the EXPR, this behaves as a scalar comma expression,
evaluating all but the last element in void context and returning the final
element evaluated in scalar context.  This is seldom what you want.

=end original

C<scalar> は単項演算子なので、EXPR として括弧でくくった
リストを使った場合、これはスカラカンマ表現として振舞い、最後以外の全ては
無効コンテキストとして扱われ、最後の要素をスカラコンテキストとして扱った
結果が返されます。
これがあなたの望むものであることはめったにないでしょう。

=begin original

The following single statement:

=end original

以下の一つの文は:

    print uc(scalar(foo(), $bar)), $baz;

=begin original

is the moral equivalent of these two:

=end original

以下の二つの文と等価です。

    foo();
    print(uc($bar), $baz);

=begin original

See L<perlop> for more details on unary operators and the comma operator,
and L<perldata> for details on evaluating a hash in scalar context.

=end original

単項演算子とカンマ演算子に関する詳細については L<perlop> を、
スカラコンテキストでのハッシュの評価に関する詳細については L<perldata> を
参照してください。

=item seek FILEHANDLE,POSITION,WHENCE
X<seek> X<fseek> X<filehandle, position>

=for Pod::Functions reposition file pointer for random-access I/O

=begin original

Sets FILEHANDLE's position, just like the L<fseek(3)> call of C C<stdio>.
FILEHANDLE may be an expression whose value gives the name of the
filehandle.  The values for WHENCE are C<0> to set the new position
I<in bytes> to POSITION; C<1> to set it to the current position plus
POSITION; and C<2> to set it to EOF plus POSITION, typically
negative.  For WHENCE you may use the constants C<SEEK_SET>,
C<SEEK_CUR>, and C<SEEK_END> (start of the file, current position, end
of the file) from the L<Fcntl> module.  Returns C<1> on success, false
otherwise.

=end original

C の C<stdio> ライブラリの L<fseek(3)> 関数のように、FILEHANDLE の
ファイルポインタを任意の位置に設定します。
FILEHANDLE は、実際のファイルハンドル名を与える式でもかまいません。
WHENCE の値が、C<0> ならば、新しい位置を I<バイト単位で> POSITION の位置へ
設定します; C<1> ならば、現在位置から POSITION 加えた位置へ
設定します; C<2> ならば、EOF からPOSITION だけ加えた位置へ、新しい位置を
設定します。
この値には、L<Fcntl> モジュールで使われている C<SEEK_SET>、C<SEEK_CUR>、
C<SEEK_END> (ファイルの先頭、現在位置、ファイルの最後)という定数を
使うこともできます。
成功時には、C<1> を、失敗時にはそれ以外を返します。

=begin original

Note the emphasis on bytes: even if the filehandle has been set to operate
on characters (for example using the C<:encoding(UTF-8)> I/O layer), the
C<seek>,
L<C<tell>|/tell FILEHANDLE>, and
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>
family of functions use byte offsets, not character offsets,
because seeking to a character offset would be very slow in a UTF-8 file.

=end original

バイト単位に対する注意: 例え(例えば C<:encoding(UTF-8)> I/O 層を使うなどして)
ファイルハンドルが文字単位で処理するように設定されていたとしても、
C<seek>,
L<C<tell>|/tell FILEHANDLE>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> シリーズの関数は
文字オフセットではなくバイトオフセットを使います;
文字オフセットでシークするのは UTF-8 ファイルではとても遅いからです。

=begin original

If you want to position the file for
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> or
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>, don't use
C<seek>, because buffering makes its
effect on the file's read-write position unpredictable and non-portable.
Use L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> instead.

=end original

L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> や
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET> のためにファイルの
位置を指定したい場合は、C<seek> は
使えません; なぜならバッファリングのためにファイルの読み込み位置は
動作は予測不能で移植性のないものになってしまいます。
代わりに L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> を使ってください。

=begin original

Due to the rules and rigors of ANSI C, on some systems you have to do a
seek whenever you switch between reading and writing.  Amongst other
things, this may have the effect of calling stdio's L<clearerr(3)>.
A WHENCE of C<1> (C<SEEK_CUR>) is useful for not moving the file position:

=end original

ANSI C の規則と困難により、システムによっては読み込みと書き込みを
切り替える度にシークしなければならない場合があります。
その他のことの中で、これは stdio の L<clearerr(3)> を呼び出す効果があります。
WHENCE の C<1> (C<SEEK_CUR>) が、ファイル位置を変えないので有用です:

    seek($fh, 0, 1);

=begin original

This is also useful for applications emulating C<tail -f>.  Once you hit
EOF on your read and then sleep for a while, you (probably) have to stick in a
dummy C<seek> to reset things.  The
C<seek> doesn't change the position,
but it I<does> clear the end-of-file condition on the handle, so that the
next C<readline FILE> makes Perl try again to read something.  (We hope.)

=end original

これはアプリケーションで C<tail -f> をエミュレートするのにも有用です。
一度読み込み時に EOF に到達すると、しばらくスリープし、
(おそらく) ダミーの C<seek> をすることで
リセットする必要があります。
C<seek> は現在の位置を変更しませんが、
ハンドルの EOF 状態をI<クリアします> ので、次の C<readline FILE> で Perl は
再び何かを読み込もうとします。(そのはずです。)

=begin original

If that doesn't work (some I/O implementations are particularly
cantankerous), you might need something like this:

=end original

これが動かない場合(特に意地の悪い I/O 実装もあります)、
以下のようなことをする必要があります:

    for (;;) {
        for ($curpos = tell($fh); $_ = readline($fh);
             $curpos = tell($fh)) {
            # search for some stuff and put it into files
        }
        sleep($for_a_while);
        seek($fh, $curpos, 0);
    }

=item seekdir DIRHANDLE,POS
X<seekdir>

=for Pod::Functions reposition directory pointer

=begin original

Sets the current position for the L<C<readdir>|/readdir DIRHANDLE>
routine on DIRHANDLE.  POS must be a value returned by
L<C<telldir>|/telldir DIRHANDLE>.  C<seekdir>
also has the same caveats about possible directory compaction as the
corresponding system library routine.

=end original

DIRHANDLE での L<C<readdir>|/readdir DIRHANDLE> ルーチンの現在位置を
設定します。
POS は、L<C<telldir>|/telldir DIRHANDLE> が返す値でなければなりません。
C<seekdir> は同名のシステムライブラリルーチンと
同じく、ディレクトリ縮小時の問題が考えられます。

=item select FILEHANDLE
X<select> X<filehandle, default>

=item select

=for Pod::Functions reset default output or do I/O multiplexing

=begin original

Returns the currently selected filehandle.  If FILEHANDLE is supplied,
sets the new current default filehandle for output.  This has two
effects: first, a L<C<write>|/write FILEHANDLE>,  L<C<print>|/print
FILEHANDLE LIST>, or L<C<say>|/say FILEHANDLE LIST> without a
filehandle will default to this FILEHANDLE.  Second, references to variables
related to output will refer to this output channel.

=end original

その時点で、選択されていたファイルハンドルを返します。
FILEHANDLE を指定した場合には、その値を出力のデフォルトファイルハンドルに
設定します。
これには、2 つの効果があります: まず、ファイルハンドルを指定しないで
L<C<write>|/write FILEHANDLE>, L<C<print>|/print FILEHANDLE LIST>,
L<C<say>|/say FILEHANDLE LIST> を
行なった場合のデフォルトが、この FILEHANDLE になります。
もう一つは、出力関連の変数への参照は、この出力チャネルを
参照するようになります。 

=begin original

For example, to set the top-of-form format for more than one
output channel, you might do the following:

=end original

例えば、複数の出力チャネルに対して、ページ先頭フォーマットを
設定するには:

    select(REPORT1);
    $^ = 'report1_top';
    select(REPORT2);
    $^ = 'report2_top';

=begin original

FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.  Thus:

=end original

FILEHANDLE は、実際のファイルハンドル名を示す式でもかまいません。
つまり、以下のようなものです:

    my $oldfh = select(STDERR); $| = 1; select($oldfh);

=begin original

Some programmers may prefer to think of filehandles as objects with
methods, preferring to write the last example as:

=end original

ファイルハンドルはメソッドを持ったオブジェクトであると考えることを好む
プログラマもいるかもしれません; そのような場合のための最後の例は
以下のようなものです:

    STDERR->autoflush(1);

=begin original

(Prior to Perl version 5.14, you have to C<use IO::Handle;> explicitly
first.)

=end original

(Perl バージョン 5.14 以前では、まず明示的に C<use IO::Handle;> とする
必要があります。)

=begin original

Whilst you can use C<select> to temporarily "capture" the output of
C<print> like this:

=end original

一方、次のようにして、C<print> の出力を一時的に「捕捉」するために
C<select> を使えます:

    {
        my $old_handle = select $new_handle;

        # This goes to $new_handle:
        print "ok 1\n";
        ...

        select $old_handle;
    }

=begin original

you might find it easier to localize the typeglob instead:

=end original

代わりに型グロブをローカル化する方がより簡単かもしれません:

    {
        local *STDOUT = $new_handle;

        print "ok 1\n";
        ...
    }

=begin original

The two are not exactly equivalent, but the latter might be clearer and will
restore STDOUT if the wrapped code dies.  The difference is that in the
former, the original STDOUT can still be accessed by explicitly using it in a
C<print> statement (as C<print STDOUT ...>), whereas in the latter the meaning
of the STDOUT handle itself has temporarily been changed.

=end original

この二つはまったく同じではありませんが、後者の方がより明確で、
ラップされたコードが die した場合に STDOUT を復元します。
違いは、前者では、元の STDOUT は C<print> 文
(C<print STDOUT ...>など) で明示的に使うことでアクセスできるのに対し、
後者では STDOUT ハンドル自体の意味が一時的に変更されていることです。

=begin original

Portability issues: L<perlport/select>.

=end original

移植性の問題: L<perlport/select>。

=item select RBITS,WBITS,EBITS,TIMEOUT
X<select>

=begin original

This calls the L<select(2)> syscall with the bit masks specified, which
can be constructed using L<C<fileno>|/fileno FILEHANDLE> and
L<C<vec>|/vec EXPR,OFFSET,BITS>, along these lines:

=end original

これは、L<select(2)> システムコールを、指定したビットマスクで呼び出します;
ビットマスクは、L<C<fileno>|/fileno FILEHANDLE> と
L<C<vec>|/vec EXPR,OFFSET,BITS> を使って、以下のようにして作成できます:

    my $rin = my $win = my $ein = '';
    vec($rin, fileno(STDIN),  1) = 1;
    vec($win, fileno(STDOUT), 1) = 1;
    $ein = $rin | $win;

=begin original

If you want to select on many filehandles, you may wish to write a
subroutine like this:

=end original

複数のファイルハンドルに select を行ないたいのであれば、
以下のようにします:

    sub fhbits {
        my @fhlist = @_;
        my $bits = "";
        for my $fh (@fhlist) {
            vec($bits, fileno($fh), 1) = 1;
        }
        return $bits;
    }
    my $rin = fhbits(\*STDIN, $tty, $mysock);

=begin original

The usual idiom is:

=end original

通常は、

 my ($nfound, $timeleft) =
   select(my $rout = $rin, my $wout = $win, my $eout = $ein,
                                                          $timeout);

=begin original

or to block until something becomes ready just do this

=end original

のように使い、いずれかの準備が整うまでブロックするには、
以下のようにします。

 my $nfound =
   select(my $rout = $rin, my $wout = $win, my $eout = $ein, undef);

=begin original

Most systems do not bother to return anything useful in C<$timeleft>, so
calling C<select> in scalar context
just returns C<$nfound>.

=end original

ほとんどのシステムではわざわざ意味のある値を C<$timeleft> に返さないので、
C<select> をスカラコンテキストで
呼び出すと、単に C<$nfound> を返します。

=begin original

Any of the bit masks can also be L<C<undef>|/undef EXPR>.  The timeout,
if specified, is
in seconds, which may be fractional.  Note: not all implementations are
capable of returning the C<$timeleft>.  If not, they always return
C<$timeleft> equal to the supplied C<$timeout>.

=end original

どのビットマスクにも L<C<undef>|/undef EXPR> を設定することができます。
TIMEOUT を指定するときは、秒数で指定し、小数でかまいません。
注: すべての実装で、C<$timeleft> が返せるものではありません。
その場合、C<$timeleft> には、常に指定した C<$timeout> と同じ値が返されます。

=begin original

You can effect a sleep of 250 milliseconds this way:

=end original

250 ミリ秒の sleep と同じ効果が、以下のようにして得られます。

    select(undef, undef, undef, 0.25);

=begin original

Note that whether C<select> gets
restarted after signals (say, SIGALRM) is implementation-dependent.  See
also L<perlport> for notes on the portability of
C<select>.

=end original

C<select> がシグナル (例えば、SIGALRM) の
後に再起動するかどうかは実装依存であることに注意してください。
C<select> の移植性に関する
注意については L<perlport> も参照してください。

=begin original

On error, C<select> behaves just
like L<select(2)>: it returns C<-1> and sets L<C<$!>|perlvar/$!>.

=end original

エラー時は、C<select> は
L<select(2)> のように振舞います:
C<-1> を返し、L<C<$!>|perlvar/$!> をセットします。

=begin original

On some Unixes, L<select(2)> may report a socket file descriptor as
"ready for reading" even when no data is available, and thus any
subsequent L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> would block.
This can be avoided if you always use C<O_NONBLOCK> on the socket.  See
L<select(2)> and L<fcntl(2)> for further details.

=end original

Unix の中には、実際に利用可能なデータがないために引き続く
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> が
ブロックされる場合でも、L<select(2)> が、ソケットファイル記述子が
「読み込み準備中」であると報告するものもあります。
これは、ソケットに対して常に C<O_NONBLOCK> フラグを使うことで回避できます。
さらなる詳細については L<select(2)> と L<fcntl(2)> を参照してください。

=begin original

The standard L<C<IO::Select>|IO::Select> module provides a
user-friendlier interface to
C<select>, mostly because it does
all the bit-mask work for you.

=end original

標準の L<C<IO::Select>|IO::Select> モジュールは
C<select> へのよりユーザーフレンドリーな
インターフェースを提供します; 主な理由はビットマスクの仕事を
してくれることです。

=begin original

B<WARNING>: One should not attempt to mix buffered I/O (like
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> or
L<C<readline>|/readline EXPR>) with
C<select>, except as permitted by
POSIX, and even then only on POSIX systems.  You have to use
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> instead.

=end original

B<警告>: バッファ付き I/O (L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> や
L<C<readline>|/readline EXPR>) と
C<select> を
混ぜて使ってはいけません(例外: POSIX で認められている形で使い、
POSIX システムでだけ動かす場合を除きます)。
代わりに L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> を
使わなければなりません。

=begin original

Portability issues: L<perlport/select>.

=end original

移植性の問題: L<perlport/select>。

=item semctl ID,SEMNUM,CMD,ARG
X<semctl>

=for Pod::Functions SysV semaphore control operations

=begin original

Calls the System V IPC function L<semctl(2)>.  You'll probably have to say

=end original

System V IPC 関数 L<semctl(2)> を呼び出します。
正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is IPC_STAT or
GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.  Returns like
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR>:
the undefined value for error, "C<0 but true>" for zero, or the actual
return value otherwise.  The ARG must consist of a vector of native
short integers, which may be created with C<pack("s!",(0)x$nsem)>.
See also L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV> and L<C<IPC::Semaphore>|IPC::Semaphore>.

=end original

と書くことが必要でしょう。
CMD が、IPC_STAT か GETALL のときには、ARG は、返される
semid_ds 構造体か、セマフォ値の配列を納める変数でなければなりません。
L<C<ioctl>|/ioctl FILEHANDLE,FUNCTION,SCALAR> と同じように、エラー時には
未定義値、ゼロのときは C<"0 だが真">、それ以外なら、その値そのものを返します。
ARG はネイティブな short int のベクターから成っていなければなりません; これは
C<pack("s!",(0)x$nsem)> で作成できます。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Semaphore>|IPC::Semaphore> の文書も参照してください。

=begin original

Portability issues: L<perlport/semctl>.

=end original

移植性の問題: L<perlport/semctl>。

=item semget KEY,NSEMS,FLAGS
X<semget>

=for Pod::Functions get set of SysV semaphores

=begin original

Calls the System V IPC function L<semget(2)>.  Returns the semaphore id, or
the undefined value on error.  See also
L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV> and L<C<IPC::Semaphore>|IPC::Semaphore>.

=end original

System V IPC 関数 L<semget(2)> を呼び出します。
セマフォ ID か、エラー時には未定義値を返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Semaphore>|IPC::Semaphore> の文書も参照してください。

=begin original

Portability issues: L<perlport/semget>.

=end original

移植性の問題: L<perlport/semget>。

=item semop KEY,OPSTRING
X<semop>

=for Pod::Functions SysV semaphore operations

=begin original

Calls the System V IPC function L<semop(2)> for semaphore operations
such as signalling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with
C<pack("s!3", $semnum, $semop, $semflag)>.  The length of OPSTRING
implies the number of semaphore operations.  Returns true if
successful, false on error.  As an example, the
following code waits on semaphore $semnum of semaphore id $semid:

=end original

シグナルを送信や、待ち合わせなどのセマフォ操作を行なうために、
System V IPC 関数 L<semop(2)> を呼び出します。
OPSTRING は、semop 構造体の pack された配列でなければなりません。
semop 構造体は、それぞれ、C<pack("s!3", $semnum, $semop, $semflag)> のように
作ることができます。
セマフォ操作の数は、OPSTRING の長さからわかります。
成功時には真を、エラー時には偽を返します。
以下の例は、セマフォ ID $semid のセマフォ $semnum で
待ち合わせを行ないます。

    my $semop = pack("s!3", $semnum, -1, 0);
    die "Semaphore trouble: $!\n" unless semop($semid, $semop);

=begin original

To signal the semaphore, replace C<-1> with C<1>.  See also
L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV> and L<C<IPC::Semaphore>|IPC::Semaphore>.

=end original

セマフォにシグナルを送るには、C<-1> を C<1> に変更してください。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と
L<C<IPC::Semaphore>|IPC::Semaphore> の文書も参照してください。

=begin original

Portability issues: L<perlport/semop>.

=end original

移植性の問題: L<perlport/semop>。

=item send SOCKET,MSG,FLAGS,TO
X<send>

=item send SOCKET,MSG,FLAGS

=for Pod::Functions send a message over a socket

=begin original

Sends a message on a socket.  Attempts to send the scalar MSG to the SOCKET
filehandle.  Takes the same flags as the system call of the same name.  On
unconnected sockets, you must specify a destination to I<send to>, in which
case it does a L<sendto(2)> syscall.  Returns the number of characters sent,
or the undefined value on error.  The L<sendmsg(2)> syscall is currently
unimplemented.  See L<perlipc/"UDP: Message Passing"> for examples.

=end original

ソケットにメッセージを送ります。
スカラ MSG を ファイルハンドル SOCKET に送ろうとします。
同名のシステムコールと同じフラグが指定できます。
接続していないソケットには、I<send to> に接続先を指定しなければならず、
この場合、L<sendto(2)> を実行します。
送信した文字数か、エラー時には、未定義値を返します。
システムコール L<sendmsg(2)> は現在実装されていません。
例については L<perlipc/"UDP: Message Passing"> を参照してください。

=begin original

Note that if the socket has been marked as C<:utf8>, C<send> will
throw an exception.  The C<:encoding(...)> layer implicitly introduces
the C<:utf8> layer.  See L<C<binmode>|/binmode FILEHANDLE, LAYER>.

=end original

ソケットが C<:utf8> とマークされている場合、
C<send> は例外を投げることに注意してください。
C<:encoding(...)> 層は暗黙に C<:utf8> 層を導入します。
L<C<binmode>|/binmode FILEHANDLE, LAYER> を参照してください。

=item setpgrp PID,PGRP
X<setpgrp> X<group>

=for Pod::Functions set the process group of a process

=begin original

Sets the current process group for the specified PID, C<0> for the current
process.  Raises an exception when used on a machine that doesn't
implement POSIX L<setpgid(2)> or BSD L<setpgrp(2)>.  If the arguments
are omitted, it defaults to C<0,0>.  Note that the BSD 4.2 version of
C<setpgrp> does not accept any arguments, so only
C<setpgrp(0,0)> is portable.  See also
L<C<POSIX::setsid()>|POSIX/C<setsid>>.

=end original

指定した PID (C<0> を指定するとカレントプロセス) に
対するプロセスグループを設定します。
POSIX L<setpgrp(2)> または BSD L<setpgrp(2)> が実装されていないマシンでは、
例外が発生します。
引数が省略された場合は、C<0,0>が使われます。
BSD 4.2 版の C<setpgrp> は引数を取ることができないので、
C<setpgrp(0,0)> のみが移植性があることに注意してください。
L<C<POSIX::setsid()>|POSIX/C<setsid>> も参照してください。

=begin original

Portability issues: L<perlport/setpgrp>.

=end original

移植性の問題: L<perlport/setpgrp>。

=item setpriority WHICH,WHO,PRIORITY
X<setpriority> X<priority> X<nice> X<renice>

=for Pod::Functions set a process's nice value

=begin original

Sets the current priority for a process, a process group, or a user.
(See L<setpriority(2)>.)  Raises an exception when used on a machine
that doesn't implement L<setpriority(2)>.

=end original

プロセス、プロセスグループ、ユーザに対する優先順位を設定します。
(L<setpriority(2)> を参照してください。)
L<setpriority(2)> が実装されていないマシンでは、例外が発生します。

=begin original

C<WHICH> can be any of C<PRIO_PROCESS>, C<PRIO_PGRP> or C<PRIO_USER>
imported from L<POSIX/RESOURCE CONSTANTS>.

=end original

C<WHICH> は、L<POSIX/RESOURCE CONSTANTS> からインポートされた
C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER> のいずれかです。

=begin original

Portability issues: L<perlport/setpriority>.

=end original

移植性の問題: L<perlport/setpriority>。

=item setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
X<setsockopt>

=for Pod::Functions set some socket options

=begin original

Sets the socket option requested.  Returns L<C<undef>|/undef EXPR> on
error.  Use integer constants provided by the L<C<Socket>|Socket> module
for
LEVEL and OPNAME.  Values for LEVEL can also be obtained from
getprotobyname.  OPTVAL might either be a packed string or an integer.
An integer OPTVAL is shorthand for pack("i", OPTVAL).

=end original

要求したソケットオプションを設定します。
エラー時には、L<C<undef>|/undef EXPR> を返します。
LEVEL と OPNAME には L<C<Socket>|Socket> モジュールが提供する
整数定数を使います。
LEVEL の値は getprotobyname から得ることもできます。
OPTVAL は pack された文字列か整数です。
整数の OPTVAL は pack("i", OPTVAL) の省略表現です。

=begin original

An example disabling Nagle's algorithm on a socket:

=end original

ソケットに対する Nagle のアルゴリズムを無効にする例です:

    use Socket qw(IPPROTO_TCP TCP_NODELAY);
    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);

=begin original

Portability issues: L<perlport/setsockopt>.

=end original

移植性の問題: L<perlport/setsockopt>。

=item shift ARRAY
X<shift>

=item shift

=for Pod::Functions remove the first element of an array, and return it

=begin original

Removes and returns the B<first> element of an array. This shortens the
array by one and moves everything down.

=end original

配列の B<最初の> 値を削除して返します。
配列を一つ短くして、すべての要素を前へずらします。

    my @arr  = ('cat', 'dog');
    my $item = shift(@arr); # 'cat'

    # @arr is now ('dog');

=begin original

Returns C<undef> if the array is empty.

=end original

配列が空なら C<undef> を返します。

=begin original

B<Note:> C<shift> may also return C<undef> if the first element in the array
is C<undef>.

=end original

B<注意:> C<shift> は、配列の最初の要素が C<undef> の場合も C<undef> を
返します。

    my @arr  = (undef, 'two', 'three');
    my $item = shift(@arr); # undef

=begin original

If ARRAY is omitted, C<shift> operates on the C<@ARGV> array in the main
program, and the C<@_> array in subroutines. C<shift> will operate on the
C<@ARGV> array in C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}> blocks.

=end original

ARRAY が省略されると、C<shift> はメインプログラムでは C<@ARGV> 配列を、
サブルーチンでは C<@_> 配列を操作します。
C<shift> は C<eval STRING>, C<BEGIN {}>, C<INIT {}>, C<CHECK {}>
ブロックでは C<@ARGV> 配列を操作します。

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<shift> to take a
scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<shift> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=begin original

See also L<C<unshift>|/unshift ARRAY,LIST>, L<C<push>|/push ARRAY,LIST>,
and L<C<pop>|/pop ARRAY>.  C<shift> and
L<C<unshift>|/unshift ARRAY,LIST> do the same thing to the left end of
an array that L<C<pop>|/pop ARRAY> and L<C<push>|/push ARRAY,LIST> do to
the right end.

=end original

L<C<unshift>|/unshift ARRAY,LIST>、L<C<push>|/push ARRAY,LIST>、
L<C<pop>|/pop ARRAY> も参照してください。
C<shift> と L<C<unshift>|/unshift ARRAY,LIST> は、
L<C<pop>|/pop ARRAY> と L<C<push>|/push ARRAY,LIST> が配列の右端で
行なうことを、左端で行ないます。

=item shmctl ID,CMD,ARG
X<shmctl>

=for Pod::Functions SysV shared memory operations

=begin original

Calls the System V IPC function shmctl.  You'll probably have to say

=end original

System V IPC 関数 shmctl を呼び出します。
正しい定数定義を得るために、まず

    use IPC::SysV;

=begin original

first to get the correct constant definitions.  If CMD is C<IPC_STAT>,
then ARG must be a variable that will hold the returned C<shmid_ds>
structure.  Returns like ioctl: L<C<undef>|/undef EXPR> for error; "C<0>
but true" for zero; and the actual return value otherwise.
See also L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV>.

=end original

と書くことが必要でしょう。
CMD が、C<IPC_STAT> ならば、ARG は、返される C<shmid_ds> 構造体を
納める変数でなければなりません。
ioctl と同様です: エラー時には L<C<undef>|/undef EXPR>; ゼロのときは
"C<0> だが真"; それ以外なら、その値そのものを返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> の文書も
参照してください。

=begin original

Portability issues: L<perlport/shmctl>.

=end original

移植性の問題: L<perlport/shmctl>。

=item shmget KEY,SIZE,FLAGS
X<shmget>

=for Pod::Functions get SysV shared memory segment identifier

=begin original

Calls the System V IPC function shmget.  Returns the shared memory
segment id, or L<C<undef>|/undef EXPR> on error.
See also L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV>.

=end original

System V IPC 関数 shmget を呼び出します。
共有メモリのセグメント ID か、エラー時には L<C<undef>|/undef EXPR> を返します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> の文書も
参照してください。

=begin original

Portability issues: L<perlport/shmget>.

=end original

移植性の問題: L<perlport/shmget>。

=item shmread ID,VAR,POS,SIZE
X<shmread>
X<shmwrite>

=for Pod::Functions read SysV shared memory

=item shmwrite ID,STRING,POS,SIZE

=for Pod::Functions write SysV shared memory

=begin original

Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable that will
hold the data read.  When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.  Return true if successful, false on error.
C<shmread> taints the variable.  See also
L<perlipc/"SysV IPC"> and the documentation for
L<C<IPC::SysV>|IPC::SysV> and the L<C<IPC::Shareable>|IPC::Shareable>
module from CPAN.

=end original

System V 共有メモリセグメント ID に対し、アタッチして、コピーを行ない、
デタッチするという形で、位置 POS から、サイズ SIZE だけ、読み込みか書き込みを
行ないます。
読み込み時には、VAR は読み込んだデータを納める変数でなければなりません。
書き込み時には、STRING が長すぎても、SIZE バイトだけが使われます; STRING が
短すぎる場合には、SIZE バイトを埋めるために、ヌル文字が書き込まれます。
成功時には真を、エラー時には偽を返します。
C<shmread> は変数を汚染します。
L<perlipc/"SysV IPC"> および、L<C<IPC::SysV>|IPC::SysV> と CPAN の
L<C<IPC::Shareable>|IPC::Shareable> の文書も参照してください。

=begin original

Portability issues: L<perlport/shmread> and L<perlport/shmwrite>.

=end original

移植性の問題: L<perlport/shmread> と L<perlport/shmwrite>。

=item shutdown SOCKET,HOW
X<shutdown>

=for Pod::Functions close down just half of a socket connection

=begin original

Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the syscall of the same name.

=end original

同名のシステムコールと同じように解釈される HOW によって、
指定された方法でソケット接続のシャットダウンを行ないます。

    shutdown($socket, 0);    # I/we have stopped reading data
    shutdown($socket, 1);    # I/we have stopped writing data
    shutdown($socket, 2);    # I/we have stopped using this socket

=begin original

This is useful with sockets when you want to tell the other
side you're done writing but not done reading, or vice versa.
It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.

=end original

これは、こちらがソケットを書き終わったが読み終わっていない、
またはその逆を相手側に伝えたいときに便利です。
これはその他のプロセスでフォークしたファイル記述子のコピーも
無効にするので、よりしつこい閉じ方です。

=begin original

Returns C<1> for success; on error, returns L<C<undef>|/undef EXPR> if
the first argument is not a valid filehandle, or returns C<0> and sets
L<C<$!>|perlvar/$!> for any other failure.

=end original

成功時には C<1> を返します;
エラーの場合、最初の引数が有効なファイルハンドルでない場合は
L<C<undef>|/undef EXPR> を返し、その他のエラーの場合は C<0> を返して
L<C<$!>|perlvar/$!> をセットします。

=item sin EXPR
X<sin> X<sine> X<asin> X<arcsine>

=item sin

=for Pod::Functions return the sine of a number

=begin original

Returns the sine of EXPR (expressed in radians).  If EXPR is omitted,
returns sine of L<C<$_>|perlvar/$_>.

=end original

(ラジアンで示した) EXPR の正弦を返します。
EXPR が省略されたときには、L<C<$_>|perlvar/$_> の正弦を返します。

=begin original

For the inverse sine operation, you may use the C<Math::Trig::asin>
function, or use this relation:

=end original

逆正弦を求めるためには、C<Math::Trig::asin> 関数を使うか、
以下の関係を使ってください:

    sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }

=item sleep EXPR
X<sleep> X<pause>

=item sleep

=for Pod::Functions block for some number of seconds

=begin original

Causes the script to sleep for (integer) EXPR seconds, or forever if no
argument is given.  Returns the integer number of seconds actually slept.

=end original

スクリプトを(整数の) EXPR で指定した秒数 (省略時には、永久に)
スリープさせます。
実際にスリープした秒数を返します。 

=begin original

EXPR should be a positive integer. If called with a negative integer,
C<sleep> does not sleep but instead emits a warning, sets
C<$!> (C<errno>), and returns zero.

=end original

EXPR は正の整数である必要があります。
負の整数で呼び出すと、 C<sleep> はスリープせず、
警告を出力して、C<$!> (C<errno>) を設定し、ゼロを返します。

=begin original

If called with a non-integer, the fractional part is ignored.

=end original

非整数で呼び出すと、小数部分は無視されます。

=begin original

C<sleep 0> is permitted, but a function call to the underlying platform
implementation still occurs, with any side effects that may have.
C<sleep 0> is therefore not exactly identical to not sleeping at all.

=end original

C<sleep 0> は許されていますが、基となるプラットフォーム実装への
関数呼び出しはやはり行われ、どのような副作用も起こり得ます。
従って、C<sleep 0> は全くスリープしないのと正確に同じではありません。

=begin original

May be interrupted if the process receives a signal such as C<SIGALRM>.

=end original

そのプロセスが C<SIGALRM>のようなシグナルを受信すると、
割り込みがかかります。

    eval {
        local $SIG{ALRM} = sub { die "Alarm!\n" };
        sleep;
    };
    die $@ unless $@ eq "Alarm!\n";

=begin original

You probably cannot mix L<C<alarm>|/alarm SECONDS> and
C<sleep> calls, because C<sleep> is often
implemented using L<C<alarm>|/alarm SECONDS>.

=end original

C<sleep> は、L<C<alarm>|/alarm SECONDS> を使って
実装されることが多いので、L<C<alarm>|/alarm SECONDS> と
L<C<sleep>|/sleep EXPR> は、混ぜて使用することはおそらくできません。

=begin original

On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.  They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.

=end original

古いシステムでは、どのように秒を数えるかによって、要求した秒数に完全に
満たないうちに、スリープから抜ける場合があります。
最近のシステムでは、常に完全にスリープします。
しかし、負荷の高いマルチタスクシステムでは
正しくスケジューリングされないがために
より長い時間スリープすることがあります。

=begin original

For delays of finer granularity than one second, the L<Time::HiRes>
module (from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides L<C<usleep>|Time::HiRes/usleep ( $useconds )>.
You may also use Perl's four-argument
version of L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> leaving the
first three arguments undefined, or you might be able to use the
L<C<syscall>|/syscall NUMBER, LIST> interface to access L<setitimer(2)>
if your system supports it.  See L<perlfaq8> for details.

=end original

1 秒より精度の高いスリープを行なうには、L<Time::HiRes> モジュール(CPAN から、
また Perl 5.8 からは標準配布されています) が
L<C<usleep>|Time::HiRes/usleep ( $useconds )> を提供します。
Perl の 4 引数版 L<C<select>|/select RBITS,WBITS,EBITS,TIMEOUT> を最初の
3 引数を未定義にして使うか、L<setitimer(2)> をサポートしているシステムでは、
Perl の L<C<syscall>|/syscall NUMBER, LIST> インタフェースを使って
アクセスすることもできます。
詳しくは L<perlfaq8> を参照してください。

=begin original

See also the L<POSIX> module's L<C<pause>|POSIX/C<pause>> function.

=end original

L<POSIX> モジュールの L<C<pause>|POSIX/C<pause>> 関数も参照してください。

=item socket SOCKET,DOMAIN,TYPE,PROTOCOL
X<socket>

=for Pod::Functions create a socket

=begin original

Opens a socket of the specified kind and attaches it to filehandle
SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified the same as for
the syscall of the same name.  You should C<use Socket> first
to get the proper definitions imported.  See the examples in
L<perlipc/"Sockets: Client/Server Communication">.

=end original

指定した種類のソケットをオープンし、ファイルハンドル SOCKET にアタッチします。
DOMAIN, TYPE, PROTOCOL は、同名のシステムコールと同じように指定します。
適切な定義を import するために、まず、C<use Socket> とするとよいでしょう。
L<perlipc/"Sockets: Client/Server Communication"> の例を参照してください。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of L<C<$^F>|perlvar/$^F>.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは L<C<$^F>|perlvar/$^F> の値で決定される、新しくオープンされた
ファイル記述子に対してセットされます。
L<perlvar/$^F> を参照してください。

=item socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
X<socketpair>

=for Pod::Functions create a pair of sockets

=begin original

Creates an unnamed pair of sockets in the specified domain, of the
specified type.  DOMAIN, TYPE, and PROTOCOL are specified the same as
for the syscall of the same name.  If unimplemented, raises an exception.
Returns true if successful.

=end original

指定した DOMAIN に、指定した TYPE で名前の無いソケットのペアを生成します。
DOMAIN, TYPE, PROTOCOL は、同名のシステムコールと同じように指定します。
実装されていない場合には、例外が発生します。
成功時には真を返します。

=begin original

On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptors, as determined by the value
of L<C<$^F>|perlvar/$^F>.  See L<perlvar/$^F>.

=end original

ファイルに対する close-on-exec フラグをサポートしているシステムでは、
フラグは L<C<$^F>|perlvar/$^F> の値で決定される、新しくオープンされた
ファイル記述子に対してセットされます。
L<perlvar/$^F> を参照してください。

=begin original

Some systems define L<C<pipe>|/pipe READHANDLE,WRITEHANDLE> in terms of
C<socketpair>, in
which a call to C<pipe($rdr, $wtr)> is essentially:

=end original

L<C<pipe>|/pipe READHANDLE,WRITEHANDLE> を
C<socketpair> を使って
定義しているシステムもあります;
C<pipe($rdr, $wtr)> は本質的には以下のようになります:

    use Socket;
    socketpair(my $rdr, my $wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    shutdown($rdr, 1);        # no more writing for reader
    shutdown($wtr, 0);        # no more reading for writer

=begin original

See L<perlipc> for an example of socketpair use.  Perl 5.8 and later will
emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.

=end original

socketpair の使用例については L<perlipc> を参照してください。
Perl 5.8 以降では、システムがソケットを実装しているが socketpair を
実装していない場合、localhost に対して IP ソケットを使うことで
socketpair をエミュレートします。

=begin original

Portability issues: L<perlport/socketpair>.

=end original

移植性の問題: L<perlport/socketpair>。

=item sort SUBNAME LIST
X<sort>

=item sort BLOCK LIST

=item sort LIST

=for Pod::Functions sort a list of values

=begin original

In list context, this sorts the LIST and returns the sorted list value.
In scalar context, the behaviour of C<sort> is
undefined.

=end original

リストコンテキストでは、LIST をソートし、ソートされたリスト値を返します。
スカラコンテキストでは、C<sort> の振る舞いは未定義です。

=begin original

If SUBNAME or BLOCK is omitted, C<sort>s in
standard string comparison
order.  If SUBNAME is specified, it gives the name of a subroutine
that returns a numeric value less than, equal to, or greater than C<0>,
depending on how the elements of the list are to be ordered.  (The
C<< <=> >> and C<cmp> operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.  In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.

=end original

SUBNAME や BLOCK を省略すると、C<sort> は標準の
文字列比較の順番で行なわれます。
SUBNAME を指定すると、それは、リストの要素をどのような順番に並べるかに
応じて、負の数、C<0>、正の数を返すサブルーチンの名前であると解釈されます。
(このようなルーチンには、C<< <=> >> 演算子や C<cmp> 演算子が、
たいへん便利です。)
SUBNAME は、スカラ変数名(添字なし)でもよく、その場合には、その値が使用する
実際のサブルーチンの名前(またはそのリファレンス)と解釈されます。
SUBNAME の代わりに、無名のインラインソートルーチンとして、BLOCK を
書くことができます。

=begin original

If the subroutine's prototype is C<($$)>, the elements to be compared are
passed by reference in L<C<@_>|perlvar/@_>, as for a normal subroutine.
This is slower than unprototyped subroutines, where the elements to be
compared are passed into the subroutine as the package global variables
C<$a> and C<$b> (see example below).

=end original

サブルーチンのプロトタイプが C<($$)>の場合、比較する要素は通常のサブルーチンと
同じように L<C<@_>|perlvar/@_> の中にリファレンスとして渡されます。
これはプロトタイプなしのサブルーチンより遅いです; この場合は比較のため
サブルーチンに渡される二つの要素は、パッケージのグローバル変数 C<$a> と
C<$b> で渡されます(次の例を参照してください)。

=begin original

If the subroutine is an XSUB, the elements to be compared are pushed on
to the stack, the way arguments are usually passed to XSUBs.  C<$a> and
C<$b> are not set.

=end original

サブルーチンが XSUB の場合、比較される要素は、普通に引数を XSUB に渡す形で、
スタックにプッシュされます。
C<$a> と C<$b> は設定されません。

=begin original

If two or more elements of LIST compare the same (i.e. the comparison
operation returns 0 for them), they retain the relative order they had
in LIST. In other words, sorting is stable (and has been since v5.8.0).

=end original

LIST の二つ以上の要素が比較したときに同じ(つまりそれらに対する比較関数が
0 を返す)場合、LIST 内の相対的な位置関係は維持されます。
言い換えると、ソートは安定しています (これは v5.8.0 からです)。

=begin original

The values to be compared are always passed by reference and should not
be modified.

=end original

比較される値はリファレンスによって渡されるので、変更するべきではありません。

=begin original

You also cannot exit out of the sort block or subroutine using any of the
loop control operators described in L<perlsyn> or with
L<C<goto>|/goto LABEL>.

=end original

また、ソートブロックやサブルーチンから L<perlsyn> で説明されている
ループ制御子や L<C<goto>|/goto LABEL> を使って抜けてはいけません。

=begin original

When L<C<use locale>|locale> (but not C<use locale ':not_characters'>)
is in effect, C<sort LIST> sorts LIST according to the
current collation locale.  See L<perllocale>.

=end original

L<C<use locale>|locale> が有効(そして C<use locale ':not_characters'> が
有効でない)の場合、C<sort LIST> は LIST を現在の比較ロケールに従って
ソートします。
L<perllocale> を参照してください。

=begin original

C<sort> returns aliases into the original list,
much as a for loop's index variable aliases the list elements.  That is,
modifying an element of a list returned by C<sort>
(for example, in a C<foreach>, L<C<map>|/map BLOCK LIST> or
L<C<grep>|/grep BLOCK LIST>)
actually modifies the element in the original list.  This is usually
something to be avoided when writing clear code.

=end original

C<sort> は元のリストへのエイリアスを返します;
for ループのインデックス変数がリスト要素へのエイリアスと同様です。
つまり、C<sort> で返されるリストの要素を(例えば、
C<foreach> や L<C<map>|/map BLOCK LIST> や
L<C<grep>|/grep BLOCK LIST> で)変更すると、実際に元のリストの要素が
変更されます。
これはきれいなコードを書くときには普通は回避されます。

=begin original

Examples:

=end original

例:

    # sort lexically
    my @articles = sort @files;

    # same thing, but with explicit sort routine
    my @articles = sort {$a cmp $b} @files;

    # now case-insensitively
    my @articles = sort {fc($a) cmp fc($b)} @files;

    # same thing in reversed order
    my @articles = sort {$b cmp $a} @files;

    # sort numerically ascending
    my @articles = sort {$a <=> $b} @files;

    # sort numerically descending
    my @articles = sort {$b <=> $a} @files;

    # this sorts the %age hash by value instead of key
    # using an in-line function
    my @eldest = sort { $age{$b} <=> $age{$a} } keys %age;

    # sort using explicit subroutine name
    sub byage {
        $age{$a} <=> $age{$b};  # presuming numeric
    }
    my @sortedclass = sort byage @class;

    sub backwards { $b cmp $a }
    my @harry  = qw(dog cat x Cain Abel);
    my @george = qw(gone chased yz Punished Axed);
    print sort @harry;
        # prints AbelCaincatdogx
    print sort backwards @harry;
        # prints xdogcatCainAbel
    print sort @george, 'to', @harry;
        # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

    # inefficiently sort by descending numeric compare using
    # the first integer after the first = sign, or the
    # whole record case-insensitively otherwise

    my @new = sort {
        ($b =~ /=(\d+)/)[0] <=> ($a =~ /=(\d+)/)[0]
                            ||
                    fc($a)  cmp  fc($b)
    } @old;

    # same thing, but much more efficiently;
    # we'll build auxiliary indices instead
    # for speed
    my (@nums, @caps);
    for (@old) {
        push @nums, ( /=(\d+)/ ? $1 : undef );
        push @caps, fc($_);
    }

    my @new = @old[ sort {
                           $nums[$b] <=> $nums[$a]
                                    ||
                           $caps[$a] cmp $caps[$b]
                         } 0..$#old
                  ];

    # same thing, but without any temps
    my @new = map { $_->[0] }
           sort { $b->[1] <=> $a->[1]
                           ||
                  $a->[2] cmp $b->[2]
           } map { [$_, /=(\d+)/, fc($_)] } @old;

    # using a prototype allows you to use any comparison subroutine
    # as a sort subroutine (including other package's subroutines)
    package Other;
    sub backwards ($$) { $_[1] cmp $_[0]; }  # $a and $b are
                                             # not set here
    package main;
    my @new = sort Other::backwards @old;

    ## using a prototype with function signature
    use feature 'signatures';
    sub function_with_signature :prototype($$) ($one, $two) {
        return $one <=> $two
    }

    my @new = sort function_with_signature @old;

=begin original

Warning: syntactical care is required when sorting the list returned from
a function.  If you want to sort the list returned by the function call
C<find_records(@key)>, you can use:

=end original

警告: 関数から返されたリストをソートするときには文法上の注意が必要です。
関数呼び出し C<find_records(@key)> から返されたリストをソートしたい場合、
以下のように出来ます:

    my @contact = sort { $a cmp $b } find_records @key;
    my @contact = sort +find_records(@key);
    my @contact = sort &find_records(@key);
    my @contact = sort(find_records(@key));

=begin original

If instead you want to sort the array C<@key> with the comparison routine
C<find_records()> then you can use:

=end original

一方、配列 C<@key> を比較ルーチン C<find_records()> でソートしたい場合は、
以下のように出来ます:

    my @contact = sort { find_records() } @key;
    my @contact = sort find_records(@key);
    my @contact = sort(find_records @key);
    my @contact = sort(find_records (@key));

=begin original

C<$a> and C<$b> are set as package globals in the package the sort() is
called from.  That means C<$main::a> and C<$main::b> (or C<$::a> and
C<$::b>) in the C<main> package, C<$FooPack::a> and C<$FooPack::b> in the
C<FooPack> package, etc.  If the sort block is in scope of a C<my> or
C<state> declaration of C<$a> and/or C<$b>, you I<must> spell out the full
name of the variables in the sort block :

=end original

C<$a> と C<$b> は、sort() を呼び出したパッケージのパッケージグローバルとして
設定されます。
つまり、C<main> パッケージの C<$main::a> と C<$main::b>
(あるいは C<$::a> と C<$::b>) 、
C<FooPack> パッケージの C<$FooPack::a> と C<$FooPack::b>、などです。
ソートブロックが C<$a> や C<$b> の C<my> または C<state> のスコープ内の場合、
ソートブロックの変数の完全名を I<指定しなければなりません>:

   package main;
   my $a = "C"; # DANGER, Will Robinson, DANGER !!!

   print sort { $a cmp $b }               qw(A C E G B D F H);
                                          # WRONG
   sub badlexi { $a cmp $b }
   print sort badlexi                     qw(A C E G B D F H);
                                          # WRONG
   # the above prints BACFEDGH or some other incorrect ordering

   print sort { $::a cmp $::b }           qw(A C E G B D F H);
                                          # OK
   print sort { our $a cmp our $b }       qw(A C E G B D F H);
                                          # also OK
   print sort { our ($a, $b); $a cmp $b } qw(A C E G B D F H);
                                          # also OK
   sub lexi { our $a cmp our $b }
   print sort lexi                        qw(A C E G B D F H);
                                          # also OK
   # the above print ABCDEFGH

=begin original

With proper care you may mix package and my (or state) C<$a> and/or C<$b>:

=end original

適切に注意すれば、パッケージと my (あるいは state) C<$a> や C<$b> を
混ぜることができます:

   my $a = {
      tiny   => -2,
      small  => -1,
      normal => 0,
      big    => 1,
      huge   => 2
   };

   say sort { $a->{our $a} <=> $a->{our $b} }
       qw{ huge normal tiny small big};

   # prints tinysmallnormalbighuge

=begin original

C<$a> and C<$b> are implicitly local to the sort() execution and regain their
former values upon completing the sort.

=end original

C<$a> と C<$b> は sort() の実行中は暗黙にローカル化され、ソート終了時に
元の値に戻ります。

=begin original

Sort subroutines written using C<$a> and C<$b> are bound to their calling
package. It is possible, but of limited interest, to define them in a
different package, since the subroutine must still refer to the calling
package's C<$a> and C<$b> :

=end original

C<$a> と C<$b> を使って書かれたソートサブルーチンはその呼び出しパッケージに
しなければなりません。
異なるパッケージに定義することは可能ですが、
これは可能ですが、限られた関心しかありません;
サブルーチンは呼び出しパッケージの C<$a> と C<$b> を
参照しなければならないからです:

   package Foo;
   sub lexi { $Bar::a cmp $Bar::b }
   package Bar;
   ... sort Foo::lexi ...

=begin original

Use the prototyped versions (see above) for a more generic alternative.

=end original

より一般的な代替案としては(前述の)プロトタイプ版を使ってください。

=begin original

The comparison function is required to behave.  If it returns
inconsistent results (sometimes saying C<$x[1]> is less than C<$x[2]> and
sometimes saying the opposite, for example) the results are not
well-defined.

=end original

比較関数は一貫した振る舞いをすることが求められます。
一貫しない結果を返す(例えば、あるときは C<$x[1]> が C<$x[2]> より
小さいと返し、またあるときは逆を返す)場合、結果は未定義です。

=begin original

Because C<< <=> >> returns L<C<undef>|/undef EXPR> when either operand
is C<NaN> (not-a-number), be careful when sorting with a
comparison function like C<< $a <=> $b >> any lists that might contain a
C<NaN>.  The following example takes advantage that C<NaN != NaN> to
eliminate any C<NaN>s from the input list.

=end original

C<< <=> >> はどちらかのオペランドが C<NaN> (not-a-number) のときに
L<C<undef>|/undef EXPR> を返すので、C<< $a <=> $b >> といった比較関数で
ソートする場合はリストに C<NaN> が含まれないように注意してください。
以下の例は 入力リストから C<NaN> を取り除くために C<NaN != NaN> という性質を
利用しています。

    my @result = sort { $a <=> $b } grep { $_ == $_ } @input;

=begin original

In the current version of Perl, the C<sort> function is implemented via
the mergesort algorithm.

=end original

現在のバージョンの Perl では、C<sort> 関数はマージソートアルゴリズムで
実装されています。

=item splice ARRAY,OFFSET,LENGTH,LIST
X<splice>

=item splice ARRAY,OFFSET,LENGTH

=item splice ARRAY,OFFSET

=item splice ARRAY

=for Pod::Functions add or remove elements anywhere in an array

=begin original

Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.  In list context,
returns the elements removed from the array.  In scalar context,
returns the last element removed, or L<C<undef>|/undef EXPR> if no
elements are
removed.  The array grows or shrinks as necessary.
If OFFSET is negative then it starts that far from the end of the array.
If LENGTH is omitted, removes everything from OFFSET onward.
If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.
If both OFFSET and LENGTH are omitted, removes everything.  If OFFSET is
past the end of the array and a LENGTH was provided, Perl issues a warning,
and splices at the end of the array.

=end original

ARRAY から OFFSET、LENGTH で指定される要素を取り除き、
LIST があれば、それを代わりに挿入します。
リストコンテキストでは、配列から取り除かれた要素を返します。
スカラコンテキストでは、取り除かれた最後の要素を返します; 要素が
取り除かれなかった場合は L<C<undef>|/undef EXPR> を返します。
配列は、必要に応じて、大きくなったり、小さくなったりします。
OFFSET が負の数の場合は、配列の最後からの距離を示します。
LENGTH が省略されると、OFFSET 以降のすべての要素を取り除きます。
LENGTH が負の数の場合は、OFFSET から前方へ、配列の最後から -LENGTH 要素を
除いて取り除きます。
OFFSET と LENGTH の両方が省略されると、全ての要素を取り除きます。
OFFSET が配列の最後より後ろで、 LENGTH が指定されていると、Perl は警告を出し、
配列の最後に対して処理します。

=begin original

The following equivalences hold (assuming C<< $#a >= $i >> )

=end original

以下は、(C<< $#a >= $i >> と仮定すると) それぞれ、等価です。

    push(@a,$x,$y)      splice(@a,@a,0,$x,$y)
    pop(@a)             splice(@a,-1)
    shift(@a)           splice(@a,0,1)
    unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
    $a[$i] = $y         splice(@a,$i,1,$y)

=begin original

C<splice> can be used, for example,
to implement n-ary queue processing:

=end original

C<splice> は、例えば、n-ary キュー処理の
実装に使えます:

    sub nary_print {
      my $n = shift;
      while (my @next_n = splice @_, 0, $n) {
        say join q{ -- }, @next_n;
      }
    }

    nary_print(3, qw(a b c d e f g h));
    # prints:
    #   a -- b -- c
    #   d -- e -- f
    #   g -- h

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<splice> to take a
scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<splice> がスカラ式を
取ることが出来るという実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=item split /PATTERN/,EXPR,LIMIT
X<split>

=item split /PATTERN/,EXPR

=item split /PATTERN/

=item split

=for Pod::Functions split up a string using a regexp delimiter

=begin original

Splits the string EXPR into a list of strings and returns the
list in list context, or the size of the list in scalar context.
(Prior to Perl 5.11, it also overwrote C<@_> with the list in
void and scalar context. If you target old perls, beware.)

=end original

文字列 EXPR を文字列のリストに分割して、リストコンテキストではそのリストを
返し、スカラコンテキストではリストの大きさを返します。
(Perl 5.11 以前では、無効コンテキストやスカラコンテキストの場合は
C<@_> をリストで上書きします。
もし古い perl を対象にするなら、注意してください。)

=begin original

If only PATTERN is given, EXPR defaults to L<C<$_>|perlvar/$_>.

=end original

PATTERN のみが与えられた場合、EXPR のデフォルトは L<C<$_>|perlvar/$_> です。

=begin original

Anything in EXPR that matches PATTERN is taken to be a separator
that separates the EXPR into substrings (called "I<fields>") that
do B<not> include the separator.  Note that a separator may be
longer than one character or even have no characters at all (the
empty string, which is a zero-width match).

=end original

EXPR の中で PATTERN にマッチングするものは何でも EXPR を("I<fields>" と
呼ばれる)セパレータを B<含まない> 部分文字列に分割するための
セパレータとなります。
セパレータは一文字より長くてもよく、全く文字がなくてもよい(空文字列は
ゼロ幅マッチングです)ということに注意してください。

=begin original

The PATTERN need not be constant; an expression may be used
to specify a pattern that varies at runtime.

=end original

PATTERN は定数である必要はありません; 実行時に変更されるパターンを
指定するために式を使えます。

=begin original

If PATTERN matches the empty string, the EXPR is split at the match
position (between characters).  As an example, the following:

=end original

PATTERN が空文字列にマッチングする場合、EXPR はマッチング位置
(文字の間)で分割されます。
例えば、以下のものは:

    my @x = split(/b/, "abc"); # ("a", "c")

=begin original

uses the C<b> in C<'abc'> as a separator to produce the list ("a", "c").
However, this:

=end original

C<'abc'> の C<b> をセパレータとして使ってリスト ("a", "c") を生成します。
しかし、これは:

    my @x = split(//, "abc"); # ("a", "b", "c")

=begin original

uses empty string matches as separators; thus, the empty string
may be used to split EXPR into a list of its component characters.

=end original

空文字列マッチングをセパレータとして使います; 従って、
空文字列は EXPR を構成する文字のリストに分割するために使われます。

=begin original

As a special case for C<split>PATTERNE<sol>,EXPR,LIMIT>,
the empty pattern given in
L<match operator|perlop/"m/PATTERN/msixpodualngc"> syntax (C<//>)
specifically matches the empty string, which is contrary to its usual
interpretation as the last successful match.

=end original

C<split> の特殊な場合として、
L<マッチング演算子|perlop/"m/PATTERN/msixpodualngc"> 文法で与えられた
空パターン (C<//>) は特に空文字列にマッチングし、最後に成功した
マッチングという普通の解釈と異なります。

=begin original

If PATTERN is C</^/>, then it is treated as if it used the
L<multiline modifier|perlreref/OPERATORS> (C</^/m>), since it
isn't much use otherwise.

=end original

PATTERN が C</^/> の場合、L<複数行修飾子|perlreref/OPERATORS>
(C</^/m>) が使われたかのように扱われます; そうでなければほとんど
使えないからです。

=begin original

C<E<sol>m> and any of the other pattern modifiers valid for C<qr>
(summarized in L<perlop/qrE<sol>STRINGE<sol>msixpodualn>) may be
specified explicitly.

=end original

C<qr> で有効な C<E<sol>m> 及びその他のパターン修飾子
(L<perlop/qrE<sol>STRINGE<sol>msixpodualn> にまとめられています) は
明示的に定義されます。

=begin original

As another special case,
C<split>PATTERNE<sol>,EXPR,LIMIT> emulates the default
behavior of the
command line tool B<awk> when the PATTERN is either omitted or a
string composed of a single space character (such as S<C<' '>> or
S<C<"\x20">>, but not e.g. S<C</ />>).  In this case, any leading
whitespace in EXPR is removed before splitting occurs, and the PATTERN is
instead treated as if it were C</\s+/>; in particular, this means that
I<any> contiguous whitespace (not just a single space character) is used as
a separator.

=end original

もう一つの特別な場合として、
C<split> は
PATTERN が省略されるか単一のスペース文字からなる文字列 (つまり例えば
S<C</ />> ではなく S<C<' '>> や S<C<"\x20">>) の場合、コマンドラインツール
B<awk> のデフォルトの振る舞いをエミュレートします。
この場合、EXPR の先頭の空白は分割を行う前に削除され、PATTERN は
C</\s+/> であったかのように扱われます; 特に、これは (単に単一の
スペース文字ではなく) I<あらゆる> 連続した空白がセパレータとして
使われるということです。

    my @x = split(" ", "  Quick brown fox\n");
    # ("Quick", "brown", "fox")

    my @x = split(" ", "RED\tGREEN\tBLUE");
    # ("RED", "GREEN", "BLUE")

=begin original

Using split in this fashion is very similar to how
L<C<qwE<sol>E<sol>>|/qwE<sol>STRINGE<sol>> works.

=end original

この方法で split を使うのは、
L<C<qwE<sol>E<sol>>|/qwE<sol>STRINGE<sol>> の動作と非常に似ています。

=begin original

However, this special treatment can be avoided by specifying
the pattern S<C</ />> instead of the string S<C<" ">>, thereby allowing
only a single space character to be a separator.  In earlier Perls this
special case was restricted to the use of a plain S<C<" ">> as the
pattern argument to split; in Perl 5.18.0 and later this special case is
triggered by any expression which evaluates to the simple string S<C<" ">>.

=end original

しかし、この特別の扱いは文字列 S<C<" ">> の代わりにパターン S<C</ />> を
指定することで回避でき、それによってセパレータとして単一の
スペース文字のみが使われます。
以前の Perl ではこの特別な場合は split のパターン引数として単に S<C<" ">> を
使った場合に制限されていました; Perl 5.18.0 以降では、この特別な場合は
単純な文字列 S<C<" ">> と評価される任意の式によって引き起こされます。

=begin original

As of Perl 5.28, this special-cased whitespace splitting works as expected in
the scope of L<< S<C<"use feature 'unicode_strings'">>|feature/The
'unicode_strings' feature >>. In previous versions, and outside the scope of
that feature, it exhibits L<perlunicode/The "Unicode Bug">: characters that are
whitespace according to Unicode rules but not according to ASCII rules can be
treated as part of fields rather than as field separators, depending on the
string's internal encoding.

=end original

Perl 5.28 から、この特別な場合の空白分割は
L<< S<C<"use feature 'unicode_strings'">>|feature/The
'unicode_strings' feature >> のスコープの中では想定通りに動作します。
以前のバージョンでは、そしてこの機能のスコープの外側では、
これは L<perlunicode/The "Unicode Bug"> を引き起こします:
Unicode によれば空白だけれども ASCII の規則ではそうではない文字は、
文字列の内部エンコーディングに依存して、
フィールドの区切りではなくフィールドの一部として扱われることがあります。

=begin original

As of Perl 5.39.9 the C</x> default modifier does NOT affect
C<split STRING> but does affect C<split PATTERN>, this means that
C<split " "> will produce the expected I<awk> emulation regardless as
to whether it is used in the scope of a C<use re "/x"> statement. If you
want to split by spaces under C<use re "/x"> you must do something like
C<split /(?-x: )/> or C<split /\x{20}/> instead of C<split / />.

=end original

Perl 5.39.9 から、C</x> デフォルト修飾子は C<split STRING> には
影響しませんが、C<split PATTERN> には影響します;
つまり、C<split " "> は、C<use re "/x"> 文のスコープ内で
使われているかどうかにかかわらず、期待される
I<awk> エミュレーションを生成します。
C<use re "/x"> の下でスペースで分割したい場合は、
C<split / /> の代わりに C<split /(?-x: )/> または
C<split /\x{20}/> のようにしなければなりません。

=begin original

If omitted, PATTERN defaults to a single space, S<C<" ">>, triggering
the previously described I<awk> emulation.

=end original

省略されると、PATTERN のデフォルトは単一のスペース S<C<" ">> になり、
先に記述した I<awk> エミュレーションを起動します。

=begin original

If LIMIT is specified and positive, it represents the maximum number
of fields into which the EXPR may be split; in other words, LIMIT is
one greater than the maximum number of times EXPR may be split.  Thus,
the LIMIT value C<1> means that EXPR may be split a maximum of zero
times, producing a maximum of one field (namely, the entire value of
EXPR).  For instance:

=end original

LIMIT が指定された正数の場合、EXPR が分割されるフィールドの最大数を
表現します; 言い換えると、 LIMIT は EXPR が分割される数より一つ大きい数です。
従って、LIMIT の値 C<1> は EXPR が最大 0 回分割されるということで、
最大で一つのフィールドを生成します (言い換えると、EXPR 全体の値です)。
例えば:

    my @x = split(/,/, "a,b,c", 1); # ("a,b,c")
    my @x = split(/,/, "a,b,c", 2); # ("a", "b,c")
    my @x = split(/,/, "a,b,c", 3); # ("a", "b", "c")
    my @x = split(/,/, "a,b,c", 4); # ("a", "b", "c")

=begin original

If LIMIT is negative, it is treated as if it were instead arbitrarily
large; as many fields as possible are produced.

=end original

LIMIT が負数なら、非常に大きい数であるかのように扱われます; できるだけ多くの
フィールドが生成されます。

=begin original

If LIMIT is omitted (or, equivalently, zero), then it is usually
treated as if it were instead negative but with the exception that
trailing empty fields are stripped (empty leading fields are always
preserved); if all fields are empty, then all fields are considered to
be trailing (and are thus stripped in this case).  Thus, the following:

=end original

LIMIT が省略されると(あるいは等価な 0 なら)、普通は負数が指定されたかのように
動作しますが、末尾の空フィールドは取り除かれるという例外があります
(先頭の空フィールドは常に保存されます); もし全てのフィールドが空なら、
全てのフィールドが末尾として扱われます(そしてこの場合取り除かれます)。
従って、以下のようにすると:

    my @x = split(/,/, "a,b,c,,,"); # ("a", "b", "c")

=begin original

produces only a three element list.

=end original

3 要素だけのリストを生成します。

    my @x = split(/,/, "a,b,c,,,", -1); # ("a", "b", "c", "", "", "")

=begin original

produces a six element list.

=end original

6 要素のリストを生成します。

=begin original

In time-critical applications, it is worthwhile to avoid splitting
into more fields than necessary.  Thus, when assigning to a list,
if LIMIT is omitted (or zero), then LIMIT is treated as though it
were one larger than the number of variables in the list; for the
following, LIMIT is implicitly 3:

=end original

時間に厳しいアプリケーションでは、必要でないフィールドの分割を避けるのは
価値があります。
従って、リストに代入される場合に、LIMIT が省略される(または 0)と、
LIMIT は リストにある変数の数より一つ大きい数のように扱われます;
次の場合、LIMIT は暗黙に 3 になります:

    my ($login, $passwd) = split(/:/);

=begin original

Note that splitting an EXPR that evaluates to the empty string always
produces zero fields, regardless of the LIMIT specified.

=end original

LIMIT の指定に関わらず、空文字列に評価される EXPR を分割すると常に 0 個の
フィールドを生成することに注意してください。

=begin original

An empty leading field is produced when there is a positive-width
match at the beginning of EXPR.  For instance:

=end original

EXPR の先頭で正数幅でマッチングしたときには先頭に空のフィールドが
生成されます。
例えば:

    my @x = split(/ /, " abc"); # ("", "abc")

=begin original

splits into two elements.  However, a zero-width match at the
beginning of EXPR never produces an empty field, so that:

=end original

これは 2 要素に分割します。
しかし、EXPR の先頭でのゼロ幅マッチングは決して空フィールドを生成しないので:

    my @x = split(//, " abc"); # (" ", "a", "b", "c")

=begin original

splits into four elements instead of five.

=end original

これは 5 要素ではなく 4 要素に分割します。

=begin original

An empty trailing field, on the other hand, is produced when there is a
match at the end of EXPR, regardless of the length of the match
(of course, unless a non-zero LIMIT is given explicitly, such fields are
removed, as in the last example).  Thus:

=end original

一方、末尾の空のフィールドは、マッチングの長さに関わらず、EXPR の末尾で
マッチングしたときに生成されます(もちろん非 0 の LIMIT が明示的に
指定されていない場合です; このようなフィールドは前の例のように
取り除かれます)。
従って:

    my @x = split(//, " abc", -1); # (" ", "a", "b", "c", "")

=begin original

If the PATTERN contains
L<capturing groups|perlretut/Grouping things and hierarchical matching>,
then for each separator, an additional field is produced for each substring
captured by a group (in the order in which the groups are specified,
as per L<backreferences|perlretut/Backreferences>); if any group does not
match, then it captures the L<C<undef>|/undef EXPR> value instead of a
substring.  Also,
note that any such additional field is produced whenever there is a
separator (that is, whenever a split occurs), and such an additional field
does B<not> count towards the LIMIT.  Consider the following expressions
evaluated in list context (each returned list is provided in the associated
comment):

=end original

PATTERN が
L<捕捉グループ|perlretut/Grouping things and hierarchical matching> を
含んでいる場合、それぞれのセパレータについて、
(L<後方参照|perlretut/Backreferences> のようにグループが指定された)
グループによって捕捉されたそれぞれの部分文字列について追加のフィールドが
生成されます; どのグループもマッチングしなかった場合、部分文字列の代わりに
L<C<undef>|/undef EXPR> 値を捕捉します。
また、このような追加のフィールドはセパレータがあるとき(つまり、分割が
行われるとき)はいつでも生成され、このような追加のフィールドは
LIMIT に関してはカウント B<されない> ことに注意してください。
リストコンテキストで評価される以下のような式を考えます
(それぞれの返されるリストは関連づけられたコメントで提供されます):

    my @x = split(/-|,/    , "1-10,20", 3);
    # ("1", "10", "20")

    my @x = split(/(-|,)/  , "1-10,20", 3);
    # ("1", "-", "10", ",", "20")

    my @x = split(/-|(,)/  , "1-10,20", 3);
    # ("1", undef, "10", ",", "20")

    my @x = split(/(-)|,/  , "1-10,20", 3);
    # ("1", "-", "10", undef, "20")

    my @x = split(/(-)|(,)/, "1-10,20", 3);
    # ("1", "-", undef, "10", undef, ",", "20")

=item sprintf FORMAT, LIST
X<sprintf>

=for Pod::Functions formatted print into a string

=begin original

Returns a string formatted by the usual
C<printf> conventions of the C
library function C<sprintf>.  See below for
more details and see L<sprintf(3)> or L<printf(3)> on your system for an
explanation of the general principles.

=end original

C ライブラリ関数 C<sprintf> の
普通の C<printf> 記法の
整形された文字列を返します。
一般的な原則の説明については以下の説明と、システムの
L<sprintf(3)> または L<printf(3)> の説明を参照してください。

=begin original

For example:

=end original

例えば:

        # Format number with up to 8 leading zeroes
        my $result = sprintf("%08d", $number);

        # Round number to 3 digits after decimal point
        my $rounded = sprintf("%.3f", $number);

=begin original

Perl does its own C<sprintf> formatting: it
emulates the C
function L<sprintf(3)>, but doesn't use it except for floating-point
numbers, and even then only standard modifiers are allowed.
Non-standard extensions in your local L<sprintf(3)> are
therefore unavailable from Perl.

=end original

Perl は C<sprintf> フォーマット処理を自力で行います:
これは C の L<sprintf(3)> 関数をエミュレートしますが、C の関数は使いません
(浮動小数点を除きますが、それでも標準の記述子のみが利用できます)。
従って、ローカルな非標準の L<sprintf(3)> 拡張機能は Perl では使えません。

=begin original

Unlike C<printf>,
C<sprintf> does not do what you probably mean
when you pass it an array as your first argument.
The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.

=end original

C<printf> と違って、
C<sprintf> の最初の引数に配列を渡しても
あなたが多分望むとおりには動作しません。
配列はスカラコンテキストで渡されるので、配列の 0 番目の要素ではなく、
配列の要素数をフォーマットとして扱います; これはほとんど役に立ちません。

=begin original

Perl's C<sprintf> permits the following
universally-known conversions:

=end original

Perl の C<sprintf> は以下の一般に知られている変換に
対応しています:

=begin original

   %%    a percent sign
   %c    a character with the given number
   %s    a string
   %d    a signed integer, in decimal
   %u    an unsigned integer, in decimal
   %o    an unsigned integer, in octal
   %x    an unsigned integer, in hexadecimal
   %e    a floating-point number, in scientific notation
   %f    a floating-point number, in fixed decimal notation
   %g    a floating-point number, in %e or %f notation

=end original

   %%    パーセントマーク
   %c    与えられた番号の文字
   %s    文字列
   %d    符号付き 10 進数
   %u    符号なし 10 進数
   %o    符号なし 8 進数
   %x    符号なし 16 進数
   %e    科学的表記の浮動小数点数
   %f    固定 10 進数表記の浮動小数点数
   %g    %e か %f の表記の浮動小数点数

=begin original

In addition, Perl permits the following widely-supported conversions:

=end original

さらに、Perl では以下のよく使われている変換に対応しています:

=begin original

   %X    like %x, but using upper-case letters
   %E    like %e, but using an upper-case "E"
   %G    like %g, but with an upper-case "E" (if applicable)
   %b    an unsigned integer, in binary
   %B    like %b, but using an upper-case "B" with the # flag
   %p    a pointer (outputs the Perl value's address in hexadecimal)
   %n    special: *stores* the number of characters output so far
         into the next argument in the parameter list
   %a    hexadecimal floating point
   %A    like %a, but using upper-case letters
   %i    a synonym for %d
   %D    a synonym for %ld
   %U    a synonym for %lu
   %O    a synonym for %lo
   %F    a synonym for %f

=end original

   %X    %x と同様だが大文字を使う
   %E    %e と同様だが大文字の "E" を使う
   %G    %g と同様だが(適切なら)大文字の "E" を使う
   %b    符号なし 2 進数
   %B    %b と同様だが、# フラグで大文字の "B" を使う
   %p    ポインタ (Perl の値のアドレスを 16 進数で出力する)
   %n    特殊: 出力文字数を引数リストの次の変数に「格納」する
   %a    16 進浮動小数点
   %A    %a と同様だが、大文字を使う
   %i    %d の同義語
   %D    %ld の同義語
   %U    %lu の同義語
   %O    %lo の同義語
   %F    %f の同義語

=begin original

Note that the number of exponent digits in the scientific notation produced
by C<%e>, C<%E>, C<%g> and C<%G> for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).  In other words, 1.23 times ten to the
99th may be either "1.23e99" or "1.23e099".  Similarly for C<%a> and C<%A>:
the exponent or the hexadecimal digits may float: especially the
"long doubles" Perl configuration option may cause surprises.

=end original

C<%e>, C<%E>, C<%g>, C<%G> において、指数部が 100 未満の場合の
指数部の科学的な表記法はシステム依存であることに注意してください:
3 桁かもしれませんし、それ以下かもしれません(必要に応じて 0 で
パッディングされます)。
言い換えると、 1.23 掛ける 10 の 99 乗は "1.23e99" かもしれませんし
"1.23e099" かもしれません。
同様に C<%a> と C<%A> の場合:
指数部と 16 進数が浮動小数点かもしれません:
特に "long doubles" Perl 設定オプションが驚きを引き起こすかもしれません。

=begin original

Between the C<%> and the format letter, you may specify several
additional attributes controlling the interpretation of the format.
In order, these are:

=end original

C<%> とフォーマット文字の間に、フォーマットの解釈を制御するための、
いくつかの追加の属性を指定できます。
順番に、以下のものがあります:

=over 4

=item format parameter index

(フォーマットパラメータインデックス)

=begin original

An explicit format parameter index, such as C<2$>.  By default sprintf
will format the next unused argument in the list, but this allows you
to take the arguments out of order:

=end original

C<2$> のような明示的なフォーマットパラメータインデックス。
デフォルトでは sprintf はリストの次の使われていない引数を
フォーマットしますが、これによって異なった順番の引数を使えるようにします:

  printf '%2$d %1$d', 12, 34;      # prints "34 12"
  printf '%3$d %d %1$d', 1, 2, 3;  # prints "3 1 1"

=item flags

(フラグ)

=begin original

one or more of:

=end original

以下のうちの一つまたは複数指定できます:

=begin original

   space   prefix non-negative number with a space
   +       prefix non-negative number with a plus sign
   -       left-justify within the field
   0       use zeros, not spaces, to right-justify
   #       ensure the leading "0" for any octal,
           prefix non-zero hexadecimal with "0x" or "0X",
           prefix non-zero binary with "0b" or "0B"

=end original

   space   非負数の前に空白をつける
   +       非負数の前にプラス記号をつける
   -       フィールド内で左詰めする
   0       右詰めに空白ではなくゼロを使う
   #       8 進数では確実に先頭に "0" をつける;
           非 0 の 16 進数では "0x" か "0X" をつける;
           非 0 の 2 進数では "0b" か "0B" をつける

=begin original

For example:

=end original

例えば:

  printf '<% d>',  12;   # prints "< 12>"
  printf '<% d>',   0;   # prints "< 0>"
  printf '<% d>', -12;   # prints "<-12>"
  printf '<%+d>',  12;   # prints "<+12>"
  printf '<%+d>',   0;   # prints "<+0>"
  printf '<%+d>', -12;   # prints "<-12>"
  printf '<%6s>',  12;   # prints "<    12>"
  printf '<%-6s>', 12;   # prints "<12    >"
  printf '<%06s>', 12;   # prints "<000012>"
  printf '<%#o>',  12;   # prints "<014>"
  printf '<%#x>',  12;   # prints "<0xc>"
  printf '<%#X>',  12;   # prints "<0XC>"
  printf '<%#b>',  12;   # prints "<0b1100>"
  printf '<%#B>',  12;   # prints "<0B1100>"

=begin original

When a space and a plus sign are given as the flags at once,
the space is ignored.

=end original

空白とプラス記号がフラグとして同時に与えられると、
空白は無視されます。

  printf '<%+ d>', 12;   # prints "<+12>"
  printf '<% +d>', 12;   # prints "<+12>"

=begin original

When the # flag and a precision are given in the %o conversion,
the precision is incremented if it's necessary for the leading "0".

=end original

%o 変換に # フラグと精度が与えられると、先頭の "0" が必要な場合は
精度に 1 が加えられます。

  printf '<%#.5o>', 012;      # prints "<00012>"
  printf '<%#.5o>', 012345;   # prints "<012345>"
  printf '<%#.0o>', 0;        # prints "<0>"

=item vector flag

(ベクタフラグ)

=begin original

This flag tells Perl to interpret the supplied string as a vector of
integers, one for each character in the string.  Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot C<.> by default).  This can be useful for displaying ordinal values of
characters in arbitrary strings:

=end original

このフラグは Perl に、与えられた文字列を、文字毎に一つの整数のベクタとして
解釈させます。
Perl は各数値をフォーマットし、それから結果の文字列をセパレータ
(デフォルトでは C<.>)で連結します。
これは任意の文字列の文字を順序付きの値として表示するのに便利です:

  printf "%vd", "AB\x{100}";           # prints "65.66.256"
  printf "version is v%vd\n", $^V;     # Perl's version

=begin original

Put an asterisk C<*> before the C<v> to override the string to
use to separate the numbers:

=end original

アスタリスク C<*> を C<v> の前に置くと、数値を分けるために使われる文字列を
上書きします:

  printf "address is %*vX\n", ":", $addr;   # IPv6 address
  printf "bits are %0*v8b\n", " ", $bits;   # random bitstring

=begin original

You can also explicitly specify the argument number to use for
the join string using something like C<*2$v>; for example:

=end original

また、C<*2$v> のように、連結する文字列として使う引数の番号を明示的に
指定できます; 例えば:

  printf '%*4$vX %*4$vX %*4$vX',       # 3 IPv6 addresses
          @addr[1..3], ":";

=item (minimum) width

((最小)幅)

=begin original

Arguments are usually formatted to be only as wide as required to
display the given value.  You can override the width by putting
a number here, or get the width from the next argument (with C<*>)
or from a specified argument (e.g., with C<*2$>):

=end original

引数は、普通は値を表示するのに必要なちょうどの幅でフォーマットされます。
ここに数値を置くか、(C<*> で)次の引数か(C<*2$> で)明示的に指定した引数で
幅を上書きできます。

 printf "<%s>", "a";       # prints "<a>"
 printf "<%6s>", "a";      # prints "<     a>"
 printf "<%*s>", 6, "a";   # prints "<     a>"
 printf '<%*2$s>', "a", 6; # prints "<     a>"
 printf "<%2s>", "long";   # prints "<long>" (does not truncate)

=begin original

If a field width obtained through C<*> is negative, it has the same
effect as the C<-> flag: left-justification.

=end original

C<*> を通して得られたフィールドの値が負数の場合、C<-> フラグと
同様の効果 (左詰め) があります。

=item precision, or maximum width
X<precision>

(精度あるいは最大幅)

=begin original

You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C<.> followed by a number.
For floating-point formats except C<g> and C<G>, this specifies
how many places right of the decimal point to show (the default being 6).
For example:

=end original

C<.> の後に数値を指定することで、(数値変換の場合)精度や(文字列変換の場合)
最大幅を指定できます。
小数点数フォーマットの場合、C<g> と C<G> を除いて、表示する小数点以下の
桁数を指定します(デフォルトは 6 です)。
例えば:

  # these examples are subject to system-specific variation
  printf '<%f>', 1;       # prints "<1.000000>"
  printf '<%.1f>', 1;     # prints "<1.0>"
  printf '<%.0f>', 1;     # prints "<1>"
  printf '<%07.2f>', 1.3; # prints "<0001.30>"
  printf '<%e>', 10;      # prints "<1.000000e+01>"
  printf '<%.1e>', 10;    # prints "<1.0e+01>"

=begin original

For "g" and "G", this specifies the maximum number of significant digits to
show; for example:

=end original

"g" と "G" の場合、これは最大有効数字を指定します; 例えば:

  # These examples are subject to system-specific variation.
  printf '<%g>', 1;        # prints "<1>"
  printf '<%.10g>', 1;     # prints "<1>"
  printf '<%g>', 100;      # prints "<100>"
  printf '<%.1g>', 100;    # prints "<1e+02>"
  printf '<%.2g>', 100.01; # prints "<1e+02>"
  printf '<%.5g>', 100.01; # prints "<100.01>"
  printf '<%.4g>', 100.01; # prints "<100>"
  printf '<%.1g>', 0.0111; # prints "<0.01>"
  printf '<%.2g>', 0.0111; # prints "<0.011>"
  printf '<%.3g>', 0.0111; # prints "<0.0111>"

=begin original

For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:

=end original

整数変換の場合、精度を指定すると、数値自体の出力はこの幅に 0 で
パッディングするべきであることを暗に示すことになり、0 フラグは
無視されます:

  printf '<%.6d>', 1;      # prints "<000001>"
  printf '<%+.6d>', 1;     # prints "<+000001>"
  printf '<%-10.6d>', 1;   # prints "<000001    >"
  printf '<%10.6d>', 1;    # prints "<    000001>"
  printf '<%010.6d>', 1;   # prints "<    000001>"
  printf '<%+10.6d>', 1;   # prints "<   +000001>"

  printf '<%.6x>', 1;      # prints "<000001>"
  printf '<%#.6x>', 1;     # prints "<0x000001>"
  printf '<%-10.6x>', 1;   # prints "<000001    >"
  printf '<%10.6x>', 1;    # prints "<    000001>"
  printf '<%010.6x>', 1;   # prints "<    000001>"
  printf '<%#10.6x>', 1;   # prints "<  0x000001>"

=begin original

For string conversions, specifying a precision truncates the string
to fit the specified width:

=end original

文字列変換の場合、精度を指定すると、指定された幅に収まるように文字列を
切り詰めます:

  printf '<%.5s>', "truncated";   # prints "<trunc>"
  printf '<%10.5s>', "truncated"; # prints "<     trunc>"

=begin original

You can also get the precision from the next argument using C<.*>, or from a
specified argument (e.g., with C<.*2$>):

=end original

C<.*> を使って精度を次の引数から取ったり、
(C<.*2$> のように) 指定した引数から取ったりすることもできます:

  printf '<%.6x>', 1;       # prints "<000001>"
  printf '<%.*x>', 6, 1;    # prints "<000001>"

  printf '<%.*2$x>', 1, 6;  # prints "<000001>"

  printf '<%6.*2$x>', 1, 4; # prints "<  0001>"

=begin original

If a precision obtained through C<*> is negative, it counts
as having no precision at all.

=end original

C<*> によって得られた精度が負数の場合、精度が指定されなかった場合と
同じ効果となります。

  printf '<%.*s>',  7, "string";   # prints "<string>"
  printf '<%.*s>',  3, "string";   # prints "<str>"
  printf '<%.*s>',  0, "string";   # prints "<>"
  printf '<%.*s>', -1, "string";   # prints "<string>"

  printf '<%.*d>',  1, 0;   # prints "<0>"
  printf '<%.*d>',  0, 0;   # prints "<>"
  printf '<%.*d>', -1, 0;   # prints "<0>"

=item size

(サイズ)

=begin original

For numeric conversions, you can specify the size to interpret the
number as using C<l>, C<h>, C<V>, C<q>, C<L>, or C<ll>.  For integer
conversions (C<d u o x X b i D U O>), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:

=end original

数値変換では、C<l>, C<h>, C<V>, C<q>, C<L>, C<ll> を使って解釈する数値の
大きさを指定できます。
整数変換 (C<d u o x X b i D U O>) では、数値は通常プラットフォームの
デフォルトの整数のサイズ (通常は 32 ビットか 64 ビット) を仮定しますが、
これを Perl がビルドされたコンパイラが対応している標準 C の型の一つで
上書きできます:

=begin original

   hh          interpret integer as C type "char" or "unsigned
               char" on Perl 5.14 or later
   h           interpret integer as C type "short" or
               "unsigned short"
   j           interpret integer as C type "intmax_t" on Perl
               5.14 or later.  Prior to Perl 5.30 this worked only
               with a C99 compiler, hence was unportable before
               that release.
   l           interpret integer as C type "long" or
               "unsigned long"
   q, L, or ll interpret integer as C type "long long",
               "unsigned long long", or "quad" (typically
               64-bit integers)
   t           interpret integer as C type "ptrdiff_t" on Perl
               5.14 or later
   z           interpret integer as C types "size_t" or
               "ssize_t" on Perl 5.14 or later

=end original

   hh          Perl 5.14 以降で整数を C の "char" または "unsigned char"
               型として解釈する
   h           整数を C の "char" または "unsigned char" 型として解釈する
   j           Perl 5.14 以降整数を C の "intmax_t" 型として解釈する。
               Perl 5.30 以前はこれは C99 コンパイラのみで動作するので、
               このリリース以前では互換性がない。
   l           整数を C の "long" または "unsigned long" と解釈する
   h           整数を C の "short" または "unsigned short" と解釈する
   q, L or ll  整数を C の "long long", "unsigned long long",
               "quads"(典型的には 64 ビット整数) のどれかと解釈する
   t           Perl 5.14 以降で整数を C の "ptrdiff_t" 型として解釈する
   z           Perl 5.14 以降で整数を C の "size_t" 型または "ssize_t" 型
               として解釈する

=begin original

Note that, in general, using the C<l> modifier (for example, when writing
C<"%ld"> or C<"%lu"> instead of C<"%d"> and C<"%u">) is unnecessary
when used from Perl code.  Moreover, it may be harmful, for example on
Windows 64-bit where a long is 32-bits.

=end original

一般的に、C<l> 修飾子を使う (例えば、C<"%d"> と C<"%u"> ではなく
C<"%ld"> や C<"%lu"> と書く) ことは、Perl のコードから使われる場合は
不要であることに注意してください。
さらに、例えば long が 32 ビットのときの 64 ビット Windows のように、
有害な場合もあります。

=begin original

As of 5.14, none of these raises an exception if they are not supported on
your platform.  However, if warnings are enabled, a warning of the
L<C<printf>|warnings> warning class is issued on an unsupported
conversion flag.  Should you instead prefer an exception, do this:

=end original

5.14 から、プラットフォームがこれらに対応していないときでも例外が
発生しなくなりました。
しかし、もし警告が有効になっているなら、
非対応変換フラグに関して L<C<printf>|warnings> 警告クラスの警告が発生します。
例外の方がお好みなら、以下のようにします:

    use warnings FATAL => "printf";

=begin original

If you would like to know about a version dependency before you
start running the program, put something like this at its top:

=end original

プログラムの実行開始前にバージョン依存について知りたいなら、先頭に
以下のようなものを書きます:

    use v5.14;  # for hh/j/t/z/ printf modifiers

=begin original

You can find out whether your Perl supports quads via L<Config>:

=end original

Perl が 64 ビット整数に対応しているかどうかは L<Config> を使って
調べられます:

    use Config;
    if ($Config{use64bitint} eq "define"
        || $Config{longsize} >= 8) {
        print "Nice quads!\n";
    }

=begin original

For floating-point conversions (C<e f g E F G>), numbers are usually assumed
to be the default floating-point size on your platform (double or long double),
but you can force "long double" with C<q>, C<L>, or C<ll> if your
platform supports them.  You can find out whether your Perl supports long
doubles via L<Config>:

=end original

浮動小数点数変換 (C<e f g E F G>) では、普通はプラットフォームのデフォルトの
不動小数点数のサイズ (double か long double) を仮定しますが、
プラットフォームが対応しているなら、C<q>, C<L>, C<ll> に対して
"long double" を強制できます。
Perl が long double に対応しているかどうかは L<Config> を使って
調べられます:

    use Config;
    print "long doubles\n" if $Config{d_longdbl} eq "define";

=begin original

You can find out whether Perl considers "long double" to be the default
floating-point size to use on your platform via L<Config>:

=end original

Perl が "long double" をデフォルトの浮動小数点数として扱っているかどうかは
L<Config> を使って調べられます:

    use Config;
    if ($Config{uselongdouble} eq "define") {
        print "long doubles by default\n";
    }

=begin original

It can also be that long doubles and doubles are the same thing:

=end original

long double と double が同じ場合もあります:

        use Config;
        ($Config{doublesize} == $Config{longdblsize}) &&
                print "doubles are long doubles\n";

=begin original

The size specifier C<V> has no effect for Perl code, but is supported for
compatibility with XS code.  It means "use the standard size for a Perl
integer or floating-point number", which is the default.

=end original

サイズ指定子 C<V> は Perl のコードには何の影響もありませんが、これは
XS コードとの互換性のために対応しています。
これは「Perl 整数 (または浮動小数点数) として標準的なサイズを使う」ことを
意味し、これはデフォルトです。

=item order of arguments

(引数の順序)

=begin original

Normally, C<sprintf> takes the next unused
argument as the value to
format for each format specification.  If the format specification
uses C<*> to require additional arguments, these are consumed from
the argument list in the order they appear in the format
specification I<before> the value to format.  Where an argument is
specified by an explicit index, this does not affect the normal
order for the arguments, even when the explicitly specified index
would have been the next argument.

=end original

通常、C<sprintf> は各フォーマット指定について、
使われていない次の引数を
フォーマットする値として使います。
追加の引数を要求するためにフォーマット指定 C<*> を使うと、
これらはフォーマットする値の I<前> のフォーマット指定に現れる順番に
引数リストから消費されます。
引数の位置が明示的なインデックスを使って指定された場合、
(明示的に指定したインデックスが次の引数の場合でも)
これは通常の引数の順番に影響を与えません。

=begin original

So:

=end original

それで:

    printf "<%*.*s>", $x, $y, $z;

=begin original

uses C<$x> for the width, C<$y> for the precision, and C<$z>
as the value to format; while:

=end original

とすると C<$x> を幅に、C<$y> を精度に、C<$z> をフォーマットの値に
使います; 一方:

  printf '<%*1$.*s>', $x, $y;

=begin original

would use C<$x> for the width and precision, and C<$y> as the
value to format.

=end original

とすると C<$x> を幅と精度に、C<$y> をフォーマットの値に使います。

=begin original

Here are some more examples; be aware that when using an explicit
index, the C<$> may need escaping:

=end original

以下にさらなる例を示します; 明示的にインデックスを使う場合、C<$> は
エスケープする必要があることに注意してください:

 printf "%2\$d %d\n",      12, 34;     # will print "34 12\n"
 printf "%2\$d %d %d\n",   12, 34;     # will print "34 12 34\n"
 printf "%3\$d %d %d\n",   12, 34, 56; # will print "56 12 34\n"
 printf "%2\$*3\$d %d\n",  12, 34,  3; # will print " 34 12\n"
 printf "%*1\$.*f\n",       4,  5, 10; # will print "5.0000\n"

=back

=begin original

If L<C<use locale>|locale> (including C<use locale ':not_characters'>)
is in effect and L<C<POSIX::setlocale>|POSIX/C<setlocale>> has been
called,
the character used for the decimal separator in formatted floating-point
numbers is affected by the C<LC_NUMERIC> locale.  See L<perllocale>
and L<POSIX>.

=end original

(C<use locale ':not_characters'> を含む)L<C<use locale>|locale> が有効で、
L<C<POSIX::setlocale>|POSIX/C<setlocale>> が呼び出されている場合、
フォーマットされた浮動小数点数の小数点として使われる文字は
C<LC_NUMERIC> ロケールの影響を受けます。
L<perllocale> と L<POSIX> を参照してください。

=item sqrt EXPR
X<sqrt> X<root> X<square root>

=item sqrt

=for Pod::Functions square root function

=begin original

Return the positive square root of EXPR.  If EXPR is omitted, uses
L<C<$_>|perlvar/$_>.  Works only for non-negative operands unless you've
loaded the L<C<Math::Complex>|Math::Complex> module.

=end original

EXPR の正の平方根を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。
L<C<Math::Complex>|Math::Complex> モジュールを使わない場合は、負の数の引数は
扱えません。

    use Math::Complex;
    print sqrt(-4);    # prints 2i

=item srand EXPR
X<srand> X<seed> X<randseed>

=item srand

=for Pod::Functions seed the random number generator

=begin original

Sets and returns the random number seed for the L<C<rand>|/rand EXPR>
operator.

=end original

L<C<rand>|/rand EXPR> 演算子のためのシード値を設定して返します。

=begin original

The point of the function is to "seed" the L<C<rand>|/rand EXPR>
function so that L<C<rand>|/rand EXPR> can produce a different sequence
each time you run your program.  When called with a parameter,
C<srand> uses that for the seed; otherwise it
(semi-)randomly chooses a seed (see below).  In either case, starting with Perl 5.14,
it returns the seed.  To signal that your code will work I<only> on Perls
of a recent vintage:

=end original

この関数のポイントは、プログラムを実行するごとに L<C<rand>|/rand EXPR> 関数が
異なる乱数列を生成できるように L<C<rand>|/rand EXPR> 関数の「種」を
設定することです。
C<srand> を引数付きで呼び出すと、これを種として使います;
さもなければ(だいたい)ランダムに種を選びます(後述)。
どちらの場合でも、Perl 5.14 からは種を返します。
特定の時期の Perl I<でのみ> 動作することを知らせるには以下のようにします:

    use v5.14;	# so srand returns the seed

=begin original

If C<srand> is not called explicitly, it is called
implicitly without a parameter at the first use of the
L<C<rand>|/rand EXPR> operator.  However, there are a few situations
where programs are likely to want to call C<srand>.  One
is for generating predictable results, generally for testing or
debugging.  There, you use C<srand($seed)>, with the same C<$seed> each
time.  Another case is that you may want to call C<srand>
after a L<C<fork>|/fork> to avoid child processes sharing the same seed
value as the parent (and consequently each other).

=end original

C<srand> が明示的に呼び出されなかった場合、最初に
L<C<rand>|/rand EXPR> 演算子を使った時点で暗黙に引数なしで呼び出されます。
しかし、最近の Perl でプログラムが C<srand> を
呼び出したいであろう状況がいくつかあります。
一つはテストやデバッグのために予測可能な結果を生成するためです。
この場合、C<srand($seed)> (C<$seed> は毎回同じ値を使う) を使います。
もう一つの場合としては、子プロセスが親や他の子プロセスと同じ種の値を
共有することを避けるために、L<C<fork>|/fork> の後に C<srand> を
呼び出したいかもしれません。

=begin original

Do B<not> call C<srand()> (i.e., without an argument) more than once per
process.  The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
C<srand> again actually I<loses> randomness.

=end original

C<srand> (引数なし)をプロセス中で複数回
呼び出しては B<いけません>。
乱数生成器の内部状態はどのような種によって提供されるものよりも
高いエントロピーを持っているので、C<srand()> を再び呼び出すと
ランダム性が I<失われます>。

=begin original

Most implementations of C<srand> take an integer and will
silently
truncate decimal numbers.  This means C<srand(42)> will usually
produce the same results as C<srand(42.1)>.  To be safe, always pass
C<srand> an integer.

=end original

C<srand> のほとんどの実装では整数を取り、小数を暗黙に
切り捨てます。
これは、C<srand(42)> は普通 C<srand(42.1)> と同じ結果になることを意味します。
安全のために、C<srand> には常に整数を渡しましょう。

=begin original

A typical use of the returned seed is for a test program which has too many
combinations to test comprehensively in the time available to it each run.  It
can test a random subset each time, and should there be a failure, log the seed
used for that run so that it can later be used to reproduce the same results.

=end original

返された種の典型的な利用法は、実行毎のテストを利用可能な時間内に完全に
行うには組み合わせが多すぎるテストプログラム用です。
毎回ランダムなサブセットをテストし、もし失敗したら、その実行で使った
種をログに出力することで、後で同じ結果を再現するために使えます。

=begin original

If the C<PERL_RAND_SEED> environment variable is set to a non-negative
integer during process startup then calls to C<srand()> with no
arguments will initialize the perl random number generator with a
consistent seed each time it is called, whether called explicitly with
no arguments or implicitly via use of C<rand()>. The exact seeding that
a given C<PERL_RAND_SEED> will produce is deliberately unspecified, but
using different values for C<PERL_RAND_SEED> should produce different
results. This is intended for debugging and performance analysis and is
only guaranteed to produce consistent results between invocations of the
same perl executable running the same code when all other factors are
equal. The environment variable is read only once during process
startup, and changing it during the program flow will not affect the
currently running process. See L<perlrun> for more details.

=end original

プロセスの起動時に C<PERL_RAND_SEED> 環境変数が非負整数に
設定されている場合、引数を指定せずに C<srand()> を呼び出すと、
引数を指定せずに明示的に呼び出されたか、C<rand()> を使うことにより
暗黙的に呼び出されたかに拘らず、呼び出されるたびに一貫した種で
perl 乱数生成器が初期化されます。
特定の C<PERL_RAND_SEED> が生成する正確な種は意図的に
未指定ですが、C<PERL_RAND_SEED> に異なる値を使うと、
異なる結果が生成されます。
これはデバッグとパフォーマンス分析を目的としており、他の
すべての要素が等しい場合に、同じコードを実行する同じ Perl
実行可能ファイルの呼び出し間で一貫した結果が生成されることのみが
保証されています。
環境変数はプロセスの起動時に 1 回だけ読み込まれ、プログラム
フロー中に変更しても、現在実行中のプロセスには影響しません。
さらなる詳細については L<perlrun> を参照してください。

=begin original

B<L<C<rand>|/rand EXPR> is not cryptographically secure.  You should not rely
on it in security-sensitive situations.> See documentation of C<rand> for
a list of suitable alternatives.

=end original

B<L<C<rand>|/rand EXPR> は暗号学的に安全ではありません。
セキュリティ的に重要な状況でこれに頼るべきではありません。>
適切な代替案の一覧については C<rand> の文書を参照してください。

=item stat FILEHANDLE
X<stat> X<file, status> X<ctime>

=item stat EXPR

=item stat DIRHANDLE

=item stat

=for Pod::Functions get a file's status information

=begin original

Returns a 13-element list giving the status info for a file, either
the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.  If EXPR is
omitted, it stats L<C<$_>|perlvar/$_> (not C<_>!).  Returns the empty
list if C<stat> fails.  Typically
used as follows:

=end original

FILEHANDLE か DIRHANDLE を通じてオープンされているファイルか、
EXPR で指定されるファイルの情報を与える、13 要素のリストを返します。
EXPR が省略されると、 L<C<$_>|perlvar/$_> が用いられます
(C<_> ではありません!)。
C<stat> に失敗した場合には、空リストを返します。
普通は、以下のようにして使います:

    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);

=begin original

Not all fields are supported on all filesystem types.  Here are the
meanings of the fields:

=end original

全てのファイルシステムで全てのフィールドに対応しているわけではありません。
フィールドの意味は以下の通りです。

=begin original

  0 dev      device number of filesystem
  1 ino      inode number
  2 mode     file mode  (type and permissions)
  3 nlink    number of (hard) links to the file
  4 uid      numeric user ID of file's owner
  5 gid      numeric group ID of file's owner
  6 rdev     the device identifier (special files only)
  7 size     total size of file, in bytes
  8 atime    last access time in seconds since the epoch
  9 mtime    last modify time in seconds since the epoch
 10 ctime    inode change time in seconds since the epoch (*)
 11 blksize  preferred I/O size in bytes for interacting with the
             file (may vary from file to file)
 12 blocks   actual number of system-specific blocks allocated
             on disk (often, but not always, 512 bytes each)

=end original

  0 dev      ファイルシステムのデバイス番号
  1 ino      inode 番号
  2 mode     ファイルモード (タイプとパーミッション)
  3 nlink    ファイルへの(ハード)リンクの数
  4 uid      ファイル所有者のユーザー ID の数値
  5 gid      ファイル所有者のグループ ID の数値
  6 rdev     デバイス識別子(特殊ファイルのみ)
  7 size     ファイルサイズ(バイト単位)
  8 atime    紀元から、最後にアクセスされた時刻までの秒数
  9 mtime    紀元から、最後に修正(modify)された時刻までの秒数
 10 ctime    紀元から、inode 変更(change)された時刻までの秒数 (*)
 11 blksize  ファイルとの相互作用のために適した I/O バイト数
             (ファイルごとに異なるかもしれない)
 12 blocks   ディスクに割り当てたシステム依存のブロック(常にでは
             ありませんがたいていはそれぞれ 512 バイト)の数

=begin original

(The epoch was at 00:00 January 1, 1970 GMT.)

=end original

(紀元は GMT で 1970/01/01 00:00:00。)

=begin original

(*) Not all fields are supported on all filesystem types.  Notably, the
ctime field is non-portable.  In particular, you cannot expect it to be a
"creation time"; see L<perlport/"Files and Filesystems"> for details.

=end original

(*) 全てのフィールドが全てのファイルシステムタイプで対応しているわけでは
ありません。
明らかに、ctime のフィールドは移植性がありません。
特に、これから「作成時刻」を想定することは出来ません;
詳細については L<perlport/"Files and Filesystems"> を参照してください。

=begin original

If C<stat> is passed the special filehandle
consisting of an underline, no stat is done, but the current contents of
the stat structure from the last C<stat>,
L<C<lstat>|/lstat FILEHANDLE>, or filetest are returned.  Example:

=end original

下線だけの _ という特別なファイルハンドルを C<stat> に
渡すと、実際には stat を行なわず、stat 構造体に残っている
前回の C<stat>, L<C<lstat>|/lstat FILEHANDLE> や
ファイルテストの情報が返されます。
例:

    if (-x $file && (($d) = stat(_)) && $d < 0) {
        print "$file is executable NFS file\n";
    }

=begin original

(This works on machines only for which the device number is negative
under NFS.)

=end original

(これは、NFS のもとでデバイス番号が負になるマシンでのみ動作します。)

=begin original

On some platforms inode numbers are of a type larger than perl knows how
to handle as integer numerical values.  If necessary, an inode number will
be returned as a decimal string in order to preserve the entire value.
If used in a numeric context, this will be converted to a floating-point
numerical value, with rounding, a fate that is best avoided.  Therefore,
you should prefer to compare inode numbers using C<eq> rather than C<==>.
C<eq> will work fine on inode numbers that are represented numerically,
as well as those represented as strings.

=end original

一部のプラットフォームでは、inode 番号は perl が整数値として
扱い方を知っているものよりも大きい型になっています。
もし必要なら、inode 番号は、値全体を保存するために 10 進文字列として
返されます。
数値コンテキストで使うと、これは丸めを伴う浮動小数点数に変換され、
できるだけ避けるべき結果になります。
従って、inode 番号の比較には C<==> ではなく C<eq> を使うべきです。
C<eq> は、inode 番号が数値で表現されていても、文字列で表現されていても
うまく動作します。

=begin original

Because the mode contains both the file type and its permissions, you
should mask off the file type portion and (s)printf using a C<"%o">
if you want to see the real permissions.

=end original

モードにはファイルタイプとその権限の両方が含まれているので、
本当の権限を見たい場合は、(s)printf で C<"%"> を使うことで
ファイルタイプをマスクするべきです。

    my $mode = (stat($filename))[2];
    printf "Permissions are %04o\n", $mode & 07777;

=begin original

In scalar context, C<stat> returns a boolean value
indicating success
or failure, and, if successful, sets the information associated with
the special filehandle C<_>.

=end original

スカラコンテキストでは、C<stat> は成功か失敗を表す真偽値を
返し、成功した場合は、特別なファイルハンドル C<_> に結び付けられた
情報をセットします。

=begin original

The L<File::stat> module provides a convenient, by-name access mechanism:

=end original

L<File::stat> モジュールは、便利な名前によるアクセス機構を提供します。

    use File::stat;
    my $sb = stat($filename);
    printf "File is %s, size is %s, perm %04o, mtime %s\n",
           $filename, $sb->size, $sb->mode & 07777,
           scalar localtime $sb->mtime;

=begin original

You can import symbolic mode constants and functions
(C<S_I*>) from the L<Fcntl> module:

=end original

モード定数と関数 (C<S_I*>) を L<Fcntl> モジュールから
インポートできます。

    use Fcntl ':mode';

    my $mode = (stat($filename))[2];

    my $user_rwx      = ($mode & S_IRWXU) >> 6;
    my $group_read    = ($mode & S_IRGRP) >> 3;
    my $other_execute =  $mode & S_IXOTH;

    printf "Permissions are %04o\n", S_IMODE($mode), "\n";

    my $is_setuid     =  $mode & S_ISUID;
    my $is_directory  =  S_ISDIR($mode);

=begin original

You could write the last two using the C<-u> and C<-d> operators.
Commonly available C<S_I*> constants are:

=end original

最後の二つは C<-u> と C<-d> 演算子を使っても書けます。
一般に利用可能な C<S_I*> 定数は以下のものです。

    # Permissions: read, write, execute, for user, group, others.

    S_IRWXU S_IRUSR S_IWUSR S_IXUSR
    S_IRWXG S_IRGRP S_IWGRP S_IXGRP
    S_IRWXO S_IROTH S_IWOTH S_IXOTH

    # Setuid/Setgid/Stickiness/SaveText/EnforcedLocks.
    # Note that the exact meaning of these is system-dependent.

    S_ISUID S_ISGID S_ISVTX S_ISTXT S_ENFMT

    # File types.  Not all are necessarily available on
    # your system.

    S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR
    S_IFIFO S_IFSOCK S_IFWHT

    # The following are compatibility aliases for S_IRUSR,
    # S_IWUSR, and S_IXUSR.

    S_IREAD S_IWRITE S_IEXEC

=begin original

and the C<S_I*> functions are

=end original

一般に利用可能な C<S_I*> 関数は以下のものです。

    S_IMODE($mode)    the part of $mode containing the permission
                      bits and the setuid/setgid/sticky bits

    S_IFMT($mode)     the part of $mode containing the file type,
                      which will match one of the S_IF* constants
                      (e.g. S_IFMT($mode) == S_IFDIR for directories),
                      but see the following helper functions

    # The operators -f, -d, -l, -b, -c, -p, and -S.

    S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)
    S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)

    # No direct -X operator counterpart.

    S_ISWHT($mode)

=begin original

See your native L<chmod(2)> and L<stat(2)> documentation for more details
about the C<S_I*> constants.  To get status info for a symbolic link
instead of the target file behind the link, use the
L<C<lstat>|/lstat FILEHANDLE> function.

=end original

C<S_I*> 定数に関する詳細についてはネイティブの L<chmod(2)> と L<stat(2)> の
ドキュメントを参照してください。
リンクの先にあるファイルではなく、シンボリックリンクそのものの情報を
得たい場合は、L<C<lstat>|/lstat FILEHANDLE> 関数を使ってください。

=begin original

Portability issues: L<perlport/stat>.

=end original

移植性の問題: L<perlport/stat>。

=item state VARLIST
X<state>

=item state TYPE VARLIST

=item state VARLIST : ATTRS

=item state TYPE VARLIST : ATTRS

=for Pod::Functions +state declare and assign a persistent lexical variable

=begin original

C<state> declares a lexically scoped variable, just
like L<C<my>|/my VARLIST>.
However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.
See L<perlsub/"Persistent Private Variables"> for details.

=end original

C<state> はちょうど L<C<my>|/my VARLIST> と同様に、
レキシカルなスコープの変数を宣言します。
しかし、レキシカル変数がブロックに入る毎に再初期化されるのと異なり、
この変数は決して再初期化されません。
詳しくは L<perlsub/"Persistent Private Variables"> を参照してください。

=begin original

If more than one variable is listed, the list must be placed in
parentheses.  With a parenthesised list, L<C<undef>|/undef EXPR> can be
used as a
dummy placeholder.  However, since initialization of state variables in
such lists is currently not possible this would serve no purpose.

=end original

複数の変数を指定する場合は、リストはかっこで囲まなければなりません。
かっこで囲まれたリストでは、L<C<undef>|/undef EXPR> はダミーの
プレースホルダとして使えます。
しかし、そのようなリストでの state 変数の初期化は現在のところできないので、
これは無意味です。

=begin original

Like L<C<my>|/my VARLIST>, L<C<local>|/local EXPR>, and
L<C<our>|/our VARLIST>, C<state> can operate on a variable
anywhere it appears in an expression (aside from interpolation in strings).
The declaration will not apply to additional uses of the same variable until
the next statement. This means additional uses of that variable within the
same statement will act as they would have before that declaration occurred,
or result in a strict 'vars' error, as appropriate.

=end original

L<C<my>|/my VARLIST>, L<C<local>|/local EXPR>,
L<C<our>|/our VARLIST> と同様に、C<state> は、
(文字列内の置換を除いて) 式内の任意の場所で変数を操作できます。
この宣言は、次の文まで、同じ変数の追加使用には適用されません。
つまり、同じ文内でその変数を追加使用すると、適切に、
その宣言が行われる前と同じように動作するか、
strict 'vars' エラーが発生します。

    package main;
    use feature 'state';
    our $x = 2;
    foo($x, state $x = $x + 1, $x); # foo() receives (2, 3, 2)
    foo($x, $main::x);              # foo() receives (3, 2)

=begin original

Redeclaring a variable in the same scope or statement will "shadow" the
previous declaration, creating a new instance and preventing access to
the previous one. This is usually undesired and, if warnings are enabled,
will result in a warning in the C<shadow> category.

=end original

同じスコープや文で変数を再宣言すると、以前の宣言を「隠し」、
新しい実体を作って、以前の実体にアクセスできなくなります。
これは普通は望まれているものではなく、警告が有効なら、
C<shadow> カテゴリの警告が出ます。

=begin original

C<state> is available only if the
L<C<"state"> feature|feature/The 'state' feature> is enabled or if it is
prefixed with C<CORE::>.  The
L<C<"state"> feature|feature/The 'state' feature> is enabled
automatically with a C<use v5.10> (or higher) declaration in the current
scope.

=end original

C<state> は
L<C<"state"> 機能|feature/The 'state' feature> が有効か C<CORE::> を
前置した場合にのみ利用可能です。
L<C<"state"> 機能|feature/The 'state' feature> は現在のスコープで
C<use v5.10> (またはそれ以上) を宣言した場合自動的に有効になります。

=item study SCALAR
X<study>

=item study

=for Pod::Functions no-op, formerly optimized input data for repeated searches

=begin original

At this time, C<study> does nothing. This may change in the future.

=end original

現時点では、C<study> は何もしません。
これは将来変更されるかもしれません。

=begin original

Prior to Perl version 5.16, it would create an inverted index of all characters
that occurred in the given SCALAR (or L<C<$_>|perlvar/$_> if unspecified). When
matching a pattern, the rarest character from the pattern would be looked up in
this index. Rarity was based on some static frequency tables constructed from
some C programs and English text.

=end original

Perl バージョン 5.16 より前では、
与えられた SCALAR (または指定されていなかった場合は L<C<$_>|perlvar/$_>)に
現れた全ての文字の転置インデックスを作ります。
パターンにマッチングしたとき、
パターン中の最も頻度の少ない文字がこのインデックスから探されます。
頻度は、C プログラムと英語の文章から構築された静的頻度テーブルを
基にしています。

=item sub NAME BLOCK
X<sub>

=item sub NAME (PROTO) BLOCK

=item sub NAME : ATTRS BLOCK

=item sub NAME (PROTO) : ATTRS BLOCK

=for Pod::Functions declare a subroutine, possibly anonymously

=begin original

This is subroutine definition, not a real function I<per se>.  Without a
BLOCK it's just a forward declaration.  Without a NAME, it's an anonymous
function declaration, so does return a value: the CODE ref of the closure
just created.

=end original

これはサブルーチン定義であり、I<本質的には> 実際の関数ではありません。
BLOCK なしの場合、これは単に前方宣言です。
NAME なしの場合は、無名関数定義であり、値(作成したブロックの
コードリファレンス)を返します: 単にクロージャの CODE リファレンスが
作成されます。

=begin original

See L<perlsub> and L<perlref> for details about subroutines and
references; see L<attributes> and L<Attribute::Handlers> for more
information about attributes.

=end original

サブルーチンとリファレンスに関する詳細については、L<perlsub> と
L<perlref> を参照してください; 属性に関する更なる情報については
L<attributes> と L<Attribute::Handlers> を参照してください。

=item __SUB__
X<__SUB__>

=for Pod::Functions +current_sub the current subroutine, or C<undef> if not in a subroutine

=begin original

A special token that returns a reference to the current subroutine, or
L<C<undef>|/undef EXPR> outside of a subroutine.

=end original

現在のサブルーチンのリファレンスを返す特殊トークン; サブルーチンの外側では
L<C<undef>|/undef EXPR>。

=begin original

The behaviour of L<C<__SUB__>|/__SUB__> within a regex code block (such
as C</(?{...})/>) is subject to change.

=end original

(C</(?{...})/> のような) 正規表現コードブロックの中の
L<C<__SUB__>|/__SUB__> の振る舞いは変更される予定です。

=begin original

This token is only available under C<use v5.16> or the
L<C<"current_sub"> feature|feature/The 'current_sub' feature>.
See L<feature>.

=end original

このトークンは C<use v5.16> または
L<C<"current_sub"> 機能|feature/The 'current_sub' feature> でのみ
利用可能です。
L<feature> を参照してください。

=item substr EXPR,OFFSET,LENGTH,REPLACEMENT
X<substr> X<substring> X<mid> X<left> X<right>

=item substr EXPR,OFFSET,LENGTH

=item substr EXPR,OFFSET

=for Pod::Functions get or alter a portion of a string

=begin original

Extracts a substring out of EXPR and returns it.  First character is at
offset zero.  If OFFSET is negative, starts
that far back from the end of the string.  If LENGTH is omitted, returns
everything through the end of the string.  If LENGTH is negative, leaves that
many characters off the end of the string.

=end original

EXPR から、部分文字列を取り出して返します。
最初の文字がオフセット 0 となります。
OFFSET に負の値を設定すると、EXPR の終わりからのオフセットとなります。
LENGTH を省略すると、EXPR の最後まですべてが返されます。
LENGTH が負の値だと、文字列の最後から指定された数だけ文字を取り除きます。

    my $s = "The black cat climbed the green tree";
    my $color  = substr $s, 4, 5;      # black
    my $middle = substr $s, 4, -11;    # black cat climbed the
    my $end    = substr $s, 14;        # climbed the green tree
    my $tail   = substr $s, -4;        # tree
    my $z      = substr $s, -4, 2;     # tr

=begin original

You can use the C<substr>
function as an lvalue, in which case EXPR
must itself be an lvalue.  If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.  To keep the string the same
length, you may need to pad or chop your value using
L<C<sprintf>|/sprintf FORMAT, LIST>.

=end original

C<substr> を左辺値として
使用することも可能で、その場合には、EXPR が自身左辺値でなければなりません。
LENGTH より短いものを代入したときには、
EXPR は短くなり、LENGTH より長いものを代入したときには、
EXPR はそれに合わせて伸びることになります。
EXPR の長さを一定に保つためには、L<C<sprintf>|/sprintf FORMAT, LIST> を
使って、代入する値の長さを調整することが、必要になるかもしれません。

=begin original

If OFFSET and LENGTH specify a substring that is partly outside the
string, only the part within the string is returned.  If the substring
is beyond either end of the string,
C<substr> returns the undefined
value and produces a warning.  When used as an lvalue, specifying a
substring that is entirely outside the string raises an exception.
Here's an example showing the behavior for boundary cases:

=end original

OFFSET と LENGTH として文字列の外側を含むような部分文字列が指定されると、
文字列の内側の部分だけが返されます。
部分文字列が文字列の両端の外側の場合、
C<substr> は未定義値を返し、
警告が出力されます。
左辺値として使った場合、文字列の完全に外側を部分文字列として指定すると
例外が発生します。
以下は境界条件の振る舞いを示す例です:

    my $name = 'fred';
    substr($name, 4) = 'dy';         # $name is now 'freddy'
    my $null = substr $name, 6, 2;   # returns "" (no warning)
    my $oops = substr $name, 7;      # returns undef, with warning
    substr($name, 7) = 'gap';        # raises an exception

=begin original

An alternative to using
C<substr> as an lvalue is to
specify the
REPLACEMENT string as the 4th argument.  This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with
L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST>.

=end original

C<substr> を左辺値として使う
代わりの方法は、置き換える文字列を 4 番目の引数として指定することです。
これにより、EXPR の一部を置き換え、置き換える前が何であったかを返す、
ということを(L<C<splice>|/splice ARRAY,OFFSET,LENGTH,LIST> と同様)
1 動作で行えます。

    my $s = "The black cat climbed the green tree";
    my $z = substr $s, 14, 7, "jumped from";    # climbed
    # $s is now "The black cat jumped from the green tree"

=begin original

Note that the lvalue returned by the three-argument version of
C<substr> acts as
a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:

=end original

3 引数の C<substr> によって返された
左辺値は「魔法の弾丸」のように振舞うことに注意してください;
これが代入される毎に、元の文字列のどの部分が変更されたかが思い出されます;
例えば:

    my $x = '1234';
    for (substr($x,1,2)) {
        $_ = 'a';   print $x,"\n";    # prints 1a4
        $_ = 'xyz'; print $x,"\n";    # prints 1xyz4
        $x = '56789';
        $_ = 'pq';  print $x,"\n";    # prints 5pq9
    }

=begin original

With negative offsets, it remembers its position from the end of the string
when the target string is modified:

=end original

負数のオフセットの場合、ターゲット文字列が修正されたときに文字列の末尾からの
位置を覚えます:

    my $x = '1234';
    for (substr($x, -3, 2)) {
        $_ = 'a';   print $x,"\n";    # prints 1a4, as above
        $x = 'abcdefg';
        print $_,"\n";                # prints f
    }

=begin original

Prior to Perl version 5.10, the result of using an lvalue multiple times was
unspecified.  Prior to 5.16, the result with negative offsets was
unspecified.

=end original

バージョン 5.10 より前の Perl では、複数回左辺値を使った場合の結果は
未定義でした。
5.16 より前では、負のオフセットの結果は未定義です。

=item symlink OLDFILE,NEWFILE
X<symlink> X<link> X<symbolic link> X<link, symbolic>

=for Pod::Functions create a symbolic link to a file

=begin original

Creates a new filename symbolically linked to the old filename.
Returns C<1> for success, C<0> otherwise.  On systems that don't support
symbolic links, raises an exception.  To check for that,
use eval:

=end original

NEWFILE として、OLDFILE へのシンボリックリンクを生成します。
成功時には C<1> を返し、失敗時には C<0> を返します。
シンボリックリンクをサポートしていないシステムでは、
例外が発生します。
これをチェックするには、eval を使用します:

    my $symlink_exists = eval { symlink("",""); 1 };

=begin original

Portability issues: L<perlport/symlink>.

=end original

移植性の問題: L<perlport/symlink>。

=item syscall NUMBER, LIST
X<syscall> X<system call>

=for Pod::Functions execute an arbitrary system call

=begin original

Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.  If
unimplemented, raises an exception.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  You can't use a
string literal (or other read-only string) as an argument to
C<syscall> because Perl has to assume that any
string pointer might be written through.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add C<0> to them to force them to look
like numbers.  This emulates the
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET> function (or
vice versa):

=end original

LIST の最初の要素で指定するシステムコールを、残りの要素をその
システムコールの引数として呼び出します。
実装されていない場合には、例外が発生します。
引数は、以下のように解釈されます: 引数が数字であれば、int として
引数を渡します。
そうでなければ、文字列値へのポインタが渡されます。
文字列に結果を受け取るときには、その結果を受け取るのに十分なくらいに、
文字列を予め伸ばしておく必要があります。
文字列リテラル(あるいはその他の読み込み専用の文字列)を
C<syscall> の引数として使うことはできません;
Perl は全ての文字列ポインタは書き込まれると仮定しなければならないからです。
整数引数が、リテラルでなく、数値コンテキストで評価されたことのない
ものであれば、数値として解釈されるように、
C<0> を足しておく必要があるかもしれません。
以下は L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET> 関数(あるいは
その逆)をエミュレートします。

    require 'syscall.ph';        # may need to run h2ph
    my $s = "hi there\n";
    syscall(SYS_write(), fileno(STDOUT), $s, length $s);

=begin original

Note that Perl supports passing of up to only 14 arguments to your syscall,
which in practice should (usually) suffice.

=end original

Perl は、システムコールに最大 14 個の引数しか渡せませんが、
(普通は)実用上問題はないでしょう。

=begin original

Syscall returns whatever value returned by the system call it calls.
If the system call fails, C<syscall> returns
C<-1> and sets L<C<$!>|perlvar/$!> (errno).
Note that some system calls I<can> legitimately return C<-1>.  The proper
way to handle such calls is to assign C<$! = 0> before the call, then
check the value of L<C<$!>|perlvar/$!> if
C<syscall> returns C<-1>.

=end original

syscall は、呼び出したシステムコールが返した値を返します。
システムコールが失敗すると、C<syscall> は C<-1> を
返し、L<C<$!>|perlvar/$!>(errno) を設定します。
システムコールが正常に C<-1> を返す I<場合がある> ことに注意してください。
このようなシステムコールを正しく扱うには、
C<$! = 0> をシステムコールの前に実行し、それから
C<syscall> が C<-1> を返した時には
L<C<$!>|perlvar/$!> の値を調べてください。

=begin original

There's a problem with C<syscall(SYS_pipe())>: it returns the file
number of the read end of the pipe it creates, but there is no way
to retrieve the file number of the other end.  You can avoid this
problem by using L<C<pipe>|/pipe READHANDLE,WRITEHANDLE> instead.

=end original

C<syscall(&SYS_pipe)> には問題があり、作ったパイプの、読み出し側の
ファイル番号を返しますが、もう一方のファイル番号を得る方法がありません。
この問題を避けるためには、代わりに L<C<pipe>|/pipe READHANDLE,WRITEHANDLE> を
使ってください。

=begin original

Portability issues: L<perlport/syscall>.

=end original

移植性の問題: L<perlport/syscall>。

=item sysopen FILEHANDLE,FILENAME,MODE
X<sysopen>

=item sysopen FILEHANDLE,FILENAME,MODE,PERMS

=for Pod::Functions +5.002 open a file, pipe, or descriptor

=begin original

Opens the file whose filename is given by FILENAME, and associates it with
FILEHANDLE.  If FILEHANDLE is an expression, its value is used as the real
filehandle wanted; an undefined scalar will be suitably autovivified.  This
function calls the underlying operating system's L<open(2)> function with the
parameters FILENAME, MODE, and PERMS.

=end original

FILENAME で与えられたファイル名のファイルをオープンし、
FILEHANDLE と結び付けます。
FILEHANDLE が式の場合、その値は実際の求めているファイルハンドルの名前として
扱われます; 未定義のスカラは適切に自動有効化されます。
この関数呼び出しはシステムの L<open(2)> 関数を FILENAME, MODE, PERMS の
引数で呼び出すことを基礎としています。

=begin original

Returns true on success and L<C<undef>|/undef EXPR> otherwise.

=end original

成功時は真を、さもなければ L<C<undef>|/undef EXPR> を返します。

=begin original

L<PerlIO> layers will be applied to the handle the same way they would in an
L<C<open>|/open FILEHANDLE,MODE,EXPR> call that does not specify layers. That is,
the current value of L<C<${^OPEN}>|perlvar/${^OPEN}> as set by the L<open>
pragma in a lexical scope, or the C<-C> command-line option or C<PERL_UNICODE>
environment variable in the main program scope, falling back to the platform
defaults as described in L<PerlIO/Defaults and how to override them>. If you
want to remove any layers that may transform the byte stream, use
L<C<binmode>|/binmode FILEHANDLE, LAYER> after opening it.

=end original

L<PerlIO> 層は、層を指定しない L<C<open>|/open FILEHANDLE,MODE,EXPR>
呼び出しでするのと同じ方法でハンドルに適用されます。
これは、レキシカルスコープの L<open> プラグマで設定された
L<C<${^OPEN}>|perlvar/${^OPEN}> の現在の値、
またはメインプログラムスコープの C<-C> コマンドラインオプションまたは
C<PERL_UNICODE> 環境変数、L<PerlIO/Defaults and how to override them> で
記述されているようにプラットフォームのデフォルトに
フォールバックしたものです。
バイトストリームを変換する全ての層を除去したい場合は、
それを開いた後に L<C<binmode>|/binmode FILEHANDLE, LAYER> を使ってください。

=begin original

The possible values and flag bits of the MODE parameter are
system-dependent; they are available via the standard module
L<C<Fcntl>|Fcntl>.  See the documentation of your operating system's
L<open(2)> syscall to see
which values and flag bits are available.  You may combine several flags
using the C<|>-operator.

=end original

MODE パラメータに指定できるフラグビットと値はシステム依存です;
これは標準モジュール L<C<Fcntl>|Fcntl> 経由で利用可能です。
どのようなフラグビットと値が利用可能であるかについては、
OS の L<open(2)> システムコールに関する文書を参照してください。
C<|> 演算子を使って複数のフラグを結合することができます。

=begin original

Some of the most common values are C<O_RDONLY> for opening the file in
read-only mode, C<O_WRONLY> for opening the file in write-only mode,
and C<O_RDWR> for opening the file in read-write mode.
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=end original

もっともよく使われる値は、ファイルを読み込み専用で開く C<O_RDONLY>、
ファイルを書き込み専用で開く C<O_WRONLY>、
ファイルを読み書き両用で開く C<O_RDWR> です。
X<O_RDONLY> X<O_RDWR> X<O_WRONLY>

=begin original

For historical reasons, some values work on almost every system
supported by Perl: 0 means read-only, 1 means write-only, and 2
means read/write.  We know that these values do I<not> work under
OS/390; you probably don't want to use them in new code.

=end original

歴史的な理由により、Perl が対応しているほとんどのシステムで使える値が
あります:0 は読み込み専用、1 は書き込み専用、2 は読み書き両用を意味します。
OS/390 では動作 I<しない> ことが分かっています;
新しく書くコードではこれらは使わないほうがよいでしょう。

=begin original

If the file named by FILENAME does not exist and the
L<C<open>|/open FILEHANDLE,MODE,EXPR> call creates
it (typically because MODE includes the C<O_CREAT> flag), then the value of
PERMS specifies the permissions of the newly created file.  If you omit
the PERMS argument to C<sysopen>,
Perl uses the octal value C<0666>.
These permission values need to be in octal, and are modified by your
process's current L<C<umask>|/umask EXPR>.
X<O_CREAT>

=end original

FILENAME という名前のファイルが存在せず、(典型的には MODE が
C<O_CREAT> フラグを含んでいたために)
L<C<open>|/open FILEHANDLE,MODE,EXPR> 呼び出しがそれを作った場合、
PERMS の値は新しく作られたファイルの権限を指定します。
C<sysopen> の PERMS 引数を省略した場合、
Perl は 8 進数 C<0666> を使います。
これらの権限は 8 進数である必要があり、プロセスの現在の
L<C<umask>|/umask EXPR> で修正されます。
X<O_CREAT>

=begin original

In many systems the C<O_EXCL> flag is available for opening files in
exclusive mode.  This is B<not> locking: exclusiveness means here that
if the file already exists,
C<sysopen> fails.  C<O_EXCL> may
not work
on network filesystems, and has no effect unless the C<O_CREAT> flag
is set as well.  Setting C<O_CREAT|O_EXCL> prevents the file from
being opened if it is a symbolic link.  It does not protect against
symbolic links in the file's path.
X<O_EXCL>

=end original

多くのシステムではファイルを排他モードで開くために C<O_EXCL> が
利用可能です。
これはロック B<ではありません>: 排他性というのは既にファイルが
存在していた場合、C<sysopen> が
失敗することを意味します。
C<O_EXCL> はネットワークファイルシステムでは動作せず、
またC<O_CREAT> フラグも有効でない限りは効果がありません。
C<O_CREAT|O_EXCL> をセットすると、これがシンボリックリンクだった場合は
ファイルを開くことを妨げます。
これはファイルパス中のシンボリックリンクは守りません。
X<O_EXCL>

=begin original

Sometimes you may want to truncate an already-existing file.  This
can be done using the C<O_TRUNC> flag.  The behavior of
C<O_TRUNC> with C<O_RDONLY> is undefined.
X<O_TRUNC>

=end original

既に存在しているファイルを切り詰めたい場合もあるかもしれません。
これは C<O_TRUNC> フラグを使うことで行えます。
C<O_RDONLY> と C<O_TRUNC> を同時に指定したときの振る舞いは未定義です。
X<O_TRUNC>

=begin original

You should seldom if ever use C<0644> as argument to
C<sysopen>, because
that takes away the user's option to have a more permissive umask.
Better to omit it.  See L<C<umask>|/umask EXPR> for more on this.

=end original

めったなことでは C<sysopen> の引数に
C<0644> を指定するべきではないでしょう:
ユーザーがより寛大な umask を指定する選択肢を奪うからです。
省略した方がいいです。
これに関するさらなる情報については L<C<umask>|/umask EXPR> を
参照してください。

=begin original

This function has no direct relation to the usage of
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
or L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>.  A handle opened with
this function can be used with buffered IO just as one opened with
L<C<open>|/open FILEHANDLE,MODE,EXPR> can be used with unbuffered IO.

=end original

この関数は、
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> の使用法と
直接の関係はありません。
この関数で開かれたハンドルがバッファリングされた IO で使えるのと同様、
L<C<open>|/open FILEHANDLE,MODE,EXPR> で開かれたものは
バッファリングされない IO で使えます。

=begin original

Note that under Perls older than 5.8.0,
C<sysopen> depends on the
L<fdopen(3)> C library function.  On many Unix systems, L<fdopen(3)> is known
to fail when file descriptors exceed a certain value, typically 255.  If
you need more file descriptors than that, consider using the
L<C<POSIX::open>|POSIX/C<open>> function.  For Perls 5.8.0 and later,
PerlIO is (most often) the default.

=end original

5.8.0 より古い Perl では、
C<sysopen> は
C の L<fdopen(3)> ライブラリ関数に依存していることに注意してください。
多くの Unix システムでは、L<fdopen(3)> はファイル記述子がある値(例えば 255)を
超えると失敗することが知られています。
これより多くのファイル記述子が必要な場合は、
L<C<POSIX::open>|POSIX/C<open>> 関数を使うことを検討してください。
5.8.0 以降の Perl では、(ほぼ確実に) PerlIO がデフォルトです。

=begin original

See L<perlopentut> for a kinder, gentler explanation of opening files.

=end original

ファイルを開くことに関するより親切な説明については L<perlopentut> を
参照してください。

=begin original

Portability issues: L<perlport/sysopen>.

=end original

移植性の問題: L<perlport/sysopen>。

=item sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
X<sysread>

=item sysread FILEHANDLE,SCALAR,LENGTH

=for Pod::Functions fixed-length unbuffered input from a filehandle

=begin original

Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using L<read(2)>.  It bypasses any L<PerlIO> layers
including buffered IO (but is affected by the presence of the C<:utf8>
layer as described later), so mixing this with other kinds of reads,
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<tell>|/tell FILEHANDLE>, or L<C<eof>|/eof FILEHANDLE> can cause
confusion because the
C<:perlio> or C<:crlf> layers usually buffer data.  Returns the number of
bytes actually read, C<0> at end of file, or undef if there was an
error (in the latter case L<C<$!>|perlvar/$!> is also set).  SCALAR will
be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.

=end original

L<read(2)> を用いて、指定した FILEHANDLE から、変数 SCALAR へ、LENGTH バイトの
データの読み込みを試みます。
これは、バッファ付き IO ルーチンを含むどの L<PerlIO> も通らないので
(しかし、後述するように C<:utf8> の存在の影響を受けます)、他の入力関数、
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>, L<C<tell>|/tell FILEHANDLE>,
L<C<eof>|/eof FILEHANDLE> と混ぜて使うと、入力がおかしくなるかも
しれません;
C<:perlio> 層や C<:crlf> 層は普通データをバッファリングするからです。
ファイルの最後では C<0>が、エラー時には undef が、それ以外では実際に
読み込まれたデータの長さが返されます (後者の場合は L<C<$!>|perlvar/$!> も
セットされます)。
実際に読み込んだ最後のバイトが read した後の最後のバイトになるので、
SCALAR は伸び縮みします。

=begin original

An OFFSET may be specified to place the read data at some place in the
string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with C<"\0">
bytes before the result of the read is appended.

=end original

OFFSET を指定すると、文字列の先頭以外の場所から読み込みを行なえます。
OFFSET に負の値を指定すると、文字列の最後から逆向きに何文字目かで
位置を指定します。
OFFSET が正の値で、SCALAR の長さよりも大きかった場合、文字列は読み込みの結果が
追加される前に、必要なサイズまで C<"\0"> のバイトでパッディングされます。

    open(my $FH, "<", "input.txt") or die("Cannot open file: $!");

    my $buf = "";
    my $num = 0;

    # Read up to 64 bytes
    $num = sysread($FH, $buf, 64);

    # Read up to 32 bytes into position 512 of $buf
    $num = sysread($FH, $buf, 32, 512);

=begin original

There is no syseof() function, which is ok, since
L<C<eof>|/eof FILEHANDLE> doesn't work well on device files (like ttys)
anyway.  Use C<sysread> and
check for a return value of 0 to decide whether you're done.

=end original

syseof() 関数はありませんが、問題ありません; どちらにしろ
L<C<eof>|/eof FILEHANDLE> は
(tty のような)デバイスファイルに対してはうまく動作しないからです。
C<sysread> を使って、
返り値が 0 かどうかで最後まで読んだかを判断してください。

=begin original

Note that if the filehandle has been marked as C<:utf8>, C<sysread> will
throw an exception.  The C<:encoding(...)> layer implicitly
introduces the C<:utf8> layer.  See
L<C<binmode>|/binmode FILEHANDLE, LAYER>,
L<C<open>|/open FILEHANDLE,MODE,EXPR>, and the L<open> pragma.

=end original

ファイルハンドルが C<:utf8> であるとマークが付けられていると、
C<sysread> は例外を投げます。
C<:encoding(...)> 層は暗黙に C<:utf8> 層を導入します。
L<C<binmode>|/binmode FILEHANDLE, LAYER>,
L<C<open>|/open FILEHANDLE,MODE,EXPR>, L<open> プラグマを参照してください。

=item sysseek FILEHANDLE,POSITION,WHENCE
X<sysseek> X<lseek>

=for Pod::Functions +5.004 position I/O pointer on handle used with sysread and syswrite

=begin original

Sets FILEHANDLE's system position I<in bytes> using L<lseek(2)>.  FILEHANDLE may
be an expression whose value gives the name of the filehandle.  The values
for WHENCE are C<0> to set the new position to POSITION; C<1> to set it
to the current position plus POSITION; and C<2> to set it to EOF plus
POSITION, typically negative.

=end original

FILEHANDLE のシステム位置を I<バイト単位> で L<lseek(2)> を使って設定します。
FILEHANDLE は、実際のファイルハンドル名を与える式でもかまいません。
WHENCE の値が、C<0> ならば、新しい位置を POSITION の位置へ設定します;
C<1> ならば、現在位置から POSITION 加えた位置へ設定します; C<2> ならば、
EOF から POSITION だけ(普通は負の数です)加えた位置へ、新しい位置を
設定します。

=begin original

Note the emphasis on bytes: even if the filehandle has been set to operate
on characters (for example using the C<:encoding(UTF-8)> I/O layer), the
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<tell>|/tell FILEHANDLE>, and
C<sysseek>
family of functions use byte offsets, not character offsets,
because seeking to a character offset would be very slow in a UTF-8 file.

=end original

バイト単位に対する注意: 例え(例えば C<:encoding(UTF-8)> I/O 層を使うなどして)
ファイルハンドルが文字単位で処理するように設定されていたとしても、
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<tell>|/tell FILEHANDLE>,
C<sysseek> シリーズの関数は
文字オフセットではなくバイトオフセットを使います;
文字オフセットでシークするのは UTF-8 ファイルではとても遅いからです。

=begin original

C<sysseek> bypasses normal
buffered IO, so mixing it with reads other than
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> (for example
L<C<readline>|/readline EXPR> or
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>),
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<tell>|/tell FILEHANDLE>, or L<C<eof>|/eof FILEHANDLE> may cause
confusion.

=end original

C<sysseek> は普通のバッファ付き IO を
バイパスしますので、
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET> 以外の (例えば
L<C<readline>|/readline EXPR> や
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> の)読み込み、
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>, L<C<tell>|/tell FILEHANDLE>,
L<C<eof>|/eof FILEHANDLE> と混ぜて使うと混乱を引き起こします。

=begin original

For WHENCE, you may also use the constants C<SEEK_SET>, C<SEEK_CUR>,
and C<SEEK_END> (start of the file, current position, end of the file)
from the L<Fcntl> module.  Use of the constants is also more portable
than relying on 0, 1, and 2.  For example to define a "systell" function:

=end original

WHENCE には、L<Fcntl> モジュールで使われている C<SEEK_SET>, C<SEEK_CUR>,
C<SEEK_END> (ファイルの先頭、現在位置、ファイルの最後)という定数を
使うこともできます。
定数の使用は 0, 1, 2 に依存するよりも移植性があります。
例えば "systell" 関数を定義するには:

    use Fcntl 'SEEK_CUR';
    sub systell { sysseek($_[0], 0, SEEK_CUR) }

=begin original

Returns the new position, or the undefined value on failure.  A position
of zero is returned as the string C<"0 but true">; thus
C<sysseek> returns
true on success and false on failure, yet you can still easily determine
the new position.

=end original

新しい位置を返します; 失敗したときは未定義値を返します。
位置がゼロの場合は、C<"0 but true"> の文字列として返されます; 従って
C<sysseek> は成功時に真を返し、
失敗時に偽を返しますが、簡単に新しい位置を判定できます。

=item system LIST
X<system> X<shell>

=item system PROGRAM LIST

=for Pod::Functions run a separate program

=begin original

Does exactly the same thing as L<C<exec>|/exec LIST>, except that a fork is
done first and the parent process waits for the child process to
exit.  Note that argument processing varies depending on the
number of arguments.  If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.  If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is C</bin/sh -c> on Unix platforms, but varies on other
platforms).  If there are no shell metacharacters in the argument,
it is split into words and passed directly to C<execvp>, which is
more efficient.  On Windows, only the C<system PROGRAM LIST> syntax will
reliably avoid using the shell; C<system LIST>, even with more than one
element, will fall back to the shell if the first spawn fails.

=end original

L<C<exec>|/exec LIST> とほとんど同じですが、まず fork を行ない、
親プロセスではチャイルドプロセスが終了するのを wait します。
exec の項で述べたように、引数の処理は、引数の数によって異なることに
注意してください。
LIST に複数の引数がある場合、または LIST が複数の要素からなる配列の場合、
リストの最初の要素で与えられるプログラムを、リストの残りの要素を引数として
起動します。
スカラの引数が一つだけの場合、引数はシェルのメタ文字をチェックされ、もし
あればパースのために引数全体がシステムコマンドシェル (これは
Unix プラットフォームでは C</bin/sh -c> ですが、他のプラットフォームでは
異なります)に渡されます。
シェルのメタ文字がなかった場合、引数は単語に分解されて直接 C<execvp> に
渡されます; この方がより効率的です。
Windows では、C<system PROGRAM LIST> 構文のみが安定してシェルの使用を
回避します; C<system LIST> は、2 要素以上でも、最初の spawn が失敗すると
シェルにフォールバックします。

=begin original

Perl will attempt to flush all files opened for
output before any operation that may do a fork, but this may not be
supported on some platforms (see L<perlport>).  To be safe, you may need
to set L<C<$E<verbar>>|perlvar/$E<verbar>> (C<$AUTOFLUSH> in L<English>)
or call the C<autoflush> method of L<C<IO::Handle>|IO::Handle/METHODS>
on any open handles.

=end original

Perl は書き込み用に開いている全てのファイルに対して
fork を行う前にフラッシュしようとしますが、これに対応していない
プラットフォームもあります(L<perlport> を参照してください)。
安全のために、L<C<$E<verbar>>|perlvar/$E<verbar>> (L<English> モジュールでは
C<$AUTOFLUSH>) をセットするか、全ての開いているハンドルに対して
L<C<IO::Handle>|IO::Handle/METHODS> の C<autoflush> メソッドを
呼び出す必要があるかもしれません。

=begin original

The return value is the exit status of the program as returned by the
L<C<wait>|/wait> call.  To get the actual exit value, shift right by
eight (see below).  See also L<C<exec>|/exec LIST>.  This is I<not> what
you want to use to capture the output from a command; for that you
should use merely backticks or
L<C<qxE<sol>E<sol>>|/qxE<sol>STRINGE<sol>>, as described in
L<perlop/"`STRING`">.  Return value of -1 indicates a failure to start
the program or an error of the L<wait(2)> system call (inspect
L<C<$!>|perlvar/$!> for the reason).

=end original

返り値は、L<C<wait>|/wait> が返すプログラムの exit 状態です。
実際の exit 値を得るには 右に 8 ビットシフトしてください(後述)。
L<C<exec>|/exec LIST> も参照してください。
これはコマンドからの出力を捕らえるために使うものI<ではありません>;
そのような用途には、L<perlop/"`STRING`"> に記述されている
逆クォートや L<C<qxE<sol>E<sol>>|/qxE<sol>STRINGE<sol>> を使用してください。
-1 の返り値はプログラムを開始させることに失敗したか、L<wait(2)>
システムコールがエラーを出したことを示します
(理由は L<C<$!>|perlvar/$!> を調べてください)。

=begin original

If you'd like to make C<system> (and many other bits of
Perl) die on error, have a look at the L<autodie> pragma.

=end original

もし C<system> (及び Perl のその他の多くの部分) でエラー時に
die したいなら、L<autodie> プラグマを見てみてください。

=begin original

Like L<C<exec>|/exec LIST>, C<system> allows you to lie
to a program about its name if you use the C<system PROGRAM LIST>
syntax.  Again, see L<C<exec>|/exec LIST>.

=end original

L<C<exec>|/exec LIST> と同様に、C<system> でも
C<system PROGRAM LIST> の文法を使うことで、プログラムに対してその名前を
嘘をつくことができます。
再び、L<C<exec>|/exec LIST> を参照してください。

=begin original

Since C<SIGINT> and C<SIGQUIT> are ignored during the execution of
C<system>, if you expect your program to terminate on
receipt of these signals you will need to arrange to do so yourself
based on the return value.

=end original

C<SIGINT> と C<SIGQUIT> は C<system> の実行中は無視されるので、
これらのシグナルを受信して終了させることを想定したプログラムの場合、
返り値を利用するように変更する必要があります。

    my @args = ("command", "arg1", "arg2");
    system(@args) == 0
        or die "system @args failed: $?";

=begin original

If you'd like to manually inspect C<system>'s failure,
you can check all possible failure modes by inspecting
L<C<$?>|perlvar/$?> like this:

=end original

C<system> の失敗を手動で検査したいなら、以下のように
L<C<$?>|perlvar/$?> を調べることで、全ての失敗の可能性をチェックできます:

    if ($? == -1) {
        print "failed to execute: $!\n";
    }
    elsif ($? & 127) {
        printf "child died with signal %d, %s coredump\n",
            ($? & 127),  ($? & 128) ? 'with' : 'without';
    }
    else {
        printf "child exited with value %d\n", $? >> 8;
    }

=begin original

Alternatively, you may inspect the value of
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> with the
L<C<W*()>|POSIX/C<WIFEXITED>> calls from the L<POSIX> module.

=end original

または、L<POSIX> モジュールの L<C<W*()>|POSIX/C<WIFEXITED>> 呼び出しを使って
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> の値を
調べることもできます。

=begin original

When C<system>'s arguments are executed indirectly by
the shell, results and return codes are subject to its quirks.
See L<perlop/"`STRING`"> and L<C<exec>|/exec LIST> for details.

=end original

C<system> の引数がシェルによって間接的に実行された場合、
結果と返り値はシェルの癖によって変更されることがあります。
詳細については L<perlop/"`STRING`"> と L<C<exec>|/exec LIST> を
参照してください。

=begin original

Since C<system> does a L<C<fork>|/fork> and
L<C<wait>|/wait> it may affect a C<SIGCHLD> handler.  See L<perlipc> for
details.

=end original

C<system> は L<C<fork>|/fork> と L<C<wait>|/wait> を行うので、
C<SIGCHLD> ハンドラの影響を受けます。
詳しくは L<perlipc> を参照してください。

=begin original

Portability issues: L<perlport/system>.

=end original

移植性の問題: L<perlport/system>。

=item syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
X<syswrite>

=item syswrite FILEHANDLE,SCALAR,LENGTH

=item syswrite FILEHANDLE,SCALAR

=for Pod::Functions fixed-length unbuffered output to a filehandle

=begin original

Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using L<write(2)>.  If LENGTH is
not specified, writes whole SCALAR.  It bypasses any L<PerlIO> layers
including buffered IO (but is affected by the presence of the C<:utf8>
layer as described later), so
mixing this with reads (other than C<sysread)>),
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
L<C<tell>|/tell FILEHANDLE>, or L<C<eof>|/eof FILEHANDLE> may cause
confusion because the C<:perlio> and C<:crlf> layers usually buffer data.
Returns the number of bytes actually written, or L<C<undef>|/undef EXPR>
if there was an error (in this case the errno variable
L<C<$!>|perlvar/$!> is also set).  If the LENGTH is greater than the
data available in the SCALAR after the OFFSET, only as much data as is
available will be written.

=end original

L<write(2)> を使って、指定した FILEHANDLEへ、変数 SCALAR から、LENGTH バイトの
データの書き込みを試みます。
LENGTH が指定されなかった場合、 SCALAR 全体を書き込みます。
これは、バッファ付き IO ルーチンを含むどの L<PerlIO> も通らないので
(しかし、後述するように C<:utf8> の存在の影響を受けます)、他の入力関数、
他の入力関数 (C<sysread> 以外),
L<C<print>|/print FILEHANDLE LIST>, L<C<write>|/write FILEHANDLE>,
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>, L<C<tell>|/tell FILEHANDLE>,
L<C<eof>|/eof FILEHANDLE> と混ぜて使うと、出力がおかしくなるかもしれません;
C<:perlio> 層と C<:crlf> 層は普通データをバッファリングするからです。
実際に読み込まれたデータの長さか、エラー時には L<C<undef>|/undef EXPR> が
返されます(この場合エラー変数 L<C<$!>|perlvar/$!> もセットされます)。
LENGTH が OFFSET 以降の SCALAR の利用可能なデータより大きかった場合、
利用可能なデータのみが書き込まれます。

=begin original

An OFFSET may be specified to write the data from some part of the
string other than the beginning.  A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.
If SCALAR is of length zero, you can only use an OFFSET of 0.

=end original

OFFSET を指定すると、SCALAR の先頭以外の場所から、
データを取り出して、書き込みを行なうことができます。
OFFSET に負の値を指定すると、文字列の最後から逆向きに数えて
何バイト目から書き込むかを示します。
SCALAR の長さが 0 の場合、OFFSET は 0 のみ使用できます。

=begin original

B<WARNING>: If the filehandle is marked C<:utf8>, C<syswrite> will raise an exception.
The C<:encoding(...)> layer implicitly introduces the C<:utf8> layer.
Alternately, if the handle is not marked with an encoding but you
attempt to write characters with code points over 255, raises an exception.
See L<C<binmode>|/binmode FILEHANDLE, LAYER>,
L<C<open>|/open FILEHANDLE,MODE,EXPR>, and the L<open> pragma.

=end original

B<警告>: ファイルハンドルが C<:utf8> であるとマークが付けられていると、
C<syswrite> は例外を投げます。
C<:encoding(...)> 層は暗黙に C<:utf8> 層を導入します。
または、もしハンドルにエンコーディングが記録されていない状態で
255 を超える符号位置の文字を書き込もうとすると、例外が発生します。
L<C<binmode>|/binmode FILEHANDLE, LAYER>,
L<C<open>|/open FILEHANDLE,MODE,EXPR>,
L<open> プラグマを参照してください。

=item tell FILEHANDLE
X<tell>

=item tell

=for Pod::Functions get current seekpointer on a filehandle

=begin original

Returns the current position I<in bytes> for FILEHANDLE, or -1 on
error.  FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.  If FILEHANDLE is omitted, assumes the file
last read.

=end original

FILEHANDLE の現在の位置を I<バイト数で> 返します; エラーの場合は -1 を
返します。
FILEHANDLE は、実際のファイルハンドル名を示す式でもかまいません。
FILEHANDLE が省略された場合には、最後に読み込みを行なったファイルについて
調べます。

=begin original

Note the emphasis on bytes: even if the filehandle has been set to operate
on characters (for example using the C<:encoding(UTF-8)> I/O layer), the
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
C<tell>, and
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>
family of functions use byte offsets, not character offsets,
because seeking to a character offset would be very slow in a UTF-8 file.

=end original

バイト単位に対する注意: 例え(例えば C<:encoding(UTF-8)> I/O 層を使うなどして)
ファイルハンドルが文字単位で処理するように設定されていたとしても、
L<C<seek>|/seek FILEHANDLE,POSITION,WHENCE>,
C<tell>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> シリーズの関数は
文字オフセットではなくバイトオフセットを使います;
文字オフセットでシークするのは UTF-8 ファイルではとても遅いからです。

=begin original

The return value of C<tell> for the standard streams
like the STDIN depends on the operating system: it may return -1 or
something else.  C<tell> on pipes, fifos, and
sockets usually returns -1.

=end original

STDIN のような標準ストリームに対する C<tell> の返り値は
OS に依存します:
-1 やその他の値が返ってくるかもしれません。
パイプ、FIFO、ソケットに対して C<tell> を使うと、普通は
-1 が返ります。

=begin original

There is no C<systell> function.  Use
L<C<sysseek($fh, 0, 1)>|/sysseek FILEHANDLE,POSITION,WHENCE> for that.

=end original

C<systell> 関数はありません。
代わりに L<C<sysseek($fh, 0, 1)>|/sysseek FILEHANDLE,POSITION,WHENCE> を
使ってください。

=begin original

Do not use C<tell> (or other buffered I/O
operations) on a filehandle that has been manipulated by
L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>, or
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE>.  Those functions
ignore the buffering, while C<tell> does not.

=end original

L<C<sysread>|/sysread FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<syswrite>|/syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET>,
L<C<sysseek>|/sysseek FILEHANDLE,POSITION,WHENCE> で操作された
ファイルハンドルに C<tell>
(またはその他のバッファリング I/O 操作) を使わないでください。
これらの関数はバッファリングを無視しますが、C<tell> は
違います。

=item telldir DIRHANDLE
X<telldir>

=for Pod::Functions get current seekpointer on a directory handle

=begin original

Returns the current position of the L<C<readdir>|/readdir DIRHANDLE>
routines on DIRHANDLE.  Value may be given to
L<C<seekdir>|/seekdir DIRHANDLE,POS> to access a particular location in
a directory.  C<telldir> has the same caveats
about possible directory compaction as the corresponding system library
routine.

=end original

DIRHANDLE 上の L<C<readdir>|/readdir DIRHANDLE> ルーチンに対する現在位置を
返します。
値は、そのディレクトリで特定の位置をアクセスするため、
L<C<seekdir>|/seekdir DIRHANDLE,POS> に渡すことができます。
C<telldir> は同名のシステムライブラリルーチンと同じく、
ディレクトリ縮小時の問題が考えられます。

=item tie VARIABLE,CLASSNAME,LIST
X<tie>

=for Pod::Functions +5.002 bind a variable to an object class

=begin original

This function binds a variable to a package class that will provide the
implementation for the variable.  VARIABLE is the name of the variable
to be enchanted.  CLASSNAME is the name of a class implementing objects
of correct type.  Any additional arguments are passed to the
appropriate constructor
method of the class (meaning C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>,
or C<TIEHASH>).  Typically these are arguments such as might be passed
to the L<dbm_open(3)> function of C.  The object returned by the
constructor is also returned by the
C<tie> function, which would be useful
if you want to access other methods in CLASSNAME.

=end original

この関数は、変数を、その変数の実装を行なうクラスと結び付けます。
VARIABLE は、魔法をかける変数の名前です。
CLASSNAME は、正しい型のオブジェクトを実装するクラスの名前です。
他に引数があれば、そのクラスの適切なコンストラクタメソッドに渡されます
(つまり C<TIESCALAR>, C<TIEHANDLE>, C<TIEARRAY>, C<TIEHASH>)。
通常、これらは、C の L<dbm_open(3)> などの関数に渡す引数となります。
コンストラクタで返されるオブジェクトはまた
C<tie> 関数でも返されます;
これは CLASSNAME の他のメソッドにアクセスしたいときに便利です。

=begin original

Note that functions such as L<C<keys>|/keys HASH> and
L<C<values>|/values HASH> may return huge lists when used on large
objects, like DBM files.  You may prefer to use the L<C<each>|/each
HASH> function to iterate over such.  Example:

=end original

DBM ファイルのような大きなオブジェクトでは、L<C<keys>|/keys HASH> や
L<C<values>|/values HASH> のような関数は、大きなリストを返す可能性があります。
そのような場合では、L<C<each>|/each HASH> 関数を使って繰り返しを行なった方が
よいかもしれません。
例:

    # print out history file offsets
    use NDBM_File;
    tie(my %HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
    while (my ($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L', $val), "\n";
    }

=begin original

A class implementing a hash should have the following methods:

=end original

ハッシュを実装するクラスでは、次のようなメソッドを用意します:

    TIEHASH classname, LIST
    FETCH this, key
    STORE this, key, value
    DELETE this, key
    CLEAR this
    EXISTS this, key
    FIRSTKEY this
    NEXTKEY this, lastkey
    SCALAR this
    DESTROY this
    UNTIE this

=begin original

A class implementing an ordinary array should have the following methods:

=end original

通常の配列を実装するクラスでは、次のようなメソッドを用意します:

    TIEARRAY classname, LIST
    FETCH this, key
    STORE this, key, value
    FETCHSIZE this
    STORESIZE this, count
    CLEAR this
    PUSH this, LIST
    POP this
    SHIFT this
    UNSHIFT this, LIST
    SPLICE this, offset, length, LIST
    EXTEND this, count
    DELETE this, key
    EXISTS this, key
    DESTROY this
    UNTIE this

=begin original

A class implementing a filehandle should have the following methods:

=end original

ファイルハンドルを実装するクラスでは、次のようなメソッドを用意します:

    TIEHANDLE classname, LIST
    READ this, scalar, length, offset
    READLINE this
    GETC this
    WRITE this, scalar, length, offset
    PRINT this, LIST
    PRINTF this, format, LIST
    BINMODE this
    EOF this
    FILENO this
    SEEK this, position, whence
    TELL this
    OPEN this, mode, LIST
    CLOSE this
    DESTROY this
    UNTIE this

=begin original

A class implementing a scalar should have the following methods:

=end original

スカラ変数を実装するクラスでは、次のようなメソッドを用意します:

    TIESCALAR classname, LIST
    FETCH this,
    STORE this, value
    DESTROY this
    UNTIE this

=begin original

Not all methods indicated above need be implemented.  See L<perltie>,
L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>, and L<Tie::Handle>.

=end original

上記の全てのメソッドを実装する必要はありません。
L<perltie>, L<Tie::Hash>, L<Tie::Array>, L<Tie::Scalar>,
L<Tie::Handle> を参照してください。

=begin original

Unlike L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK>, the
C<tie> function will not
L<C<use>|/use Module VERSION LIST> or L<C<require>|/require VERSION> a
module for you; you need to do that explicitly yourself.  See L<DB_File>
or the L<Config> module for interesting
C<tie> implementations.

=end original

L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK> と違い、
C<tie> 関数はモジュールを
L<C<use>|/use Module VERSION LIST> したり
L<C<require>|/require VERSION> したりしません;
自分で明示的に行う必要があります。
C<tie> の興味深い実装については
L<DB_File> や L<Config> モジュールを参照してください。

=begin original

For further details see L<perltie>, L<C<tied>|/tied VARIABLE>.

=end original

更なる詳細については L<perltie> や L<C<tied>|/tied VARIABLE> を
参照してください。

=item tied VARIABLE
X<tied>

=for Pod::Functions get a reference to the object underlying a tied variable

=begin original

Returns a reference to the object underlying VARIABLE (the same value
that was originally returned by the
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.

=end original

VARIABLE の基となるオブジェクトへのリファレンスを返します
(変数をパッケージに結びつけるために
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> 呼び出しをしたときの
返り値と同じものです)。
VARIABLE がパッケージと結び付けられていない場合は未定義値を返します。

=item time
X<time> X<epoch>

=for Pod::Functions return number of seconds since 1970

=begin original

Returns the number of non-leap seconds since whatever time the system
considers to be the epoch, suitable for feeding to
L<C<gmtime>|/gmtime EXPR> and L<C<localtime>|/localtime EXPR>.  On most
systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.

=end original

L<C<gmtime>|/gmtime EXPR> や L<C<localtime>|/localtime EXPR> への入力形式に
合っている、システムが紀元と考える時点からの連続秒数を返します。
ほとんどのシステムでは紀元は UTC 1970 年 1 月 1 日 00:00:00 です;
特徴的な例外としては、古い Mac OS ではローカルタイムゾーンの
1904 年 1 月 1 日 00:00:00 を紀元として使います。

=begin original

For measuring time in better granularity than one second, use the
L<Time::HiRes> module from Perl 5.8 onwards (or from CPAN before then), or,
if you have L<gettimeofday(2)>, you may be able to use the
L<C<syscall>|/syscall NUMBER, LIST> interface of Perl.  See L<perlfaq8>
for details.

=end original

1 秒よりも細かい時間を計測するためには、Perl 5.8 以降(それ以前では
CPANから)の L<Time::HiRes> モジュールを使うか、
L<gettimeofday(2)> があるなら、Perl の
L<C<syscall>|/syscall NUMBER, LIST> インターフェースを使ってください。
詳しくは L<perlfaq8> を参照してください。

=begin original

For date and time processing look at the many related modules on CPAN.
For a comprehensive date and time representation look at the
L<DateTime> module.

=end original

日付と時刻の処理は、多くの関連するモジュールが CPAN にあります。
包括的な日付と時刻の表現については、CPAN の L<DateTime> モジュールを
参照してください。

=item times
X<times>

=for Pod::Functions return elapsed time for self and child processes

=begin original

Returns a four-element list giving the user and system times in
seconds for this process and any exited children of this process.

=end original

現プロセス及び終了したその子プロセスに対する、ユーザ時間とシステム時間を
秒で示した、4 要素のリスト値を返します。

    my ($user,$system,$cuser,$csystem) = times;

=begin original

In scalar context, C<times> returns C<$user>.

=end original

スカラコンテキストでは、C<times> は C<$user> を返します。

=begin original

Children's times are only included for terminated children.

=end original

子プロセスに対する times は、終了した子プロセスのみ含められます。

=begin original

Portability issues: L<perlport/times>.

=end original

移植性の問題: L<perlport/times>。

=item tr///

=for Pod::Functions transliterate a string

=begin original

The transliteration operator.  Same as
L<C<yE<sol>E<sol>E<sol>>|/yE<sol>E<sol>E<sol>>.  See
L<perlop/"Quote-Like Operators">.

=end original

文字変換演算子です。
L<C<yE<sol>E<sol>E<sol>>|/yE<sol>E<sol>E<sol>> と同じです。
L<perlop/"Quote-Like Operators"> を参照してください。

=item truncate FILEHANDLE,LENGTH
X<truncate>

=item truncate EXPR,LENGTH

=for Pod::Functions shorten a file

=begin original

Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.  Raises an exception if truncate isn't implemented
on your system.  Returns true if successful, L<C<undef>|/undef EXPR> on
error.

=end original

FILEHANDLE 上にオープンされたファイルか、EXPR で名前を表わしたファイルを、
指定した長さに切り詰めます。
システム上に truncate が実装されていなければ、例外が発生します。
成功すれば真を、エラー時には L<C<undef>|/undef EXPR> を返します。

=begin original

The behavior is undefined if LENGTH is greater than the length of the
file.

=end original

LENGTH がファイルの長さより大きい場合の振る舞いは未定義です。

=begin original

The position in the file of FILEHANDLE is left unchanged.  You may want to
call L<seek|/"seek FILEHANDLE,POSITION,WHENCE"> before writing to the
file.

=end original

FILEHANDLE のファイルの位置は変わりません。
ファイルに書き込む前に L<seek|/"seek FILEHANDLE,POSITION,WHENCE"> を
呼び出したいかもしれません。

=begin original

Portability issues: L<perlport/truncate>.

=end original

移植性の問題: L<perlport/truncate>。

=item uc EXPR
X<uc> X<uppercase> X<toupper>

=item uc

=for Pod::Functions return upper-case version of a string

=begin original

Returns an uppercased version of EXPR.  If EXPR is omitted, uses
L<C<$_>|perlvar/$_>.

=end original

EXPR の大文字版を返します。
EXPR が省略されると、L<C<$_>|perlvar/$_> を使います。

    my $str = uc("Perl is GREAT"); # "PERL IS GREAT"

=begin original

This function behaves the same way under various pragmas, such as in a locale,
as L<C<lc>|/lc EXPR> does.

=end original

この関数は、ロケールのようなさまざまなプラグマの影響下では、
L<C<lc>|/lc EXPR> と同様に振る舞います。

=begin original

If you want titlecase mapping on initial letters see
L<C<ucfirst>|/ucfirst EXPR> instead.

=end original

最初の文字のタイトル文字マッピングがほしい場合は、
代わりに L<C<ucfirst>|/ucfirst EXPR> を使ってください。

=begin original

B<Note:> This is the internal function implementing the
L<C<\U>|perlop/"Quote and Quote-like Operators"> escape in double-quoted
strings.

=end original

B<注意:> これは、ダブルクォート文字列における、
L<C<\U>|perlop/"Quote and Quote-like Operators"> エスケープを
実装する内部関数です。

    my $str = "Perl is \Ugreat\E"; # "Perl is GREAT"

=item ucfirst EXPR
X<ucfirst> X<uppercase>

=item ucfirst

=for Pod::Functions return a string with the first letter in upper case

=begin original

Returns the value of EXPR with the B<first> character in uppercase
(Unicode calls this titlecase). If EXPR is omitted, C<ucfirst> uses L<C<$_>|perlvar/$_>.

=end original

B<最初の> 文字だけを大文字(Unicode ではこれをタイトル文字と呼びます)にした、
EXPR を返します。
EXPR が省略されると、C<ucfirst> は L<C<$_>|perlvar/$_> を使います。

    my $str = ucfirst("hello world!"); # "Hello world!"

=begin original

This function behaves the same way under various pragmas, such as in a locale,
as L<C<lc>|/lc EXPR> does.

=end original

この関数は、ロケールのようなさまざまなプラグマの影響下では、
L<C<lc>|/lc EXPR> と同様に振る舞います。

=begin original

B<Note:> This is the internal function implementing the C<\u> escape in
double-quoted strings.

=end original

B<注意:> これは、ダブルクォート文字列における、C<\u> エスケープを
実装する内部関数です。

    my $str = "\uperl\E is great"; # "Perl is great"

=item umask EXPR
X<umask>

=item umask

=for Pod::Functions set file creation mode mask

=begin original

Sets the umask for the process to EXPR and returns the previous value.
If EXPR is omitted, merely returns the current umask.

=end original

現在のプロセスの umask を EXPR に設定し、以前の値を返します。
EXPR が省略されると、単にその時点の umask の値を返します。

=begin original

The Unix permission C<rwxr-x---> is represented as three sets of three
bits, or three octal digits: C<0750> (the leading 0 indicates octal
and isn't one of the digits).  The C<umask> value is such
a number representing disabled permissions bits.  The permission (or
"mode") values you pass L<C<mkdir>|/mkdir FILENAME,MODE> or
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> are modified by your
umask, so even if you tell
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> to create a file with
permissions C<0777>, if your umask is C<0022>, then the file will
actually be created with permissions C<0755>.  If your
C<umask> were C<0027> (group can't write; others can't
read, write, or execute), then passing
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> C<0666> would create a
file with mode C<0640> (because C<0666 &~ 027> is C<0640>).

=end original

Unix パーミッション C<rwxr-x---> は 3 ビットの三つの組、
または 3 桁の 8 進数として表現されます:
C<0750> (先頭の 0 は 8 進数を意味し、実際の値ではありません)。
C<umask> の値は無効にするパーミッションビットのこのような
数値表現です。
L<C<mkdir>|/mkdir FILENAME,MODE> や
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> で渡されたパーミッション
(または「モード」)の値は umask で修正され、たとえ
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> で C<0777> のパーミッションで
ファイルを作るように指定しても、umask が C<0022> なら、
結果としてファイルは C<0755> のパーミッションで作成されます。
C<umask> が C<0027> (グループは書き込めない; その他は読み込み、
書き込み、実行できない) のとき
L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> に C<0666> を渡すと、
ファイルはモード C<0640> (なぜなら C<0666 &~ 027> は C<0640>)で作成されます。

=begin original

Here's some advice: supply a creation mode of C<0666> for regular
files (in L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE>) and one of
C<0777> for directories (in L<C<mkdir>|/mkdir FILENAME,MODE>) and
executable files.  This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of C<022>, C<027>, or even the particularly antisocial mask of C<077>.
Programs should rarely if ever make policy decisions better left to
the user.  The exception to this is when writing files that should be
kept private: mail files, web browser cookies, F<.rhosts> files, and
so on.

=end original

以下は助言です: 作成モードとして、
(L<C<sysopen>|/sysopen FILEHANDLE,FILENAME,MODE> による)通常ファイルでは
C<0666> を、(L<C<mkdir>|/mkdir FILENAME,MODE> による)ディレクトリでは
C<0777> を指定しましょう。
これにより、ユーザーに選択の自由を与えます: もしファイルを守りたいなら、
プロセスの umask として C<022>, C<027>, あるいは特に非社交的な
C<077> を選択できます。
プログラムがユーザーより適切なポリシー選択ができることは稀です。
例外は、プライベートに保つべきファイル(メール、ウェブブラウザのクッキー、
F<.rhosts> ファイルなど)を書く場合です。

=begin original

If L<umask(2)> is not implemented on your system and you are trying to
restrict access for I<yourself> (i.e., C<< (EXPR & 0700) > 0 >>),
raises an exception.  If L<umask(2)> is not implemented and you are
not trying to restrict access for yourself, returns
L<C<undef>|/undef EXPR>.

=end original

L<umask(2)> が実装されていないシステムで、I<自分自身> へのアクセスを
制限しようとした(つまり C<< (EXPR & 0700) > 0 >>)場合、例外が発生します。
L<umask(2)> が実装されていないシステムで、自分自身へのアクセスは
制限しようとしなかった場合、L<C<undef>|/undef EXPR> を返します。

=begin original

Remember that a umask is a number, usually given in octal; it is I<not> a
string of octal digits.  See also L<C<oct>|/oct EXPR>, if all you have
is a string.

=end original

umask は通常 8 進数で与えられる数値であることを忘れないでください; 8 進数の
文字列 I<ではありません>。
文字列しかない場合、 L<C<oct>|/oct EXPR> も参照してください。

=begin original

Portability issues: L<perlport/umask>.

=end original

移植性の問題: L<perlport/umask>。

=item undef EXPR
X<undef> X<undefine>

=item undef

=for Pod::Functions remove a variable or function definition

=begin original

Undefines the value of EXPR, which must be an lvalue.  Use only on a
scalar value, an array (using C<@>), a hash (using C<%>), a subroutine
(using C<&>), or a typeglob (using C<*>).  Saying C<undef $hash{$key}>
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see L<C<delete>|/delete EXPR>.
Always returns the undefined value.
You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable, or pass as a
parameter.  Examples:

=end original

左辺値である EXPR の値を未定義にします。
スカラ値、(C<@> を使った)配列、(C<%> を使った)ハッシュ、(C<&> を使った)
サブルーチン、(C<*> を使った)型グロブだけに使用します。
特殊変数や DBM リスト値に C<undef $hash{$key}> などとしても
おそらく期待通りの結果にはなりませんから、しないでください;
L<C<delete>|/delete EXPR> を参照してください。
常に未定義値を返します。
EXPR は省略することができ、その場合には何も未定義にされませんが
未定義値は返されますので、それをたとえば、
サブルーチンの返り値、変数への割り当て、引数などとして使うことができます。
例:

    undef $foo;
    undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};
    undef @ary;
    undef %hash;
    undef &mysub;
    undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
    return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;
    select undef, undef, undef, 0.25;
    my ($x, $y, undef, $z) = foo();    # Ignore third value returned

=begin original

Note that this is a unary operator, not a list operator.

=end original

これはリスト演算子ではなく、単項演算子であることに注意してください。

=item unlink LIST
X<unlink> X<delete> X<remove> X<rm> X<del>

=item unlink

=for Pod::Functions remove one link to a file

=begin original

Deletes a list of files.  On success, it returns the number of files
it successfully deleted.  On failure, it returns false and sets
L<C<$!>|perlvar/$!> (errno):

=end original

LIST に含まれるファイルを削除します。
成功時は削除に成功したファイルの数を返します。
失敗時は偽を返して L<C<$!>|perlvar/$!> (error) をセットします:

    my $unlinked = unlink 'a', 'b', 'c';
    unlink @goners;
    unlink glob "*.bak";

=begin original

On error, C<unlink> will not tell you which files it
could not remove.
If you want to know which files you could not remove, try them one
at a time:

=end original

エラーの場合、C<unlink> はどのファイルが削除できなかったかを
知らせません。
どのファイルが削除できなかったかを知りたい場合は、一つずつ削除してください:

     foreach my $file ( @goners ) {
         unlink $file or warn "Could not unlink $file: $!";
     }

=begin original

Note: C<unlink> will not attempt to delete directories
unless you are
superuser and the B<-U> flag is supplied to Perl.  Even if these
conditions are met, be warned that unlinking a directory can inflict
damage on your filesystem.  Finally, using C<unlink> on
directories is not supported on many operating systems.  Use
L<C<rmdir>|/rmdir FILENAME> instead.

=end original

注: スーパーユーザ権限で、Perl に B<-U> を付けて実行した場合でなければ、
C<unlink> はディレクトリを削除しようとすることはありません。
この条件にあう場合にも、ディレクトリの削除は、
ファイルシステムに多大な損害を与える可能性があります。
最後に、C<unlink> をディレクトリに使うのはほとんどの OS では
対応していません。
代わりに L<C<rmdir>|/rmdir FILENAME> を使ってください。

=begin original

If LIST is omitted, C<unlink> uses L<C<$_>|perlvar/$_>.

=end original

LIST が省略されると、C<unlink> は L<C<$_>|perlvar/$_> を
使います。

=item unpack TEMPLATE,EXPR
X<unpack>

=item unpack TEMPLATE

=for Pod::Functions convert binary structure into normal perl variables

=begin original

C<unpack> does the reverse of
L<C<pack>|/pack TEMPLATE,LIST>: it takes a string
and expands it out into a list of values.
(In scalar context, it returns merely the first value produced.)

=end original

C<unpack> は L<C<pack>|/pack TEMPLATE,LIST> の逆を
行ないます: 構造体を表わす文字列をとり、
リスト値に展開し、その配列値を返します。
(スカラコンテキストでは、単に最初の値を返します。)

=begin original

If EXPR is omitted, unpacks the L<C<$_>|perlvar/$_> string.
See L<perlpacktut> for an introduction to this function.

=end original

EXPR が省略されると、L<C<$_>|perlvar/$_> の文字列を unpack します。
この関数の説明については L<perlpacktut> を参照してください。

=begin original

The string is broken into chunks described by the TEMPLATE.  Each chunk
is converted separately to a value.  Typically, either the string is a result
of L<C<pack>|/pack TEMPLATE,LIST>, or the characters of the string
represent a C structure of some kind.

=end original

文字列は TEMPLATE で示された固まりに分割されます。
それぞれの固まりは別々に値に変換されます。
典型的には、文字列は L<C<pack>|/pack TEMPLATE,LIST> の結果あるいはある種の
C の構造体の文字列表現の文字列です。

=begin original

The TEMPLATE has the same format as in the
L<C<pack>|/pack TEMPLATE,LIST> function.
Here's a subroutine that does substring:

=end original

TEMPLATE は、L<C<pack>|/pack TEMPLATE,LIST> 関数と同じフォーマットを使います。
部分文字列を取り出すうサブルーチンの例を示します:

    sub substr {
        my ($what, $where, $howmuch) = @_;
        unpack("x$where a$howmuch", $what);
    }

=begin original

and then there's

=end original

これもそうです。

    sub ordinal { unpack("W",$_[0]); } # same as ord()

=begin original

In addition to fields allowed in L<C<pack>|/pack TEMPLATE,LIST>, you may
prefix a field with a %<number> to indicate that
you want a <number>-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  The checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
C<ord($char)> is taken; for bit fields the sum of zeroes and ones).

=end original

L<C<pack>|/pack TEMPLATE,LIST> で利用可能なフィールドの他に、
フィールドの前に %<数値> というものを付けて、
項目自身の代わりに、その項目の <数値>-ビットのチェックサムを
計算させることができます。
デフォルトは、16-ビットチェックサムです。
チェックサムは展開された値の数値としての値の合計
(文字列フィールドの場合は C<ord($char)> の合計;
ビットフィールドの場合は 0 と 1 の合計) が用いられます。

=begin original

For example, the following
computes the same number as the System V sum program:

=end original

たとえば、以下のコードは
System V の sum プログラムと同じ値を計算します。

    my $checksum = do {
        local $/;  # slurp!
        unpack("%32W*", readline) % 65535;
    };

=begin original

The following efficiently counts the number of set bits in a bit vector:

=end original

以下は、効率的にビットベクターの設定されているビットを
数えるものです。

    my $setbits = unpack("%32b*", $selectmask);

=begin original

The C<p> and C<P> formats should be used with care.  Since Perl
has no way of checking whether the value passed to
C<unpack>
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.

=end original

C<p> と C<P> は注意深く使うべきです。
Perl は C<unpack> に渡された値が有効なメモリ位置を
指しているかどうかを確認する方法がないので、有効かどうかわからない
ポインタ値を渡すと悲惨な結果を引き起こすかもしれません。

=begin original

If there are more pack codes or if the repeat count of a field or a group
is larger than what the remainder of the input string allows, the result
is not well defined: the repeat count may be decreased, or
C<unpack> may produce empty strings or zeros,
or it may raise an exception.
If the input string is longer than one described by the TEMPLATE,
the remainder of that input string is ignored.

=end original

多くの pack コードがある場合や、フィールドやグループの繰り返し回数が
入力文字列の残りより大きい場合、結果は未定義です:
繰り返し回数が減らされる場合もありますし、
C<unpack> が空文字列や 0 を
返すこともありますし、例外が発生します。
もし入力文字列が TEMPLATE で表現されているものより大きい場合、
入力文字列の残りは無視されます。

=begin original

See L<C<pack>|/pack TEMPLATE,LIST> for more examples and notes.

=end original

さらなる例と注意に関しては L<C<pack>|/pack TEMPLATE,LIST> を参照してください。

=item unshift ARRAY,LIST
X<unshift>

=for Pod::Functions prepend more elements to the beginning of a list

=begin original

Add one or more elements to the B<beginning> of an array. This is the
opposite of a L<C<shift>|/shift ARRAY>.

=end original

一つまたは複数の要素を配列の B<先頭> に追加します。
これは L<C<shift>|/shift ARRAY> の逆操作です。

    my @animals = ("cat");
    unshift(@animals, "mouse"); # ("mouse", "cat")

    my @colors = ("red");
    unshift(@colors, ("blue", "green")); # ("blue", "green", "red")

=begin original

Returns the new number of elements in the updated array.

=end original

更新された配列の要素の数を返します。

    # Return value is the number of items in the updated array
    my $color_count = unshift(@colors, ("yellow", "purple"));

    say "There are $color_count colors in the updated array";

=begin original

Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.  Use
L<C<reverse>|/reverse LIST> to do the reverse.

=end original

LIST は、はらばらにではなく、一度に登録されるので、順番はそのままです。
逆順に登録するには、L<C<reverse>|/reverse LIST> を使ってください。

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<unshift> to take
a scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<unshift> がスカラ式を
取ることが出来るという実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=item untie VARIABLE
X<untie>

=for Pod::Functions break a tie binding to a variable

=begin original

Breaks the binding between a variable and a package.
(See L<tie|/tie VARIABLE,CLASSNAME,LIST>.)
Has no effect if the variable is not tied.

=end original

変数とパッケージの間の結合を解きます。
(L<tie|/tie VARIABLE,CLASSNAME,LIST> を参照してください。)
結合されていない場合は何も起きません。

=item use Module VERSION LIST
X<use> X<module> X<import>

=item use Module VERSION

=item use Module LIST

=item use Module

=for Pod::Functions load in a module at compile time and import its namespace

=begin original

Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to

=end original

指定したモジュールから、現在のパッケージにさまざまな内容をインポートします;
多くは、パッケージのサブルーチン名や、変数名に別名を付けることで、
実現されています。
これは、以下は等価ですが:

    BEGIN { require Module; Module->import( LIST ); }

=begin original

except that Module I<must> be a bareword.
The importation can be made conditional by using the L<if> module.

=end original

Module が I<裸の単語でなければならない> ことを除けば、です。
インポートは、L<if> を使って条件付きで行うことができます。

=begin original

The C<BEGIN> forces the L<C<require>|/require VERSION> and
L<C<import>|/import LIST> to happen at compile time.  The
L<C<require>|/require VERSION> makes sure the module is loaded into
memory if it hasn't been yet.  The L<C<import>|/import LIST> is not a
builtin; it's just an ordinary static method
call into the C<Module> package to tell the module to import the list of
features back into the current package.  The module can implement its
L<C<import>|/import LIST> method any way it likes, though most modules
just choose to derive their L<C<import>|/import LIST> method via
inheritance from the C<Exporter> class that is defined in the
L<C<Exporter>|Exporter> module.  See L<Exporter>.  If no
L<C<import>|/import LIST> method can be found, then the call is skipped,
even if there is an AUTOLOAD method.

=end original

C<BEGIN> によって、L<C<require>|/require VERSION> や
L<C<import>|/import LIST> は、コンパイル時に
実行されることになります。
L<C<require>|/require VERSION> は、モジュールがまだメモリに
ロードされていなければ、ロードします。
L<C<import>|/import LIST> は、組込みの関数ではありません; さまざまな機能を
現在のパッケージにインポートするように C<Module> パッケージに伝えるために
呼ばれる、通常の静的メソッドです。
モジュール側では、L<C<import>|/import LIST> メソッドをどのようにでも
実装することができますが、多くのモジュールでは、
L<C<Exporter>|Exporter> モジュールで定義された、
C<Exporter> クラスからの継承によって、L<C<import>|/import LIST> メソッドを
行なうようにしています。
L<Exporter>モジュールを参照してください。
L<C<import>|/import LIST>メソッドが見つからなかった場合、AUTOLOAD メソッドが
あったとしても呼び出しはスキップされます。

=begin original

If you do not want to call the package's L<C<import>|/import LIST>
method (for instance,
to stop your namespace from being altered), explicitly supply the empty list:

=end original

パッケージの L<C<import>|/import LIST> メソッドを呼び出したくない場合(例えば、
名前空間を変更したくない場合など)は、明示的に空リストを指定してください:

    use Module ();

=begin original

That is exactly equivalent to

=end original

これは以下と完全に等価です:

    BEGIN { require Module }

=begin original

If the VERSION argument is present between Module and LIST, then the
C<use> will call the C<VERSION> method in
class Module with the given version as an argument:

=end original

Module と LIST の間に VERSION 引数がある場合、
C<use> は Module クラスの
C<VERSION> メソッドを、与えられたバージョンを引数として呼び出します:

    use Module 12.34;

=begin original

is equivalent to:

=end original

は以下と等価です:

    BEGIN { require Module; Module->VERSION(12.34) }

=begin original

The L<default C<VERSION> method|UNIVERSAL/C<VERSION ( [ REQUIRE ] )>>,
inherited from the L<C<UNIVERSAL>|UNIVERSAL> class, croaks if the given
version is larger than the value of the variable C<$Module::VERSION>.

=end original

デフォルトの
L<default C<VERSION> メソッド|UNIVERSAL/C<VERSION ( [ REQUIRE ] )>> は、
L<C<UNIVERSAL>|UNIVERSAL> クラスから継承したもので、
与えられたバージョンが 変数 C<$Module::VERSION> の値より大きい場合に
警告を出します。

=begin original

The VERSION argument cannot be an arbitrary expression.  It only counts
as a VERSION argument if it is a version number literal, starting with
either a digit or C<v> followed by a digit.  Anything that doesn't
look like a version literal will be parsed as the start of the LIST.
Nevertheless, many attempts to use an arbitrary expression as a VERSION
argument will appear to work, because L<Exporter>'s C<import> method
handles numeric arguments specially, performing version checks rather
than treating them as things to export.

=end original

VERSION 引数は任意の式ではありません。
VERSION 引数が数値または C<v> に引き続いて数値であるバージョン番号リテラルの
場合にのみ扱われます。
バージョンリテラルのように見えないものは LIST の開始としてパースされます。
それにも関わらず、VERSION 引数として任意の式を使おうとする
多くの試みは動作しているように見えます; なぜなら
L<Exporter> の C<import> メソッドは数値引数を特別に扱い、
それらをエクスポートするべきものと扱わずにバージョンチェックを
実行するからです。

=begin original

Again, there is a distinction between omitting LIST (L<C<import>|/import
LIST> called with no arguments) and an explicit empty LIST C<()>
(L<C<import>|/import LIST> not called).  Note that there is no comma
after VERSION!

=end original

繰り返すと、LIST を省略する(L<C<import>|/import LIST> が引数なしで
呼び出される)ことと明示的に空の LIST C<()> を指定する
(L<C<import>|/import LIST> は呼び出されない)ことは違います。
VERSION の後ろにカンマが不要なことに注意してください!

=begin original

Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.  Some of the currently implemented
pragmas are:

=end original

これは、広く公開されているインタフェースですので、
プラグマ (コンパイラディレクティブ) も、この方法で実装されています。
現在実装されているプラグマには、以下のようなものがあります:

    use constant;
    use diagnostics;
    use integer;
    use feature  qw(say signatures bitwise);
    use sigtrap  qw(SEGV BUS);
    use strict   qw(subs vars refs);
    use subs     qw(afunc blurfl);
    use warnings qw(all);

=begin original

Some of these pseudo-modules import semantics into the current
block scope (like L<C<strict>|strict> or L<C<integer>|integer>, unlike
ordinary modules, which import symbols into the current package (which
are effective through the end of the file).

=end original

通常のモジュールが、現在のパッケージにシンボルをインポートする
(これは、ファイルの終わりまで有効です) のに対して、これらの擬似モジュールの
一部(L<C<strict>|strict> や L<C<integer>|integer> など)は、現在の
ブロックスコープにインポートを行ないます。

=begin original

Because C<use> takes effect at compile time,
it doesn't respect the ordinary flow control of the code being compiled.
In particular, putting a C<use> inside the
false branch of a conditional doesn't prevent it
from being processed.  If a module or pragma only needs to be loaded
conditionally, this can be done using the L<if> pragma:

=end original

C<use> はコンパイル時に有効なので、コードが
コンパイルされる際の通常の流れ制御には従いません。
特に、条件文のうち成立しない側の中に C<use> を
書いても、処理を妨げられません。
モジュールやプラグマを条件付きでのみ読み込みたい場合、
L<if> プラグマを使って実現できます:

    use if $] < 5.008, "utf8";
    use if WANT_WARNINGS, warnings => qw(all);

=begin original

There's a corresponding L<C<no>|/no MODULE VERSION LIST> declaration
that unimports meanings imported by C<use>,
i.e., it calls C<< Module->unimport(LIST) >> instead of
L<C<import>|/import LIST>.  It behaves just as L<C<import>|/import LIST>
does with VERSION, an omitted or empty LIST,
or no unimport method being found.

=end original

これに対して、L<C<no>|/no MODULE VERSION LIST> 宣言という、
C<use> によってインポートされたものを、
インポートされていないことにするものがあります; つまり、
L<C<import>|/import LIST> の代わりに
C<< Module->unimport(LIST) >> を呼び出します。
これは VERSION、省略された LIST、空の LIST、unimport メソッドが見つからない
場合などの観点では、L<C<import>|/import LIST> と同様に振る舞います。

    no integer;
    no strict 'refs';
    no warnings;

=begin original

See L<perlmodlib> for a list of standard modules and pragmas.  See
L<perlrun|perlrun/-m[-]module> for the C<-M> and C<-m> command-line
options to Perl that give C<use>
functionality from the command-line.

=end original

標準モジュールやプラグマの一覧は、L<perlmodlib> を参照してください。
コマンドラインから C<use> 機能を
指定するための C<-M> と C<-m> の
コマンドラインオプションについては
L<perlrun|perlrun/-m[-]module> を参照してください。

=item use VERSION

=for Pod::Functions enable Perl language features and declare required version

=begin original

Lexically enables all features available in the requested version as
defined by the L<feature> pragma, disabling any features not in the
requested version's feature bundle.  See L<feature>.

=end original

L<feature> プラグマで定義された、指定されたバージョンで利用可能な
全ての機能を有効にし、指定されたバージョンの機能の束で要求されていない
全ての機能を無効にします。
L<feature> を参照してください。

=begin original

VERSION may be either a v-string such as v5.24.1, which will be compared
to L<C<$^V>|perlvar/$^V> (aka $PERL_VERSION), or a numeric argument of the
form 5.024001, which will be compared to L<C<$]>|perlvar/$]>.  An
exception is raised if VERSION is greater than the version of the current
Perl interpreter; Perl will not attempt to parse the rest of the file.
Compare with L<C<require>|/require VERSION>, which can do a similar check
at run time.

=end original

VERSION は v5.24.1 のような v-文字列
(L<C<$^V>|perlvar/$^V> (またの名を $PERL_VERSION) と比較されます)
か、5.024001 の形の数値形式 (L<C<$]>|perlvar/$]> と比較されます) で
指定します。
VERSION が Perl の現在のバージョンより大きいと、例外が発生します;
Perl はファイルの残りを読み込みません。
L<C<require>|/require VERSION> と似ていますが、これは実行時に
チェックされます。

=begin original

If the specified Perl version is 5.12 or higher, strictures are enabled
lexically as with L<C<use strict>|strict>.

=end original

指定された Perl のバージョンが 5.12 以上の場合、
L<C<use strict>|strict> と同様に、strict 機能がレキシカルに有効になります。

=begin original

If the specified Perl version is 5.35.0 or higher, L<warnings> are enabled.

=end original

指定された Perl のバージョンが 5.35.0 以上の場合、
L<warnings> が有効になります。

=begin original

If the specified Perl version is 5.39.0 or higher, builtin functions are
imported lexically as with L<C<use builtin>|builtin> with a corresponding
version bundle.

=end original

指定された Perl のバージョンが 5.39.0 以上の場合、組み込み関数は、
対応するバージョンの束付きの L<C<use builtin>|builtin> のように、
レキシカルにインポートされます。

=begin original

Use of C<use VERSION> while another is in effect is not allowed with a
C<use v5.39;> or greater version.  For lower versions, C<use VERSION> will
override most behavior of a previous C<use VERSION>, possibly removing
C<warnings> and C<feature> effects added by it. This behavior is deprecated,
and a future release of perl will disallow changing the version once one has
been declared.  Additionally, a C<use VERSION> with a version less than 5.11
is not allowed after a C<use VERSION> with a version greater than 5.11.

=end original

C<use v5.39;> 以降のバージョンでは、別のバージョンが有効な間に
C<use VERSION> を使用することはできません。
より低いバージョンでは、C<use VERSION> は以前の C<use VERSION> の
ほとんどの振る舞いを上書きし、それによって追加された C<warnings> および
C<feature> の効果を削除する可能性があります。
この振る舞いは廃止予定であり、将来の perl リリースでは、一度宣言された
バージョンを変更することはできなくなります。
また、5.11 より小さいバージョンの C<use VERSION> は、
5.11 より大きいバージョンの C<use VERSION> の後に使うことはできません。

=begin original

C<use VERSION> does not load the F<feature.pm>, F<strict.pm>, F<warnings.pm>
or F<builtin.pm> files, but instead implements the equivalent functionality
directly.

=end original

C<use VERSION> は、F<feature.pm>, F<strict.pm>, F<warnings.pm>,
F<builtin.pm> ファイルをロードせず、代わりに同等の機能を直接実装します。

=begin original

In the current implementation, any explicit use of C<no strict> overrides
C<use VERSION>, even if it comes before it. However, this may be subject to
change in a future release of Perl, so new code should not rely on this fact.
It is recommended that a C<use VERSION> declaration be the first significant
statement within a file (possibly after a C<package> statement or any amount
of whitespace or comment), so that its effects happen first, and other pragmata
are applied after it.

=end original

現在の実装では、明示的に C<no strict> を使うと、例え先に
指定されていたとしても、C<use VERSION> を上書きします。
しかし、これは将来のリリースの Perl で変更されるかもしれないので、
新しいコードはこの事実に依存するべきではありません。
(場合によっては C<package> 文や任意の量の空白やコメントの後の)ファイルの
最初の有効な文として C<use VERSION> 宣言することを勧めます;
この機能が最初に怒り、その他のプラグマはその後に適用されるからです。

=begin original

Specifying VERSION as a numeric argument of the form 5.024001 should
generally be avoided as older less readable syntax compared to
v5.24.1. Before perl 5.8.0 released in 2002 the more verbose numeric
form was the only supported syntax, which is why you might see it in
older code.

=end original

VERSION に 5.024001 の形の数値引数を指定することは一般的には避けるべきです;
v5.24.1 に比べてより古く読みにくい文法だからです。
(2002 年にリリースされた) perl 5.8.0 より前では、より冗長な
数値形式が唯一対応している文法でした; これが古いコードでこれを
見るかも知れない理由です。

=begin original

    use v5.24.1;    # compile time version check
    use 5.24.1;     # ditto
    use 5.024_001;  # ditto; older syntax compatible with perl 5.6

=end original

    use v5.24.1;    # 実行時バージョンチェック
    use 5.24.1;     # 同様
    use 5.024_001;  # 同様; perl 5.6 と互換性のある古い文法

=begin original

This is often useful if you need to check the current Perl version before
C<use>ing library modules that won't work
with older versions of Perl.
(We try not to do this more than we have to.)

=end original

これは古いバージョンの Perl で動かなくなったライブラリモジュールを
C<use> する前に、現在の Perl のバージョンを
調べたい場合に有用です。
(我々は必要な場合以外にそのようなことがないように努力していますが。)

=begin original

Symmetrically, C<no VERSION> allows you to specify that you want a version
of Perl older than the specified one.  Historically this was added during
early designs of the Raku language (formerly "Perl 6"), so that a Perl 5
program could begin

=end original

対称的に、C<no VERSION> は指定されたバージョンより古いバージョンの Perl で
動作させたいことを意味します。
歴史的には、これは Raku 言語 (以前は "Perl 6") の初期仕様で加えられたので、
Perl 5 のプログラムは次のもので始めて:

    no 6;

=begin original

to declare that it is not a Perl 6 program.  As the two languages have
different implementations, file naming conventions, and other
infrastructure, this feature is now little used in practice and should be
avoided in newly-written code.

=end original

Perl 6 プログラムでないことを宣言できました。
二つの言語は異なる実装、命名規則、およびその他のインフラを持つので、
今ではこの機能は実際にはほとんど使われておらず、新しいコードでは
避けるべきです。

=begin original

Care should be taken when using the C<no VERSION> form, as it is I<only>
meant to be used to assert that the running Perl is of an earlier version
than its argument and I<not> to undo the feature-enabling side effects
of C<use VERSION>.

=end original

C<no VERSION> 形式を使うときには注意を払うべきです;
これは引数で指定されたバージョンよりも前の Perl で実行されたときに
アサートされることを意味する I<だけ> で、C<use VERSION> によって
有効にされた副作用をなかったことにするもの I<ではありません>。

=item utime LIST
X<utime>

=for Pod::Functions set a file's last access and modify times

=begin original

Changes the access and modification times on each file of a list of
files.  The first two elements of the list must be the NUMERIC access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode change time of each file is set
to the current time.  For example, this code has the same effect as the
Unix L<touch(1)> command when the files I<already exist> and belong to
the user running the program:

=end original

ファイルのアクセス時刻と修正(modification) 時刻を変更します。
LIST の最初の二つの要素に、数値で表わしたアクセス時刻と修正時刻を
順に指定します。
変更に成功したファイルの数を返します。
各ファイルの inode 変更(change)時刻には、その時点の時刻が設定されます。
例えば、このコードはファイルが I<既に存在して> いて、ユーザーが
実行しているプログラムに従っているなら、
Unix の L<touch(1)> コマンドと同じ効果があります。

    #!/usr/bin/perl
    my $atime = my $mtime = time;
    utime $atime, $mtime, @ARGV;

=begin original

Since Perl 5.8.0, if the first two elements of the list are
L<C<undef>|/undef EXPR>,
the L<utime(2)> syscall from your C library is called with a null second
argument.  On most systems, this will set the file's access and
modification times to the current time (i.e., equivalent to the example
above) and will work even on files you don't own provided you have write
permission:

=end original

Perl 5.8.0 から、リストの最初の二つの要素が L<C<undef>|/undef EXPR> である
場合、C ライブラリの L<utime(2)> システムコールを、秒の引数を null として
呼び出します。
ほとんどのシステムでは、これによってファイルのアクセス時刻と修正時刻を
現在の時刻にセットし(つまり、上記の例と等価です)、
書き込み権限があれば他のユーザーのファイルに対しても動作します。

    for my $file (@ARGV) {
	utime(undef, undef, $file)
	    || warn "Couldn't touch $file: $!";
    }

=begin original

Under NFS this will use the time of the NFS server, not the time of
the local machine.  If there is a time synchronization problem, the
NFS server and local machine will have different times.  The Unix
L<touch(1)> command will in fact normally use this form instead of the
one shown in the first example.

=end original

NFS では、これはローカルマシンの時刻ではなく、NFS サーバーの時刻が
使われます。
時刻同期に問題がある場合、NFS サーバーとローカルマシンで違う時刻に
なっている場合があります。
実際のところ、Unix の L<touch(1)> コマンドは普通、最初の例ではなく、
この形を使います。

=begin original

Passing only one of the first two elements as L<C<undef>|/undef EXPR> is
equivalent to passing a 0 and will not have the effect described when
both are L<C<undef>|/undef EXPR>.  This also triggers an
uninitialized warning.

=end original

最初の二つの要素のうち、一つだけに L<C<undef>|/undef EXPR> を渡すと、その
要素は 0 を渡すのと等価となり、上述の、両方に L<C<undef>|/undef EXPR> を
渡した時と同じ効果ではありません。
この場合は、未初期化の警告が出ます。

=begin original

On systems that support L<futimes(2)>, you may pass filehandles among the
files.  On systems that don't support L<futimes(2)>, passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

=end original

L<futimes(2)> に対応しているシステムでは、ファイルハンドルを引数として
渡せます。
L<futimes(2)> に対応していないシステムでは、ファイルハンドルを渡すと
例外が発生します。
ファイルハンドルを認識させるためには、グロブまたはリファレンスとして
渡されなければなりません; 裸の単語はファイル名として扱われます。

=begin original

Portability issues: L<perlport/utime>.

=end original

移植性の問題: L<perlport/utime>。

=item values HASH
X<values>

=item values ARRAY

=for Pod::Functions return a list of the values in a hash or array

=begin original

Called in list context, returns a list consisting of all the value of the
named hash, or in Perl 5.12 or later, the values of an array.  Perl
releases prior to 5.12 will produce a syntax error if you try to use an
array argument.  In scalar context, returns the number of keys or indices.

=end original

リストコンテキストで呼び出すと、指定したハッシュのすべての値、あるいは、
Perl 5.12 以降では、配列の全ての値を返します。
Perl 5.12 より前では、配列引数を使おうとすると文法エラーが発生します。
スカラコンテキストでは、キーまたはインデックスの数を返します。

=begin original

Array entries are returned in the order of lowest index first.

=end original

配列エントリはインデックスの小さいものから順に返されます。

=begin original

Hash entries are returned in an apparently random order.  The actual random
order is specific to a given hash; the exact same series of operations
on two hashes may result in a different order for each hash.  Any insertion
into the hash may change the order, as will any deletion, with the exception
that the most recent key returned by L<C<each>|/each HASH> or
L<C<keys>|/keys HASH> may be deleted without changing the order.  So
long as a given hash is unmodified you may rely on
L<C<keys>|/keys HASH>, C<values> and
L<C<each>|/each HASH> to repeatedly return the same order
as each other.  See L<perlsec/"Algorithmic Complexity Attacks"> for
details on why hash order is randomized.  Aside from the guarantees
provided here, the exact details of Perl's hash algorithm and the hash
traversal order are subject to change in any release of Perl.  Tied hashes
may behave differently to Perl's hashes with respect to changes in order on
insertion and deletion of items.

=end original

ハッシュ要素は見かけ上、ランダムな順序で返されます。
実際のランダムな順序はハッシュに固有です; 二つのハッシュに全く同じ一連の
操作を行っても、ハッシュによって異なった順序になります。
ハッシュへの挿入によって順序が変わることがあります; 削除も同様ですが、
L<C<each>|/each HASH> または L<C<keys>|/keys HASH> によって返されたもっとも
最近のキーは順序を変えることなく削除できます。
ハッシュが変更されない限り、L<C<keys>|/keys HASH>, C<values>,
L<C<each>|/each HASH> が繰り返し同じ順序で返すことに依存してもかまいません。
なぜハッシュの順序がランダム化されているかの詳細については
L<perlsec/"Algorithmic Complexity Attacks"> を参照してください。
ここで保証したことを除いて、Perl のハッシュアルゴリズムとハッシュ横断順序の
正確な詳細は Perl のリリースによって変更される可能性があります。
tie されたハッシュは、アイテムの挿入と削除の順序に関して Perl のハッシュと
異なった振る舞いをします。

=begin original

As a side effect, calling C<values> resets the HASH or
ARRAY's internal iterator (see L<C<each>|/each HASH>) before yielding the
values.  In particular,
calling C<values> in void context resets the iterator
with no other overhead.

=end original

副作用として、C<values> を呼び出すと、
値を取り出す前に HASH や ARRAY の
内部反復子(L<C<each>|/each HASH> 参照)をリセットします。
特に、C<values> を無効コンテキストで呼び出すとその他の
オーバーヘッドなしで反復子をリセットします。

=begin original

Apart from resetting the iterator,
C<values @array> in list context is the same as plain C<@array>.
(We recommend that you use void context C<keys @array> for this, but
reasoned that taking C<values @array> out would require more
documentation than leaving it in.)

=end original

反復子をリセットするということを除けば、
リストコンテキストでの C<values @array> は単なる C<@array> と同じです。
この目的のためには無効コンテキストで C<keys @array> を使うことを
お勧めしますが、C<values @array> を取り出すにはそのままにするよりも
より多くの文書が必要だと判断しました。)

=begin original

Note that the values are not copied, which means modifying them will
modify the contents of the hash:

=end original

値はコピーされないので、返されたリストを変更すると
ハッシュの中身が変更されることに注意してください。

    for (values %hash)      { s/foo/bar/g }  # modifies %hash values
    for (@hash{keys %hash}) { s/foo/bar/g }  # same

=begin original

Starting with Perl 5.14, an experimental feature allowed
C<values> to take a
scalar expression. This experiment has been deemed unsuccessful, and was
removed as of Perl 5.24.

=end original

Perl 5.14 から、C<values> がスカラ式を取ることが出来るという
実験的機能がありました。
この実験は失敗と見なされ、Perl 5.24 で削除されました。

=begin original

To avoid confusing would-be users of your code who are running earlier
versions of Perl with mysterious syntax errors, put this sort of thing at
the top of your file to signal that your code will work I<only> on Perls of
a recent vintage:

=end original

あなたのコードを以前のバージョンの Perl で実行したユーザーが不思議な
文法エラーで混乱することを避けるために、コードが最近のバージョンの Perl で
I<のみ> 動作することを示すためにファイルの先頭に以下のようなことを
書いてください:

    use v5.12;	# so keys/values/each work on arrays

=begin original

See also L<C<keys>|/keys HASH>, L<C<each>|/each HASH>, and
L<C<sort>|/sort SUBNAME LIST>.

=end original

L<C<keys>|/keys HASH>, L<C<each>|/each HASH>, L<C<sort>|/sort SUBNAME LIST> も
参照してください。

=item vec EXPR,OFFSET,BITS
X<vec> X<bit> X<bit vector>

=for Pod::Functions test or set particular bits in a string

=begin original

Treats the string in EXPR as a bit vector made up of elements of
width BITS and returns the value of the element specified by OFFSET
as an unsigned integer.  BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.  This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).

=end original

文字列 EXPR を BITS 幅の要素からなるビットベクターとして扱い、
OFFSET で指定された要素を符号なし整数として返します。
従って、 BITS はビットベクターの中の各要素について予約されるビット数です。
BIT は、1 から 32 まで(プラットホームが
対応していれば 64 まで) の 2 のべき乗でなければなりません。

=begin original

If BITS is 8, "elements" coincide with bytes of the input string.

=end original

BITS が 8 の場合、「要素」は入力文字列の各バイトと一致します。

=begin original

If BITS is 16 or more, bytes of the input string are grouped into chunks
of size BITS/8, and each group is converted to a number as with
L<C<pack>|/pack TEMPLATE,LIST>/L<C<unpack>|/unpack TEMPLATE,EXPR> with
big-endian formats C<n>/C<N> (and analogously for BITS==64).  See
L<C<pack>|/pack TEMPLATE,LIST> for details.

=end original

BITS が 16 以上の場合、入力のバイト列は BITS/8 のサイズの固まりに
グループ化され、各グループは L<C<pack>|/pack TEMPLATE,LIST>/
L<C<unpack>|/unpack TEMPLATE,EXPR> のビッグエンディアン
フォーマット C<n>/C<N> を用いて(BITS==64 の類似として)数値に変換されます。
詳細は L<C<pack>|/pack TEMPLATE,LIST> を参照してください。

=begin original

If bits is 4 or less, the string is broken into bytes, then the bits
of each byte are broken into 8/BITS groups.  Bits of a byte are
numbered in a little-endian-ish way, as in C<0x01>, C<0x02>,
C<0x04>, C<0x08>, C<0x10>, C<0x20>, C<0x40>, C<0x80>.  For example,
breaking the single input byte C<chr(0x36)> into two groups gives a list
C<(0x6, 0x3)>; breaking it into 4 groups gives C<(0x2, 0x1, 0x3, 0x0)>.

=end original

BITS が 4 以下の場合、文字列はバイトに分解され、バイトの各ビットは
8/BITS 個のグループに分割されます。
ビットはリトルエンディアン風に、C<0x01>, C<0x02>,
C<0x04>, C<0x08>, C<0x10>, C<0x20>, C<0x40>, C<0x80> の順になります。
例えば、入力バイト C<chr(0x36)> を二つのグループに分割すると、
C<(0x6, 0x3)> になります; 4 つに分割すると C<(0x2, 0x1, 0x3, 0x0)> に
なります。

=begin original

C<vec> may also be assigned to, in which case
parentheses are needed
to give the expression the correct precedence as in

=end original

C<vec> は左辺値として、代入の
対象にすることもできます; この場合、式を正しく
先行させるために以下のように括弧が必要です:

    vec($image, $max_x * $x + $y, 8) = 3;

=begin original

If the selected element is outside the string, the value 0 is returned.
If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.   It is an error
to try to write off the beginning of the string (i.e., negative OFFSET).

=end original

選択された要素が文字列の外側だった場合、値 0 が返されます。
文字列の最後よりも後ろの要素に書き込もうとした場合、
Perl はまず文字列を必要な分だけ 0 のバイトで拡張します。
文字列の先頭より前に書き込もうとした(つまり OFFSET が負の数だった)
場合はエラーとなります。

=begin original

If the string happens to be encoded as UTF-8 internally (and thus has
the UTF8 flag set), C<vec> tries to convert it
to use a one-byte-per-character internal representation. However, if the
string contains characters with values of 256 or higher, a fatal error
will occur.

=end original

文字列がたまたま内部で UTF-8 でエンコードされている場合(したがって
UTF8 フラグがセットされている場合)、
C<vec> はこれを単一バイト文字内部表現に
変換しようとします。
しかし、この文字列に値が 256 以上の文字が含まれている場合、
致命的エラーが発生します。

=begin original

Strings created with C<vec> can also be
manipulated with the logical
operators C<|>, C<&>, C<^>, and C<~>.  These operators will assume a bit
vector operation is desired when both operands are strings.
See L<perlop/"Bitwise String Operators">.

=end original

C<vec> で作られた文字列は、論理演算子 C<|>、C<&>、
C<^>, C<~> で扱うこともできます。
これらの演算子は、両方の被演算子に文字列を使うと、
ビットベクター演算を行ないます。
L<perlop/"Bitwise String Operators"> を参照してください。

=begin original

The following code will build up an ASCII string saying C<'PerlPerlPerl'>.
The comments show the string after each step.  Note that this code works
in the same way on big-endian or little-endian machines.

=end original

次のコードは C<'PerlPerlPerl'> という ASCII 文字列を作成します。
コメントは各行の実行後の文字列を示します。
このコードはビッグエンディアンでもリトルエンディアンでも同じように
動作することに注意してください。

    my $foo = '';
    vec($foo,  0, 32) = 0x5065726C; # 'Perl'

    # $foo eq "Perl" eq "\x50\x65\x72\x6C", 32 bits
    print vec($foo, 0, 8);  # prints 80 == 0x50 == ord('P')

    vec($foo,  2, 16) = 0x5065; # 'PerlPe'
    vec($foo,  3, 16) = 0x726C; # 'PerlPerl'
    vec($foo,  8,  8) = 0x50;   # 'PerlPerlP'
    vec($foo,  9,  8) = 0x65;   # 'PerlPerlPe'
    vec($foo, 20,  4) = 2;      # 'PerlPerlPe'   . "\x02"
    vec($foo, 21,  4) = 7;      # 'PerlPerlPer'
                                   # 'r' is "\x72"
    vec($foo, 45,  2) = 3;      # 'PerlPerlPer'  . "\x0c"
    vec($foo, 93,  1) = 1;      # 'PerlPerlPer'  . "\x2c"
    vec($foo, 94,  1) = 1;      # 'PerlPerlPerl'
                                   # 'l' is "\x6c"

=begin original

To transform a bit vector into a string or list of 0's and 1's, use these:

=end original

ビットベクターを、0 と 1 の文字列や配列に変換するには、
以下のようにします。

    my $bits = unpack("b*", $vector);
    my @bits = split(//, unpack("b*", $vector));

=begin original

If you know the exact length in bits, it can be used in place of the C<*>.

=end original

ビット長が分かっていれば、C<*> の代わりにその長さを使うことができます。

=begin original

Here is an example to illustrate how the bits actually fall in place:

=end original

これはビットが実際にどのような位置に入るかを図示する例です。

  #!/usr/bin/perl -wl

  print <<'EOT';
                                    0         1         2         3
                     unpack("V",$_) 01234567890123456789012345678901
  ------------------------------------------------------------------
  EOT

  for $w (0..3) {
      $width = 2**$w;
      for ($shift=0; $shift < $width; ++$shift) {
          for ($off=0; $off < 32/$width; ++$off) {
              $str = pack("B*", "0"x32);
              $bits = (1<<$shift);
              vec($str, $off, $width) = $bits;
              $res = unpack("b*",$str);
              $val = unpack("V", $str);
              write;
          }
      }
  }

  format STDOUT =
  vec($_,@#,@#) = @<< == @######### @>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  $off, $width, $bits, $val, $res
  .
  __END__

=begin original

Regardless of the machine architecture on which it runs, the
example above should print the following table:

=end original

実行するマシンのアーキテクチャに関わらず、
上記の例は以下の表を出力します。

                                    0         1         2         3
                     unpack("V",$_) 01234567890123456789012345678901
  ------------------------------------------------------------------
  vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000
  vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000
  vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000
  vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000
  vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000
  vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000
  vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
  vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
  vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
  vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
  vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
  vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
  vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
  vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
  vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
  vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
  vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
  vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
  vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
  vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
  vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
  vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
  vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
  vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
  vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
  vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
  vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
  vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
  vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
  vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
  vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
  vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
  vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
  vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
  vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
  vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
  vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
  vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
  vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
  vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
  vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
  vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
  vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
  vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
  vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
  vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
  vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
  vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
  vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
  vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
  vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
  vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
  vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
  vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
  vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
  vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
  vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
  vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
  vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
  vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
  vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
  vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
  vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
  vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
  vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
  vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
  vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
  vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
  vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
  vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
  vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
  vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
  vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
  vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
  vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
  vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
  vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
  vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
  vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
  vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
  vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
  vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
  vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
  vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
  vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
  vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
  vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
  vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
  vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
  vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
  vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
  vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
  vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
  vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
  vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
  vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
  vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
  vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
  vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
  vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
  vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
  vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
  vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
  vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
  vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
  vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
  vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
  vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
  vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
  vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
  vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
  vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001

=item wait
X<wait>

=for Pod::Functions wait for any child process to die

=begin original

Behaves like L<wait(2)> on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C<-1> if there are no child processes.  The status is returned in
L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.
Note that a return value of C<-1> could mean that child processes are
being automatically reaped, as described in L<perlipc>.

=end original

L<wait(2)> と同様に振る舞います: チャイルドプロセスが終了するのを待ち、
消滅したプロセスの pid を返します; チャイルドプロセスが存在しないときには、
C<-1> を返します。
ステータスは L<C<$?>|perlvar/$?> と
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> に返されます。
L<perlipc> に書いているように、返り値が C<-1> の場合は子プロセスが
自動的に刈り取られたことを意味するかもしれないことに注意してください。

=begin original

If you use C<wait> in your handler for
L<C<$SIG{CHLD}>|perlvar/%SIG>, it may accidentally wait for the child
created by L<C<qx>|/qxE<sol>STRINGE<sol>> or L<C<system>|/system LIST>.
See L<perlipc> for details.

=end original

C<wait> を L<C<$SIG{CHLD}>|perlvar/%SIG> のハンドラで使うと、誤って
L<C<qx>|/qxE<sol>STRINGE<sol>> や L<C<system>|/system LIST> によって
作られた子を待つことになるかも知れません。
詳しくは L<perlipc> を参照してください。

=begin original

Equivalent to L<C<waitpid(-1, 0)>|/waitpid PID,FLAGS>.

=end original

L<C<waitpid(-1, 0)>|/waitpid PID,FLAGS> と等価です。

=begin original

Portability issues: L<perlport/wait>.

=end original

移植性の問題: L<perlport/wait>。

=item waitpid PID,FLAGS
X<waitpid>

=for Pod::Functions wait for a particular child process to die

=begin original

Waits for a particular child process to terminate and returns the pid of
the deceased process, or C<-1> if there is no such child process.  A
non-blocking wait (with L<WNOHANG|POSIX/C<WNOHANG>> in FLAGS) can return 0 if
there are child processes matching PID but none have terminated yet.
The status is returned in L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.

=end original

特定の子プロセスが終了するのを待ち、消滅したプロセスの pid を
返します; 指定した子プロセスが存在しないときには、C<-1> を返します。
(FLAGS に L<WNOHANG|POSIX/C<WNOHANG>> を指定した) 非ブロッキング wait は、
PID がマッチングする子プロセスがいてもまだ終了していない場合に 0 を
返すことがあります。
ステータスは L<C<$?>|perlvar/$?> と
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}> に返されます。

=begin original

A PID of C<0> indicates to wait for any child process whose process group ID is
equal to that of the current process.  A PID of less than C<-1> indicates to
wait for any child process whose process group ID is equal to -PID.  A PID of
C<-1> indicates to wait for any child process.

=end original

PID に C<0> を指定すると、プロセスグループ ID が現在のプロセスと同じである
任意の子プロセスを wait します。
PID に C<-1> 以下を指定すると、プロセスグループ ID が -PID に等しい
任意の子プロセスを wait します。
PID に C<-1> を指定すると任意の子プロセスを wait します。

=begin original

If you say

=end original

以下のようにするか

    use POSIX ":sys_wait_h";

    my $kid;
    do {
        $kid = waitpid(-1, WNOHANG);
    } while $kid > 0;

=begin original

or

=end original

または

    1 while waitpid(-1, WNOHANG) > 0;

=begin original

then you can do a non-blocking wait for all pending zombie processes (see
L<POSIX/WAIT>).
Non-blocking wait is available on machines supporting either the
L<waitpid(2)> or L<wait4(2)> syscalls.  However, waiting for a particular
pid with FLAGS of C<0> is implemented everywhere.  (Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)

=end original

とすると、ブロックが起こらないようにして、全ての待機中ゾンビプロセスを
wait します (L<POSIX/WAIT> を参照してください)。
ブロックなしの wait は、システムコール L<wait_pid(2)> か、
システムコール L<wait4(2)> をサポートしているマシンで利用可能です。
しかしながら、特定の pid を C<0> の FLAGS での wait はどこでも
実装されています。
(exit したプロセスのステータス値を覚えておいて、Perl がシステムコールを
エミュレートしますが、Perl スクリプトには取り入れられていません。)

=begin original

Note that on some systems, a return value of C<-1> could mean that child
processes are being automatically reaped.  See L<perlipc> for details,
and for other examples.

=end original

システムによっては、返り値が C<-1> の場合は子プロセスが自動的に
刈り取られたことを意味するかもしれないことに注意してください。
詳細やその他の例については L<perlipc> を参照してください。

=begin original

Portability issues: L<perlport/waitpid>.

=end original

移植性の問題: L<perlport/waitpid>。

=item wantarray
X<wantarray> X<context>

=for Pod::Functions get void vs scalar vs list context of current subroutine call

=begin original

Returns true if the context of the currently executing subroutine or
L<C<eval>|/eval EXPR> is looking for a list value.  Returns false if the
context is
looking for a scalar.  Returns the undefined value if the context is
looking for no value (void context).

=end original

現在実行中のサブルーチンか L<C<eval>|/eval EXPR> ブロックのコンテキストが、
リスト値を要求するものであれば、真を返します。
スカラを要求するコンテキストであれば、偽を返します。
何も値を要求しない(無効コンテキスト)場合は未定義値を返します。

    return unless defined wantarray; # don't bother doing more
    my @a = complex_calculation();
    return wantarray ? @a : "@a";

=begin original

C<wantarray>'s result is unspecified in the top level of a file,
in a C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> or C<END> block, or
in a C<DESTROY> method.

=end original

ファイルのトップレベル、C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT>, C<END>
ブロック内、C<DESTROY> メソッド内では C<wantarray> の結果は
未定義です。

=begin original

This function should have been named wantlist() instead.

=end original

この関数は wantlist() という名前にするべきでした。

=item warn LIST
X<warn> X<warning> X<STDERR>

=for Pod::Functions print debugging info

=begin original

Emits a warning, usually by printing it to C<STDERR>.  C<warn> interprets
its operand LIST in the same way as C<die>, but is slightly different
in what it defaults to when LIST is empty or makes an empty string.
If it is empty and L<C<$@>|perlvar/$@> already contains an exception
value then that value is used after appending C<"\t...caught">.  If it
is empty and C<$@> is also empty then the string C<"Warning: Something's
wrong"> is used.

=end original

(通常は C<STDERR> に表示することで) 警告を出力します。
C<warn> はそのオペランド LIST を C<die> と同様に解釈しますが、
LIST が空や空文字列を作る時に何をデフォルトとするかが少し異なります。
それが空かつ、L<C<$@>|perlvar/$@> に既に
例外値が入っている場合、C<"\t...caught"> を追加した値が
用いられます。
もしこれが空で C<$@> も空の場合は、C<"Warning: Something's wrong"> という
文字列が使われます。

=begin original

By default, the exception derived from the operand LIST is stringified
and printed to C<STDERR>.  This behaviour can be altered by installing
a L<C<$SIG{__WARN__}>|perlvar/%SIG> handler.  If there is such a
handler then no message is automatically printed; it is the handler's
responsibility to deal with the exception
as it sees fit (like, for instance, converting it into a
L<C<die>|/die LIST>).  Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling
C<warn>
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since C<__WARN__> hooks are not called from
inside one.

=end original

デフォルトでは、LIST オペランドから生成された例外は
文字列化されて C<STDERR> に表示されます。
この振る舞いは、L<C<$SIG{__WARN__}>|perlvar/%SIG> ハンドラを設定することで
置き換えられます。
このようなハンドラが設定されている場合は何の
メッセージも自動的には表示されません;
例外をどう扱うか(例えば L<C<die>|/die LIST> に変換するか)はハンドラの
責任ということです。
従ってほとんどのハンドラは、扱おうと準備していない警告を表示するために、
ハンドラの中で C<warn> を再び呼び出します。
C<__WARN__> フックはハンドラ内では呼び出されないので、これは十分安全で、
無限ループを引き起こすことはないということに注意してください。

=begin original

You will find this behavior is slightly different from that of
L<C<$SIG{__DIE__}>|perlvar/%SIG> handlers (which don't suppress the
error text, but can instead call L<C<die>|/die LIST> again to change
it).

=end original

この振る舞いは L<C<$SIG{__DIE__}>|perlvar/%SIG> ハンドラ(エラーテキストは
削除しませんが、代わりに L<C<die>|/die LIST> をもう一度呼び出すことで
変更できます)とは少し違うことに気付くことでしょう。

=begin original

Using a C<__WARN__> handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).  An example:

=end original

C<__WARN__> ハンドラを使うと、(いわゆる必須のものを含む)全ての
警告を黙らせる強力な手段となります。
例:

    # wipe out *all* compile-time warnings
    BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
    my $foo = 10;
    my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!
    # no compile-time or run-time warnings before here
    $DOWARN = 1;

    # run-time warnings enabled after here
    warn "\$foo is alive and $foo!";     # does show up

=begin original

See L<perlvar> for details on setting L<C<%SIG>|perlvar/%SIG> entries
and for more
examples.  See the L<Carp> module for other kinds of warnings using its
C<carp> and C<cluck> functions.

=end original

L<C<%SIG>|perlvar/%SIG> エントリのセットに関する詳細とさらなる例に関しては
L<perlvar> を参照してください。
C<carp> 関数と C<cluck> 関数を用いた警告の方法に関しては
L<Carp> モジュールを参照してください。

=item write FILEHANDLE
X<write>

=item write EXPR

=item write

=for Pod::Functions print a picture record

=begin original

Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the
L<C<select>|/select FILEHANDLE> function) may be set explicitly by
assigning the name of the format to the L<C<$~>|perlvar/$~> variable.

=end original

指定された FILEHANDLE に対して、そのファイルに対応させた
フォーマットを使って、(複数行の場合もある) 整形された
レコードを書き出します。
デフォルトでは、ファイルに対応するフォーマットは、ファイルハンドルと
同じ名前のものですが、その時点の出力チャネル
(L<C<select>|/select FILEHANDLE> 関数の項を
参照してください) のフォーマットは、その名前を明示的に変数
L<C<$~>|perlvar/$~> に代入することで、変更が可能です。

=begin original

Top of form processing is handled automatically:  if there is insufficient
room on the current page for the formatted record, the page is advanced by
writing a form feed and a special top-of-page
format is used to format the new
page header before the record is written.  By default, the top-of-page
format is the name of the filehandle with C<_TOP> appended, or C<top>
in the current package if the former does not exist.  This would be a
problem with autovivified filehandles, but it may be dynamically set to the
format of your choice by assigning the name to the L<C<$^>|perlvar/$^>
variable while that filehandle is selected.  The number of lines
remaining on the current page is in variable L<C<$->|perlvar/$->, which
can be set to C<0> to force a new page.

=end original

ページの先頭の処理は、自動的に行なわれます: 現在のページに整形された
レコードを出力するだけのスペースがない場合には、改ページを行なってページを
進め、新しいページヘッダを整形するため、ページ先頭フォーマットが使われ、
その後でレコードが書かれます。
デフォルトでは、ページ先頭フォーマットは、ファイルハンドルの名前に
C<_TOP> をつなげたものか、前者が存在しないなら、現在のパッケージの
C<top> です。
これは自動有効化されたファイルハンドルで問題になる可能性がありますが、
ファイルハンドルが選択されている間に、
変数 L<C<$^>|perlvar/$^> に名前を設定すれば、動的にフォーマットを
変更することができます。
そのページの残り行数は、変数 L<C<$->|perlvar/$-> に入っており、この変数を
C<0> に設定することで、強制的に改ページを行なうことができます。

=begin original

If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
L<C<select>|/select FILEHANDLE> operator.  If the FILEHANDLE is an EXPR,
then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see L<perlform>.

=end original

FILEHANDLE を指定しないと、出力はその時点のデフォルト出力チャネルに対して
行なわれます; これは、スクリプトの開始時点では STDOUT ですが、
L<C<select>|/select FILEHANDLE> 演算子で変更することができます。
FILEHANDLE が EXPR ならば、式が評価され、その結果の文字列が
実行時に FILEHANDLE の名前として見られます。
フォーマットについて、さらには、L<perlform> を参照してください。

=begin original

Note that write is I<not> the opposite of
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>.  Unfortunately.

=end original

write は L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET> の
反対のことをするもの I<ではありません>。
残念ながら。

=item y///

=for Pod::Functions transliterate a string

=begin original

The transliteration operator.  Same as
L<C<trE<sol>E<sol>E<sol>>|/trE<sol>E<sol>E<sol>>.  See
L<perlop/"Quote-Like Operators">.

=end original

文字変換演算子です。
L<C<trE<sol>E<sol>E<sol>>|/trE<sol>E<sol>E<sol>> と同じです。
L<perlop/"Quote-Like Operators"> を参照してください。

=back

=head2 Non-function Keywords by Cross-reference

=head3 perldata

=over

=item __DATA__

=item __END__

=begin original

These keywords are documented in L<perldata/"Special Literals">.

=end original

これらのキーワードは L<perldata/"Special Literals"> で文書化されています。

=back

=head3 perlmod

=over

=item BEGIN

=item CHECK

=item END

=item INIT

=item UNITCHECK

=begin original

These compile phase keywords are documented in L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END">.

=end original

これらのコンパイルフェーズキーワードは
L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END"> で文書化されています。

=back

=head3 perlobj

=over

=item DESTROY

=begin original

This method keyword is documented in L<perlobj/"Destructors">.

=end original

このメソッドキーワードは L<perlobj/"Destructors"> で文書化されています。

=back

=head3 perlop

=over

=item and

=item cmp

=item eq

=item ge

=item gt

=item isa

=item le

=item lt

=item ne

=item not

=item or

=item x

=item xor

=begin original

These operators are documented in L<perlop>.

=end original

これらの演算子は L<perlop> で文書化されています。

=back

=head3 perlsub

=over

=item AUTOLOAD

=begin original

This keyword is documented in L<perlsub/"Autoloading">.

=end original

このキーワードは L<perlsub/"Autoloading"> で文書化されています。

=back

=head3 perlsyn

=over

=item else

=item elsif

=item for

=item foreach

=item if

=item unless

=item until

=item while

=begin original

These flow-control keywords are documented in L<perlsyn/"Compound Statements">.

=end original

これらのフロー制御キーワードは L<perlsyn/"Compound Statements"> で
文書化されています。

=item elseif

=begin original

The "else if" keyword is spelled C<elsif> in Perl.  There's no C<elif>
or C<else if> either.  It does parse C<elseif>, but only to warn you
about not using it.

=end original

"else if" キーワードは Perl では C<elsif> と綴ります。
C<elif> や C<else if> はありません。
C<elseif> はパースされますが、使わないように警告するためだけです。

=begin original

See the documentation for flow-control keywords in L<perlsyn/"Compound
Statements">.

=end original

L<perlsyn/"Compound Statements"> のフロー制御キーワードに関する文章を
参照してください。

=back

=over

=item default

=item given

=item when

=begin original

These flow-control keywords related to the experimental switch feature are
documented in L<perlsyn/"Switch Statements">.

=end original

これらの実験的な switch 機能に関連するフロー制御キーワードは
L<perlsyn/"Switch Statements"> で文書化されています。

=back

=over

=item try

=item catch

=item finally

=begin original

These flow-control keywords related to the experimental C<try> feature are
documented in L<perlsyn/"Try Catch Exception Handling">.

=end original

実験的な C<try> 機能に関係するこれらのフロー制御キーワードは
L<perlsyn/"Try Catch Exception Handling"> に文書化されています。

=back

=over

=item defer

=begin original

This flow-control keyword related to the experimental C<defer> feature is
documented in L<perlsyn/"defer blocks">.

=end original

実験的な C<defer> 機能に関係するこれらのフロー制御キーワードは
L<perlsyn/"defer blocks"> に文書化されています。

=back

=over

=item ADJUST

=begin original

This class-related phaser block is documented in L<perlclass>.

=end original

クラス関連のフェーズブロックは L<perlclass> に文書化されています。

=back

=cut

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.6.1-)
Status: completed

=end meta

