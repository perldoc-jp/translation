
=encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlgit.pod

=head1 NAME

=begin original

perlgit - Detailed information about git and the Perl repository

=end original

perlgit - git と Perl リポジトリに関する詳細情報

=head1 DESCRIPTION

=begin original

This document provides details on using git to develop Perl. If you are
just interested in working on a quick patch, see L<perlhack> first.
This document is intended for people who are regular contributors to
Perl, including those with write access to the git repository.

=end original

この文書は、Perl を開発するために git を使う詳細を提供します。
単に簡単なパッチに対して作業することに興味があるなら、
まず L<perlhack> を参照してください。
この文書は、git リポジトリへの書き込みアクセスを持つ人々を含む、
Perl の定期的な貢献者である人々のためを意図しています。

=head1 CLONING THE REPOSITORY

(リポジトリをクローンする)

=begin original

All of Perl's source code is kept centrally in a Git repository at
I<github.com>.

=end original

Perlのソースコードはすべて、I<github.com> の Git リポジトリに
集中管理されています。

=begin original

You can make a read-only clone of the repository by running:

=end original

これを実行することでリポジトリの読み込み専用のクローンを作ることができます:

  % git clone git@github.com:Perl/perl5.git perl

=begin original

If you cannot use that for firewall reasons, you can also clone via http:

=end original

ファイアウォールの関係でこれが使えない場合、
http 経由でもクローンできます:

  % git clone https://github.com/Perl/perl5.git perl

=head1 WORKING WITH THE REPOSITORY

(リポジトリでの作業)

=begin original

Once you have changed into the repository directory, you can inspect
it. After a clone the repository will contain a single local branch,
which will be the current branch as well, as indicated by the asterisk.

=end original

リポジトリディレクトリに変更を加えたら、そのディレクトリを検査できます。
クローン作成後、リポジトリには単一のローカルブランチが含まれます;
このローカルブランチは、アスタリスクで示されているように、
現在のブランチにもなります。

  % git branch
  * blead

=begin original

Using the -a switch to C<branch> will also show the remote tracking
branches in the repository:

=end original

C<branch> に -a スイッチを使用すると、リポジトリ内の
リモート追跡ブランチも表示されます:

  % git branch -a
  * blead
    origin/HEAD
    origin/blead
  ...

=begin original

The branches that begin with "origin" correspond to the "git remote"
that you cloned from (which is named "origin"). Each branch on the
remote will be exactly tracked by these branches. You should NEVER do
work on these remote tracking branches. You only ever do work in a
local branch. Local branches can be configured to automerge (on pull)
from a designated remote tracking branch. This is the case with the
default branch C<blead> which will be configured to merge from the
remote tracking branch C<origin/blead>.

=end original

"origin" で始まるブランチは、クローン元の "git remote"
("origin" という名前) に対応します。
リモートの各ブランチは、これらのブランチによって正確に追跡されます。
これらのリモート追跡ブランチでは絶対に作業しないでください。
ローカルブランチでのみ作業します。
ローカルブランチは、指定されたリモート追跡ブランチから
(プル時に)自動マージするように構成できます。
これは、リモート追跡ブランチ C<origin/blead> からマージするように
構成されているデフォルトブランチ C<blead> の場合です。

=begin original

You can see recent commits:

=end original

最近のコミットを見られます:

  % git log

=begin original

And pull new changes from the repository, and update your local
repository (must be clean first)

=end original

リポジトリから新しい変更をプルし、ローカルリポジトリを更新します
(最初にクリーンにする必要があります)。

  % git pull

=begin original

Assuming we are on the branch C<blead> immediately after a pull, this
command would be more or less equivalent to:

=end original

プルの直後にブランチ C<blead> にいると仮定すると、このコマンドは
以下とほぼ等価になります:

  % git fetch
  % git merge origin/blead

=begin original

In fact if you want to update your local repository without touching
your working directory you do:

=end original

実際、作業ディレクトリにアクセスせずにローカルリポジトリを更新したい場合は、
次のようにします:

  % git fetch

=begin original

And if you want to update your remote-tracking branches for all defined
remotes simultaneously you can do

=end original

また、定義されたすべてのリモートに対してリモート追跡ブランチを
同時に更新したい場合は、以下のように行うことができます:

  % git remote update

=begin original

Neither of these last two commands will update your working directory,
however both will update the remote-tracking branches in your
repository.

=end original

最後の二つのコマンドはどちらも作業ディレクトリを更新しませんが、どちらも
リポジトリ内のリモート追跡ブランチを更新します。

=begin original

To make a local branch of a remote branch:

=end original

リモートブランチのローカルブランチを作るには:

  % git checkout -b maint-5.10 origin/maint-5.10

=begin original

To switch back to blead:

=end original

blead に戻るには:

  % git checkout blead

=head2 Finding out your status

(現在の状態を確認する)

=begin original

The most common git command you will use will probably be

=end original

おそらくもっともよく使う git コマンドは:

  % git status

=begin original

This command will produce as output a description of the current state
of the repository, including modified files and unignored untracked
files, and in addition it will show things like what files have been
staged for the next commit, and usually some useful information about
how to change things. For instance the following:

=end original

このコマンドは、変更されたファイルや無視されていない
追跡されていないファイルなど、リポジトリの現在の状態の説明を
出力として生成します;
さらに、次のコミットのためにステージングされたファイルや、
通常は変更方法に関する有用な情報を表示します。
たとえば、次のようになります:

 % git status
 On branch blead
 Your branch is ahead of 'origin/blead' by 1 commit.

 Changes to be committed:
   (use "git reset HEAD <file>..." to unstage)

       modified:   pod/perlgit.pod

 Changes not staged for commit:
   (use "git add <file>..." to update what will be committed)
   (use "git checkout -- <file>..." to discard changes in working
                                                              directory)

       modified:   pod/perlgit.pod

 Untracked files:
   (use "git add <file>..." to include in what will be committed)

       deliberate.untracked

=begin original

This shows that there were changes to this document staged for commit,
and that there were further changes in the working directory not yet
staged. It also shows that there was an untracked file in the working
directory, and as you can see shows how to change all of this. It also
shows that there is one commit on the working branch C<blead> which has
not been pushed to the C<origin> remote yet. B<NOTE>: This output
is also what you see as a template if you do not provide a message to
C<git commit>.

=end original

これは、コミットのためにステージングされたこの文書に変更があったことと、
まだステージングされていないワーキングディレクトリに
さらに変更があったことを示しています。
また、ワーキングディレクトリに追跡されていないファイルが
あったことも示しています;
また、これらすべてを変更する方法を示しています。
また、C<origin> リモートにまだプッシュされていないワーキングブランチ
C<blead> に一つのコミットがあることも示しています。
B<注>: この出力は、C<git commit> にメッセージを提供しない場合に
テンプレートとして表示されるものでもあります。

=head2 Patch workflow

(パッチのワークフロー)

=begin original

First, please read L<perlhack> for details on hacking the Perl core.
That document covers many details on how to create a good patch.

=end original

まず、Perl コアをハックするための詳細については L<perlhack> を読んでください。
この文書はよいパッチの作り方に関する多くの詳細に対応しています。

=begin original

If you already have a Perl repository, you should ensure that you're on
the I<blead> branch, and your repository is up to date:

=end original

すでに Perl リポジトリを持っている場合は、
I<blead> ブランチにいて、リポジトリが最新であることを確認する必要があります:

  % git checkout blead
  % git pull

=begin original

It's preferable to patch against the latest blead version, since this
is where new development occurs for all changes other than critical bug
fixes. Critical bug fix patches should be made against the relevant
maint branches, or should be submitted with a note indicating all the
branches where the fix should be applied.

=end original

最新の blead バージョンに対してパッチを適用することをお勧めします;
これは、重大なバグ修正以外のすべての変更に対して新たな開発が行われる
場所であるためです。
重大なバグ修正パッチは、関連するメインブランチに対して作成するか、
修正が適用されるすべてのブランチを示すメモとともに提出する必要があります。

=begin original

Now that we have everything up to date, we need to create a temporary
new branch for these changes and switch into it:

=end original

すべてが最新の状態になったので、これらの変更に対して一時的な
新しいブランチを作成し、そのブランチに切り替える必要があります:

  % git checkout -b orange

=begin original

which is the short form of

=end original

これは以下のものの短縮形です

  % git branch orange
  % git checkout orange

=begin original

Creating a topic branch makes it easier for the maintainers to rebase
or merge back into the master blead for a more linear history. If you
don't work on a topic branch the maintainer has to manually cherry pick
your changes onto blead before they can be applied.

=end original

トピックブランチを作成することで、メンテナはよりリニアな履歴のために
master blead にリベースまたはマージバックすることが簡単になります。
トピックブランチで作業しない場合、
メンテナは変更を適用する前に手動で blead にチェリーピックする
必要があります。

=begin original

That'll get you scolded on perl5-porters, so don't do that. Be Awesome.

=end original

perl5-porters で叱られることになるので、そんなことはしないでください。
うまくやりましょう。

=begin original

Then make your changes. For example, if Leon Brocard changes his name
to Orange Brocard, we should change his name in the AUTHORS file:

=end original

次に、変更を加えます。
たとえば、Leon Brocard が名前を Orange Brocard に変更した場合、
AUTHORS ファイル内の名前を変更する必要があります:

  % perl -pi -e 's{Leon Brocard}{Orange Brocard}' AUTHORS

=begin original

You can see what files are changed:

=end original

どのファイルを変更したかを見られます:

  % git status
  On branch orange
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)

     modified:   AUTHORS

=begin original

And you can see the changes:

=end original

そして変更が見られます:

 % git diff
 diff --git a/AUTHORS b/AUTHORS
 index 293dd70..722c93e 100644
 --- a/AUTHORS
 +++ b/AUTHORS
 @@ -541,7 +541,7 @@    Lars Hecking              <lhecking@nmrc.ucc.ie>
  Laszlo Molnar                  <laszlo.molnar@eth.ericsson.se>
  Leif Huhn                      <leif@hale.dkstat.com>
  Len Johnson                    <lenjay@ibm.net>
 -Leon Brocard                   <acme@astray.com>
 +Orange Brocard                 <acme@astray.com>
  Les Peters                     <lpeters@aol.net>
  Lesley Binks                   <lesley.binks@gmail.com>
  Lincoln D. Stein               <lstein@cshl.org>

=begin original

Now commit your change locally:

=end original

ここで変更をローカルにコミットします:

 % git commit -a -m 'Rename Leon Brocard to Orange Brocard'
 Created commit 6196c1d: Rename Leon Brocard to Orange Brocard
  1 files changed, 1 insertions(+), 1 deletions(-)

=begin original

The C<-a> option is used to include all files that git tracks that you
have changed. If at this time, you only want to commit some of the
files you have worked on, you can omit the C<-a> and use the command
C<S<git add I<FILE ...>>> before doing the commit. C<S<git add
--interactive>> allows you to even just commit portions of files
instead of all the changes in them.

=end original

C<-a> オプションは、git が追跡しているファイルの中であなたが変更した
全てのファイルを含むために使われます。
もしこの時点で、作業したファイルの一部だけをコミットしたい場合は、
C<-a> を省略して、コミットを行う前にコマンド
C<S<git add I<FILE ...>>> を使ってください。
C<S<git add --interactive>> は、ファイル中の全ての変更ではなく、
ファイルの一部をコミットできるようにします。

=begin original

The C<-m> option is used to specify the commit message. If you omit it,
git will open a text editor for you to compose the message
interactively. This is useful when the changes are more complex than
the sample given here, and, depending on the editor, to know that the
first line of the commit message doesn't exceed the 50 character legal
maximum. See L<perlhack/Commit message> for more information about what
makes a good commit message.

=end original

C<-m> オプションはコミットメッセージを指定するために使われます。
これを省略すると、git はメッセージを対話的に作成するために
テキストエディタを開きます。
これは、変更がここで指定するサンプルよりも複雑な場合、そして
エディタによっては、コミットメッセージの先頭行が上限の
50 文字を超えないことを知るために有用です。
よいコミットメッセージとは何かということに関するさらなる情報については
L<perlhack/Commit message> を参照してください。

=begin original

Once you've finished writing your commit message and exited your
editor, git will write your change to disk and tell you something like
this:

=end original

コミットメッセージを書き終えてエディタを終了すると、
git は変更をディスクに書き込み、以下のようなメッセージを出力します:

 Created commit daf8e63: explain git status and stuff about remotes
  1 files changed, 83 insertions(+), 3 deletions(-)

=begin original

If you re-run C<git status>, you should see something like this:

=end original

C<git status> を再実行すると、次のようなものが表示されます:

 % git status
 On branch orange
 Untracked files:
   (use "git add <file>..." to include in what will be committed)

       deliberate.untracked

 nothing added to commit but untracked files present (use "git add" to
                                                                  track)

=begin original

When in doubt, before you do anything else, check your status and read
it carefully, many questions are answered directly by the git status
output.

=end original

疑わしいときには、他のことをする前に、ステータスをチェックして
注意深く読んでください;
多くの疑問は git status の出力で直接応えられています。

=begin original

You can examine your last commit with:

=end original

最後のコミットを以下のようにして検査できます:

  % git show HEAD

=begin original

and if you are not happy with either the description or the patch
itself you can fix it up by editing the files once more and then issue:

=end original

説明またはパッチ自体に満足できない場合は、ファイルをもう一度編集してから
次のコマンドを発行することで修正できます:

  % git commit -a --amend

=begin original

Now, create a fork on GitHub to push your branch to, and add it as a
remote if you haven't already, as described in the GitHub documentation
at L<https://help.github.com/en/articles/working-with-forks>:

=end original

ここで、このブランチをプッシュするために GitHub 上でフォークし、
もしまだならこれをリモートとして追加します;
これは GitHub 文書
L<https://help.github.com/en/articles/working-with-forks> に記述されています:

  % git remote add fork git@github.com:MyUser/perl5.git

=begin original

And push the branch to your fork:

=end original

そしてフォークしたブランチをプッシュします:

  % git push -u fork orange

=begin original

You should now submit a Pull Request (PR) on GitHub from the new branch
to blead. For more information, see the GitHub documentation at
L<https://help.github.com/en/articles/creating-a-pull-request-from-a-fork>.

=end original

ここで新しいブランチから blead へのプルリクエスト (PR) を GitHub で
登録する必要があります。
更なる情報については、GitHub 文書
L<https://help.github.com/en/articles/creating-a-pull-request-from-a-fork> を
参照してください。

=begin original

You can also send patch files to
L<perl5-porters@perl.org|mailto:perl5-porters@perl.org> directly if the
patch is not ready to be applied, but intended for discussion.

=end original

パッチが適用できる準備ができておらず、議論を目的としたものなら、
L<perl5-porters@perl.org|mailto:perl5-porters@perl.org> に
直接パッチファイルを送ることもできます。

=begin original

To create a patch file for all your local changes:

=end original

全てのローカルな変更のためのパッチファイルを作るには:

  % git format-patch -M blead..
  0001-Rename-Leon-Brocard-to-Orange-Brocard.patch

=begin original

Or for a lot of changes, e.g. from a topic branch:

=end original

あるいは変更が多い場合、つまりトピックブランチからは:

  % git format-patch --stdout -M blead.. > topic-branch-changes.patch

=begin original

If you want to delete your temporary branch, you may do so with:

=end original

一時的なブランチを削除したいなら、以下のようにできます:

 % git checkout blead
 % git branch -d orange
 error: The branch 'orange' is not an ancestor of your current HEAD.
 If you are sure you want to delete it, run 'git branch -D orange'.
 % git branch -D orange
 Deleted branch orange.

=head2 A note on derived files

(派生ファイルに関する注意)

=begin original

Be aware that many files in the distribution are derivative--avoid
patching them, because git won't see the changes to them, and the build
process will overwrite them. Patch the originals instead. Most
utilities (like perldoc) are in this category, i.e. patch
F<utils/perldoc.PL> rather than F<utils/perldoc>. Similarly, don't
create patches for files under F<$src_root/ext> from their copies found
in F<$install_root/lib>. If you are unsure about the proper location of
a file that may have gotten copied while building the source
distribution, consult the F<MANIFEST>.

=end original

ディストリビューション内の多くのファイルは
派生的なものであることに注意してください -- 
それらのファイルにパッチを当てることは避けてください;
なぜなら、git はそれらに対する変更を見ることができず、
ビルドプロセスがそれらを上書きするからです。
代わりにオリジナルにパッチを当ててください。
ほとんどのユーティリティ(perldoc など)はこのカテゴリにあります;
すなわち、utils/perldoc ではなく F<utils/perldoc.PL> にパッチを当てます。
同様に、F<$install_root/lib> にあるコピーから F<$src_root/ext> 以下のファイルに
パッチを作成しないでください。
ソースディストリビューションのビルド中にコピーされた可能性のあるファイルの
適切な場所がわからない場合は、F<MANIFEST> を調べてください。

=head2 Cleaning a working directory

(作業ディレクトリを掃除する)

=begin original

The command C<git clean> can with varying arguments be used as a
replacement for C<make clean>.

=end original

C<git clean> コマンドはさまざまな引数で C<make clean> の代わりに
使うことができます。

=begin original

To reset your working directory to a pristine condition you can do:

=end original

作業ディレクトリを初期状態にリセットするには、次のようにします:

  % git clean -dxf

=begin original

However, be aware this will delete ALL untracked content. You can use

=end original

ただし、これによりすべての追跡されていないコンテンツが削除されます。
次のようにすると:

  % git clean -Xf

=begin original

to remove all ignored untracked files, such as build and test
byproduct, but leave any manually created files alone.

=end original

ビルドやテストの副産物など、すべての無視された
追跡されていないファイルを削除します;
ただし、手動で作成したファイルは残します。

=begin original

If you only want to cancel some uncommitted edits, you can use C<git
checkout> and give it a list of files to be reverted, or C<git checkout
-f> to revert them all.

=end original

コミットされていない編集だけをキャンセルしたい場合は、
C<git checkout> を使用して元に戻すファイルのリストを与えるか、
C<git checkout -f> を使用してすべてを元に戻すことができます。

=begin original

If you want to cancel one or several commits, you can use C<git reset>.

=end original

1つまたは複数のコミットをキャンセルしたい場合は、C<git reset> を
使うことができます。

=head2 Bisecting

(bisect)

=begin original

C<git> provides a built-in way to determine which commit should be blamed
for introducing a given bug. C<git bisect> performs a binary search of
history to locate the first failing commit. It is fast, powerful and
flexible, but requires some setup and to automate the process an auxiliary
shell script is needed.

=end original

C<git> は、指定されたバグが導入されたのがどのコミットに責任があるかを
決定する組み込みの手段を提供しています。
C<git bisect> は失敗する最初のコミットを特定するために
履歴の二分検索を行います。
これは高速で強力で柔軟性がありますが、多少の準備が必要で、
処理を自動化するには外部シェルスクリプトが必要です。

=begin original

The core provides a wrapper program, F<Porting/bisect.pl>, which attempts to
simplify as much as possible, making bisecting as simple as running a Perl
one-liner. For example, if you want to know when this became an error:

=end original

コアはラッパプログラムである F<Porting/bisect.pl> を提供しています;
これはできるだけ作業を単純化して、
Perl のワンライナーを実行するだけで bisect ができるようにします。
例えば、次のものがいつエラーになったかを知りたい場合:

    perl -e 'my $x := 2'

=begin original

you simply run this:

=end original

単純にこれを実行します:

    .../Porting/bisect.pl -e 'my $x := 2;'

=begin original

Using F<Porting/bisect.pl>, with one command (and no other files) it's easy to
find out

=end original

F<Porting/bisect.pl> を (他のファイルなしで) 一つのコマンドで使うことで、
次のものを簡単に見つけられます:

=over 4

=item *

=begin original

Which commit caused this example code to break?

=end original

どのコミットがこの例のコードを壊しているか

=item *

=begin original

Which commit caused this example code to start working?

=end original

どのコミットからこの例のコードが動作し始めているか

=item *

=begin original

Which commit added the first file to match this regex?

=end original

どのコミットが最初にこの正規表現にマッチングするファイルを追加したか

=item *

=begin original

Which commit removed the last file to match this regex?

=end original

どのコミットが最後にこの正規表現にマッチングするファイルを削除したか

=back

=begin original

usually without needing to know which versions of perl to use as start and
end revisions, as F<Porting/bisect.pl> automatically searches to find the
earliest stable version for which the test case passes. Run
C<Porting/bisect.pl --help> for the full documentation, including how to
set the C<Configure> and build time options.

=end original

通常はどのバージョンの perl を使うかの始点と終点のリビジョンを
知っている必要はありません; F<Porting/bisect.pl> は自動的に、
テストケースが通過する最初の安定版バージョンを探します。
C<Configure> とビルド時オプションを含む完全な文書を見るには
C<Porting/bisect.pl --help> を実行してください。

=begin original

If you require more flexibility than F<Porting/bisect.pl> has to offer, you'll
need to run C<git bisect> yourself. It's most useful to use C<git bisect run>
to automate the building and testing of perl revisions. For this you'll need
a shell script for C<git> to call to test a particular revision. An example
script is F<Porting/bisect-example.sh>, which you should copy B<outside> of
the repository, as the bisect process will reset the state to a clean checkout
as it runs. The instructions below assume that you copied it as F<~/run> and
then edited it as appropriate.

=end original

F<Porting/bisect.pl> が提供しているものよりもさらに柔軟性が必要な場合、
C<git bisect> を自分自身で実行する必要があります。
perl リビジョンのビルドとテストを自動化するために
C<git bisect run> を使うのが最も便利です。
このために、特定のリビジョンをテストするために呼び出すための
C<git> のためのシェルスクリプトが必要です。
例のスクリプトは F<Porting/bisect-example.sh> で、
これはリポジトリの B<外側> にコピーするべきです;
bisect 処理は、実行されるとクリーンなチェックアウトのために
状態をリセットするからです。
後述の説明は、スクリプトを F<~/run> としてコピーして、それを
適切に編集することを仮定しています。

=begin original

You first enter in bisect mode with:

=end original

まず bisect モードに入ります:

  % git bisect start

=begin original

For example, if the bug is present on C<HEAD> but wasn't in 5.10.0,
C<git> will learn about this when you enter:

=end original

例えば、バグが C<HEAD> にあっても 5.10.0 にはなかった場合、C<git> は
以下のように入力することでこれを学習します:

  % git bisect bad
  % git bisect good perl-5.10.0
  Bisecting: 853 revisions left to test after this

=begin original

This results in checking out the median commit between C<HEAD> and
C<perl-5.10.0>. You can then run the bisecting process with:

=end original

この結果、C<HEAD> と C<perl-5.10.0> の中間のコミットが
チェックアウトされます。
次のようにして bisect 処理を実行します:

  % git bisect run ~/run

=begin original

When the first bad commit is isolated, C<git bisect> will tell you so:

=end original

最初の不正なコミットが分離されると、C<git bisect> は次のように言います:

  ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 is first bad commit
  commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
  Author: Dave Mitchell <davem@fdisolutions.com>
  Date:   Sat Feb 9 14:56:23 2008 +0000

      [perl #49472] Attributes + Unknown Error
      ...

  bisect run success

=begin original

You can peek into the bisecting process with C<git bisect log> and
C<git bisect visualize>. C<git bisect reset> will get you out of bisect
mode.

=end original

C<git bisect log> と C<git bisect visualize> で bisect 処理を
覗き見ることができます。
C<git bisect reset>は bisect モードを解除します。

=begin original

Please note that the first C<good> state must be an ancestor of the
first C<bad> state. If you want to search for the commit that I<solved>
some bug, you have to negate your test case (i.e. exit with C<1> if OK
and C<0> if not) and still mark the lower bound as C<good> and the
upper as C<bad>. The "first bad commit" has then to be understood as
the "first commit where the bug is solved".

=end original

最初の C<good> 状態は、最初の C<bad> 状態の祖先である必要があることに
注意してください。
何らかのバグを I<解決した> コミットを検索したい場合は、テストケースを
反転させ、
(つまり、OK なら C<1> で終了し、そうでないなら C<0> で終了する)、
下限を C<good>、上限を C<bad> とマークする必要があります。
「最初の不正なコミット」は、「バグが解決された最初のコミット」と
解釈する必要があります。

=begin original

C<git help bisect> has much more information on how you can tweak your
binary searches.

=end original

C<git help bisect> には、二分探索を微調整する方法に関する情報が豊富に
用意されています。

=begin original

Following bisection you may wish to configure, build and test perl at
commits identified by the bisection process.  Sometimes, particularly
with older perls, C<make> may fail during this process.  In this case
you may be able to patch the source code at the older commit point.  To
do so, please follow the suggestions provided in
L<perlhack/Building perl at older commits>.

=end original

bisect の後、bisect 処理で識別されたコミットの時点で perl を設定、
ビルド、テストしたいと思うかもしれません。
時々、特に古い perl では、この処理中に C<make> が失敗することがあります。
この場合、古いコミットのポイントでソースコードにパッチを当てることが
できるかもしれません。
そうするためには、
L<perlhack/Building perl at older commits> で提供されている提案に
従ってください。

=head2 Topic branches and rewriting history

(トピックブランチと履歴の書き換え)

=begin original

Individual committers should create topic branches under
B<yourname>/B<some_descriptive_name>:

=end original

個々のコミッターは、B<yourname>/B<some_descriptive_name> 
の下にトピックブランチを作成する必要があります:

  % branch="$yourname/$some_descriptive_name"
  % git checkout -b $branch
  ... do local edits, commits etc ...
  % git push origin -u $branch

=begin original

Should you be stuck with an ancient version of git (prior to 1.7), then
C<git push> will not have the C<-u> switch, and you have to replace the
last step with the following sequence:

=end original

とても古いバージョン (1.7 より前) の git をまだ使っている場合、
C<git push> には C<-u> オプションがありません;
最後の手順を次のもので置き換える必要があります:

  % git push origin $branch:refs/heads/$branch
  % git config branch.$branch.remote origin
  % git config branch.$branch.merge refs/heads/$branch

=begin original

If you want to make changes to someone else's topic branch, you should
check with its creator before making any change to it.

=end original

他の人のトピックブランチを変更したい場合、変更する前に
その作成者に確認する必要があります。

=begin original

You
might sometimes find that the original author has edited the branch's
history. There are lots of good reasons for this. Sometimes, an author
might simply be rebasing the branch onto a newer source point.
Sometimes, an author might have found an error in an early commit which
they wanted to fix before merging the branch to blead.

=end original

元の作成者がブランチの履歴を編集したことに気付くことがあります。
これには多くの正当な理由があります。
場合によっては、単にブランチを新しいソースポイントに基づいて
作り直すことになることもあります。
場合によっては、ブランチを blead にマージする前に、
初期のコミットで修正したいエラーを見つけたこともあります。

=begin original

Currently the master repository is configured to forbid
non-fast-forward merges. This means that the branches within can not be
rebased and pushed as a single step.

=end original

現在、マスターリポジトリは、非 fast-forward のマージを禁止するように
構成されています。
これは、中のブランチはリベースとプッシュを単一ステップとしては
できないことを意味します。

=begin original

The only way you will ever be allowed to rebase or modify the history
of a pushed branch is to delete it and push it as a new branch under
the same name. Please think carefully about doing this. It may be
better to sequentially rename your branches so that it is easier for
others working with you to cherry-pick their local changes onto the new
version. (XXX: needs explanation).

=end original

プッシュされたブランチの履歴を再取得または変更する唯一の方法は、
そのブランチを削除し、同じ名前で新しいブランチとしてプッシュすることです。
これを行うことについては慎重に検討してください。
他のユーザーが新しいバージョンにローカルの変更を簡単に
チェリーピックできるように、
ブランチの名前を順番に変更した方がよい場合があります。
(XXX:説明が必要)。

=begin original

If you want to rebase a personal topic branch, you will have to delete
your existing topic branch and push as a new version of it. You can do
this via the following formula (see the explanation about C<refspec>'s
in the git push documentation for details) after you have rebased your
branch:

=end original

個人的なトピックブランチをリベースしたい場合は、
既存のトピックブランチを削除し、新しいバージョンとして
プッシュする必要があります。
これは、ブランチをリベースした後、次の公式
(詳細は git push 文書の C<refspec> に関する説明を参照)で行うことができます。

  # first rebase
  % git checkout $user/$topic
  % git fetch
  % git rebase origin/blead

  # then "delete-and-push"
  % git push origin :$user/$topic
  % git push origin $user/$topic

=begin original

B<NOTE:> it is forbidden at the repository level to delete any of the
"primary" branches. That is any branch matching
C<m!^(blead|maint|perl)!>. Any attempt to do so will result in git
producing an error like this:

=end original

B<注意:> リポジトリレベルで"プライマリ"ブランチを削除することは
禁止されています。
これは C<m!^(blead maint perl)!> にマッチングするブランチです。
削除しようとすると、gitは次のようなエラーを生成します:

  % git push origin :blead
  *** It is forbidden to delete blead/maint branches in this repository
  error: hooks/update exited with error code 1
  error: hook declined to update refs/heads/blead
  To ssh://perl5.git.perl.org/perl
   ! [remote rejected] blead (hook declined)
   error: failed to push some refs to 'ssh://perl5.git.perl.org/perl'

=begin original

As a matter of policy we do B<not> edit the history of the blead and
maint-* branches. If a typo (or worse) sneaks into a commit to blead or
maint-*, we'll fix it in another commit. The only types of updates
allowed on these branches are "fast-forwards", where all history is
preserved.

=end original

ポリシーとして、blead ブランチと maint-* ブランチの履歴は編集 B<しません>。
タイプミス(またはそれ以上)が blead または maint-* へのコミットに
忍び込んだ場合は、別のコミットで修正します。
これらのブランチで許可されている更新のタイプは "fast-forward" だけで、
すべての履歴が保存されます。

=begin original

Annotated tags in the canonical perl.git repository will never be
deleted or modified. Think long and hard about whether you want to push
a local tag to perl.git before doing so. (Pushing simple tags is
not allowed.)

=end original

標準的な perl.git リポジトリ内の注釈付きタグは、削除や
変更されることはありません。
ローカルタグを perl.git にプッシュする前に、じっくり考えてみてください。
(単純タグのプッシュは許可されていません。)

=head2 Grafts

(接ぎ木)

=begin original

The perl history contains one mistake which was not caught in the
conversion: a merge was recorded in the history between blead and
maint-5.10 where no merge actually occurred. Due to the nature of git,
this is now impossible to fix in the public repository. You can remove
this mis-merge locally by adding the following line to your
C<.git/info/grafts> file:

=end original

Perl履歴には、変換で検出されなかった誤りが一つ含まれています:
blead と maint-5.10 の間の履歴にマージが記録されましたが、
実際にはマージは発生しませんでした。
git の性質上、パブリックリポジトリで修正することは現在不可能です。
C<.git/info/graft> ファイルに次の行を追加することで、
この誤ったマージをローカルで削除できます。

 296f12bbbbaa06de9be9d09d3dcf8f4528898a49 434946e0cb7a32589ed92d18008aaa1d88515930

=begin original

It is particularly important to have this graft line if any bisecting
is done in the area of the "merge" in question.

=end original

問題の「マージ」領域で bisect が行われる場合、この graft 行を
指定することが特に重要です。

=head1 WRITE ACCESS TO THE GIT REPOSITORY

(git リポジトリへの書き込みアクセス)

=begin original

Once you have write access, you will need to modify the URL for the
origin remote to enable pushing. Edit F<.git/config> with the
git-config(1) command:

=end original

一旦書き込み権限を得たら、
プッシュを有効にするために origin remote のための URL を
変更する必要があります。
git-config(1) コマンドで F<.git/config> を次のように編集します:

  % git config remote.origin.url git@github.com:Perl/perl5.git

=begin original

You can also set up your user name and e-mail address. Most people do
this once globally in their F<~/.gitconfig> by doing something like:

=end original

ユーザー名と電子メールアドレスを設定することもできます。
ほとんどの人は、以下のようにすることで F<~/.gitconfig> でグローバルに
一度これを行います:

  % git config --global user.name "Ævar Arnfjörð Bjarmason"
  % git config --global user.email avarab@gmail.com

=begin original

However, if you'd like to override that just for perl,
execute something like the following in F<perl>:

=end original

しかし、perl だけに対してこれを変更したい場合は、
F<perl> で次のようなものを実行します:

  % git config user.email avar@cpan.org

=begin original

It is also possible to keep C<origin> as a git remote, and add a new
remote for ssh access:

=end original

C<origin> を git remote として維持し、ssh アクセス用の新しい remote を
追加することも可能です:

  % git remote add camel git@github.com:Perl/perl5.git

=begin original

This allows you to update your local repository by pulling from
C<origin>, which is faster and doesn't require you to authenticate, and
to push your changes back with the C<camel> remote:

=end original

これにより、C<origin> からプルしてローカルリポジトリを更新できます;
これはより高速で、認証を必要としません;
また、C<camel> リモートで変更をプッシュバックすることもできます。

  % git fetch camel
  % git push camel

=begin original

The C<fetch> command just updates the C<camel> refs, as the objects
themselves should have been fetched when pulling from C<origin>.

=end original

C<fetch> コマンドは単に C<camel> refs を更新するだけです;
なぜなら、オブジェクト自体は C<origin> からプルするときに
フェッチされるべきだからです。

=head2 Working with GitHub pull requests

(GitHub のプルリクエストで作業する)

=begin original

Pull requests typically originate from outside of the C<Perl/perl.git>
repository, so if you want to test or work with it locally a vanilla
C<git fetch> from the C<Perl/perl5.git> repository won't fetch it.

=end original

プルリクエストは典型的には C<Perl/perl.git> の外側から来るものなので、
それに関してテストや作業をしたいとき、
C<Perl/perl5.git> から普通に C<git fetch> しても、フェッチできません。

=begin original

However GitHub does provide a mechanism to fetch a pull request to a
local branch.  They are available on GitHub remotes under C<pull/>, so
you can use C<< git fetch pull/I<PRID>/head:I<localname> >> to make a
local copy.  eg.  to fetch pull request 9999 to the local branch
C<local-branch-name> run:

=end original

しかし、GitHub は全てのプルリクエストをローカルブランチにフェッチする
機能を提供しています。
これは GitHub のリモートの C<pull/> 以下で利用可能なので、
ローカルコピーを作るには
C<< git fetch pull/I<PRID>/head:I<localname> >> とします。
例えば、プルリクエスト 9999 をローカルブランチ
C<local-branch-name> にフェッチするには、次のものを実行し:

  git fetch origin pull/9999/head:local-branch-name

=begin original

and then:

=end original

そしてそれから:

  git checkout local-branch-name

=begin original

Note: this branch is not rebased on C<blead>, so instead of the
checkout above, you might want:

=end original

注意: このブランチは C<blead> にリベースしていないので、前述のように
チェックアウトする代わりに、次のようにした方がいいかもしれません:

  git rebase origin/blead local-branch-name

=begin original

which rebases C<local-branch-name> on C<blead>, and checks it out.

=end original

これで C<local-branch-name> を C<blead> にリベースします;
そしてこれをチェックアウトします。

=begin original

Alternatively you can configure the remote to fetch all pull requests
as remote-tracking branches.  To do this edit the remote in
F<.git/config>, for example if your GitHub remote is C<origin> you'd
have:

=end original

あるいは、全てのプルリクエストをリモート追跡ブランチとして
フェッチするようにリモートを設定することもできます。
これをするためには、F<.git/config> のリモートを編集します;
例えば、GitHub のリモートが C<origin> なら、次のようになっています:

  [remote "origin"]
          url = git@github.com:/Perl/perl5.git
          fetch = +refs/heads/*:refs/remotes/origin/*

=begin original

Add a line to map the remote pull request branches to remote-tracking
branches:

=end original

リモートのプルリクエストブランチをリモート追跡ブランチにマッピングするための
行を追加します:

  [remote "origin"]
          url = git@github.com:/Perl/perl5.git
          fetch = +refs/heads/*:refs/remotes/origin/*
          fetch = +refs/pull/*/head:refs/remotes/origin/pull/*

=begin original

and then do a fetch as normal:

=end original

そしてそれからいつも通りフェッチを行います:

  git fetch origin

=begin original

This will create a remote-tracking branch for every pull request, including
closed requests.

=end original

これは、閉じたリクエストを含む、全てのプルリクエストのための
リモート追跡ブランチを作ります。

=begin original

To remove those remote-tracking branches, remove the line added above
and prune:

=end original

リモート追跡ブランチを削除するには、先ほど追加した行を削除して、
prune します:

  git fetch -p origin # or git remote prune origin

=head2 Accepting a patch

(パッチを受け入れる)

=begin original

If you have received a patch file generated using the above section,
you should try out the patch.

=end original

前述の節でを使って生成されたパッチファイルを受け取った場合は、
パッチを試してみてください。

=begin original

First we need to create a temporary new branch for these changes and
switch into it:

=end original

まず、これらの変更のための一時的な新しいブランチを作成し、そのブランチに
切り替える必要があります:

 % git checkout -b experimental

=begin original

Patches that were formatted by C<git format-patch> are applied with
C<git am>:

=end original

C<git format-patch> でフォーマットされたパッチは、C<git am> で適用されます:

 % git am 0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
 Applying Rename Leon Brocard to Orange Brocard

=begin original

Note that some UNIX mail systems can mess with text attachments containing
'From '. This will fix them up:

=end original

一部の UNIX メールシステムは、添付テキストに 'From ' が含まれていると
おかしくなるかもしれないことに注意してください。
これは次のようにして修正します:

 % perl -pi -e's/^>From /From /' \
                        0001-Rename-Leon-Brocard-to-Orange-Brocard.patch

=begin original

If just a raw diff is provided, it is also possible use this two-step
process:

=end original

生の diff だけが提供されている場合は、次の 2 段階のプロセスを
使用することもできます:

 % git apply bugfix.diff
 % git commit -a -m "Some fixing" \
                            --author="That Guy <that.guy@internets.com>"

=begin original

Now we can inspect the change:

=end original

ここで変更を検査できます:

 % git show HEAD
 commit b1b3dab48344cff6de4087efca3dbd63548ab5e2
 Author: Leon Brocard <acme@astray.com>
 Date:   Fri Dec 19 17:02:59 2008 +0000

   Rename Leon Brocard to Orange Brocard

 diff --git a/AUTHORS b/AUTHORS
 index 293dd70..722c93e 100644
 --- a/AUTHORS
 +++ b/AUTHORS
 @@ -541,7 +541,7 @@ Lars Hecking                 <lhecking@nmrc.ucc.ie>
  Laszlo Molnar                  <laszlo.molnar@eth.ericsson.se>
  Leif Huhn                      <leif@hale.dkstat.com>
  Len Johnson                    <lenjay@ibm.net>
 -Leon Brocard                   <acme@astray.com>
 +Orange Brocard                 <acme@astray.com>
  Les Peters                     <lpeters@aol.net>
  Lesley Binks                   <lesley.binks@gmail.com>
  Lincoln D. Stein               <lstein@cshl.org>

=begin original

If you are a committer to Perl and you think the patch is good, you can
then merge it into blead then push it out to the main repository:

=end original

もしあなたが Perl のコミッタで、パッチが良いものだと思うなら、
それを blead にマージしてメインのリポジトリにプッシュすることができます:

  % git checkout blead
  % git merge experimental
  % git push origin blead

=begin original

If you want to delete your temporary branch, you may do so with:

=end original

一時的なブランチを削除したいなら、以下のようにできます:

 % git checkout blead
 % git branch -d experimental
 error: The branch 'experimental' is not an ancestor of your current
 HEAD.  If you are sure you want to delete it, run 'git branch -D
 experimental'.
 % git branch -D experimental
 Deleted branch experimental.

=begin original

If the subsequent I<push> fails then you must be careful on how you I<rebase>.
If you use

=end original

引き続く I<push> が失敗した場合、どのように I<rebase> するかに
気をつけなければなりません。
次のものを使ったり:

  % git rebase p5p/blead

=begin original

or

=end original

あるいは:

  % git pull --rebase

=begin original

then your carefully created merge commit will be lost! To avoid this you
can use:

=end original

とすると、慎重に作られたマージコミットが失われます!
これを避けるには、次のものが使えます:

  % git fetch p5p
  % git rebase --rebase-merges p5p/blead

=begin original

This will recreate your merge commit.

=end original

これはマージコミットを再作成します。

=begin original

(Should you be stuck with an older version of git (prior to 2.18), then
C<git rebase> will not have the C<--rebase-merges> switch, instead you
have to use the C<--preserve-merges> switch.)

=end original

(古い git (2.18 より前) を使い続けている場合、
C<git rebase> に C<--rebase-merges> オプションがありません;
代わりに C<--preserve-merges> オプションを使う必要があります。)

=head2 Committing to blead

(blead にコミットする)

=begin original

The 'blead' branch will become the next production release of Perl.

=end original

'blead' ブランチは、Perl の次の正式版リリースになります。

=begin original

Before pushing I<any> local change to blead, it's incredibly important
that you do a few things, lest other committers come after you with
pitchforks and torches:

=end original

I<何らかの> ローカルな変更をプッシュする前に、
あなたの後から来る他のコミッタが熊手と松明を持ってこないように、
いくつかのことをするのが極めて重要です:

=over

=item *

=begin original

Make sure you have a good commit message. See L<perlhack/Commit
message> for details.

=end original

よいコミットメッセージを書くようにしてください。
詳しくは L<perlhack/Commit message> を参照してください。

=item *

=begin original

Run the test suite. You might not think that one typo fix would break a
test file. You'd be wrong. Here's an example of where not running the
suite caused problems. A patch was submitted that added a couple of
tests to an existing F<.t>. It couldn't possibly affect anything else, so
no need to test beyond the single affected F<.t>, right?  But, the
submitter's email address had changed since the last of their
submissions, and this caused other tests to fail. Running the test
target given in the next item would have caught this problem.

=end original

テストスイートを実行します。
一つのタイプミス修正がテストファイルを壊すとは思わないかもしれません。
それは間違いです。
スイートを実行しないと問題が発生する例を次に示します。
既存の F<.t> にいくつかのテストを追加するパッチが提出されました。
他の何にも影響する可能性はないので、
影響を受けた一つの F<.t> 以上をテストする必要はありません; そうですね?
しかし、送信者のメールアドレスが前回の送信時から変更されていて、
このための他のテストが失敗するようになりました。
次の項目のテストターゲットを実行すると、この問題を捕まえられます。

=item *

=begin original

If you don't run the full test suite, at least C<make test_porting>.
This will run basic sanity checks. To see which sanity checks, have a
look in F<t/porting>.

=end original

完全なテストスイートを実行しない場合でも、
最低 C<make test_porting> は実行してください。
これは基本的な正気チェックを実行します。
どの正気チェックかを見るには、F<t/porting> を見てください。

=item *

=begin original

If you make any changes that affect miniperl or core routines that have
different code paths for miniperl, be sure to run C<make minitest>.
This will catch problems that even the full test suite will not catch
because it runs a subset of tests under miniperl rather than perl.

=end original

miniperl や miniperl のための異なるコードパスを持つコアルーチンに
影響する変更を行う場合、C<make minitest> をするようにしてください。
これは、perl ではなく miniperl でテストの一部を行うために完全な
テストスイートでは捕捉できない問題も捕捉します。 

=back

=head2 On merging and rebasing

(マージとリベース時)

=begin original

Simple, one-off commits pushed to the 'blead' branch should be simple
commits that apply cleanly.  In other words, you should make sure your
work is committed against the current position of blead, so that you can
push back to the master repository without merging.

=end original

'blead' ブランチにプッシュされた、単純な 1 回限りのコミットは、
クリーンに適用される単純なコミットであるべきです。
言い換えると、作業したものは blead の現在の位置に対して
コミットすることで、マージすることなく master に
プッシュできるようにするべきです。

=begin original

Sometimes, blead will move while you're building or testing your
changes.  When this happens, your push will be rejected with a message
like this:

=end original

あなたが変更したものをビルドしたりテストしたりしている間に、
時々 blead は動きます。
これが起きると、プッシュは次のようなメッセージで拒否されます:

 To ssh://perl5.git.perl.org/perl.git
  ! [rejected]        blead -> blead (non-fast-forward)
 error: failed to push some refs to 'ssh://perl5.git.perl.org/perl.git'
 To prevent you from losing history, non-fast-forward updates were
 rejected Merge the remote changes (e.g. 'git pull') before pushing
 again.  See the 'Note about fast-forwards' section of 'git push --help'
 for details.

=begin original

When this happens, you can just I<rebase> your work against the new
position of blead, like this (assuming your remote for the master
repository is "p5p"):

=end original

これが起きた場合、次のようにして、blead の新しい位置に対してあなたの作業を
単に I<リベース> します (master リポジトリに対するあなたのリモート名を
"p5p" と仮定します):

  % git fetch p5p
  % git rebase p5p/blead

=begin original

You will see your commits being re-applied, and you will then be able to
push safely.  More information about rebasing can be found in the
documentation for the git-rebase(1) command.

=end original

コミットが再適用され、安全にプッシュできるようになります。
リベースに関するさらなる情報は、git-rebase(1) コマンドの文書にあります。

=begin original

For larger sets of commits that only make sense together, or that would
benefit from a summary of the set's purpose, you should use a merge
commit.  You should perform your work on a L<topic branch|/Topic
branches and rewriting history>, which you should regularly rebase
against blead to ensure that your code is not broken by blead moving.
When you have finished your work, please perform a final rebase and
test.  Linear history is something that gets lost with every
commit on blead, but a final rebase makes the history linear
again, making it easier for future maintainers to see what has
happened.  Rebase as follows (assuming your work was on the
branch C<< committer/somework >>):

=end original

一緒にすることでのみ意味がある、または集合の目的の要約としての
価値があるような、より大きなコミットの集合に対しては、
マージコミットを使うべきです。
作業は L<トピックブランチ|/Topic
branches and rewriting history> で行うべきです;
そして、blead の移動によってあなたのコードが壊れていないことを
確認するために定期的に blead に対してリベースするべきです。
作業が終わったら、最後にリベースしてテストしてください。
線形の履歴は blead にコミットされる度に失われますが、
最後のリベースは再び履歴を線形にし、
将来の保守者が何が起きたのかを見るのをより容易にします。
次のようにしてリベースします (あなたの作業が
C<< committer/somework >> ブランチにあると仮定します):

  % git checkout committer/somework
  % git rebase blead

=begin original

Then you can merge it into master like this:

=end original

それから次のようにして master にマージできます:

  % git checkout blead
  % git merge --no-ff --no-commit committer/somework
  % git commit -a

=begin original

The switches above deserve explanation.  C<--no-ff> indicates that even
if all your work can be applied linearly against blead, a merge commit
should still be prepared.  This ensures that all your work will be shown
as a side branch, with all its commits merged into the mainstream blead
by the merge commit.

=end original

前述のスイッチは説明が必要でしょう。
C<--no-ff> は、たとえあなたの作業が blead に対して線形に適用可能でも、
マージコミットが準備されることを示します。
これによりあなたの作業は側道のブランチとして表示され、
そのコミットはマージコミットによってメインの blead に
マージされることになります。

=begin original

C<--no-commit> means that the merge commit will be I<prepared> but not
I<committed>.  The commit is then actually performed when you run the
next command, which will bring up your editor to describe the commit.
Without C<--no-commit>, the commit would be made with nearly no useful
message, which would greatly diminish the value of the merge commit as a
placeholder for the work's description.

=end original

C<--no-commit> は、マージコミットは I<準備> はされますが
I<コミット> はされないことを意味します。
コミットは実際には次のコマンドを実行して、
コミットの説明のためにエディタが起動した後に実行されます。
C<--no-commit> なしの場合、
有用なメッセージなしでコミットが行われます;
これは作業の説明のためのプレースホルダとしてマージコミットの価値を
大幅に減らしてしまいます。

=begin original

When describing the merge commit, explain the purpose of the branch, and
keep in mind that this description will probably be used by the
eventual release engineer when reviewing the next perldelta document.

=end original

マージコミットの説明を書くとき、
このブランチの目的を説明してください;
そしてこの説明はおそらく次の perldelta 文書をレビューするときに
最終的なリリースエンジニアによって使われるだろうということを
心に留めておいてください。

=head2 Committing to maintenance versions

(メンテナンスバージョンにコミットする)

=begin original

Maintenance versions should only be altered to add critical bug fixes,
see L<perlpolicy>.

=end original

メンテナンスバージョンは、重要なバグ修正を追加する場合にのみ変更してください;
L<perlpolicy> を参照してください。

=begin original

To commit to a maintenance version of perl, you need to create a local
tracking branch:

=end original

perl のメンテナンスバージョンにコミットするには、
ローカル追跡ブランチを作成する必要があります。

  % git checkout --track -b maint-5.005 origin/maint-5.005

=begin original

This creates a local branch named C<maint-5.005>, which tracks the
remote branch C<origin/maint-5.005>. Then you can pull, commit, merge
and push as before.

=end original

これにより、リモートブランチ C<origin/maint-5.005> を追跡する
C<maint-5.005> という名前のローカルブランチが作成されます。
次に、以前と同じようにプル、コミット、マージ、プッシュを行うことができます。

=begin original

You can also cherry-pick commits from blead and another branch, by
using the C<git cherry-pick> command. It is recommended to use the
B<-x> option to C<git cherry-pick> in order to record the SHA1 of the
original commit in the new commit message.

=end original

C<git cherry-pick> コマンドを使用して、blead と別のブランチから
コミットをチェリーピックすることもできます。
元のコミットの SHA1 を新しいコミットメッセージに記録するために、
C<git cherry-pick> に B<-x> オプションを使うことを勧めます。

=begin original

Before pushing any change to a maint version, make sure you've
satisfied the steps in L</Committing to blead> above.

=end original

maint 版に何かをプッシュする前に、前述の
L</Committing to blead> のステップを満たしていることを確認してください。

=head2 Using a smoke-me branch to test changes

(変更をテストするために smoke-me ブランチを使う)

=begin original

Sometimes a change affects code paths which you cannot test on the OSes
which are directly available to you and it would be wise to have users
on other OSes test the change before you commit it to blead.

=end original

時々、ある変更があなたが直接利用できない OS に関するテストできない
コードパスに影響することがあるので、
blead にコミットする前に他の OS のユーザーが変更をテストしてもらうのが
賢明です。

=begin original

Fortunately, there is a way to get your change smoke-tested on various
OSes: push it to a "smoke-me" branch and wait for certain automated
smoke-testers to report the results from their OSes.
A "smoke-me" branch is identified by the branch name: specifically, as
seen on github.com it must be a local branch whose first name
component is precisely C<smoke-me>.

=end original

幸い、様々な OS であなたの変更をスモークテストする方法があります:
これを "smoke-me" ブランチとしてプッシュして、いくつかの自動
smoke-testers が彼らの OS からの結果を報告するのを待ちます。
"smoke-me" ブランチはブランチ名によって識別されます:
特に、github.com で見られるように、名前の最初の部分が正確に
C<smoke-me> であるローカルブランチでなければなりません。

=begin original

The procedure for doing this is roughly as follows (using the example of
tonyc's smoke-me branch called win32stat):

=end original

これをするための手順は大まかに次のようなものです
(tonyc による win32stat と呼ばれる smoke-me ブランチの例を使います):

=begin original

First, make a local branch and switch to it:

=end original

まず、ローカルブランチを作ってそれに切り替えます:

  % git checkout -b win32stat

=begin original

Make some changes, build perl and test your changes, then commit them to
your local branch. Then push your local branch to a remote smoke-me
branch:

=end original

変更を行い、perl をビルドして変更をテストし、ローカルブランチに
コミットします。
それからローカルブランチをリモートの smoke-me ブランチにプッシュします:

  % git push origin win32stat:smoke-me/tonyc/win32stat

=begin original

Now you can switch back to blead locally:

=end original

ここでローカルの blead に戻します:

  % git checkout blead

=begin original

and continue working on other things while you wait a day or two,
keeping an eye on the results reported for your C<smoke-me> branch at
L<https://perl.develop-help.com/?b=smoke-me/tonyc/win32state>.

=end original

そして他の作業をして数日待ち、C<smoke-me> ブランチに対する報告される結果
L<https://perl.develop-help.com/?b=smoke-me/tonyc/win32state> を注視します。

=begin original

If all is well then update your blead branch:

=end original

全てがうまくいっていれば、手元の blead ブランチを更新します:

  % git pull

=begin original

then checkout your smoke-me branch once more and rebase it on blead:

=end original

それからもう一度手元の smoke-me ブランチをチェックアウトして、
それを blead にリベースします:

  % git rebase blead win32stat

=begin original

Now switch back to blead and merge your smoke-me branch into it:

=end original

ここで blead に戻して、smoke-me ブランチをマージします:

  % git checkout blead
  % git merge win32stat

=begin original

As described earlier, if there are many changes on your smoke-me branch
then you should prepare a merge commit in which to give an overview of
those changes by using the following command instead of the last
command above:

=end original

前述したように、smoke-me ブランチに多くの変更がある場合は、
前述の最後のコマンドの代わりに次のコマンドを使うことで、
これらの変更の概要を記録するためのマージコミットを準備するべきです:

  % git merge win32stat --no-ff --no-commit

=begin original

You should now build perl and test your (merged) changes one last time
(ideally run the whole test suite, but failing that at least run the
F<t/porting/*.t> tests) before pushing your changes as usual:

=end original

ここで perl をビルドして、いつものように変更をプッシュする前に、
あなたの(マージされた)変更を最後にもう一度テストするべきです
(理想的には、テストスイート全体を実行します; しかし、
少なくとも F<t/porting/*.t> テストを実行します) 。

  % git push origin blead

=begin original

Finally, you should then delete the remote smoke-me branch:

=end original

最後に、リモートの smoke-me ブランチを削除して:

  % git push origin :smoke-me/tonyc/win32stat

=begin original

(which is likely to produce a warning like this, which can be ignored:

=end original

(これはおそらく次のような警告を出しますが、無視できます:

 remote: fatal: ambiguous argument
                                  'refs/heads/smoke-me/tonyc/win32stat':
 unknown revision or path not in the working tree.
 remote: Use '--' to separate paths from revisions

=begin original

) and then delete your local branch:

=end original

) そしてローカルブランチを削除します:

  % git branch -d win32stat

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: completed

=end meta

