
=encoding utf8

=head1 NAME

=begin original

perllocale - Perl locale handling (internationalization and localization)

=end original

perllocale - Perl のロケール操作 (国際化と地域化)

=head1 DESCRIPTION

=begin original

In the beginning there was ASCII, the "American Standard Code for
Information Interchange", which works quite well for Americans with
their English alphabet and dollar-denominated currency (as long as they
don't need the cents C<E<162>> symbol, as it is not in ASCII)).  But it
doesn't work so well even for other English speakers, who may use
different currencies, such as the pound sterling C<E<163>> (as the
symbol for that currency is also not in ASCII); and it's hopelessly
inadequate for many of the thousands of the world's other languages.

=end original

まず最初に、ASCII、つまり "American Standard Code for
Information Interchange" がありました; これは、英語アルファベットと
ドル建て通貨を使うアメリカ人にとってはうまくいきました
(ASCII にないセント C<E<162>> 記号が不要であるなら)。
しかしこれは、ポンド貨 C<E<163>>(この通貨の記号も ASCII にはありません)
のような異なった通貨を使っているかもしれない
その他の英語話者に取ってすらあまりうまくいきませんでした;
そして世界中の何百ものその他の言語にとっては絶望的に無力でした。

=begin original

To address these deficiencies, the concept of locales was invented
(formally the ISO C, XPG4, POSIX 1.c "locale system").  These allow for
users to interface with their computer more according to their preferences.
Applications were and are being written that use the locale mechanism.
The process of making such an application take account of its users'
preferences in these kinds of matters is called B<internationalization>
(often abbreviated as B<i18n>); telling such an application about a
particular set of preferences is known as B<localization> (B<l10n>).

=end original

これらの欠陥に対処するために、ロケールという概念が考案されました
(正式には ISO C, XPG4, POSIX 1.c "locale system")。
これらは、ユーザーが好みに応じてコンピュータとよりよく
相互作用できるようにします。
アプリケーションはロケール機構を使って書かれ、そして
書かれようとしていました。
アプリケーションにそういったユーザーの選択を考慮させるためのプロセスは、
国際化(B<internationalization>)と呼ばれます(これはしばしば B<i18n> と
省略されます); アプリケーションを特定の選択の集合に対応させることは
地域化(B<localization>、B<l10n>)として知られています。

=begin original

Perl has been extended to support certain types of locales available in
the locale system.  This is controlled per application by using one
pragma, one function call, and several environment variables.

=end original

Perl はロケールシステムで利用可能なある種のロケールに対応するように
拡張されました。
これは一つのプラグマ、一つの関数呼び出し、いくつかの環境変数を使って、
アプリケーション毎に制御します。

=begin original

Perl supports single-byte locales that are supersets of ASCII, such as
the ISO 8859 ones, and one multi-byte-type locale, UTF-8 ones, described
in the next paragraph.  Perl doesn't support any other multi-byte
locales, such as the ones for East Asian languages.

=end original

Perl は ISO 8859 のような、ASCII のスーパーセットである
単一バイトロケールと、次の段落に記述されている UTF-8 の複数バイトロケールに
対応しています。
Perl は、東アジア言語用のようなその他の複数バイトロケールには
対応していません。

=begin original

Unfortunately, there are quite a few deficiencies with the design (and
often, the implementations) of locales.  Unicode was invented (see
L<perlunitut> for an introduction to that) in part to address these
design deficiencies, and nowadays, there is a series of "UTF-8
locales", based on Unicode.  These are locales whose character set is
Unicode, encoded in UTF-8.  Starting in v5.20, Perl fully supports
UTF-8 locales, except for sorting and string comparisons like C<lt> and
C<ge>.  Starting in v5.26, Perl can handle these reasonably as well,
depending on the platform's implementation.  However, for earlier
releases or for better control, use L<Unicode::Collate>.

=end original

残念ながら、ロケールにはかなりの数の設計上の(そしてしばしば実装上の)欠陥が
あります。
Unicode (これに関する紹介については L<perlunitut> を参照してください) は、
この設計上の欠陥に部分的に対処するために発明され、そして最近では、
Unicode を基とした一連の「UTF-8 ロケール」があります。
これらは文字集合は Unicode で、UTF-8 でエンコードされています。
v5.20 から、Perl は UTF-8 ロケールに完全に対応しています; ただしソートと
C<lt> や C<ge> のような文字列比較を除きます。
v5.26 から Perl はプラットフォームの実装に依存してこれらを
かなりうまく扱います。
しかし、より古いリリースやよりよい制御のためには、
L<Unicode::Collate> を使ってください。

=begin original

There are actually two slightly different types of UTF-8 locales: one
for Turkic languages and one for everything else.  Starting in Perl
v5.30, Perl detects UTF-8 Turkic locales by their behaviour, and
seamlessly handles both types; previously only the non-Turkic one was
supported.  The name of the locale is ignored; if your system has a
C<tr_TR.UTF-8> locale and it doesn't behave like a Turkic locale, perl
will treat it like a non-Turkic locale.

=end original

UTF-8 ロケールには少し異なる二つの型があります: 一つはトルコ語用で
もう一つはそれ以外全て用です。
Perl v5.30 から、Perl は振る舞いで UTF-8 トルコ語ロケールを検出し、
二つの型を継ぎ目なく扱います; 以前は
非トルコ語用のもののみを扱っていました。
ロケールの名前は無視されます:
システムに C<tr_TR.UTF-8> ロケールがあってそれがトルコ語ロケールのように
振る舞わない場合、perl はそれを非トルコ語のように扱います。

=begin original

Perl continues to support the old non UTF-8 locales as well.  There are
currently no UTF-8 locales for EBCDIC platforms.

=end original

Perl は古い非 UTF-8 ロケールも対応し続けています。
現在のところ EBCDIC プラットフォームのための UTF-8 ロケールはありません。

=begin original

The perl interpreter is a C language program.  At least stub locale
support is required by the C language specification.  So any instance of
perl automatically has this.  Later, the POSIX standard added more
capabilities beyond the ones required by C.  Perl supports these on the
platforms where they are available.  And Unicode supports a database of
more types of information than the basic locale systems have.  This
database is called C<CLDR>, the "Common Locale Data Repository",
L<http://cldr.unicode.org/>.  There are various CPAN modules that
provide access to this XML-encoded data, such as L<Locale::CLDR>,
L<CLDR::Number>, and L<DateTime::Format::CLDR>.

=end original

perl インタプリタは C 言語プログラムです。
C 言語の仕様では、少なくともスタブロケールの対応が必要です。
したがって、perl のインスタンスには自動的にこれを持ちます。
その後、POSIX 標準では、C で必要とされる機能以外にも
多くの機能が追加されました。
Perl は、これらの機能を利用可能なプラットフォームでは
対応しています。
また、Unicode は、基本的なロケールシステムよりも多くの種類の
情報のデータベースに対応しています。
このデータベースは、C<CLDR> 「共通ロケールデータリポジトリ」
(Common Locale Data Repository)  L<http://cldr.unicode.org/> と
呼ばれます。
L<Locale::CLDR>, L<CLDR::Number>,  L<DateTime::Format::CLDR> など、
この XM Lエンコードされたデータへのアクセスを提供するさまざまな
CPAN モジュールがあります。

=head1 WHAT IS A LOCALE

(ロケールって何?)

=begin original

A locale is a set of data that describes various aspects of how various
communities in the world categorize their world.  These categories are
broken down into the following types (some of which include a brief
note here):

=end original

ロケールとは、世界中の様々なコミュニティがその世界をどのように
カテゴリ化しているかについての様々な側面を記述したデータの集合です。
これらのカテゴリは以下の型に分解されます(一部は概略の説明もあります):

=over

=item Category C<LC_NUMERIC>: Numeric formatting

(カテゴリ C<LC_NUMERIC>: 数値フォーマット)

=begin original

This indicates how numbers should be formatted for human readability,
for example the character used as the decimal point.

=end original

これは人間に対する可読性のために数値をどのようにフォーマットするかを示します;
たとえば小数点として使われる文字です。

=item Category C<LC_MONETARY>: Formatting of monetary amounts

(カテゴリ C<LC_MONETARY>: 通貨量のフォーマット)

Z<>

=item Category C<LC_TIME>: Date/Time formatting

(カテゴリ C<LC_TIME>: 日付/時刻のフォーマット)

Z<>

=item Category C<LC_COLLATE>: Collation

(カテゴリ C<LC_COLLATE>: 照合)

=begin original

This indicates the ordering of letters for comparison and sorting.
In Latin alphabets, for example, "b", generally follows "a".

=end original

これは比較とソートのための文字の順序を示します。
例えば、ラテンアルファベットなら、"b" は一般的に "a" の次です。

=item Category C<LC_CTYPE>: Character Types

(カテゴリ C<LC_CTYPE>: 文字型)

=begin original

This indicates, for example if a character is an uppercase letter.

=end original

これは、例えば、文字が大文字かどうかを示します。

=item Category C<LC_MESSAGES>: Error and other messages

(カテゴリ C<LC_MESSAGES>: エラーとそのほかのメッセージ)

=begin original

This is a POSIX extension beyond the basic C language required
categories.  On Windows and other non-POSIX platforms, perl uses
workarounds to simulate it.

=end original

これは、基本的な C 言語が要求しているものを超えた POSIX 拡張です。
Windows とその他の非 POSIX プラットフォームでは、
これをシミュレートするための回避策を使います。

=item Category C<LC_TIME>: Date/Time formatting

Z<>

=item Category C<LC_ALL>

=begin original

This is not an actual category, but a convenience short-hand to refer to
all of the actual ones.

=end original

これは実際のカテゴリではありませんが、全ての実際のカテゴリを
参照するための便利な省略形です。

=item Other categories

(その他のカテゴリ)

=begin original

Some platforms have other categories, dealing with such things as
measurement units and paper sizes.  None of these are used directly by
Perl, but outside operations that Perl interacts with may use
these.  See L</Not within the scope of "use locale"> below.

=end original

一部のプラットフォームでは、長さの単位や紙のサイズといったものを扱う
その他のカテゴリを持っています。
これらはどれも Perl が直接使うことはありませんが、Perl が相互作用する
外側の操作ではこれらを使うかもしれません。
後述する L</Not within the scope of "use locale"> を
参照してください。

=back

=begin original

More details on the categories used by Perl are given below in L</LOCALE
CATEGORIES>.

=end original

Perl で使われるカテゴリに関するさらなる詳細については後述する
L</LOCALE CATEGORIES> を参照してください。

=begin original

Together, these categories go a long way towards being able to customize
a single program to run in many different locations.  And adding Unicode
CLDR goes further.  But there are deficiencies, so keep reading.

=end original

全体として、これらのカテゴリは単一のプログラムが複数の異なった場所で
実行するようにカスタマイズするために役立ちます。
そして Unicode の CLDR がさらに進めます。
しかし欠陥があるので、読み進めてください。

=head1 PREPARING TO USE LOCALES

(ロケールの使う前の準備)

=begin original

Perl itself (outside the L<POSIX> module) will not use locales unless
specifically requested to (but
again note that Perl may interact with code that does use them).  Even
if there is such a request, B<all> of the following must be true
for it to work properly:

=end original

(L<POSIX> モジュールの外側の)Perl 自身は、特に要求されない限りロケールを
使いません (しかし再び、Perl はこれらを使うコードと
相互作用するかもしれません)。
たとえそのような要求があっても、正しく動作するには
以下の B<すべて> が真になっていなければなりません:

=over 4

=item *

=begin original

B<Perl must believe that the locale system is supported>.  If it does,
C<perl -V:d_setlocale> will say that the value for C<d_setlocale> is
C<define>.

=end original

B<Perl が、ロケールシステムがサポートされていると信じていなければ
なりません>。
もしそうなっていれば、C<perl -V:d_setlocale> は
C<d_setlocale> の値が定義されているように報告するでしょう。

=item *

=begin original

B<Definitions for the locales that you use must be installed>.  All
platforms that perl runs on are required to support at least one locale,
named "C", which is essentially ASCII, and typical American preferences.

=end original

B<あなたの使うロケールの定義がインストールされていなければなりません>。
perl を実行する全てのプラットフォームは少なくとも "C" という
名前の一つのロケールに対応することが求められます;
これは基本的には ASCII で、典型的なアメリカ人の設定です。

=begin original

Most platforms allow for additional locales, but these must be
specifically installed.  You, or your system administrator, must make
sure that any locales you want are installed.  The available locales,
the location in which they are kept, and the manner in which they are
installed all vary from system to system.  Some systems provide only a
few, hard-wired locales and do not allow more to be added.  Others allow
you to add "canned" locales provided by the system supplier.  Still
others allow you or the system administrator to define and add arbitrary
locales.  (You may have to ask your supplier to provide canned locales
that are not delivered with your operating system.)  Read your system
documentation for further illumination.

=end original

ほとんどのプラットフォームは追加のロケールを許していますが、
これらは特にインストールされなければなりません。
あなた、もしくは管理者は必要なロケールがインストールされている
状態にしなければなりません。
使うことのできるロケール、それらが置かれている場所、インストールされる
規則といったものシステム毎に変わります。
一部のシステムでは、固定のほんの少しのロケールだけを提供し、ユーザーが
新たに追加することを許していません。
また、システムのサプライヤーが提供した「準備された」ロケールを
追加することができるシステムもあります。
さらに、ユーザーやシステム管理者が任意のロケールを定義して追加できる
システムもあります。
(あなたのサプライヤーに使っているオペレーティング
システムと一緒に渡されていない準備されたロケールを提供するよう
依頼する必要があるかもしれません。)
詳細はシステムのドキュメントを読んでください。

=back

=begin original

If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the S<C<use locale>> pragma (see L</The "use locale" pragma>) where
appropriate, and B<at least one> of the following must be true:

=end original

Perl アプリケーションをあなたの使うデータを特定のロケールで処理したり
するようにしたいのであれば、そのアプリケーションコードはプラグマ
S<C<use locale>> (L</The "use locale" pragma> 参照) を適切な場所に、
そして以下に挙げる項目の B<少なくとも一つ> が真でなければなりません。

=over 4

=item 1

=begin original

B<The locale-determining environment variables (see L</"ENVIRONMENT">)
must be correctly set up> at the time the application is started, either
by yourself or by whomever set up your system account; or

=end original

あなた自身でやるにしろ、あなたの使うシステムの管理者がするにしろ、
アプリケーションの実行開始時には B<ロケールを決定する環境変数
(L</"ENVIRONMENT"> を参照)が正しく設定されていなければなりません>; 
または

=item 2

=begin original

B<The application must set its own locale> using the method described in
L</The setlocale function>.

=end original

アプリケーションは、L</The setlocale function> に記述されている
メソッドを使う、B<自分用のロケールを設定しておかねばなりません>。

=back

=head1 USING LOCALES

(ロケールを使う)

=head2 The C<"use locale"> pragma

(C<"use locale"> プラグマ)

=begin original

By default, Perl itself (outside the L<POSIX> module)
ignores the current locale.  The S<C<use locale>>
pragma tells Perl to use the current locale for some operations.
Starting in v5.16, there are optional parameters to this pragma,
described below, which restrict which operations are affected by it.

=end original

デフォルトでは、(L<POSIX> モジュールの外側の) Perl 自身は現在のロケールを
無視します。
S<C<use locale>> プラグマは Perl に、幾つかの操作においてカレントのロケールを
使うよう指示します。
v5.16 から、これらのプラグマには後述するオプションの引数があり、
どの操作が影響を受けるかを制限します。

=begin original

Starting in Perl 5.28, this pragma may be used in
L<multi-threaded|threads> applications on systems that have thread-safe
locale ability.  Some caveats apply, see L</Multi-threaded> below.  On
systems without this capability, or in earlier Perls, do NOT use this
pragma in scripts that have multiple L<threads|threads> active.  The
locale in these cases is not local to a single thread.  Another thread
may change the locale at any time, which could cause at a minimum that a
given thread is operating in a locale it isn't expecting to be in.  On
some platforms, segfaults can also occur.  The locale change need not be
explicit; some operations cause perl itself to change the locale.  You
are vulnerable simply by having done a S<C<"use locale">>.

=end original

Perl 5.28 から、このプラグマは
スレッドセーフなロケールの能力を持つシステムでの
L<マルチスレッド|threads> アプリケーションで使われます。
いくつかの欠点があります; 後述する L</Multi-threaded> を参照してください。
この機能がないシステムや、より以前の Perl では、
このプラグマを、複数の L<スレッド|threads> が有効なスクリプトで
使わないでください。
このような場合、ロケールは単一のスレッドでローカルなものではありません。
他のスレッドは任意のタイミングでロケールを変更するかもしれず、
これは少なくとも想定しているものと異なるロケールでスレッドが
動作することになります。
一部のプラットフォームでは、セグメンテーションフォルトも起こります。
ロケールの変更は明示的に行われる必要はありません;
一部の操作は perl が自分自身でロケールを変更します。
単に S<C<"use locale">> とするだけで脆弱になります。

=begin original

The current locale is set at execution time by
L<setlocale()|/The setlocale function> described below.  If that function
hasn't yet been called in the course of the program's execution, the
current locale is that which was determined by the L</"ENVIRONMENT"> in
effect at the start of the program.
If there is no valid environment, the current locale is whatever the
system default has been set to.   On POSIX systems, it is likely, but
not necessarily, the "C" locale.  On Windows, the default is set via the
computer's S<C<Control Panel-E<gt>Regional and Language Options>> (or its
current equivalent).

=end original

現在のロケールは、後述する
L<setlocale()|/The setlocale function> 関数によって実行時に設定されます。
プログラム実行の過程でこの関数がまだ呼び出されていないとき、現在の
ロケールはプログラムの開始時に有効な L</"ENVIRONMENT"> によって
決定されます。
有効な環境がない場合、現在のロケールはシステムデフォルトとして
設定されたものとなります。
POSIX システムでは、これは、おそらく "C" ロケールになりますが、かならず
そうとは限りません。
Windows ではデフォルトはコンピュータの
S<C<コントロールパネル-E<gt>地域と言語>> (または現在の等価物)経由で
設定されます。

=begin original

The operations that are affected by locale are:

=end original

ロケールによって影響を受ける処理は:

=over 4

=item B<Not within the scope of C<"use locale">>

=begin original

Only certain operations (all originating outside Perl) should be
affected, as follows:

=end original

次のように、(全て Perl の外側を元とする) 一部の操作のみが影響を受けます:

=over 4

=item *

=begin original

The current locale is used when going outside of Perl with
operations like L<system()|perlfunc/system LIST> or
L<qxE<sol>E<sol>|perlop/qxE<sol>STRINGE<sol>>, if those operations are
locale-sensitive.

=end original

現在のロケールは、L<system()|perlfunc/system LIST> や
L<qxE<sol>E<sol>|perlop/qxE<sol>STRINGE<sol>> のような操作によって Perl の
外側に行く場合(その操作がロケールを認識する場合)に使われます。

=item *

=begin original

Also Perl gives access to various C library functions through the
L<POSIX> module.  Some of those functions are always affected by the
current locale.  For example, C<POSIX::strftime()> uses C<LC_TIME>;
C<POSIX::strtod()> uses C<LC_NUMERIC>; C<POSIX::strcoll()> and
C<POSIX::strxfrm()> use C<LC_COLLATE>.  All such functions
will behave according to the current underlying locale, even if that
locale isn't exposed to Perl space.

=end original

また、Perl は L<POSIX> モジュールを通して様々な C ライブラリ関数への
アクセスを提供します。
これらの関数の一部は常に現在のロケールの影響を受けます。
例えば、C<POSIX::strftime()> は C<LC_TIME> を使います;
C<POSIX::strtod()> は C<LC_NUMERIC> を使います;
C<POSIX::strcoll()> と C<POSIX::strxfrm()> は C<LC_COLLATE> を使います。
これら全ての関数は、例えロケールが Perl 空間に露出していなくても、
現在の基となるロケールに従って振る舞います。

=begin original

This applies as well to L<I18N::Langinfo>.

=end original

これは L<I18N::Langinfo> にも適用されます。

=item *

=begin original

XS modules for all categories but C<LC_NUMERIC> get the underlying
locale, and hence any C library functions they call will use that
underlying locale.  For more discussion, see
L<perlclib/Dealing with locales>.

=end original

C<LC_NUMERIC> 以外の全てのカテゴリに関する XS モジュールは基となる
ロケールを使うので、呼び出した C ライブラリ関数は基となるロケールを使います。
さらなる議論については L<perlclib/Dealing with locales> を
参照してください。

=back

=begin original

Note that all C programs (including the perl interpreter, which is
written in C) always have an underlying locale.  That locale is the "C"
locale unless changed by a call to L<setlocale()|/The setlocale
function>.  When Perl starts up, it changes the underlying locale to the
one which is indicated by the L</ENVIRONMENT>.  When using the L<POSIX>
module or writing XS code, it is important to keep in mind that the
underlying locale may be something other than "C", even if the program
hasn't explicitly changed it.

=end original

(C で書かれている perl インタプリタを含めて) 全ての C プログラムは
基となるロケールがあることに注意してください。
このロケールは、L<setlocale()|/setlocale 関数> の呼び出しによって
変更されない限り "C" ロケールです。
Perl の起動時、ロケールを L</ENVIRONMENT> で示されているロケールに変更します。
L<POSIX> モジュールを使ったり XS コードを書いたりするとき、
例えプログラムが明示的に変更しなくても基となるロケールが
"C" ではないかもしれないことに注意することは重要です。

Z<>

=item B<Lingering effects of C<S<use locale>>>

=begin original

Certain Perl operations that are set-up within the scope of a
C<use locale> retain that effect even outside the scope.
These include:

=end original

C<use locale> のスコープ内で設定される一部の Perl 操作は、
スコープの外側でも影響を受けたままになります。
これには以下のようなものがあります:

=over 4

=item *

=begin original

The output format of a L<write()|perlfunc/write> is determined by an
earlier format declaration (L<perlfunc/format>), so whether or not the
output is affected by locale is determined by if the C<format()> is
within the scope of a C<use locale>, not whether the C<write()>
is.

=end original

L<write()|perlfunc/write> の出力形式は、事前のフォーマット宣言
(L<perlfunc/format>) によって決定されるので、出力がロケールの影響を
受けるかどうかは、C<format()> は C<use locale> のスコープ内にあるかどうかで
決定され、C<write()> ではありません。

=item *

=begin original

Regular expression patterns can be compiled using
L<qrE<sol>E<sol>|perlop/qrE<sol>STRINGE<sol>msixpodualn> with actual
matching deferred to later.  Again, it is whether or not the compilation
was done within the scope of C<use locale> that determines the match
behavior, not if the matches are done within such a scope or not.

=end original

正規表現パターンは、
L<qrE<sol>E<sol>|perlop/qrE<sol>STRINGE<sol>msixpodualn> を使って、
実際のマッチングを後に遅らせてコンパイルすることが出来ます。
再び、コンパイルが C<use locale> のスコープ内で行われたかどうかが
マッチングの振る舞いを決定します; スコープ内でマッチングが
行われたかどうかではありません。

=back

Z<>

=item B<Under C<"use locale";>>

=over 4

=item *

=begin original

All the above operations

=end original

前述の操作全て

=item *

=begin original

B<Format declarations> (L<perlfunc/format>) and hence any subsequent
C<write()>s use C<LC_NUMERIC>.

=end original

B<フォーマット宣言> (L<perlfunc/format>) と引き続く C<write()> は
C<LC_NUMERIC> を使います。

=item *

=begin original

B<stringification and output> use C<LC_NUMERIC>.
These include the results of
C<print()>,
C<printf()>,
C<say()>,
and
C<sprintf()>.

=end original

B<文字列化と出力> は C<LC_NUMERIC> を使います。
これらには
C<print()>,
C<printf()>,
C<say()>,
C<sprintf()> の結果が含まれます。

=item *

=begin original

B<The comparison operators> (C<lt>, C<le>, C<cmp>, C<ge>, and C<gt>) use
C<LC_COLLATE>.  C<sort()> is also affected if used without an
explicit comparison function, because it uses C<cmp> by default.

=end original

B<比較演算子> (C<lt>, C<le>, C<cmp>, C<ge>, C<gt>) は C<LC_COLLATE> を
使用します。
C<sort()> は比較関数が陽に指定されなかった場合に影響を受けます; これは、
デフォルトでは C<cmp> を使うからです。

=begin original

B<Note:> C<eq> and C<ne> are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if C<cmp> finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns I<0> (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings--which C<eq> and C<cmp> may consider different--are equal
as far as collation in the locale is concerned, see the discussion in
L</Category C<LC_COLLATE>: Collation>.

=end original

B<注意:> C<eq> および C<ne> はロケールの影響を受けません: これらの関数は常に
文字毎の比較をそのスカラオペランドに対して実行します。
それに加えて、C<cmp>はそのオペランドがカレントのロケールで
指定される照合シーケンスで等しいものであった場合、さらに文字毎の
照合を行おうします; そして、オペランドの全部の文字が等しい場合にのみ
C<cmp> は I<0>(等しい)を返します。
C<eq> と C<cmp> が異なると判定する可能性のある二つの文字列がロケールを
考慮した照合で等しいかどうかを本当に知りたいのなら、
L</Category C<LC_COLLATE>: Collation> の記述を参照してください。

=item *

=begin original

B<Regular expressions and case-modification functions> (C<uc()>, C<lc()>,
C<ucfirst()>, and C<lcfirst()>) use C<LC_CTYPE>

=end original

B<正規表現と大小文字変換関数> (C<uc()>, C<lc()>, C<ucfirst()>,
C<lcfirst()>) は C<LC_CTYPE> を使用します。

=item *

=begin original

B<The variables L<C<$!>|perlvar/$ERRNO>> (and its synonyms C<$ERRNO> and
C<$OS_ERROR>) B<and> L<C<$^E>|perlvar/$EXTENDED_OS_ERROR>> (and its synonym
C<$EXTENDED_OS_ERROR>) when used as strings use C<LC_MESSAGES>  On
platforms that lack this category C<LC_CTYPE> is used instead.

=end original

B<変数 L<C<$!>|perlvar/$ERRNO>> (およびその同義語 C<$ERRNO> と C<$OS_ERROR>) と
L<C<$^E>|perlvar/$EXTENDED_OS_ERROR>> (およびその同義語 C<$EXTENDED_OS_ERROR>) は
文字列として使われると常に C<LC_MESSAGES> を使います。
このカテゴリがないプラットフォームでは、代わりに
C<LC_CTYPE> が使われます。

=back

=back

=begin original

The default behavior is restored with the S<C<no locale>> pragma, or
upon reaching the end of the block enclosing C<use locale>.
Note that C<use locale> calls may be
nested, and that what is in effect within an inner scope will revert to
the outer scope's rules at the end of the inner scope.

=end original

S<C<no locale>> に出会うか、(S<C<use locale>> を囲む)ブロックの終端に
達するとデフォルトの動作に戻ります。
C<use locale> はネストしているかもしれず、
内側のスコープで有効だったものが内側のスコープの終了によって外側のスコープの
規則に差し戻されることに注意してください。

=begin original

The string result of any operation that uses locale
information is tainted (if your perl supports taint checking),
as it is possible for a locale to be untrustworthy.
See L</"SECURITY">.

=end original

ロケール情報を使っている操作の結果である文字列は、
(perl が汚染チェックに対応している場合)
ロケールが信頼できない可能性があるかのように、
汚染されていることに注意してください。
L</"SECURITY"> を参照してください。

=begin original

Starting in Perl v5.16 in a very limited way, and more generally in
v5.22, you can restrict which category or categories are enabled by this
particular instance of the pragma by adding parameters to it.  (This
capability was to enable you to write code to work around deficiencies in
perl's locale handling, which have since been corrected, so it is
unlikely that new code will need to use it.)

=end original

Perl v5.16 からとても限定的な形で、そして v5.22 でより一般的に、
引数を指定することでこの特定のプラグマの実体によって有効になる
カテゴリを制限できます。
(この機能は、perl のロケール処理の欠陥を回避するためのコードを
書けるようにするためのものでしたが、その後修正されたため、
新しいコードで使用する必要はほとんどありません。)

=begin original

For example,

=end original

例えば:

 use locale qw(:ctype :numeric);

=begin original

enables locale awareness within its scope of only those operations
(listed above) that are affected by C<LC_CTYPE> and C<LC_NUMERIC>.

=end original

は、スコープ内の C<LC_CTYPE> と C<LC_NUMERIC> で影響を受ける(上述した)
演算子に対してだけロケールを有効にします。

=begin original

The possible categories are: C<:collate>, C<:ctype>, C<:messages>,
C<:monetary>, C<:numeric>, C<:time>, and the pseudo category
C<:characters> (described below).

=end original

指定できるカテゴリは: C<:collate>, C<:ctype>, C<:messages>,
C<:monetary>, C<:numeric>, C<:time> および疑似カテゴリ
C<:characters> (後述します) です。

=begin original

Thus you can say

=end original

従って次のように書くと:

 use locale ':messages';

=begin original

and only L<C<"$!">|perlvar/$ERRNO> and L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR>
will be locale aware.  Everything else is unaffected.

=end original

L<C<"$!">|perlvar/$ERRNO> と L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR> のみが
ロケールの影響を受けます。
それ以外全ては影響を受けません。

=begin original

Since Perl doesn't currently do anything with the C<LC_MONETARY>
category, specifying C<:monetary> does effectively nothing.  Some
systems have other categories, such as C<LC_PAPER>, but the perl core
doesn't do anything with them, and there is no way to specify
them in this pragma's arguments.

=end original

Perl は今のところ C<LC_MONETARY> カテゴリに対して何もしないので、
C<:monetary> を指定しても事実上何もしません。
システムによっては C<LC_PAPER> のようなその他のカテゴリを持ちますが、
perl コアはこれらについても何もせず、このプラグマの引数としてこれを指定する
方法はありません。

=begin original

You can also easily say to use all categories but one, by either, for
example,

=end original

例えば、次のどちらかのようにして、一つ以外の全てのカテゴリを使うように
簡単に指定できます;

 use locale ':!ctype';
 use locale ':not_ctype';

=begin original

both of which mean to enable locale awareness of all categories but
C<LC_CTYPE>.  Only one category argument may be specified in a
S<C<use locale>> if it is of the negated form.

=end original

この両方は、C<LC_CTYPE> 以外の全てのカテゴリでロケールを有効にします。
非定型式を使う場合に S<C<use locale>> で指定できる引数は一つだけです。

=begin original

Prior to v5.22 only one form of the pragma with arguments is available:

=end original

v5.22 より前は、引数付きのプラグマは次の一つだけが利用可能です:

 use locale ':not_characters';

=begin original

(and you have to say C<not_>; you can't use the bang C<!> form).  This
pseudo category is a shorthand for specifying both C<:collate> and
C<:ctype>.  Hence, in the negated form, it is nearly the same thing as
saying

=end original

(そして C<not_> と書かなければなりません; C<!> 型式は使えません)。
この疑似カテゴリは、C<:collate> と C<:ctype> の両方を指定することの
省略形です。
従って、否定型式では、次のものとほぼ同じです:

 use locale qw(:messages :monetary :numeric :time);

=begin original

We use the term "nearly", because C<:not_characters> also turns on
S<C<use feature 'unicode_strings'>> within its scope.  This form is
less useful in v5.20 and later, and is described fully in
L</Unicode and UTF-8>, but briefly, it tells Perl to not use the
character portions of the locale definition, that is the C<LC_CTYPE> and
C<LC_COLLATE> categories.  Instead it will use the native character set
(extended by Unicode).  When using this parameter, you are responsible
for getting the external character set translated into the
native/Unicode one (which it already will be if it is one of the
increasingly popular UTF-8 locales).  There are convenient ways of doing
this, as described in L</Unicode and UTF-8>.

=end original

ここでは「ほぼ」という言葉を使いました; なぜなら C<:not_characters> は
スコープ内の S<C<use feature 'unicode_strings'>> も有効にするからです。
この型式は v5.20 以降ではそれほど有用ではなくなりましたが、
(完全な記述は L</Unicode and UTF-8> に
ありますが)簡単に言うと、ロケール定義のうち文字に関する部分、つまり
C<LC_CTYPE> と C<LC_COLLATE> カテゴリを使わないように指示します。
代わりにこれは(Unicode によって拡張された)ネイティブな文字集合を使います。
この引数を使うとき、外部文字集合をネイティブ / Unicode のものに変換するのは
あなたの責任です(それが徐々に有名になっている UTF-8 ロケールならこれは
すでに行われています)。
L</Unicode and UTF-8> に記述されているように、これを行うための便利な方法が
あります。

=head2 The setlocale function

(setlocale 関数)

=begin original

WARNING!  Prior to Perl 5.28 or on a system that does not support
thread-safe locale operations, do NOT use this function in a
L<thread|threads>.  The locale will change in all other threads at the
same time, and should your thread get paused by the operating system,
and another started, that thread will not have the locale it is
expecting.  On some platforms, there can be a race leading to segfaults
if two threads call this function nearly simultaneously.  This warning
does not apply on unthreaded builds, or on perls where
C<${^SAFE_LOCALES}> exists and is non-zero; namely Perl 5.28 and later
unthreaded or compiled to be locale-thread-safe.  On z/OS systems, this
function becomes a no-op once any thread is started.  Thus, on that
system, you can set up the locale before creating any threads, and that
locale will be the one in effect for the entire program.

=end original

警告!
Perl 5.28 より前や、スレッドセーフロケール操作に対応していないシステムでは、
この関数を L<スレッド|threads> の中で使わないでください。
ロケールはその他全てのスレッドで同時に変更され、
スレッドがオペレーティングシステムによって停止され、再び開始すると、
スレッドは想定通りのロケールではなくなっています。
一部のプラットフォームでは、二つのスレッドがほぼ同時にこの関数を呼び出すと
競合によりセグメンテーションフォルトを起こします。
この警告は、スレッド非対応ビルドの場合や、
C<${^SAFE_LOCALES}> が存在して非 0 の perl の場合は適用されません;
つまり、Perl 5.28 以降で非スレッドやロケールスレッドセーフに
コンパイルされているもです。
z/OS システムでは、一旦スレッドが開始するとこの関数は何もしません。
従って、このシステムでは、スレッドを作る前にロケールを設定でき、
そのロケールはプログラム全体で有効です。

=begin original

Otherwise, you can switch locales as often as you wish at run time with
the C<POSIX::setlocale()> function:

=end original

あるいは、C<POSIX::setlocale()> 関数を使って、実行時に好きな回数だけ
ロケールを切り替えることができます。

        # Import locale-handling tool set from POSIX module.
        # This example uses: setlocale -- the function call
        #                    LC_CTYPE -- explained below
        # (Showing the testing for success/failure of operations is
        # omitted in these examples to avoid distracting from the main
        # point)

        use POSIX qw(locale_h);
        use locale;
        my $old_locale;

        # query and save the old locale
        $old_locale = setlocale(LC_CTYPE);

        setlocale(LC_CTYPE, "fr_CA.ISO8859-1");
        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859-1"

        setlocale(LC_CTYPE, "");
        # LC_CTYPE now reset to the default defined by the
        # LC_ALL/LC_CTYPE/LANG environment variables, or to the system
        # default.  See below for documentation.

        # restore the old locale
        setlocale(LC_CTYPE, $old_locale);

=begin original

The first argument of C<setlocale()> gives the B<category>, the second the
B<locale>.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
L</LOCALE CATEGORIES> and L</"ENVIRONMENT">.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.

=end original

C<setlocale()> の第一引数には B<カテゴリ> を、第二引数には
B<ロケール> を与えます。
カテゴリはロケール特有の規則を適用したいデータ処理の状況を指示します。
カテゴリ名は L</LOCALE CATEGORIES> と L</"ENVIRONMENT"> に記述されています。
ロケールはカスタマイズを行うための、特定の言語の組み合わせ、国や地域、
コードセットに関する情報の集合の名前です。
ヒントとしてロケールの名前付けに注目してください: すべてのシステムが
この例のようにロケールに名前を付けているわけではありません。

=begin original

If no second argument is provided and the category is something other
than C<LC_ALL>, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to C<setlocale()>, B<but> on some platforms the string
is opaque, not something that most people would be able to decipher as
to what locale it means.

=end original

第二引数が省略されていて、さらにカテゴリが C<LC_ALL> 以外の場合、この関数は
カテゴリに対するカレントロケールの名前からなる文字列を返します。
この値を、後で行う setlocale() の呼び出しでの第二引数として
使うこともできます B<が> 一部のプラットフォームでは文字列は不明瞭で、
ほとんどの人にとってどのロケールのことか解読できるようなものではありません。

=begin original

If no second argument is provided and the category is C<LC_ALL>, the
result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your L<setlocale(3)> man page for
details.

=end original

カテゴリが C<LC_ALL> で、第二引数が与えられなかった場合には
その結果は処理系に依存するものとなります。
ロケールの名前を連結したものか(セパレーターはこれまた処理系依存のもの)、
単一のロケール名となります。
詳しくは L<setlocale(3)> man ページをあたってください。

=begin original

If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to C<setlocale()>.  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument--think of it as an alias for the value you gave.)

=end original

第二引数が与えられていて、かつそれが正当なものであれば、カテゴリの
ロケールが設定され、この関数は現在のロケール値を返します。
この値は次の C<setlocale()> に呼び出しで使えます。
(一部の実装では、この返り値は第二引数を与えたときと異なる場合があります
-- これは与えた引数のエイリアスと考えられます。)

=begin original

As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.

=end original

例に示したように、第二引数が空文字列であった場合にはカテゴリの、
対応する環境変数によりデフォルト指定されるロケールが返されます。
一般的にはこの結果は、Perl が起動したときに強制的にデフォルトとして
設定された値です: アプリケーションが起動した後での環境変数の変更が
認識される/されないは、使用している C ライブラリに依存します。

=begin original

Note that when a form of C<use locale> that doesn't include all
categories is specified, Perl ignores the excluded categories.

=end original

全てのカテゴリが指定されていない型式の C<use locale> では、
Perl は除外されたカテゴリを無視することに注意してください。

=begin original

If C<setlocale()> fails for some reason (for example, an attempt to set
to a locale unknown to the system), the locale for the category is not
changed, and the function returns C<undef>.

=end original

何らかの理由 (例えばシステムが知らないロケールを設定しようとした) で
C<setlocale()> が失敗した場合、カテゴリに対するロケールは変更されず、関数は
C<undef> を返します。

=begin original

Starting in Perl 5.28, on multi-threaded perls compiled on systems that
implement POSIX 2008 thread-safe locale operations, this function
doesn't actually call the system C<setlocale>.  Instead those
thread-safe operations are used to emulate the C<setlocale> function,
but in a thread-safe manner.

=end original

Perl 5.28 から、POSIX 2008 スレッドセーフロケール操作を実装している
システムでコンパイルされたマルチスレッド perl では、
この関数は実際にはシステムの C<setlocale> を呼び出します。
これらのスレッドセーフ操作は C<setlocale> 関数をエミュレートするために
使われるのではなく、スレッドセーフの作法で行われます。

=begin original

You can force the thread-safe locale operations to always be used (if
available) by recompiling perl with

=end original

次のようにして、(利用可能なら)常にスレッドセーフのロケール操作を
使うように共生することができます

 -Accflags='-DUSE_THREAD_SAFE_LOCALE'

=begin original

added to your call to F<Configure>.

=end original

これを F<Configure> に追加します。

=begin original

For further information about the categories, consult L<setlocale(3)>.

=end original

カテゴリに対する詳細な情報は、L<setlocale(3)> を参照してください。

=head2 Multi-threaded operation

(マルチスレッドでの操作)

=begin original

Beginning in Perl 5.28, multi-threaded locale operation is supported on
systems that implement either the POSIX 2008 or Windows-specific
thread-safe locale operations.  Many modern systems, such as various
Unix variants do have this.  Others, such as most *BSD-derived variants,
including Darwin, claim to have it, but are buggy as of May 2024, so
Perl avoids their use.

=end original

Perl 5.28 から、POSIX 2008 または Windows 固有のどちらかのスレッドセーフ
ロケール操作を実装しているシステムでは、マルチスレッドロケール操作に
対応しています。
様々な Unix の亜種や Darwin のような多くのモダンなシステムは
これを持っています。
その他の、例えば Darwin を含むほとんどの *BSD 由来の亜種は、
これを持っていると主張していますが、2024 年 5 月時点でバグっぽいので、
Perl はこれらを使うことを避けます。

=begin original

You can tell if using locales is safe on your system by looking at the
read-only variable C<${^SAFE_LOCALES}>.  The value is 1 if the
perl is not threaded, or if it is using thread-safe locale operations.

=end original

読み込み専用の変数 C<${^SAFE_LOCALES}> を見ることによって、
あなたのシステムでロケールを使うことが安全か知ることができます。
perl がスレッド対応でないか、スレッドセーフロケール操作を使っているなら
値は 1 です。

=begin original

Thread-safe operations are supported in Windows starting in Visual Studio
2005, in cygwin, in MingW compiled to use UCRT (the Universal C Run Time
library), and in systems compatible with POSIX 2008.
C<${^SAFE_LOCALES}> will be 0 on threaded builds on platforms that Perl
knows to have buggy implementations.

=end original

スレッドセーフ操作は、Visual Studio 2005 以降の Windows、
cygwin、UCRT (the Universal C Run Time library) を使うようにコンパイルされた
MingW と、POSIX 2008 に互換性のあるシステムで対応しています。
バグっぽい実装であることを Perl が知っているプラットフォームでの
スレッド付きビルドでは、C<${^SAFE_LOCALES}> は 0 になります。

=begin original

Be aware that writing a multi-threaded application will not be portable
to a platform which lacks the native thread-safe locale support.  On
systems that do have it, you automatically get this behavior for
threaded perls, without having to do anything.  If for some reason, you
don't want to use this capability (perhaps the POSIX 2008 support turns
out to be buggy on your system), you can manually compile Perl to use
the old non-thread-safe implementation by passing the argument
C<-Accflags='-DNO_THREAD_SAFE_LOCALE'> to F<Configure>.  Except on
Windows, this will continue to use certain of the POSIX 2008 functions
in some situations.  If these are buggy, you can pass the following to
F<Configure> instead or additionally:
C<-Accflags='-DNO_POSIX_2008_LOCALE'>.  This will also keep the code
from using thread-safe locales.
C<${^SAFE_LOCALES}> will be 0 on systems that turn off the thread-safe
operations.

=end original

マルチスレッドアプリケーションを書くと、ネイティブなスレッドセーフ
ロケール対応がないプラットフォームへの移植性がなくなることに注意してください。
対応があるシステムでは、何もしなくても自動的にスレッド対応
perl のためのこの振る舞いを得ます。
もし何らかの (おそらくあなたのシステムの POSIX 2008 対応がバグっぽいという)
理由により、この機能を使いたくない場合、
F<Configure> に C<-Accflags='-DNO_THREAD_SAFE_LOCALE'> を渡すことで
古い非スレッドセーフ実装を使った Perl を手動でコンパイル出来ます。
Windows 以外では、これは一部の状況で一部の POSIX 2008 関数を
使い続けます。
もしそれらがバグっぽいなら、
F<Configure> に次の設定を追加または修正します:
C<-Accflags='-DNO_POSIX_2008_LOCALE'>。
これはまた、コードがスレッドセーフなロケールを使い続けるようにします。
スレッドセーフ操作がオフになっているシステムでは C<${^SAFE_LOCALES}> は
0 です。

=begin original

Normally on unthreaded builds, Perl uses the traditional C<setlocale()> 
to change the locale, and not the alternate POSIX 2008 thread-safe
locale-changing functions.  You can force the use of these on systems
that have them by adding the C<-Accflags='-DUSE_THREAD_SAFE_LOCALE'> to
F<Configure>.

=end original

通常、非スレッドビルドでは、Perl はロケールを変更するのに POSIX 2008 の
スレッドセーフなロケール変更関数ではなく、
伝統的な C<setlocale()> を使います。
F<Configure> に C<-Accflags='-DUSE_THREAD_SAFE_LOCALE'> を追加することで、
スレッドセーフ関数を持つシステムではそれらの使用を強制できます。

=begin original

The initial program is started up using the locale specified from the
environment, as currently, described in L</ENVIRONMENT>.   All newly
created threads start with C<LC_ALL> set to C<"C">.  Each thread may
use C<POSIX::setlocale()> to query or switch its locale at any time,
without affecting any other thread.  All locale-dependent operations
automatically use their thread's locale.

=end original

初期プログラムは、現在 L</ENVIRONMENT> に記述されているように、
環境から指定されたロケールを使って起動します。
全ての新しく作られたスレッドは C<LC_ALL> に C<"C"> を設定して開始します。
それぞれのスレッドは、他のスレッドに影響を与えることなく
いつでもロケールを問い合わせたり切り替えたりするために
C<POSIX::setlocale()> を使えます。
全てのロケール依存操作は自動的にそれぞれのスレッドのロケールを使います。

=begin original

This should be completely transparent to any applications written
entirely in Perl (minus a few rarely encountered caveats given in the
L</Multi-threaded> section).  Information for XS module writers is given
in L<perlclib/Dealing with locales>.

=end original

これは完全に Perl で書かれている全てのアプリケーションで
完全に等価であるはずです (L</Multi-threaded> 節にある、
いくつかの稀に遭遇する問題の場合を除きます)。
XS モジュール作者への情報は L<perlclib/Dealing with locales> にあります。

=head2 Finding locales

(ロケールを見つける)

=begin original

For locales available in your system, consult also L<setlocale(3)> to
see whether it leads to the list of available locales (search for the
I<SEE ALSO> section).  If that fails, try the following command lines:

=end original

ロケールが使えるシステムであれば、使用可能なロケールがどういったもので
あるかどうかを L<setlocale(3)> で調べてみてください
(I<SEE ALSO> の章を探してください)。
それがダメだったら、以下のコマンドを試してみてください。

        locale -a

        nlsinfo

        ls /usr/lib/nls/loc

        ls /usr/lib/locale

        ls /usr/lib/nls

	ls /usr/share/locale

=begin original

and see whether they list something resembling these

=end original

そして、そこに以下に挙げたものと似たものがあるかどうかを
確かめてください。

        en_US.ISO8859-1     de_DE.ISO8859-1     ru_RU.ISO8859-5
        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
        en_US               de_DE               ru_RU
        en                  de                  ru
        english             german              russian
        english.iso88591    german.iso88591     russian.iso88595
        english.roman8                          russian.koi8r

=begin original

Sadly, even though the calling interface for C<setlocale()> has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
I<language[_territory[.codeset]][@modifier]>.
The I<language> and I<country>
are usually from the standards B<ISO 3166> and B<ISO 639>, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The I<codeset> part often mentions some B<ISO
8859> character set, the Latin codesets.  For example, C<ISO 8859-1>
is the so-called "Western European codeset" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.
I<modifier> is very individualized to the rest of the locale, naming
some variant, such as a different currency symbol than the locale would
normally contain.

=end original

残念ながら、C<setlocale()> を呼び出すインターフェースが既に
標準化されているのにも関らず、ロケールの名前や、それが設定される
ディレクトリはまだなのです。
名前の基本形式は I<language[_territory[.codeset]][@modifier]> です。
I<language> と I<country> は通常は B<ISO 3166> や B<ISO 639> という
標準による、言語や国を二文字に略したものになります。
I<codeset> の部分はしばしば文字集合 B<ISO 8859> の
バリエーションとなります。
たとえば、"Western codeset" と呼ばれる C<ISO 8859-1> は西欧における
エンコーディングとして用いることができます。
繰り返しますが、一つの標準の名前であってさえ、記述するには複数の方法が
存在するのです。
嘆かわしいことです。
I<modifier> はロケールの残りの部分に対してとても個別化していて、
ロケールが普通含んでいるものと異なる通貨記号のような
バリエーションに名前を付けます。

=begin original

Two special locales are worth particular mention: "C" and "POSIX".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the POSIX standard.  They define the B<default locale> in which
every program starts in the absence of locale information in its
environment.  (The I<default> default locale, if you will.)  Its language
is (American) English and its character codeset ASCII or, rarely, a
superset thereof (such as the "DEC Multinational Character Set
(DEC-MCS)").  B<Warning>. The C locale delivered by some vendors
may not actually exactly match what the C standard calls for.  So
beware.

=end original

"C" と "POSIX" という二つの特殊なロケールがあります。
現時点では、これら二つは同じロケールとなります。
その違いは主に、前者が C の標準により決められたものであるのに対して、
後者が POSIX の標準で決められているものであるという点にあります。
これらの規格が決めていることは、環境変数にあるロケール情報がない状態での
プログラム起動時の B<デフォルトのロケール> です
(I<デフォルトの> デフォルトロケールです)。
その言語は (アメリカ)英語であり、その文字集合は ASCII か、稀に
("DEC Multinational Character Set (DEC-MCS)" のような)その上位集合になります。
B<警告>。
一部のベンダによって提供されている C ロケールは実際には C 標準が要求している
ものに正確に一致していないかもしれません。
注意してください。

=begin original

B<NOTE>: Not all systems have the "POSIX" locale (not all systems are
POSIX-conformant), so use "C" when you need explicitly to specify this
default locale.

=end original

B<注意>:すべてのシステムが "POSIX" ロケールを持っているわけでは
ありません(すべてのシステムが POSIX に準拠しているわけではありません)ので、
明示的にこのデフォルトロケールを指定するのが必要なときには
"C" を使います。

=head2 LOCALE PROBLEMS

(ロケールの問題)

=begin original

You may encounter the following warning message at Perl startup:

=end original

Perl を実行したときに以下のようなメッセージを見たことがあるかもしれません:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

=begin original

This means that your locale settings had C<LC_ALL> set to "En_US" and
LANG exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the "C" locale, the default locale
that is supposed to work no matter what.  (On Windows, it first tries
falling back to the system default locale.)  This usually means your
locale settings were wrong, they mention locales your system has never
heard of, or the locale installation in your system has problems (for
example, some system files are broken or missing).  There are quick and
temporary fixes to these problems, as well as more thorough and lasting
fixes.

=end original

これは、あなたのロケールの設定が、C<LC_ALL> が "En_US" であり LANG が
存在しているが値を持っていないということを意味します。
Perlはあなたを信じようとしたのですができなかったのです。
その代わりに、Perl はロケール設定をあきらめて、デフォルトである
"C" ロケールに戻ったのです。
(Windows では、まずシステムのデフォルトロケールにフォールバックすることを
試みます。)
これは通常はあなたのロケール設定が間違っているせいであり、聞いたことのない
ロケールであったり、あるいはあなたのインストールに問題があったのだろう
(例えば、一部のシステムファイルが壊れていたとか、なかったとか)と
いうことです。
以下で述べるのは、この問題を手っ取り早く一時的に修復するものです。

=head3 Testing for broken locales

(壊れたロケールのテスト)

=begin original

If you are building Perl from source, the Perl test suite file
F<lib/locale.t> can be used to test the locales on your system.
Setting the environment variable C<PERL_DEBUG_FULL_TEST> to 1
will cause it to output detailed results.  For example, on Linux, you
could say

=end original

Perl をソースからビルドする場合、Perl テストスイートファイル
F<lib/locale.t> がシステムのロケールのテストに使われます。
環境変数 C<PERL_DEBUG_FULL_TEST> を 1 に設定すると、詳細な結果を出力します。
例えば、Linux では、以下のようにします:

 PERL_DEBUG_FULL_TEST=1 ./perl -T -Ilib lib/locale.t > locale.log 2>&1

=begin original

Besides many other tests, it will test every locale it finds on your
system to see if they conform to the POSIX standard.  If any have
errors, it will include a summary near the end of the output of which
locales passed all its tests, and which failed, and why.

=end original

その他の多くのテストに加えて、システムで発見された全てのロケールについて
POSIX 標準に従っているかどうかをテストします。
エラーがあった場合、どのロケールが全てのテストに成功したかの出力の末尾辺りに、
どのテストがなぜ失敗したかの概要が含まれます。

=head3 Temporarily fixing locale problems

(一時的にロケールの問題を修正する)

=begin original

The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale "C".

=end original

二つの(一時的な)対応策とは、ロケールに関する矛盾を無視するように
するというものと、Perl をデフォルトロケール "C" で実行するというものです。

=begin original

Perl's moaning about locale problems can be silenced by setting the
environment variable C<PERL_BADLANG> to "0" or "".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.

=end original

Perl 起動時の問題は、環境変数 C<PERL_BADLANG> に "0" または "" を
設定することによって回避できます。
この方法は問題をカーペットの下に押し込むだけのことです:
つまり、Perl が何か間違ったことを見つけたとしても Perl を
黙らせておくというものです。
もし後でロケールに依存した変な振る舞いがあったとしても
驚かないでください。

=begin original

Perl can be run under the "C" locale by setting the environment
variable C<LC_ALL> to "C".  This method is perhaps a bit more civilized
than the C<PERL_BADLANG> approach, but setting C<LC_ALL> (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See L</"ENVIRONMENT"> for
the full list of relevant environment variables and L</"USING LOCALES">
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable C<LC_COLLATE> may well affect
your B<sort> program (or whatever the program that arranges "records"
alphabetically in your system is called).

=end original

環境変数 C<LC_ALL> に "C" を設定することにより、Perl はロケール "C" の下でも
実行することができます。
このやり方は C<PERL_BADLANG> よりは多少まともなものですが、それでも
C<LC_ALL> (もしくは他のロケール変数)を設定するということは Perl 以外の
プログラムにも影響を及ぼします。
特に、Perl の内側で実行される外部プログラムはこの変更に影響を
受けることになります。
新しい設定を恒久的なものにしたいというのであれば、あなたが実行する
プログラム全てがこの変更に影響を受けることになります。
関係する環境変数の完全なリストは L</"ENVIRONMENT"> を参照してください;
また、Perl におけるそれらの効果については L</"USING LOCALES"> を
参照してください。
他のプログラムに対する影響は簡単に避けられます。
たとえば、変数 C<LC_COLLATE> はあなたの B<sort> プログラム
(もしくは「レコード」をアルファベット順に並べ替えるプログラム)に
影響を及ぼします。

=begin original

You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For
Bourne-like shells (B<sh>, B<ksh>, B<bash>, B<zsh>):

=end original

これらの変数に対する変更を一時的に行ってテストすることができます; そして
新しい設定が助けになるものであればその設定をシェルのスタートアップ
ファイルに追加するのです。
詳細はあなたの使っているシステムのドキュメントを調べてみてください。
Bourne シェルに似たシェル(B<sh>, B<ksh>, B<bash>, B<zsh>)であれば
以下のようになります:

	LC_ALL=en_US.ISO8859-1
	export LC_ALL

=begin original

This assumes that we saw the locale "en_US.ISO8859-1" using the commands
discussed above.  We decided to try that instead of the above faulty
locale "En_US".

=end original

これは、先に議論したコマンドを使って、ロケールを "en_US.ISO8859-1" が
見られることを仮定します。
私たちは、前述の誤ったロケール "En-US" から変更しようと決めました。

=begin original

And in Csh-ish shells (B<csh>, B<tcsh>)

=end original

そして C シェル風なもの(B<csh>, B<tcsh>)の場合では:

	setenv LC_ALL en_US.ISO8859-1

=begin original

or if you have the "env" application you can do (in any shell)

=end original

あるいは、"env" プログラムがあるなら (どのようなシェルでも) 以下のように
書けます:

	env LC_ALL=en_US.ISO8859-1 perl ...

=begin original

If you do not know what shell you have, consult your local
helpdesk or the equivalent.

=end original

あなたがシェルについて良く知らないというのであれば、
あなたのおそばのヘルプデスク等に訊ねてみてください。

=head3 Permanently fixing locale problems

(ロケールの問題を恒久的に修正する)

=begin original

The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your system administrator.

=end original

時間はかかるけれども優れた修正方法は、あなたの環境の間違っている部分を
正しくするというものです。
システム全体での間違いはあなたの使っているシステムの管理者の
助けを必要とするでしょう。

=begin original

First, see earlier in this document about L</Finding locales>.  That tells
how to find which locales are really supported--and more importantly,
installed--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
LC_ALL set to "En_US" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.

=end original

まず最初にこのドキュメントの L</Finding locales> を参照してください。
そこにはあなたの使うシステムで実際にサポートされているロケール、
そしてもっと重要なインストールされているロケールを見つけだす方法が
解説されています。
私たちが使ったエラーメッセージの例では、環境変数は重要度の高いものから
低いものへという順になっています。
したがって、LC_ALL を "En_US" に設定することは良くない選択であり、
これはエラーメッセージにも現れています。
まず最初にリストの最初にあるロケール設定を修正します。

=begin original

Second, if using the listed commands you see something B<exactly>
(prefix matches do not count and case usually counts) like "En_US"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see L</Permanently fixing your system's locale configuration>.

=end original

次に、もしあなたがリストアップのコマンドを使って得たものが
B<正確に> "En_US" のようなもの(接頭辞の一致は考慮せず、大小文字の違いは
考慮します)であれば、あなたが使っているロケール名に対応するものが
システムに正しくインストールされていれば OK です。
この場合、L</Permanently fixing your system's locale configuration> を
参照してください。

=head3 Permanently fixing your system's locale configuration

(あなたのシステムのロケール設定を恒久的に修正する)

=begin original

This is when you see something like:

=end original

これは以下のようなメッセージが出たけれども:

	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.

=begin original

but then cannot see that "En_US" listed by the above-mentioned
commands.  You may see things like "en_US.ISO8859-1", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
L</Finding locales> about general rules.

=end original

"En_US" が先に挙げたコマンドによってリスト中になかった場合です。
"en_US.ISO8859-1" のようなものを見たかも知れませんが、まったく
同一のものではなかったのでしょう。
この場合、コマンドで挙げられたもの一致するロケールで
実行してみてください。
ロケール名のマッチングルールは少々はっきりしないものです; それは、この分野に
関する標準が弱いものであるからです。
一般的なルールについては L</Finding locales> をもう一度見てください。

=head3 Fixing system locale configuration

(システムのロケール設定を修正する)

=begin original

Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The L</Finding locales>
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.

=end original

システム管理者にコンタクトをとって、あなたの得たエラーメッセージそのままを
レポートして、今ここまで読んできたことを説明してください。
システム管理者はシステムのロケール設定についてどこがどう間違っているかを
理解できるはずです。
標準化がなされていないので、コマンド名などに関して L</Finding locales> の
章は残念ながら少々あやふやなものになっています。

=head2 The localeconv function

(localeconv 関数)

=begin original

The C<POSIX::localeconv()> function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
underlying C<LC_NUMERIC> and C<LC_MONETARY> locales (regardless of
whether called from within the scope of C<S<use locale>> or not).  (If
you just want the name of
the current locale for a particular category, use C<POSIX::setlocale()>
with a single parameter--see L</The setlocale function>.)

=end original

C<POSIX::localeconv()> 関数は、
(C<S<use locale>> のスコープ内で呼び出されるかどうかに関わらず)
カレントの基となる C<LC_NUMERIC> や
C<LC_MONETARY> で指定されるロケール依存の数値書式の情報を取り出します。
(ある特定のカテゴリのカレントロケールを知りたいだけなのなら、
C<POSIX::setlocale()> を引数一つで使います--L</The setlocale function> を
参照してください。)

        use POSIX qw(locale_h);

        # Get a reference to a hash of locale-dependent info
        $locale_values = localeconv();

        # Output sorted list of the values
        for (sort keys %$locale_values) {
            printf "%-20s = %s\n", $_, $locale_values->{$_}
        }

=begin original

C<localeconv()> takes no arguments, and returns B<a reference to> a hash.
The keys of this hash are variable names for formatting, such as
C<decimal_point> and C<thousands_sep>.  The values are the
corresponding, er, values.  See L<POSIX/localeconv> for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit C<use locale>, because C<localeconv()> always observes the
current locale.

=end original

C<localeconv()> は引数を取らず、戻り値としてハッシュに対する
B<リファレンス> を返します。
このハッシュのキーは C<decimal_point> や C<thousands_sep> のように
整形された変数名です。
格納されている値はそのキーに対応する値です。
ある実装が提供しているであろうすべてのカテゴリをリストアップしている
長いサンプルは L<POSIX/localeconv> を参照してください;
しかしながら、一部のものが多かったり少なかったするかもしれません。
ロケールを問い合わせるジョブの関数のように C<use locale> する必要が
ないことに注意してください; C<localeconv()> は常にカレントのロケールを
監視しています。

=begin original

Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:

=end original

以下の例は、コマンドラインで渡されたパラメーターをカレントのロケールにおける
正しい書式に書きなおすというものです。

    use POSIX qw(locale_h);

    # Get some of locale's numeric formatting parameters
    my ($thousands_sep, $grouping) =
            @{localeconv()}{'thousands_sep', 'grouping'};

    # Apply defaults if values are missing
    $thousands_sep = ',' unless $thousands_sep;

=begin original

    # grouping and mon_grouping are packed lists
    # of small integers (characters) telling the
    # grouping (thousand_seps and mon_thousand_seps
    # being the group dividers) of numbers and
    # monetary quantities.  The integers' meanings:
    # 255 means no more grouping, 0 means repeat
    # the previous grouping, 1-254 means use that
    # as the current grouping.  Grouping goes from
    # right to left (low to high digits).  In the
    # below we cheat slightly by never using anything
    # else than the first grouping (whatever that is).
    if ($grouping) {
        @grouping = unpack("C*", $grouping);
    } else {
        @grouping = (3);
    }

=end original

    # grouping と mon_grouping は小整数のパック済みリストになって
    # います; これはgrouping (thousand_seps と mon_thousand_seps
    # はグループを分けるものです)の数と金銭に関するものの指定を
    # 行っています。その整数の意味はこうです: 255はグルーピング
    # しないことを意味します; 1から254はカレントのグルーピングで
    # 使用する数値を意味します;。グルーピングは右から左へ(下位桁から
    # 上位桁)と適用されます。下の例では最初のグルーピング以外は
    # (それが何でも)使わないことによってこれを避けています。
    if ($grouping) {
        @grouping = unpack("C*", $grouping);
    } else {
        @grouping = (3);
    }

    # Format command line params for current locale
    for (@ARGV) {
        $_ = int;    # Chop non-integer part
        1 while
        s/(\d)(\d{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
        print "$_";
    }
    print "\n";

=begin original

Note that if the platform doesn't have C<LC_NUMERIC> and/or
C<LC_MONETARY> available or enabled, the corresponding elements of the
hash will be missing.

=end original

プラットフォームで C<LC_NUMERIC> や C<LC_MONETARY> が利用可能であったり
有効であったりしない場合、ハッシュの対応する要素はありません。

=head2 I18N::Langinfo

=begin original

Another interface for querying locale-dependent information is the
C<I18N::Langinfo::langinfo()> function.

=end original

ロケール依存の情報を問い合わせるその他のインターフェースとしては
C<I18N::Langinfo::langinfo()> 関数があります。

=begin original

The following example will import the C<langinfo()> function itself and
three constants to be used as arguments to C<langinfo()>: a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.

=end original

以下の例は C<langinfo()> 関数自身と、C<langinfo()> の引数として使う 3 つの
定数をインポートします: 1 つは現在のロケールでの週の最初の日の省略形
(番号は日曜日=1として振られています)、後の 2 つははい/いいえの質問に
対しての肯定および否定を現在のロケールで表すものです。

    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);

    my ($abday_1, $yesstr, $nostr)
                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);

    print "$abday_1? [$yesstr/$nostr] ";

=begin original

In other words, in the "C" (or English) locale the above will probably
print something like:

=end original

言い換えると、"C" (または English) ロケールでは上記のものはおそらく
以下のようなものが表示されます:

    Sun? [yes/no]

=begin original

See L<I18N::Langinfo> for more information.

=end original

さらなる情報については L<I18N::Langinfo> を参照してください。

=head1 LOCALE CATEGORIES

(ロケールカテゴリ)

=begin original

The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See L</"ENVIRONMENT"> for a discussion of these.

=end original

以下のセクションでは、基本的なロケールカテゴリの説明をします。
先の例のように、複数の基本カテゴリを扱うことができる幾つかの
組み合わせカテゴリ(combination categories)があります。
この事に関する詳細は、L</"ENVIRONMENT"> を参照してください。

=head2 Category C<LC_COLLATE>: Collation: Text Comparisons and Sorting

(カテゴリ C<LC_COLLATE>: 照合: テキスト比較とソート)

=begin original

In the scope of a S<C<use locale>> form that includes collation, Perl
looks to the C<LC_COLLATE>
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, "b" likely follows "a" in Latin
alphabets, but where do "E<aacute>" and "E<aring>" belong?  And while
"color" follows "chocolate" in English, what about in traditional Spanish?

=end original

照合を含む S<C<use locale>> 型式のスコープの内側にあるとき、Perl は
アプリケーションで使用する文字の照合(順番)を決定するために
環境変数 C<LC_COLLATE> を参照します
(ラテンアルファベットでは "b" はおそらく "a" に続くものですが、
"E<aacute>" や "E<aring>" はどこに置かれるのでしょう?)。
また、英語では "color" は "chocolate" よりも後になりますが、伝統的な
スペイン語ではどうでしょう?

=begin original

The following collations all make sense and you may meet any of them
if you C<"use locale">.

=end original

以下の照合は全て意味あるものであり、C<"use locale"> をすれば直面することも
あるでしょう。

	A B C D E a b c d e
	A a B b C c D d E e
	a A b B c C d D e E
	a b c d e A B C D E

=begin original

Here is a code snippet to tell what "word"
characters are in the current locale, in that locale's order:

=end original

以下のコード片はカレントのロケールにおける英数文字をそのロケールでの
順序で出力するものです。

        use locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

=begin original

Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:

=end original

これと、陽にロケールを無視するように指示したときの文字とを
比較してみてください。

        no locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

=begin original

This machine-native collation (which is what you get unless S<C<use
locale>> has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.

=end original

この、マシン本来の照合(同じブロックの前のほうで S<C<use locale>> を
していない方)は生のバイナリデータのソートに用いるもので、
最初の例で使ったロケール依存の照合は通常のテキストに使うのに便利です。

=begin original

As noted in L</USING LOCALES>, C<cmp> compares according to the current
collation locale when C<use locale> is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use C<POSIX::strcoll()> if you don't want this fall-back:

=end original

L</USING LOCALES> で述べたように、C<cmp> は C<use locale> が有効なときには
カレントの照合ロケールに従って比較を行いますが、
この結果が等しいと出た場合には文字毎の比較に逆戻りします。
この逆戻りが嫌ならば、C<POSIX::strcoll()> を使うことができます。

        use POSIX qw(strcoll);
        $equal_in_locale =
            !strcoll("space and case ignored", "SpaceAndCaseIgnored");

=begin original

C<$equal_in_locale> will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.

=end original

C<$equal_in_locale> は照合ロケールが空白キャラクタを完全に無視し、
大小文字の区別を無視するような辞書に似た順序付けを指定している場合には
真になるでしょう。

=begin original

Perl uses the platform's C library collation functions C<strcoll()> and
C<strxfrm()>.  That means you get whatever they give.  On some
platforms, these functions work well on UTF-8 locales, giving
a reasonable default collation for the code points that are important in
that locale.  (And if they aren't working well, the problem may only be
that the locale definition is deficient, so can be fixed by using a
better definition file.  Unicode's definitions (see L</Freely available
locale definitions>) provide reasonable UTF-8 locale collation
definitions.)  Starting in Perl v5.26, Perl's use of these functions has
been made more seamless.  This may be sufficient for your needs.  For
more control, and to make sure strings containing any code point (not
just the ones important in the locale) collate properly, the
L<Unicode::Collate> module is suggested.

=end original

Perl はプラットフォームの C ライブラリ照合関数 C<strcoll()> と
C<strxfrm()> を使います。
つまり、あなたが得るものはこれらが与えるものです。
一部のプラットフォームでは、これらの関数は UTF-8 ロケールでうまく動作し、
このロケールで重要な符号位置について合理的なデフォルトの照合順序を
提供します。
(そしてこれがうまく動作しない場合、
問題はロケール定義に不足があるだけかもしれないので、
より良い定義ファイルを使うことで修正されることがあります。
Unicode の定義 (L</Freely available locale definitions> を参照して下さい) は
妥当な UTF-8 ロケール照合定義を提供します。)
Perl v5.26 から、Perl のこれらの関数の使用はよりシームレスになりました。
これはあなたの需要に十分でしょう。
より多くの制御のため、そして(現在のロケールに対して重要なものだけでなく)
全ての符号位置を含む文字列を適切に照合するためには、
L<Unicode::Collate> モジュールが推奨されます。

=begin original

In non-UTF-8 locales (hence single byte), code points above 0xFF are
technically invalid.  But if present, again starting in v5.26, they will
collate to the same position as the highest valid code point does.  This
generally gives good results, but the collation order may be skewed if
the valid code point gets special treatment when it forms particular
sequences with other characters as defined by the locale.
When two strings collate identically, the code point order is used as a
tie breaker.

=end original

非 UTF-8 ロケール (つまり単一バイト) の場合、0xFF を越える符号位置は
技術的には不正です。
しかしもし存在していると、再び v5.26 から、これらは
有効な符号位置の中で最大のものと同じ位置として照合されます。
これは一般的に良い結果となりますが、
ある有効な符号位置が他の文字との特定の並びを作った場合に特別な扱いを
受けるようにロケールによって定義されている場合、
照合順序が歪むかもしれません。
二つの文字列が同一のものとして照合された場合、符号位置順序は
タイブレーカーとして使われます。

=begin original

If Perl detects that there are problems with the locale collation order,
it reverts to using non-locale collation rules for that locale.

=end original

ロケールの照合順序に問題があることを Perl が検出すると、
そのロケールに対しては非ロケール照合順序を使うように戻ります。

=begin original

If you have a single string that you want to check for "equality in
locale" against several others, you might think you could gain a little
efficiency by using C<POSIX::strxfrm()> in conjunction with C<eq>:

=end original

「ロケールにおける等価性」の検査を他のものに対して行いたい(一つの)
文字列があるときに、C<POSIX::strxfrm()> を C<eq> と一緒に
使うことによって多少の効率アップができると考えるかもしれません:

        use POSIX qw(strxfrm);
        $xfrm_string = strxfrm("Mixed-case string");
        print "locale collation ignores spaces\n"
            if $xfrm_string eq strxfrm("Mixed-casestring");
        print "locale collation ignores hyphens\n"
            if $xfrm_string eq strxfrm("Mixedcase string");
        print "locale collation ignores case\n"
            if $xfrm_string eq strxfrm("mixed-case string");

=begin original

C<strxfrm()> takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  "Under the hood", locale-affected Perl comparison operators
call C<strxfrm()> for both operands, then do a char-by-char
comparison of the transformed strings.  By calling C<strxfrm()> explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see L<perlguts/Magic Variables>) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
C<cmp> runs just about as fast.  It also copes with null characters
embedded in strings; if you call C<strxfrm()> directly, it treats the first
null it finds as a terminator.  Don't expect the transformed strings
it produces to be portable across systems--or even from one revision
of your operating system to the next.  In short, don't call C<strxfrm()>
directly: let Perl do it for you.

=end original

C<strxfrm()> は文字列を引数にとり、それを同様の変換を加えられた文字列との
文字毎の比較に使えるような文字列に変換します。
「フードの中では」、ロケールに影響された Perl の比較演算子は 
C<strxfrm()> を両オペランドのために呼び出して、その後で文字毎の比較を、
変換された文字列に対して行います。
C<strxfrm()> を陽に呼び出すこととロケールに影響されない比較を行うことで、
上記の例は変換をセーブするようになります。
実際にはこれは何もセーブしません: Perl の魔法(L<perlguts/Magic Variables> を
参照)は、比較の際に必要であれば最初に変換された文字列を生成し、それからそれが
再び必要になるまで取っておくのです。
C<cmp> を使って書き直したサンプルは可能な限り早く実行されます。
また、文字列に埋め込まれているヌル文字にも対処します; C<strxfrm()> を
直接呼び出した場合、ナルは終端子としてみなされます。
そして、変換後の文字列がシステムを越えて使えるようなものであると
期待してはいけません; また、あるオペレーティングシステムのバージョンで
作ったものが次のバージョンでも同様であるということも期待してはいけません。
一言でいうと、C<strxfrm()> を直接呼び出してはいけない、ということです:
Perl に呼び出しをさせましょう。

=begin original

Note: C<use locale> isn't shown in some of these examples because it isn't
needed: C<strcoll()> and C<strxfrm()> are POSIX:: functions
which use the standard system-supplied C<libc> functions that
always obey the current C<LC_COLLATE> locale.

=end original

注意: 幾つかのサンプルでは、必要がないので C<use locale> がありません:
C<strcoll()> や C<strxfrm()> は、常に C<LC_COLLATE> ロケールに従う、システムが
供給する標準の C<libc> 関数を使う POSIX:: 関数です。

=head2 Category C<LC_CTYPE>: Character Types

(カテゴリ C<LC_CTYPE>: 文字タイプ)

=begin original

In the scope of a S<C<use locale>> form that includes C<LC_CTYPE>, Perl
obeys the C<LC_CTYPE> locale
setting.  This controls the application's notion of which characters are
alphabetic, numeric, punctuation, I<etc>.  This affects Perl's C<\w>
regular expression metanotation,
which stands for alphanumeric characters--that is, alphabetic,
numeric, and the platform's native underscore.
(Consult L<perlre> for more information about
regular expressions.)  Thanks to C<LC_CTYPE>, depending on your locale
setting, characters like "E<aelig>", "E<eth>", "E<szlig>", and
"E<oslash>" may be understood as C<\w> characters.
It also affects things like C<\s>, C<\D>, and the POSIX character
classes, like C<[[:graph:]]>.  (See L<perlrecharclass> for more
information on all these.)

=end original

C<LC_CTYPE> を含む S<C<use locale>> 型式のスコープ内のとき、
Perl は C<LC_CTYPE> ロケールの設定に従います。
これは、アプリケーションの英字、数字、句読点 I<など> かどうかの扱いを
制御します。
これは、英数字 -- つまり、英字、数字、およびプラットフォームのネイティブな
下線を含みます --に関わる正規表現のメタ表記 C<\w> に影響します。
(正規表現に関するさらなる情報については L<perlre> を参照してください)。
C<LC_CTYPE> のおかげで、ロケール設定に依存した "E<aelig>", "E<eth>",
"E<szlig>", "E<oslash>" のような文字が C<\w> 文字として認識できるのです。
これはまた C<\s>, C<\D> および  C<[[:graph:]]> のような POSIX 文字クラスにも
影響を与えます。
(これら全てに関するさらなる情報については L<perlrecharclass> を
参照してください。)

=begin original

The C<LC_CTYPE> locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions--C<fc()>, C<lc()>, C<lcfirst()>, C<uc()>, and C<ucfirst()>;
case-mapping
interpolation with C<\F>, C<\l>, C<\L>, C<\u>, or C<\U> in double-quoted
strings and C<s///> substitutions; and case-insensitive regular expression
pattern matching using the C<i> modifier.

=end original

C<LC_CTYPE> ロケールはまた、小文字と大文字との間の相互変換に使われる
マッピングを提供します。
これは大文字小文字変換関数 C<fc()>, C<lc()>, C<lcfirst()>, C<uc()>,
C<ucfirst()> とダブルクォートで囲まれた文字列の中での C<\F>, C<\l>, C<\L>, 
C<\u>, <\U> による大文字小文字変換、そして C<s///> による置換、
C<i> 修飾子を使った(大小文字を無視する)正規表現パターンマッチングに
影響を及ぼします。

=begin original

Starting in v5.20, Perl supports UTF-8 locales for C<LC_CTYPE>, but
otherwise Perl only supports single-byte locales, such as the ISO 8859
series.  This means that wide character locales, for example for Asian
languages, are not well-supported.  Use of these locales may cause core
dumps.  If the platform has the capability for Perl to detect such a
locale, starting in Perl v5.22, L<Perl will warn, default
enabled|warnings/Category Hierarchy>, using the C<locale> warning
category, whenever such a locale is switched into.  The UTF-8 locale
support is actually a
superset of POSIX locales, because it is really full Unicode behavior
as if no C<LC_CTYPE> locale were in effect at all (except for tainting;
see L</SECURITY>).  POSIX locales, even UTF-8 ones,
are lacking certain concepts in Unicode, such as the idea that changing
the case of a character could expand to be more than one character.
Perl in a UTF-8 locale, will give you that expansion.  Prior to v5.20,
Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one,
with some restrictions, and on other platforms more like the "C" locale.
For releases v5.16 and v5.18, C<S<use locale 'not_characters>> could be
used as a workaround for this (see L</Unicode and UTF-8>).

=end original

v5.20 から、Perl は C<LC_CTYPE> に関して UTF-8 ロケールに対応していますが、
それ以外では Perl は ISO 8859 シリーズのような単一バイトロケールのみに
対応しています。
これはつまり、アジア言語のようなワイド文字ロケールには
うまく対応していないということです。
これらのロケールを使うとコアダンプを引き起こすかもしれません。
プラットフォームが Perl にこのようなロケールを検出する能力を
与えている場合、Perl v5.22 から、そのようなロケールに切り替えると、
C<locale> 警告カテゴリを使って
L<Perl は警告し、デフォルトを有効にします|warnings/Category Hierarchy>。
UTF-8 ロケール対応は実際には POSIX ロケールの上位集合です;
C<LC_CTYPE> ロケールの影響を一切受けない完全な Unicode の振る舞いだからです
(例外は汚染です; L</SECURITY> を参照してください)。
POSIX ロケールは、例え UTF-8 のものでも、
文字の大文字小文字の変更が複数文字に拡張されるような、
Unicode のいくつかの概念が欠けています。
UTF-8 ロケールでは、Perl は拡張を提供します。
UTF-8 ロケールについて、v5.20 より前の Perl では、
一部のプラットフォームではある種の制限付きの ISO 8859-1 として扱い、
その他のプラットフォームではより "C" ロケールに近いものになります。
リリース v5.16 と v5.18 では、C<S<use locale 'not_characters>> が
これの回避策として使われていました (L</Unicode and UTF-8> を
参照してください)。

=begin original

Note that there are quite a few things that are unaffected by the
current locale.  Any literal character is the native character for the
given platform.  Hence 'A' means the character at code point 65 on ASCII
platforms, and 193 on EBCDIC.  That may or may not be an 'A' in the
current locale, if that locale even has an 'A'.
Similarly, all the escape sequences for particular characters,
C<\n> for example, always mean the platform's native one.  This means,
for example, that C<\N> in regular expressions (every character
but new-line) works on the platform character set.

=end original

現在のロケールによって影響を受けないものもいくつかあることに注意してください。
あらゆるリテラル文字は与えられたプラットフォームでネイティブな文字です。
従って 'A' は ASCII プラットフォームでは 符号位置 65 で、
EBCDIC では 193 です。
これは、例え現在のロケールに 'A' があっても、現在のロケールで
'A' かもしれませんしそうでないかもしれません。
同様に、例えば C<\n> のような、特定の文字のためのエスケープシーケンス全ては、
常にプラットフォームにネイティブなものを意味します。
つまり、例えば、正規表現中の C<\N> (改行以外の全ての文字) はプラットフォームの
文字集合に対して動作します。

=begin original

Starting in v5.22, Perl will by default warn when switching into a
locale that redefines any ASCII printable character (plus C<\t> and
C<\n>) into a different class than expected.  This is likely to
happen on modern locales only on EBCDIC platforms, where, for example,
a CCSID 0037 locale on a CCSID 1047 machine moves C<"[">, but it can
happen on ASCII platforms with the ISO 646 and other
7-bit locales that are essentially obsolete.  Things may still work,
depending on what features of Perl are used by the program.  For
example, in the example from above where C<"|"> becomes a C<\w>, and
there are no regular expressions where this matters, the program may
still work properly.  The warning lists all the characters that
it can determine could be adversely affected.

=end original

v5.22 から、Perl はデフォルトで、
任意の ASCII 表示文字 (に加えて C<\t> と C<\n>) を想定と異なるクラスに
再定義するロケールに切り替えるときに警告します。
これは EBCDIC プラットフォームの最近のロケールでのみ起こるでしょう;
ここで、例えば、
CCSID 1047 マシンでの CCSID 0037 ロケールは C<"["> を動かします;
しかし、ISO 646 の ASCII プラットフォームと、本質的に古い 7 ビット
ロケールでも起きることがあります。
Perl のどの機能をプログラムで使われているかによってまだ
動作するかもしれません。
例えば、前述の例で C<"|"> が C<\w> になり、関係する部分で正規表現がない場合、
プログラムは適切に動作します。
この警告は、逆に影響されると決定される全ての文字の一覧です。

=begin original

B<Note:> A broken or malicious C<LC_CTYPE> locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) ASCII letters and
digits--for example, in command strings--locale-aware applications
should use C<\w> with the C</a> regular expression modifier.  See L</"SECURITY">.

=end original

B<注意:> 壊れた、あるいは悪意のある C<LC_CTYPE> ロケールの定義は、
不適切な文字を英数字であるとみなしてしまう可能性があります。
(アクセント記号のない)文字や数字の厳密なマッチング、例えばコマンド文字列の
ロケールを気にするアプリケーションは C</a> 正規表現修飾子付きで
C<\w> を使うべきです。
L</"SECURITY"> を参照してください。

=head2 Category C<LC_NUMERIC>: Numeric Formatting

(カテゴリ C<LC_NUMERIC>: 数値形式)

=begin original

After a proper C<POSIX::setlocale()> call, and within the scope
of a C<use locale> form that includes numerics, Perl obeys the
C<LC_NUMERIC> locale information, which controls an application's idea
of how numbers should be formatted for human readability.
In most implementations the only effect is to
change the character used for the decimal point--perhaps from "."  to ",".
The functions aren't aware of such niceties as thousands separation and
so on. (See L</The localeconv function> if you care about these things.)

=end original

適切な C<POSIX::setlocale()> 呼び出しの後、数値を含む C<use locale> の
スコープの内側では、Perl は C<LC_NUMERIC> ロケール情報を参照します; これは
アプリケーションが数値をどのように整形するかということを制御するものです。
大部分の実装では、小数点を表わす文字を "." から "," へと
変更するだけの効果しかありません。
この関数は三桁毎の区切りなどについては考慮しません。
(この事について心配があるのなら L</The localeconv function> を
参照してください。)

 use POSIX qw(strtod setlocale LC_NUMERIC);
 use locale;

 setlocale LC_NUMERIC, "";

 $n = 5/2;   # Assign numeric 2.5 to $n

 $x = " $n"; # Locale-dependent conversion to string

 print "half five is $n\n";       # Locale-dependent output

 printf "half five is %g\n", $n;  # Locale-dependent output

 print "DECIMAL POINT IS COMMA\n"
          if $n == (strtod("2,5"))[0]; # Locale-dependent conversion

=begin original

See also L<I18N::Langinfo> and C<RADIXCHAR>.

=end original

L<I18N::Langinfo> と C<RADIXCHAR> も参照してください。

=head2 Category C<LC_MONETARY>: Formatting of monetary amounts

(カテゴリ C<LC_MONETARY>: 金銭の書式)

=begin original

The C standard defines the C<LC_MONETARY> category, but not a function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.  POSIX 2001 added the C<strfmon()> function to format currency
amounts, but there is no official function to parse strings representing
currency values.)

=end original

標準 C では C<LC_MONETARY> カテゴリを定義していますが、その内容に
影響される関数はありません。
(規格委員会の経験によって、それらはワーキンググループがこの問題を
蹴り出すことに決めたことを認識したのでしょう。
POSIX 2001 は通貨量をフォーマットするための C<strfmon()> 関数を
追加しましたが、通貨量を表現する文字列をパースするための
公式な関数はありません。)

=begin original

Perl essentially takes no notice of this category.  On POSIX systems, you
can call C<strfmon()> from XS code to create formatted strings, and/or you
can query the C<LC_MONETARY> locale-specific values with
L</The localeconv function> and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.

=end original

Perl は基本的にこのカテゴリに注意を払いません。
POSIX システムでは、フォーマットされた文字列を作るのに
XS コードから C<strfmon()> を呼び出すことができ、
あるいは L</The localeconv function> の
C<LC_MONETARY> ロケール固有値を問い合わせて、
そして返ってきた情報をアプリケーションの通貨量の整形に使います。
しかし、この情報を取得することはできるでしょうが、大量かつ複雑で、
要求に対して本当にあったものではないでしょう: 金銭に関する書式は手に
おえない代物なのです。

=begin original

See also C<CRNCYSTR> in L<I18N::Langinfo>.

=end original

L<I18N::Langinfo> の C<CRNCYSTR> も参照してください。

=head2 Category C<LC_TIME>: Representation of time

(カテゴリ C<LC_TIME>: 時刻の表現)

=begin original

Output produced by C<POSIX::strftime()>, which builds a formatted
human-readable date/time string, is affected by the current C<LC_TIME>
locale.  Thus, in a French locale, the output produced by the C<%B>
format element (full month name) for the first month of the year would
be "janvier".  Here's how to get a list of long month names in the
current locale:

=end original

人が読みやすい、整形された日付/時刻文字列を作り出す
C<POSIX::strftime()> によって生成された出力はカレントの C<LC_TIME> ロケールに
影響を受けます。
したがって、フランスのロケールでは、C<%B> 書式指定子(省略のない月の名前)を
一年の最初の月に対して使ったときの結果は、"janvier" となります。
以下の例は、カレントロケールにおける長い月名のリストを得るものです。

        use POSIX qw(strftime);
        for (0..11) {
            $long_month_name[$_] =
                strftime("%B", 0, 0, 0, 1, $_, 96);
        }

=begin original

Note: C<use locale> isn't needed in this example: C<strftime()> is a POSIX::
function which uses the standard system-supplied C<libc> function that
always obeys the current C<LC_TIME> locale.

=end original

注意: C<use locale> はこの例では必要ではありません: C<strftime()> は
POSIX:: 関数で、標準のシステムが供給する C<libc> 関数を使い、常に
カレントの C<LC_TIME> ロケールを参照します。

=begin original

See also L<I18N::Langinfo> and C<ABDAY_1>..C<ABDAY_7>, C<DAY_1>..C<DAY_7>,
C<ABMON_1>..C<ABMON_12>, and C<ABMON_1>..C<ABMON_12>.

=end original

L<I18N::Langinfo> と C<ABDAY_1>..C<ABDAY_7>, C<DAY_1>..C<DAY_7> と
C<ABMON_1>..C<ABMON_12> と C<ABMON_1>..C<ABMON_12> も参照してください。

=begin original

There is also the libc C<strptime()> function defined starting in POSIX
2001 (it's not in Windows) that parses formatted time strings.  There is
currently no pure perl access to this function, so you need to write XS
code to use it.

=end original

フォーマットされた時間文字列をパースするための、
POSIX 2001 以降で定義されている (Windowsにはありません) libc
の C<strptime()> 関数もあります。
現在、この関数へのピュア perl アクセスはありませんので、
使うには XS コードを書く必要があります。

=head2 Category C<LC_MESSAGES>: System messages

(カテゴリ C<LC_MESSAGES>: システムメッセージ)

=begin original

This category is used by perl to create a string describing a system
error number, such as what you would get by saying
L<C<"$!">|perlvar/$ERRNO> or L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR>.
On some systems and locales, the string will be in the language of the
locale given by C<LC_MESSAGES>.  But not many systems have bothered to
install such translations for all locales available on the system.  If
no translation is available for a given locale, the string will be in
English.  See L<Errno> for information about portably using error codes.

=end original

このカテゴリは、L<C<"$!">|perlvar/$ERRNO> や
L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR> のような、
perl がシステムエラー番号を記述する文字列を
生成するために使います。
システムやロケールによっては、文字列が C<LC_MESSAGES> で
指定されたロケールの言語になることがあります。
しかし、システムで使用可能なすべてのロケールに対して
このような変換をインストールしようとする
システムはあまりありません。
指定されたロケールへの変換が使えない場合、
文字列は英語になります。
エラーコードの移植性のある使い方については、
L<Errno> を参照してください。

=begin original

The other categories mentioned so far are required to exist in any
platform on which Perl can run.  But this category is a POSIX extension,
and Perl runs on platforms, Windows, for example, that don't have it.  On
such platforms the underlying language for the system errors will be
whatever C<LC_CTYPE> gives, or English.

=end original

これまでに述べたその他のカテゴリは、Perl が実行可能な
すべてのプラットフォームに存在する必要があります。
しかし、このカテゴリは POSIX 拡張であり、Perl は
Windows のような、それを持たない
プラットフォームでも実行されます。
そのようなプラットフォームでは、システムエラーの基礎となる
言語は C<LC_CTYPE> が与えるもの、または英語になります。

=begin original

This category in conjunction with L<I18N::Langinfo> can be used to
output yes/no in its locale's language, and to parse strings that
contain "yes" or "no" in that language.

=end original

このカテゴリを L<I18N::Langinfo> と組み合わせて使うと、
ロケールの言語で yes/no を出力したり、その言語で
"yes" または "no" を含む文字列をパースしたりできます。

=head2 Other categories

(その他のカテゴリ)

=begin original

Some platforms have additional categories.  These are not used by Perl
itself.  L<I18N::Langinfo> may be used to query them, yielding stub
values on platforms where they don't exist.  But again note that things
Perl interacts with may use these, including extensions outside the
standard Perl distribution, and by the operating system and its
utilities.

=end original

一部のプラットフォームは追加のカテゴリを持ちます。
これらは Perl 自身では使われません。
これらを問い合わせるには L<I18N::Langinfo> が使えて、
存在しない場合はプラットフォームのスタブ値を返します。
しかし再び、標準の Perl 配布パッケージにはない拡張モジュールや
OS やそのユーティリティなど、Perl が
相互作用するものがこれらを使うかも知れないことに注意してください。

=head1 SECURITY

(セキュリティ)

=begin original

Although the main discussion of Perl security issues can be found in
L<perlsec>, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales--particularly on systems that allow unprivileged users to
build their own locales--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:

=end original

Perl のセキュリティに関する事項の主な議論は L<perlsec> にありますが、
Perl のロケールの扱いに関する議論はそれがあなたのロケール依存の
セキュリティ事項に対して注意していなければ不完全です。
ロケールは(特に特権のないユーザーが自分のロケールを構築するのを許すような
システムでは)信用できないものなのです。
悪意のある(もしくは単に壊れた)ロケールはロケールを使うアプリケーションを
予期できない結果にする可能性があります。
以下に幾つかの可能性を挙げます。

=over 4

=item *

=begin original

Regular expression checks for safe file names or mail addresses using
C<\w> may be spoofed by an C<LC_CTYPE> locale that claims that
characters such as C<"E<gt>"> and C<"|"> are alphanumeric.

=end original

安全なファイル名やメイルアドレスを検索するための正規表現で C<\w> を使うと、
C<"E<gt>"> や C<"|"> を英数字と主張するような C<LC_CTYPE> に
だまされてしまう可能性があります。

=item *

=begin original

String interpolation with case-mapping, as in, say, C<$dest =
"C:\U$name.$ext">, may produce dangerous results if a bogus C<LC_CTYPE>
case-mapping table is in effect.

=end original

C<$dest = "C:\U$name.$ext"> のような、大文字小文字変換を伴った文字列展開は、
不正な C<LC_CTYPE> の大文字小文字変換テーブルが有効であるときに
危険な結果を生成する可能性があります。

=item *

=begin original

A sneaky C<LC_COLLATE> locale could result in the names of students with
"D" grades appearing ahead of those with "A"s.

=end original

陰険な C<LC_COLLATE> ロケールは "D" 等級の生徒の名前を
"A" の前に置いてしまう結果にさせるかもしれません。

=item *

=begin original

An application that takes the trouble to use information in
C<LC_MONETARY> may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in US
dollars instead of Hong Kong dollars.

=end original

手間を惜しまずに C<LC_MONETARY> にある情報を使うアプリケーションは、
ロケールがおかしいと、負債を預金のように扱ったり、その逆にしたり
してしまうかもしれません。
あるいは、香港ドルの代わりに US ドルで支払いをさせたりしてしまうかも
しれません。

=item *

=begin original

The date and day names in dates formatted by C<strftime()> could be
manipulated to advantage by a malicious user able to subvert the
C<LC_TIME> locale.  ("Look--it says I wasn't in the building on
Sunday.")

=end original

C<strftime()> により整形された日付情報は、C<LC_TIME> をいじりまわすことの
できる悪意あるユーザーにより操作されてしまう可能性があります。
(「見てくれよ、こいつ俺が日曜日に建物にいなかったって
言ってるよ。」)

=back

=begin original

Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.

=end original

このような危険は、ロケールシステムに特有のものではありません: 意地の悪い
変更を通して同じような攻撃を受けるようなアプリケーション環境の
あらゆる状況が対象となります。
同様に、これは Perl に固有なものでもありません: 環境を考慮するような
プログラムを書くことのできるあらゆるプログラミング言語で同様の危険性が
あるのです。

=begin original

Perl cannot protect you from all possibilities shown in the
examples--there is no substitute for your own vigilance--but, when
C<use locale> is in effect, Perl uses the tainting mechanism (see
L<perlsec>) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.

=end original

perl は例示したようなすべての可能性からあなたを守ることはできません--
あなた自身の用心に代り得るものはないのです--しかし、C<use locale> が
有効であるとき、Perl は汚染チェック機構(L<perlsec> を参照)を、ロケールに
依存した結果であり、信用できないかもしれない文字列に注意するために
使用します。

=begin original

Note that it is possible to compile Perl without taint support,
in which case all taint features silently do nothing.

=end original

Perl を汚染チェック対応なしでコンパイルすることが可能で、
その場合全ての汚染チェック機能は暗黙に無視されることに注意してください。

=begin original

Here is a summary of the tainting behavior of operators and functions
that may be affected by the locale:

=end original

以下は、ロケールにより影響を受ける可能性のある演算子や関数の汚染される
振る舞いのまとめです。

=over 4

=item  *

=begin original

B<Comparison operators> (C<lt>, C<le>, C<ge>, C<gt> and C<cmp>):

=end original

B<比較演算子> (C<lt>, C<le>, C<ge>, C<gt>, C<cmp>):

=begin original

Scalar true/false (or less/equal/greater) result is never tainted.

=end original

スカラの真/偽(もしくは未満/等しい/越えている)の結果は
決して汚染されません。

=item  *

=begin original

B<Case-mapping interpolation> (with C<\l>, C<\L>, C<\u>, C<\U>, or C<\F>)

=end original

B<大文字小文字変換> (C<\l>, C<\L>, C<\u>, C<\U>, C<\F>)

=begin original

The result string containing interpolated material is tainted if
a C<use locale> form that includes C<LC_CTYPE> is in effect.

=end original

C<LC_CTYPE> を含む C<use locale> 型式が有効な場合、
展開されたものが含まれる文字列は汚染されます。

=item  *

=begin original

B<Matching operator> (C<m//>):

=end original

B<マッチング演算子> (C<m//>):

=begin original

Scalar true/false result never tainted.

=end original

スカラの真/偽の結果は決して汚染されません。

=begin original

All subpatterns, either delivered as a list-context result or as C<$1>
I<etc>., are tainted if a C<use locale> form that includes
C<LC_CTYPE> is in effect, and the subpattern
regular expression contains a locale-dependent construct.  These
constructs include C<\w> (to match an alphanumeric character), C<\W>
(non-alphanumeric character), C<\b> and C<\B> (word-boundary and
non-boundary, which depend on what C<\w> and C<\W> match), C<\s>
(whitespace character), C<\S> (non whitespace character), C<\d> and
C<\D> (digits and non-digits), and the POSIX character classes, such as
C<[:alpha:]> (see L<perlrecharclass/POSIX Character Classes>).

=end original

リストコンテキストの結果や、C<$1> I<など> として渡される全てのサブパターンは、
C<LC_CTYPE> を含む C<use locale> が有効である、かつ正規表現サブパターンに
ロケール依存の構文を含んでいるときには汚染されます。
これらの構文には C<\w> (英数字にマッチングする)、C<\W>
(英数字以外にマッチングする)、
C<\b> と C<\B> (単語境界と非単語境界; C<\w> と C<\W> がマッチングするものに
依存する)、C<\s> (空白文字)、C<\S> (空白文字以外)、
C<\d> と C<\D> (数字と非数字)、C<[:alpha:]> のような POSIX 文字クラス
(L<perlrecharclass/POSIX Character Classes> 参照) が含まれます。

=begin original

Tainting is also likely if the pattern is to be matched
case-insensitively (via C</i>).  The exception is if all the code points
to be matched this way are above 255 and do not have folds under Unicode
rules to below 256.  Tainting is not done for these because Perl
only uses Unicode rules for such code points, and those rules are the
same no matter what the current locale.

=end original

パターンが (C</i> を使って) 大文字小文字を無視してマッチングするような
ものである場合、おそらく汚染も起こります。
例外は、この方法でマッチングする全ての符号位置が 255 より大きく、
Unicode の規則の基で 256 より小さいものに畳み込みが行われない場合です。
これらについては汚染は起こりません; なぜなら Perl はこのような符号位置に
対しては Unicode の規則のみを使い、この規則は現在のロケールに関わらず
同じだからです。

=begin original

The matched-pattern variables, C<$&>, C<$`> (pre-match), C<$'>
(post-match), and C<$+> (last match) also are tainted.

=end original

マッチした結果を保持する変数、C<$&>,、C<$`>(マッチした部分より前)、
C<$'>(マッチした部分より後)、C<$+> (最後にマッチしたもの)も汚染されます。

=item  *

=begin original

B<Substitution operator> (C<s///>):

=end original

B<置換演算子> (C<s///>):

=begin original

Has the same behavior as the match operator.  Also, the left
operand of C<=~> becomes tainted when a C<use locale>
form that includes C<LC_CTYPE> is in effect, if modified as
a result of a substitution based on a regular
expression match involving any of the things mentioned in the previous
item, or of case-mapping, such as C<\l>, C<\L>,C<\u>, C<\U>, or C<\F>.

=end original

マッチング演算子と同じ振る舞いをします。
また、C<=~> の左側のオペランドは、
C<LC_CTYPE> を含む C<use locale> 型式が有効のとき、
前に言及したもの、または
C<\l>, C<\L>,C<\u>, C<\U>, C<\F> のような大文字小文字変換によって
値が変更された場合、汚染されます。

=item *

=begin original

B<Output formatting functions> (C<printf()> and C<write()>):

=end original

B<出力書式関数> (C<printf()> と C<write()>):

=begin original

Results are never tainted because otherwise even output from print,
for example C<print(1/7)>, should be tainted if C<use locale> is in
effect.

=end original

結果は決して汚染されません; なぜなら、もしそうでないなら、
例えば C<print(1/7)> のような、print からの出力ですら
C<use locale> が有効のときは汚染されることになってしまいます。

=item *

=begin original

B<Case-mapping functions> (C<lc()>, C<lcfirst()>, C<uc()>, C<ucfirst()>):

=end original

B<大文字小文字変換関数> (C<lc()>, C<lcfirst()>, C<uc()>, C<ucfirst()>):

=begin original

Results are tainted if a C<use locale> form that includes C<LC_CTYPE> is
in effect.

=end original

C<LC_CTYPE> を含む C<use locale> が型式が有効なときに、結果が汚染されます。

=item *

=begin original

B<POSIX locale-dependent functions> (C<localeconv()>, C<strcoll()>,
C<strftime()>, C<strxfrm()>):

=end original

B<POSIX ロケール依存関数> (C<localeconv()>, C<strcoll()>,
C<strftime()>, C<strxfrm()>):

=begin original

Results are never tainted.

=end original

結果は決して汚染されません。

=back

=begin original

Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.

=end original

三つの例を使って、ロケール依存の汚染を説明します。
最初のプログラムはそのロケールを無視して、実行されません: 汚染検査が
有効であるときには、コマンドラインから直接とった値を出力ファイル名として
使うことはできません。

        #/usr/local/bin/perl -T
        # Run with taint checking

        # Command line sanity check omitted...
        $tainted_output_file = shift;

        open(F, ">$tainted_output_file")
            or warn "Open of $tainted_output_file failed: $!\n";

=begin original

The program can be made to run by "laundering" the tainted value through
a regular expression: the second example--which still ignores locale
information--runs, creating the file named on its command line
if it can.

=end original

このプログラムは、汚染された値を正規表現を通して
「洗浄」(laundering)することにより実行できるようにできます:
以下に挙げる二番目の例は--これもロケール情報を無視しています--
実行されると、コマンドラインにある名前のファイルを可能であれば作成します。

        #/usr/local/bin/perl -T

        $tainted_output_file = shift;
        $tainted_output_file =~ m%[\w/]+%;
        $untainted_output_file = $&;

        open(F, ">$untainted_output_file")
            or warn "Open of $untainted_output_file failed: $!\n";

=begin original

Compare this with a similar but locale-aware program:

=end original

これを、非常に良く似てはいますが、ロケールを使ったプログラムと
比較してみてください。

        #/usr/local/bin/perl -T

        $tainted_output_file = shift;
        use locale;
        $tainted_output_file =~ m%[\w/]+%;
        $localized_output_file = $&;

        open(F, ">$localized_output_file")
            or warn "Open of $localized_output_file failed: $!\n";

=begin original

This third program fails to run because C<$&> is tainted: it is the result
of a match involving C<\w> while C<use locale> is in effect.

=end original

この三番目のプログラムは、C<$&> が汚染されているので実行に失敗します;
これは C<use locale> が有効であるときの C<\w> を含んだマッチングによる
結果です。

=head1 ENVIRONMENT

(環境変数)

=over 12

=item PERL_SKIP_LOCALE_INIT

=begin original

This environment variable, available starting in Perl v5.20, if set
(to any value), tells Perl to not use the rest of the
environment variables to initialize with.  Instead, Perl uses whatever
the current locale settings are.  This is particularly useful in
embedded environments, see
L<perlembed/Using embedded Perl with POSIX locales>.

=end original

この環境変数は Perl v5.20 から利用可能で、これが(何らかの値に)
設定されている場合、初期化のためのその他の環境変数を使わないように Perl に
伝えます。
代わりに、Perl は現在のロケール設定を使います。
これは組み込み環境で特に有用です;
L<perlembed/Using embedded Perl with POSIX locales> を参照してください。

=item PERL_BADLANG

=begin original

A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value other than "0" or "", Perl will
complain about locale setting failures.

=end original

Perl が起動時にロケールの設定に失敗した場合に警告を出すのを抑制できる
文字列です。
オペレーティングシステムのロケールサポートがなんらかの理由でなかったり、
壊れていたりするとき、あるいは環境変数に設定したロケールの名前を
間違えていた場合に発生します。
もしこの変数が存在していないか、あるいはその値が "0" や "" でない場合に、
Perl はロケールの設定に失敗するとメッセージを出力します。

=begin original

B<NOTE>: C<PERL_BADLANG> only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.

=end original

B<注意>: C<PERL_BADLANG> は警告メッセージを出さないようにするだけです。
このメッセージはあなたの使うシステムのロケールサポートになにかの問題が
あるということを伝えるものですから、あなたは問題が何なのかを
確かめるべきでしょう。

=back

=begin original

The following environment variables are not specific to Perl: They are
part of the standardized (ISO C, XPG4, POSIX 1.c) C<setlocale()> method
for controlling an application's opinion on data.  Windows is non-POSIX,
but Perl arranges for the following to work as described anyway.
If the locale given by an environment variable is not valid, Perl tries
the next lower one in priority.  If none are valid, on Windows, the
system default locale is then tried.  If all else fails, the C<"C">
locale is used.  If even that doesn't work, something is badly broken,
but Perl tries to forge ahead with whatever the locale settings might
be.

=end original

以下の環境変数は Perl に特有のものではなく、アプリケーションのデータの
扱いを制御するための標準的な(ISO C, XPG4, POSIX 1.c) C<setlocale()> メソッドの
一部分です。
Windows は POSIX ではありませんが、Perl はそれでもここで記したとおりに
動作するように用意します。
環境変数で与えられたロケールが正当ではない場合、
優先順位で次のものを使おうとします。
Windows では、正当なものがない場合、システムデフォルトロケールを
使おうとします。
全てに失敗した場合、C<"C"> ロケールが使われます。
これすらも動作しない場合、何かがひどく壊れていますが、
Perl は何かロケール設定があるものとして前に進もうとします。

=over 12

=item C<LC_ALL>

=begin original

C<LC_ALL> is the "override-all" locale environment variable. If
set, it overrides all the rest of the locale environment variables.

=end original

C<LC_ALL> は「全て上書き」ロケール環境変数です。
もしこの環境変数が設定されていると、他のすべての環境変数を上書きします。

=item C<LANGUAGE>

=begin original

B<NOTE>: C<LANGUAGE> is a GNU extension, it affects you only if you
are using the GNU libc.  This is the case if you are using e.g. Linux.
If you are using "commercial" Unixes you are most probably I<not>
using GNU libc and you can ignore C<LANGUAGE>.

=end original

B<注意>: C<LANGUAGE> は GNU の拡張で、GNU libc を使っているときにのみ
効果があります。
Linux を使ったときなどがこれに該当します。
あなたが「商用の」Unix を使っているのであれば GNU libc は
使われていないでしょうし、C<LANGUAGE> は無視することができます。

=begin original

However, in the case you are using C<LANGUAGE>: it affects the
language of informational, warning, and error messages output by
commands (in other words, it's like C<LC_MESSAGES>) but it has higher
priority than C<LC_ALL>.  Moreover, it's not a single value but
instead a "path" (":"-separated list) of I<languages> (not locales).
See the GNU C<gettext> library documentation for more information.

=end original

C<LANGUAGE> を使った場合には、コマンドからの情報、警告、エラーといった
メッセージの言語に影響を及ぼします(言い換えると C<LC_MESSAGES> と
似ています)が、C<LC_ALL> よりも優先順位は下です。
さらに、これは単一の値ではなくて言語(ロケールではありません)の、
":" で連結された「パス」になっています。
より詳しい情報は GNU C<gettext> ライブラリのドキュメントを参照してください。

=item C<LC_CTYPE>

=begin original

In the absence of C<LC_ALL>, C<LC_CTYPE> chooses the character type
locale.  In the absence of both C<LC_ALL> and C<LC_CTYPE>, C<LANG>
chooses the character type locale.

=end original

C<LC_ALL> がないときに、C<LC_CTYPE> は文字タイプのロケールを選択します。
C<LC_ALL> と C<LC_CTYPE> の両方ともない場合、C<LANG> が文字タイプの
ロケールを選択します。

=item C<LC_COLLATE>

=begin original

In the absence of C<LC_ALL>, C<LC_COLLATE> chooses the collation
(sorting) locale.  In the absence of both C<LC_ALL> and C<LC_COLLATE>,
C<LANG> chooses the collation locale.

=end original

C<LC_ALL> がないときに、C<LC_COLLATE> は照合(ソート)ロケールを選択します。
C<LC_ALL> と C<LC_COLLATE> の両方ともない場合、C<LANG> が
照合ロケールを選択します。

=item C<LC_MONETARY>

=begin original

In the absence of C<LC_ALL>, C<LC_MONETARY> chooses the monetary
formatting locale.  In the absence of both C<LC_ALL> and C<LC_MONETARY>,
C<LANG> chooses the monetary formatting locale.

=end original

C<LC_ALL> がないときに、C<LC_MONETARY> は通貨形式ロケールを選択します。
C<LC_ALL> と C<LC_MONETARY> の両方ともない場合、
C<LANG> が通貨形式ロケールを選択します。

=item C<LC_NUMERIC>

=begin original

In the absence of C<LC_ALL>, C<LC_NUMERIC> chooses the numeric format
locale.  In the absence of both C<LC_ALL> and C<LC_NUMERIC>, C<LANG>
chooses the numeric format.

=end original

C<LC_ALL> がないときに、C<LC_NUMERIC> は数値表記のロケールを選択します。
C<LC_ALL> と C<LC_NUMERIC> の両方ともない場合、C<LANG> が数値表記を
選択します。

=item C<LC_TIME>

=begin original

In the absence of C<LC_ALL>, C<LC_TIME> chooses the date and time
formatting locale.  In the absence of both C<LC_ALL> and C<LC_TIME>,
C<LANG> chooses the date and time formatting locale.

=end original

C<LC_ALL> がないときに、C<LC_TIME> は日付・時刻表記のロケールを選択します。
C<LC_ALL> と C<LC_TIME> の両方ともない場合、C<LANG> が日付・時刻表記の
ロケールを選択します。

=item C<LANG>

=begin original

C<LANG> is the "catch-all" locale environment variable. If it is set, it
is used as the last resort after the overall C<LC_ALL> and the
category-specific C<LC_I<foo>>.

=end original

C<LANG> は「包括的」なロケール環境変数です。
これに値が設定されている場合、C<LC_ALL> も、各カテゴリの C<LC_I<foo>> も
設定されていないときの最後の参照場所として使われます。

=back

=head2 Examples

(例)

=begin original

The C<LC_NUMERIC> controls the numeric output:

=end original

C<LC_NUMERIC> は数値出力を制御します:

   use locale;
   use POSIX qw(locale_h); # Imports setlocale() and the LC_ constants.
   setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
   printf "%g\n", 1.23; # If the "fr_FR" succeeded, probably shows 1,23.

=begin original

and also how strings are parsed by C<POSIX::strtod()> as numbers:

=end original

そして文字列が C<POSIX::strtod()> によってどのように数値としてパースされるかも
制御します:

   use locale;
   use POSIX qw(locale_h strtod);
   setlocale(LC_NUMERIC, "de_DE") or die "Entschuldigung";
   my $x = strtod("2,34") + 5;
   print $x, "\n"; # Probably shows 7,34.

=head1 NOTES

(注意)

=head2 String C<eval> and C<LC_NUMERIC>

(文字列 C<eval> と C<LC_NUMERIC>)

=begin original

A string L<eval|perlfunc/eval EXPR> parses its expression as standard
Perl.  It is therefore expecting the decimal point to be a dot.  If
C<LC_NUMERIC> is set to have this be a comma instead, the parsing will
be confused, perhaps silently.

=end original

文字列 L<eval|perlfunc/eval EXPR> はその式を標準の Perl としてパースします。
従って小数点がピリオドであることを想定します。
もしこれがカンマであるように C<LC_NUMERIC> が設定されると、パースは
(おそらく暗黙の内に)混乱します。

 use locale;
 use POSIX qw(locale_h);
 setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
 my $x = 1.2;
 print eval "$x + 1.5";
 print "\n";

=begin original

prints C<13,5>.  This is because in that locale, the comma is the
decimal point character.  The C<eval> thus expands to:

=end original

これは C<13,5> を表示します。
これは、このロケールではカンマが小数点文字だからです。
従って C<eval> はこれを次のように展開します:

 eval "1,2 + 1.5"

=begin original

and the result is not what you likely expected.  No warnings are
generated.  If you do string C<eval>'s within the scope of
S<C<use locale>>, you should instead change the C<eval> line to do
something like:

=end original

そして結果はおそらくあなたが想定したものではありません。
警告は出ません。
文字列 C<eval> を S<C<use locale>> スコープ内で行うなら、
C<eval> 行を以下のように変えるべきです:

 print eval "no locale; $x + 1.5";

=begin original

This prints C<2.7>.

=end original

これは C<2.7> を表示します。

=begin original

You could also exclude C<LC_NUMERIC>, if you don't need it, by

=end original

もし不要なら次のようにして C<LC_NUMERIC> を除外できます:

 use locale ':!numeric';

=head2 Backward compatibility

(過去互換性)

=begin original

Versions of Perl prior to 5.004 B<mostly> ignored locale information,
generally behaving as if something similar to the C<"C"> locale were
always in force, even if the program environment suggested otherwise
(see L</The setlocale function>).  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you B<must> use the S<C<use locale>>
pragma (see L</The "use locale" pragma>) or, in the unlikely event
that you want to do so for just pattern matching, the
C</l> regular expression modifier (see L<perlre/Character set
modifiers>) to instruct it to do so.

=end original

5.004 より前のバージョンの Perl では、B<ほとんど> ロケール情報を無視して、
たとえプログラム環境が別のものを指示していたとしても常に C<"C"> ロケール
(L</The setlocale function> を参照) が強制されているかのように
振る舞っていました。
デフォルトでは、Perl は今でもこのように動作するので、過去互換性があります。
Perl アプリケーションをロケール情報に注目するようにしたいのなら、
S<C<use locale>> プラグマ(L</The "use locale" pragma> を参照)あるいは、
あまりなさそうな状況ですが単に正規表現でそうしたいなら、C</l> 正規表現修飾子
(L<perlre/Character set modifiers> 参照) を B<使わなければなりません>。

=begin original

Versions of Perl from 5.002 to 5.003 did use the C<LC_CTYPE>
information if available; that is, C<\w> did understand what
were the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.

=end original

5.002 から 5.003 の Perl は、使用可能である場合には C<LC_CTYPE> の情報を
使っていました; つまり、C<\w> はロケールの環境変数に従った文字を
理解していたのです。
問題は、C ライブラリがロケールをサポートしている場合には Perl がそれを
使ってしまい、ユーザーがこの機能を制御できないということでした。

=head2 I18N:Collate obsolete

(I18N:Collate は古いもの)

=begin original

In versions of Perl prior to 5.004, per-locale collation was possible
using the C<I18N::Collate> library module.  This module is now mildly
obsolete and should be avoided in new applications.  The C<LC_COLLATE>
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with C<use locale>,
so there is no longer any need to juggle with the scalar references of
C<I18N::Collate>.

=end original

5.004 より前のバージョンの Perl では、ロケール毎の照合は C<I18N::Collate>
ライブラリモジュールを使うことで可能でした。
このモジュールは現在、やや時代遅れとなっていて、新しいアプリケーションでは
使用を避けるべきものです。
現在、C<LC_COLLATE> 機能は Perl のコア言語に統合されました:
スカラデータのロケール固有の比較は C<use locale> を使うことで完全に
行なわれます; このため、C<I18N::Collate> のスカラリファレンスを使って
お手玉する必要はもはやないのです。

=head2 Sort speed and memory use impacts

(ソートの速度とメモリ使用に与える影響)

=begin original

Comparing and sorting by locale is usually slower than the default
sorting; slow-downs of two to four times have been observed.  It will
also consume more memory: once a Perl scalar variable has participated
in any string comparison or sorting operation obeying the locale
collation rules, it will take 3-15 times more memory than before.  (The
exact multiplier depends on the string's contents, the operating system
and the locale.) These downsides are dictated more by the operating
system's implementation of the locale system than by Perl.

=end original

ロケールによる比較とソートは通常、デフォルトのソートに比べ二倍から
四倍遅くなります。
また、メモリの使用量も増大します。
Perl のスカラ変数がロケールの照合規則を使ったなんらかの文字列比較や
ソートの中で現れると、それによって以前より三倍から十五倍の時間を
要するようになります(実際のところの乗数は文字列の内容、オペレーティング
システム、ロケールに依存します)。
この性能ダウンは、Perl によるものよりもオペレーティングシステムの
ロケールシステムの実装によるものが顕著に現れます。

=head2 Freely available locale definitions

(自由に利用可能なロケール定義)

=begin original

The Unicode CLDR project extracts the POSIX portion of many of its
locales, available at

=end original

Unicode CLDR プロジェクトは多くのロケールの POSIX 部分を展開します;
以下で利用可能です

  https://unicode.org/Public/cldr/2.0.1/

=begin original

(Newer versions of CLDR require you to compute the POSIX data yourself.
See L<https://unicode.org/Public/cldr/latest/>.)

=end original

(より新しい版の CLDR は、POSIX データを自分自身で計算することを要求します。
L<https://unicode.org/Public/cldr/latest/> を参照してください。)

=begin original

There is a large collection of locale definitions at:

=end original

ここにロケール定義の大規模なコレクションがあります:

  http://std.dkuug.dk/i18n/WG15-collection/locales/

=begin original

You should be aware that it is
unsupported, and is not claimed to be fit for any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.

=end original

これがサポート無しのものであり、どんな目的にも適合するとは
主張していないものであることに注意すべきです。
あなたの使うシステムがロケール機能のインストールを許しているのであれば、
この場所で便利な定義を見つけることができるでしょうし、あるいは自分で
ロケールを定義する基礎となるようなものを見つけられるかもしれません。

=head2 I18n and l10n

(I18n と l10n)

=begin original

"Internationalization" is often abbreviated as B<i18n> because its first
and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, "localization" is often abbreviated to B<l10n>.

=end original

"Internationalization" (国際化)はその最初と最後の文字、そしてその間にある
文字数から B<i18n> としばしば略されます。
(なぜ(英語では) internalin ... internaliti ... i18n が省略されがちか
推測できるかも知れません。)
同様のやり方で、"localization" もしばしば B<l10n> と省略されます。

=head2 An imperfect standard

(不完全な標準)

=begin original

Internationalization, as defined in the C and POSIX standards, can be
criticized as incomplete and ungainly.  They also have a tendency, like
standards groups, to divide the world into nations, when we all know
that the world can equally well be divided into bankers, bikers, gamers,
and so on.

=end original

標準 C や標準 POSIX に定義されている国際対応は、不完全で、扱いにくいと
酷評されます。
また、世界が等しく銀行家、バイク乗り、ゲーマーなどに分割できるのを知るとき、
標準化グループに似て、世界を国に分割しようとする傾向があります。

=head1 Unicode and UTF-8

(Unicode と UTF-8)

=begin original

The support of Unicode is new starting from Perl version v5.6, and more fully
implemented in versions v5.8 and later.  See L<perluniintro>.

=end original

Unicode 対応は Perl バージョン 5.6 から始まり、バージョン 5.8 以降でより
完全に実装されました。
L<perluniintro> を参照してください。

=begin original

Starting in Perl v5.20, UTF-8 locales are supported in Perl, except
C<LC_COLLATE> is only partially supported; collation support is improved
in Perl v5.26 to a level that may be sufficient for your needs
(see L</Category C<LC_COLLATE>: Collation: Text Comparisons and Sorting>).

=end original

Perl v5.20 から、UTF-8 ロケールが Perl で対応されました; ただし
C<LC_COLLATE> は部分的にのみ対応しています;
照合順序対応は Perl v5.26 であなたの用途には十分かもしれない
レベルにまで改良されました
(L</Category C<LC_COLLATE>: Collation: Text Comparisons and Sorting> を
参照してください)。

=begin original

If you have Perl v5.16 or v5.18 and can't upgrade, you can use

=end original

Perl v5.16 または v5.18 を使っていてアップグレードできないなら、次のものが
使えます

    use locale ':not_characters';

=begin original

When this form of the pragma is used, only the non-character portions of
locales are used by Perl, for example C<LC_NUMERIC>.  Perl assumes that
you have translated all the characters it is to operate on into Unicode
(actually the platform's native character set (ASCII or EBCDIC) plus
Unicode).  For data in files, this can conveniently be done by also
specifying

=end original

この形式のプラグマが使われると、ロケールの文字以外の部分、たとえば
C<LC_NUMERIC>、のみが Perl によって使われます。
Perl は、あなたが操作する全ての文字を Unicode (実際にはプラットフォームに
ネイティブな文字集合 (ASCII または EBCDIC) に加えて Unicode) に変換していると
仮定します。
ファイルのデータについては、これは以下のように指定することでも便利に行えます

    use open ':locale';

=begin original

This pragma arranges for all inputs from files to be translated into
Unicode from the current locale as specified in the environment (see
L</ENVIRONMENT>), and all outputs to files to be translated back
into the locale.  (See L<open>).  On a per-filehandle basis, you can
instead use the L<PerlIO::locale> module, or the L<Encode::Locale>
module, both available from CPAN.  The latter module also has methods to
ease the handling of C<ARGV> and environment variables, and can be used
on individual strings.  If you know that all your locales will be
UTF-8, as many are these days, you can use the
L<B<-C>|perlrun/-C [numberE<sol>list]> command line switch.

=end original

このプラグマは、ファイルからの全ての入力について環境変数で指定されている
ロケール (L</ENVIRONMENT> 参照) から Unicode への変換と、ファイルへの
全ての出力についてそのロケールへ逆変換を行います。
(L<open> 参照)。
ファイルハンドル単位では、どちらも CPAN から利用可能である
L<PerlIO::locale> モジュールか L<Encode::Locale> が代わりに使えます。
後者のモジュールは C<ARGV> と環境変数の扱いを簡単にするメソッドも持ち、
個々の文字列で使えます。
最近多い状況として、使うロケールが UTF-8 だけであることが
分かっているなら、
L<B<-C>|perlrun/-C [numberE<sol>list]> コマンドラインオプションが使えます。

=begin original

This form of the pragma allows essentially seamless handling of locales
with Unicode.  The collation order will be by Unicode code point order.
L<Unicode::Collate> can be used to get Unicode rules collation.

=end original

この形式のプラグマは、本質的にロケールと Unicode の扱いをシームレスにします。
照合順序は Unicode の符号位置順です。
L<Unicode::Collate> は Unicode 規則の照合順序を得るのに使えます。

=begin original

All the modules and switches just described can be used in v5.20 with
just plain C<use locale>, and, should the input locales not be UTF-8,
you'll get the less than ideal behavior, described below, that you get
with pre-v5.16 Perls, or when you use the locale pragma without the
C<:not_characters> parameter in v5.16 and v5.18.  If you are using
exclusively UTF-8 locales in v5.20 and higher, the rest of this section
does not apply to you.

=end original

ここで記述されている全てのモジュールとスイッチは、
v5.20 からは単に C<use locale> と書くだけで使えます;
入力が UTF-8 でなく、v5.16 より前の Perl を使うか、
あるいは、v5.16 と v5.18 で
C<:not_characters> 引数なしで locale プラグマを使ったとき、
理想とは遠い振る舞いになります。
v5.20 以上で UTF-8 ロケールのみを使う場合は、この章の残りの内容は
適用されません。

=begin original

There are two cases, multi-byte and single-byte locales.  First
multi-byte:

=end original

マルチバイトロケールと単一バイトロケールの二つの場合があります。
まずマルチバイトの場合:

=begin original

The only multi-byte (or wide character) locale that Perl is ever likely
to support is UTF-8.  This is due to the difficulty of implementation,
the fact that high quality UTF-8 locales are now published for every
area of the world (L<https://unicode.org/Public/cldr/2.0.1/> for
ones that are already set-up, but from an earlier version;
L<https://unicode.org/Public/cldr/latest/> for the most up-to-date, but
you have to extract the POSIX information yourself), and
failing all that, you can use the L<Encode> module to translate to/from
your locale.  So, you'll have to do one of those things if you're using
one of these locales, such as Big5 or Shift JIS.  For UTF-8 locales, in
Perls (pre v5.20) that don't have full UTF-8 locale support, they may
work reasonably well (depending on your C library implementation)
simply because both
they and Perl store characters that take up multiple bytes the same way.
However, some, if not most, C library implementations may not process
the characters in the upper half of the Latin-1 range (128 - 255)
properly under C<LC_CTYPE>.  To see if a character is a particular type
under a locale, Perl uses the functions like C<isalnum()>.  Your C
library may not work for UTF-8 locales with those functions, instead
only working under the newer wide library functions like C<iswalnum()>,
which Perl does not use.
These multi-byte locales are treated like single-byte locales, and will
have the restrictions described below.  Starting in Perl v5.22 a warning
message is raised when Perl detects a multi-byte locale that it doesn't
fully support.

=end original

Perl が対応していると言える唯一のマルチバイト(ワイド文字)ロケールは
UTF-8 です。
これは、実装の難しさ、高品質な UTF-8 ロケールは世界中のあらゆる
分野で使われているという事実
(L<https://unicode.org/Public/cldr/2.0.1/> は既に設定されている版ですが、
以前の版からのものです;
L<https://unicode.org/Public/cldr/latest/> は最新版ですが、
POSIX 情報を自分で展開する必要があります)、他のロケールと変換するために
L<Encode> モジュールを使えるというのが理由です。
従って、Big5 や Shift JIS のようなこれらのロケールの一つを使っている場合、
これらのどれか一つを行う必要があります。
UTF-8 ロケールに関しては、完全な UTF-8 ロケール対応のない
(v5.20 より前の) Perl でも十分にうまく動くかもしれません
(C ライブラリの実装に依存します); 単にこれらと
Perl はマルチバイトになる文字を同じ方法で保管するからです。
しかし、ほとんどではなかったとしても時々、C ライブラリ実装は、C<LC_CTYPE> の
下では Latin-1 の範囲の上半分 (128 - 255) の文字を正しく扱えません。
ロケールの下である文字が特定の型を持っているかどうかを見るために、Perl は
C<isalnum()> のような関数を使います。
使っている C ライブラリは UTF-8 ロケールに対してこれらの関数が動作せず、
代わりに Perl が使わない C<iswalnum()> のような新しい
ワイド文字ライブラリ関数のみが動作するかもしれません。
これらのマルチバイトロケールは単一バイトロケールのように扱われ、後述するような
制限があります。
Perl v5.22 から、Perl が完全に対応していないマルチバイトロケールを検出すると
警告メッセージが発生します。

=begin original

For single-byte locales,
Perl generally takes the tack to use locale rules on code points that can fit
in a single byte, and Unicode rules for those that can't (though this
isn't uniformly applied, see the note at the end of this section).  This
prevents many problems in locales that aren't UTF-8.  Suppose the locale
is ISO8859-7, Greek.  The character at 0xD7 there is a capital Chi. But
in the ISO8859-1 locale, Latin1, it is a multiplication sign.  The POSIX
regular expression character class C<[[:alpha:]]> will magically match
0xD7 in the Greek locale but not in the Latin one.

=end original

単一バイトロケールでは、Perl は一般的にシングルバイトに合う符号位置の
ロケールルールを使い、それが出来ないときは Unicode のルールを使う方針を
とります (しかしこれは一様には適用されません; この節の末尾の注意を
参照してください)。
これは UTF-8 でないロケールでの多くの問題を防ぎます。
ロケールがギリシャ語の ISO8859-7 であると仮定します。
0xD7 の文字は capital Chi です。
しかし Latin1 である ISO8859-1 ロケールでは、これは乗算記号です。
POSIX 正規表現文字クラス C<[[:alpha:]]> はマジカルに、ギリシャ語ロケールでは
0xD7 にマッチングするけれども Latin ロケールではマッチングしません。

=begin original

However, there are places where this breaks down.  Certain Perl constructs are
for Unicode only, such as C<\p{Alpha}>.  They assume that 0xD7 always has its
Unicode meaning (or the equivalent on EBCDIC platforms).  Since Latin1 is a
subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and
Unicode, C<\p{Alpha}> will never match it, regardless of locale.  A similar
issue occurs with C<\N{...}>.  Prior to v5.20, it is therefore a bad
idea to use C<\p{}> or
C<\N{}> under plain C<use locale>--I<unless> you can guarantee that the
locale will be ISO8859-1.  Use POSIX character classes instead.

=end original

しかし、これを分解してみます。
C<\p{Alpha}> のような一部の Perl の構文は Unicode のみです。
これらは 0xD7 は常に Unicode での意味 (あるいは EBCDIC プラットフォームでの
等価物) を持つと仮定します。
Latin1 は Unicode の部分集合でであり、0xD7 は Latin1 と Unicode の両方で
乗算記号なので、ロケールに関わらず C<\p{Alpha}> はマッチングしません。
同じような問題は C<\N{...}> で起こります。
v5.20 以前では、従って生の C<use locale> で C<\p{}> や C<\N{}> を使うのは
悪い考えです --
ロケールが ISO8859-1 であることを I<保証できないかぎり> です。
代わりに POSIX 文字クラスを使ってください。

=begin original

Another problem with this approach is that operations that cross the
single byte/multiple byte boundary are not well-defined, and so are
disallowed.  (This boundary is between the codepoints at 255/256.)
For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178)
should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF).  But in the
Greek locale, for example, there is no character at 0xFF, and Perl
has no way of knowing what the character at 0xFF is really supposed to
represent.  Thus it disallows the operation.  In this mode, the
lowercase of U+0178 is itself.

=end original

この手法のもう一つの問題は、1 バイト/複数バイトの境界をまたぐ操作は
未定義なので、許可されていません。
(この境界は符号位置 255/256 の間です。)
例えば LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) の小文字化は
LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF) を返すべきです。
しかし、例えばギリシャ語ロケールでは、0xFF に文字はなく、Perl には 0xFF の
文字が実際に何を表現しているかを知る方法はありません。
従ってこの操作は許可されません。
このモードでは、U+0178 の小文字は自分自身です。

=begin original

The same problems ensue if you enable automatic UTF-8-ification of your
standard file handles, default C<open()> layer, and C<@ARGV> on non-ISO8859-1,
non-UTF-8 locales (by using either the B<-C> command line switch or the
C<PERL_UNICODE> environment variable; see
L<perlrun|perlrun/-C [numberE<sol>list]>).
Things are read in as UTF-8, which would normally imply a Unicode
interpretation, but the presence of a locale causes them to be interpreted
in that locale instead.  For example, a 0xD7 code point in the Unicode
input, which should mean the multiplication sign, won't be interpreted by
Perl that way under the Greek locale.  This is not a problem
I<provided> you make certain that all locales will always and only be either
an ISO8859-1, or, if you don't have a deficient C library, a UTF-8 locale.

=end original

同じ問題は、(B<-C> コマンドラインオプションか C<PERL_UNICODE> 環境変数を
使って (L<perlrun|perlrun/-C [numberE<sol>list]> を参照してください))
ISO-8859-1 でも UTF-8 でもない
ロケールの標準ファイルハンドル、デフォルト C<open()> 層、C<@ARGV> の
自動 UTF-8 化を有効にしている場合にも起こります。
これらは UTF-8 として読み込まれ、普通は暗黙に Unicode として
解釈されますが、ロケールの存在によって、代わりにそのロケールとして
解釈されます。
例えば、Unicode 入力での符号位置 0xD7 は、乗算記号を意味するべきですが、
ギリシャ語ロケールでは Perl はそのようには解釈しません。
全てのロケールが常に ISO-8859-1 か、不十分な C ライブラリを持っていないなら
UTF-8 ロケール、のどちらかだけであることが I<確実なら> 問題ではありません。

=begin original

Still another problem is that this approach can lead to two code
points meaning the same character.  Thus in a Greek locale, both U+03A7
and U+00D7 are GREEK CAPITAL LETTER CHI.

=end original

もう一つの問題は、この手法は同じ文字を意味する二つの符号位置を
持つことになることです。
従ってギリシャ語ロケールでは、U+03A7 と U+00D7 はどちらも
GREEK CAPITAL LETTER CHI です。

=begin original

Because of all these problems, starting in v5.22, Perl will raise a
warning if a multi-byte (hence Unicode) code point is used when a
single-byte locale is in effect.  (Although it doesn't check for this if
doing so would unreasonably slow execution down.)

=end original

これら全ての問題のために、v5.22 から、Perl は単一バイトロケールが有効のときに
マルチバイト(つまり Unicode) 符号位置が使われると警告を出力します。
(しかしこのためにチェックはしません; そうすると実行速度が不当に
遅くなるからです。)

=begin original

Vendor locales are notoriously buggy, and it is difficult for Perl to test
its locale-handling code because this interacts with code that Perl has no
control over; therefore the locale-handling code in Perl may be buggy as
well.  (However, the Unicode-supplied locales should be better, and
there is a feed back mechanism to correct any problems.  See
L</Freely available locale definitions>.)

=end original

ベンダロケールはバグ持ちで悪名高く、これは Perl が制御できないコードと
相互作用するので、Perl がロケール操作コードをテストするのは困難です;
従って Perl のロケール操作コードは同様にバグ持ちかもしれません。
(しかし、Unicode が提供しているロケールはより良いはずで、問題を修正するための
フィードバック機構があります。
L</Freely available locale definitions> を参照してください。)

=begin original

If you have Perl v5.16, the problems mentioned above go away if you use
the C<:not_characters> parameter to the locale pragma (except for vendor
bugs in the non-character portions).  If you don't have v5.16, and you
I<do> have locales that work, using them may be worthwhile for certain
specific purposes, as long as you keep in mind the gotchas already
mentioned.  For example, if the collation for your locales works, it
runs faster under locales than under L<Unicode::Collate>; and you gain
access to such things as the local currency symbol and the names of the
months and days of the week.  (But to hammer home the point, in v5.16,
you get this access without the downsides of locales by using the
C<:not_characters> form of the pragma.)

=end original

Perl v5.16 を使っているなら、(非文字部にベンダバグがない限り)
locale プラグマに C<:not_characters> 引数を使えば前述した問題はなくなります。
v5.16 がなく、動作するロケールが I<ある> なら、それを使うことは、既に言及した
コツを心に留めている限りは、ある種の特定の用途には価値があるかもしれません。
例えば、ロケール下での照合が動作するなら、
L<Unicode::Collate> 下でのロケールよりも高速に実行されます;
そしてローカルな通貨記号、月や週の名前のようなものへのアクセスを得ます。
(しかし要点を銘記するために、v5.16 では、プラグマの C<:not_characters> 形式を
使うことでロケールの弱点なしにこれにアクセスできます。)

=begin original

Note: The policy of using locale rules for code points that can fit in a
byte, and Unicode rules for those that can't is not uniformly applied.
Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly
consistently to regular expression matching except for bracketed
character classes; in v5.14 it was extended to all regex matches; and in
v5.16 to the casing operations such as C<\L> and C<uc()>.  For
collation, in all releases so far, the system's C<strxfrm()> function is
called, and whatever it does is what you get.  Starting in v5.26, various
bugs are fixed with the way perl uses this function.

=end original

注意、1 バイトに収まる符号位置に対してロケールの規則を使うポリシーと、
収まらないものに対する Unicode の規則を使うポリシーについては、一律には
適用されません。
v5.12 より前では、これは場当たり的でした; v5.12 では、大かっこ文字クラス以外の
正規表現マッチングではかなり一貫して適用されました; v5.14 では全ての
正規表現マッチングに拡大されました; v5.16 では C<\L> や C<uc()> のような
大文字小文字操作に拡大されました。
照合については、今までの全てのリリースについて、システムの C<strxfrm()> 関数が
呼び出され、その結果が結果となります。
v5.26 から、perl がこの関数を使う方法に関する様々なバグが修正されました。

=head1 BUGS

(バグ)

=head2 Collation of strings containing embedded C<NUL> characters

(組み込みの C<NUL> 文字を含む文字列の照合順序)

=begin original

C<NUL> characters will sort the same as the lowest collating control
character does, or to C<"\001"> in the unlikely event that there are no
control characters at all in the locale.  In cases where the strings
don't contain this non-C<NUL> control, the results will be correct, and
in many locales, this control, whatever it might be, will rarely be
encountered.  But there are cases where a C<NUL> should sort before this
control, but doesn't.  If two strings do collate identically, the one
containing the C<NUL> will sort to earlier.  Prior to 5.26, there were
more bugs.

=end original

C<NUL> 文字は最も低い照合順序を持つ制御文字、
またはロケール中に全く制御文字がないというありそうにない状況の場合は
C<"\001"> と同じようにソートされます。
文字列にこの非 C<NUL> 制御文字が含まれていない場合、
結果は正しく、多くのロケールでは、それがなんであれ、この制御文字に
出会うことは稀でしょう。
しかし C<NUL> はこの制御文字の前にソートされるべき場合がありますが、
そうはなりません。
二つの文字列が同一のものとして照合された場合、C<NUL> を含むものが
より前にソートされます。
5.26 より前では、もっと多くのバグがありました。

=head2 C<LANGUAGE>

=begin original

As stated above, Perl ignores this environment variable.

=end original

前述したように、Perl はこの環境変数を無視します。

=head2 Embedded perls and multi-threaded

=begin original

You should not change the locale after startup on a platform where
C<${^SAFE_LOCALES}> is 0.  It will always be 1 on an unthreaded
platform.

=end original

C<${^SAFE_LOCALES}> が 0 のプラットフォームでは、
起動後にロケールを変更するべきではありません。
これはスレッド対応していないプラットフォームでは常に 1 です。

=begin original

XS writers should refer to L<perlclib/Dealing with embedded perls and threads>.

=end original

XS 作者は L<perlclib/Dealing with embedded perls and threads> を
参照するべきです。

=head2 Broken systems

(壊れているシステム)

=begin original

On a few remaining systems, the operating system's locale support
is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when
C<use locale> is in effect.  When confronted with such a system,
please report in excruciating detail to
<L<https://github.com/Perl/perl5/issues>>, and
also contact your vendor: bug fixes may exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.  If you have the source for Perl, include in
the bug report the output of the test described above in L</Testing
for broken locales>.

=end original

いくつかの残っているオペレーティングシステムにおける環境での
ロケールサポートはおかしなもので、Perl がそれに対処したり
使ったりできないようなものです。
そういった不完全なものは、C<use locale> が有効になったときに Perl を
不可思議なハングアップに導いたり、コアダンプをさせたりします。
このようなシステムに直面した場合、詳しい状況を
<L<https://github.com/Perl/perl5/issues>> に
レポートし、そして使用しているシステムのベンダーに連絡してください:
問題の幾つかに対するバグフィックスがされているかもしれません。
そういったバグ修正は、オペレーティングシステムのアップグレードと
呼ばれることがあります。
Perl のソースがあるなら、前述の L</Testing for broken locales> で
記述されているテストの出力をバグ報告に含めてください。

=head1 SEE ALSO

L<I18N::Langinfo>, L<perluniintro>, L<perlunicode>, L<open>,
L<POSIX/localeconv>,
L<POSIX/setlocale>, L<POSIX/strcoll>, L<POSIX/strftime>,
L<POSIX/strtod>, L<POSIX/strxfrm>.

=begin original

For special considerations when Perl is embedded in a C program,
see L<perlembed/Using embedded Perl with POSIX locales>.

=end original

Perl が C プログラムに組み込まれているときに特に考慮することについては
L<perlembed/Using embedded Perl with POSIX locales> を参照してください。

=head1 HISTORY

=begin original

Jarkko Hietaniemi's original F<perli18n.pod> heavily hacked by Dominic
Dunlop, assisted by the perl5-porters.  Prose worked over a bit by
Tom Christiansen, and now maintained by Perl 5 porters.

=end original

Jarkko Hietaniemi の原文書 F<perli18n.pod> は perl5-porters の助けの元、
Dominic Dunlop によって大きく変更されました。
表現に関しては Tom Christiansen が少し作業をし、Perl 5 porters によって
保守されています。

=begin meta

Translate: KIMURA Koichi
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.8.8-)
Status: completed

=end meta

