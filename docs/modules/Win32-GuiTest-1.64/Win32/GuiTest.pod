
=encoding utf8

=head1 NAME

=begin original

Win32::GuiTest - Perl GUI Test Utilities.

=end original

Win32::GuiTest - Perl GUI テストユーティリティ

=head1 SYNOPSIS

  use Win32::GuiTest qw(FindWindowLike GetWindowText 
    SetForegroundWindow SendKeys);

  $Win32::GuiTest::debug = 0; # Set to "1" to enable verbose mode

  my @windows = FindWindowLike(0, "^Microsoft Excel", "^XLMAIN\$");
  for (@windows) {
      print "$_>\t'", GetWindowText($_), "'\n";
      SetForegroundWindow($_);
      SendKeys("%fn~a{TAB}b{TAB}{BS}{DOWN}");
  }

=head1 INSTALLATION

    // This batch file comes with MS Visual Studio.  Running
    // it first might help with various compilation problems.
    vcvars32.bat 

    perl makefile.pl
    nmake
    nmake test
    nmake install

    See more details in the DEVELOPMENT section elswhere in this document.

=begin original

You can get the most recent release from 
L<http://www.sourceforge.net/projects/winguitest>. The package will
contain Win32-GuiTest.ppd file and Win32-GuiTest.tar.gz file, 
which is all that you need to use
ppm. If you put those 2 files in C:\TEMP directory, the installation
should look as follows.  Enter PPM (Perl Package Manager) from the 
command-line and type commands as below

=end original

You can get the most recent release from 
L<http://www.sourceforge.net/projects/winguitest>. The package will
contain Win32-GuiTest.ppd file and Win32-GuiTest.tar.gz file, 
which is all that you need to use
ppm. If you put those 2 files in C:\TEMP directory, the installation
should look as follows.  Enter PPM (Perl Package Manager) from the 
command-line and type commands as below
(TBT)

    C:\TEMP>ppm
    PPM interactive shell (2.0) - type 'help' for available commands.
    PPM> install C:\temp\win32-guitest.ppd
    Install package 'C:\temp\win32-guitest.ppd?' (y/N): Y
    Retrieving package 'C:\temp\win32-guitest.ppd'...
    Writing C:\Perl\site\lib\auto\Win32\GuiTest\.packlist
    PPM>

=begin original

I extracted them to 'c:\temp', please use the directory where you extracted 
the files instead.

=end original

私は'c:\temp'に展開しました;
あなたが展開したディレクトリを代わりに使ってください。

=head1 DESCRIPTION

=begin original

Most GUI test scripts I have seen/written for Win32 use some variant of Visual
Basic (e.g. MS-VB or MS-Visual Test). The main reason is the availability of
the SendKeys function.

=end original

私がこれまで見てきた/書いてきた、ほとんどの Win32 用の GUI テストスクリプトは
なんらかの Visual Basic の一種(例えば MS-VB あるいは MS-Visual Test など）を
使っていました。
その主な理由は SendKeys 関数が使えるということです。

=begin original

A nice way to drive Win32 programs from a test script is to use OLE Automation
(ActiveX Scripting), but not all Win32 programs support this interface. That is
where SendKeys comes handy.

=end original

テストスクリプトから Win32 プログラムを動かす素晴らしい方法は、
OLE オートメーション (ActiveX スクリプティング）です。
しかし全ての Win32 プログラムがこのインターフェースを
サポートしているわけではありません。
それこど Sendkeys が役に立つのです。

=begin original

Some time ago Al Williams published a Delphi version in Dr. Dobb's
(http://www.drdobbs.com/keys-to-the-kingdom/184410429). I ported it to C and
packaged it using h2xs...

=end original

以前 Al Williams は Dr. Dobb's で Delphi 版を公開しました
(http://www.drdobbs.com/keys-to-the-kingdom/184410429)。
私はそれを C に移植し、h2xs を使ってパッケージ化しました...。

=begin original

The tentative name for this module is Win32::GuiTest (mostly because I plan to
include more GUI testing functions).

=end original

私は迷いながらもこのモジュールの名前を Win32::GuiTest としました
(私がより多くの GUI テスト機能を入れることを考えているのが主な理由です)。

=begin original

I've created a Yahoo Group for the module that you can join at
   http://groups.yahoo.com/group/perlguitest/join

=end original

みなさんが参加することができる、このモジュールのための Yahoo グループを作成
しています:
   http://groups.yahoo.com/group/perlguitest/join

=begin original

Also, an initial version of a script recording application has been written to use with this 
module.  A copy of it may be found with this distribution (Recorder\Win32GuiTest.exe)
or can be obtained at http://sourceforge.net/projects/winguitest

=end original

Also, an initial version of a script recording application has been written to use with this 
module.  A copy of it may be found with this distribution (Recorder\Win32GuiTest.exe)
or can be obtained at http://sourceforge.net/projects/winguitest
(TBT)

=begin original

If the documentation of these functions is not satisfactory, you can 
try running a search on http://msdn.microsoft.com/ using the name of the function. 
Some of these functions are described there.

=end original

If the documentation of these functions is not satisfactory, you can 
try running a search on http://msdn.microsoft.com/ using the name of the function. 
Some of these functions are described there.
(TBT)

=begin original

This distribution of the module - the one you are looking at now - has
its own CVS repository at http://sourceforge.net/projects/winguitest
Patches to both the code and the documentation are welcome.

=end original

This distribution of the module - the one you are looking at now - has
its own CVS repository at http://sourceforge.net/projects/winguitest
Patches to both the code and the documentation are welcome.
(TBT)

=cut

=head2 Functions

(関数)

=over 4

=item $debug

=begin original

When set enables the verbose mode.

=end original

設定すると冗長モードになります。

=item SendKeys($keys[,$delay])

=begin original

Sends keystrokes to the active window as if typed at the keyboard using the
optional delay between key-up and key-down messages (default is 25 ms and
should be OK for most uses). 

=end original

オプションでキーストロークの間に遅延を入れながら、アクティブな
ウィンドウにまるでキボードから打ち込んだようにキーアップと
キーダウンのメッセージを送信します
(デフォルトは25msでほとんどの利用では大丈夫でしょう)。

=begin original

The keystrokes to send are specified in KEYS. There are several
characters that have special meaning. This allows sending control codes 
and modifiers:

=end original

送信されるキーストロークはKEYSで指定されます。
いくつかの特別な意味を持つ文字があります。
これにより制御コードや修飾子も送信することができます:

	~ means ENTER
	+ means SHIFT 
	^ means CTRL 
	% means ALT

=begin original

The parens allow character grouping. You may group several characters, so
that a specific keyboard modifier applies to all of them. Groups can
be enclosed in groups.

=end original

括弧により文字をグループ化することができます。
いくつかの文字をグループにすることができ、
特定のキーボードの修飾子をそれらの全てに適用することができます。
グループはグループで囲むことができます。

=begin original

E.g. SendKeys("ABC") is equivalent to SendKeys("+(abc)")

=end original

例: SendKeys("ABC") は SendKeys("+(abc)") でも同じです

=begin original

The curly braces are used to quote special characters (SendKeys("{+}{{}")
sends a '+' and a '{'). You can also use them to specify certain named actions:

=end original

中かっこは特殊文字を引用するために使われます(SendKeys("{+}{{}") は
は'+'と'{'を送信します)。またそれらを使って名前が付けられたアクションを
使うことが出来ます:

=begin original

	Name          Action

=end original

	名前          アクション

=begin original

	{BACKSPACE}   Backspace
	{BS}          Backspace
	{BKSP}        Backspace
	{BREAK}       Break
	{CAPS}        Caps Lock
	{DELETE}      Delete
	{DOWN}        Down arrow
	{END}         End
	{ENTER}       Enter (same as ~)
	{ESCAPE}      Escape
	{HELP}        Help key
	{HOME}        Home
	{INSERT}      Insert
	{LEFT}        Left arrow
	{NUMLOCK}     Num lock
	{PGDN}        Page down
	{PGUP}        Page up
	{PRTSCR}      Print screen
	{RIGHT}       Right arrow
	{SCROLL}      Scroll lock
	{TAB}         Tab
	{UP}          Up arrow
	{PAUSE}       Pause
        {F1}          Function Key 1
        ...           ...
        {F24}         Function Key 24
        {SPC}         Spacebar
        {SPACE}       Spacebar
        {SPACEBAR}    Spacebar
        {LWI}         Left Windows Key
        {RWI}         Right Windows Key 
        {APP}         Open Context Menu Key

=end original

	{BACKSPACE}   Backspace
	{BS}          Backspace
	{BKSP}        Backspace
	{BREAK}       Break
	{CAPS}        Caps Lock
	{DELETE}      Delete
	{DOWN}        下矢印
	{END}         End
	{ENTER}       Enter (~ と同じ)
	{ESCAPE}      Escape
	{HELP}        Help キー
	{HOME}        Home
	{INSERT}      Insert
	{LEFT}        左矢印
	{NUMLOCK}     Num lock
	{PGDN}        Page down
	{PGUP}        Page up
	{PRTSCR}      Print screen
	{RIGHT}       右矢印
	{SCROLL}      Scroll lock
	{TAB}         Tab
	{UP}          上矢印
	{PAUSE}       Pause
        {F1}          ファンクションキー 1
        ...           ...
        {F24}         ファンクションキー 24
        {SPC}         スペース
        {SPACE}       スペース
        {SPACEBAR}    スペース
        {LWI}         左 Windows キー
        {RWI}         右 Windows キー
        {APP}         コンテキストメニューキー

=begin original

or supply a number that will be treated as a VK code. Note that a single-digit
number will be treated as a character, so prepend these with '0'.

=end original

or supply a number that will be treated as a VK code. Note that a single-digit
number will be treated as a character, so prepend these with '0'.
(TBT)

=begin original

All these named actions take an optional integer argument, like in {RIGHT 5}. 
For all of them, except PAUSE, the argument means a repeat count. For PAUSE
it means the number of milliseconds SendKeys should pause before proceding.

=end original

これらの全ての名前付きのアクションは、{RIGHT 5} のようにオプションで整数の
引数を取ります。
PAUSE を除いた全てにとっては、引数は繰り返しの回数を意味します。
PAUSE にとっては、先に進む前に SendKeys が中断するミリ秒数を意味します。

=begin original

In this implementation, SendKeys always returns after sending the keystrokes.
There is no way to tell if an application has processed those keys when the
function returns.

=end original

この実装では、SendKeys は、キーストロークを送信した後、常に戻ります。
この関数が戻ってきたとき、アプリケーションがそれらのキーを
処理し終えているかを知る方法はありません。

=begin original

Unicode characters in C<$keys> are translated into set of ALT+NUMPAD keystrokes.
Note that not all applications can understand unicode input.

=end original

Unicode characters in C<$keys> are translated into set of ALT+NUMPAD keystrokes.
Note that not all applications can understand unicode input.
(TBT)

=cut

=item SendMouse($command)

=begin original

This function emulates mouse input.  The COMMAND parameter is a string
containing one or more of the following substrings:

=end original

この関数はマウス入力をエミュレートします。COMMANDパラメータは
１つあるいはそれ以上の文字列が入った文字列です:

=begin original

        {LEFTDOWN}    left button down
        {LEFTUP}      left button up
        {MIDDLEDOWN}  middle button down
	{MIDDLEUP}    middle button up
	{RIGHTDOWN}   right button down
	{RIGHTUP}     right button up
	{LEFTCLICK}   left button single click
	{MIDDLECLICK} middle button single click
	{RIGHTCLICK}  right button single click
	{ABSx,y}      move to absolute coordinate ( x, y )
        {RELx,y}      move to relative coordinate ( x, y )

=end original

        {LEFTDOWN}    左ボタンのダウン
        {LEFTUP}      左ボタンのアップ
        {MIDDLEDOWN}  中ボタンのダウン
	{MIDDLEUP}    中ボタンのアップ
	{RIGHTDOWN}   右ボタンのダウン
	{RIGHTUP}     右ボタンのアップ
	{LEFTCLICK}   左ボタンのシングルクリック
	{MIDDLECLICK} 中ボタンのシングルクリック
	{RIGHTCLICK}  右ボタンのシングルクリック
	{ABSx,y}      絶対座標( x, y )に移動
        {RELx,y}      相対座標( x, y )に移動

=begin original

Note: Absolute mouse coordinates range from 0 to 65535.
      Relative coordinates can be positive or negative.
      If you need pixel coordinates you can use MouseMoveAbsPix.

=end original

注意: 絶対マウス座標の範囲は 0 から 65535 になります。
      相対座標は正にも負にもなります。
      ピクセル座標が必要であれば、MouseMoveAbsPix を使えます。

=begin original

Also equivalent low-level functions are available:

=end original

同等の低レベルの関数を利用することもできます:

    SendLButtonUp()
    SendLButtonDown()
    SendMButtonUp()
    SendMButtonDown()
    SendRButtonUp()
    SendRButtonDown()
    SendMouseMoveRel(x,y)
    SendMouseMoveAbs(x,y)

=cut

=item MouseMoveAbsPix($x,$y)

=begin original

Move the mouse cursor to the screen pixel indicated as parameter.

=end original

パラメータとして指定された画面上のピクセルにマウスカーソルを
移動します。

=begin original

  # Moves to x=200, y=100 in pixel coordinates.
  MouseMoveAbsPix(200, 100);

=end original

  # ピクセル座標での x=200, y=100 に移動します。
  MouseMoveAbsPix(200, 100); 

=cut

=item MouseMoveWheel($change)

=begin original

  Positive or negative value to direct mouse wheel movement.

=end original

  マウスホイールの動きを示す正または負の値

=cut

=item FindWindowLike($window,$titleregex,$classregex,$childid,$maxlevel) 

=begin original

Finds the window handles of the windows matching the specified parameters and
returns them as a list. 

=end original

指定されたパラメータにマッチするウィンドウのウィンドウハンドルを探し、
それをリストで返します。

=begin original

You may specify the handle of the window to search under. The routine 
searches through all of this windows children and their children recursively.
If 'undef' then the routine searches through all windows. There is also a 
regexp used to match against the text in the window caption and another regexp
used to match against the text in the window class. If you pass a child ID 
number, the functions will only match windows with this id. In each case 
undef matches everything.

=end original

検索対象のウィンドウハンドルを指定できます。
このルーチンはこのウィンドウの全ての子供とさらにその子供を
再帰的に検索していきます。
もし 'undef' であれば、このルーチンは全てのウィンドウを探していきます。
ウィンドウのキャプションの文字列にマッチングさせるために使われるものと
ウィンドウクラスのテキストにマッチングさせるために
使われるものの二つの正規表現もあります。
子 ID 番号を渡すと、この関数はその ID を持つウィンドウにのみマッチングします。
いずれも undef は全てにマッチングします。

=cut

=item GetWindowID($window)

=begin original

    Returns the control Id of the specified window.

=end original

    Returns the control Id of the specified window.
(TBT)

=cut

=item PushButton($button[,$delay])

=begin original

Equivalent to

=end original

次のものと同じです:

    PushChildButton(GetForegroundWindow, BUTTON, DELAY)

=cut

=item PushChildButton($parent,$button[,$delay])

=begin original

Allows generating a mouse click on a particular button.

=end original

特定のボタンへのマウスクリックを生成することを可能にします。

=begin original

parent - the parent window of the button

=end original

parent - そのボタンの親ウィンドウ

=begin original

button - either the text in a button (e.g. "Yes") or the control ID
of a button.

=end original

button - ボタンのテキスト(例えば "Yes")あるいは、ボタンの
コントロールIDのどちらかです。

=begin original

delay - the time (0.25 means 250 ms) to wait between the mouse down
and the mouse up event. This is useful for debugging.

=end original

delay - マウスダウンとマウスアップイベントの間の時間
(0.25 は 250 ms を意味します)を意味します。これはデバッグのときに
便利です。

=cut

=item PushChildById( $parent, $button, $level, $delay )

=begin original

Allows pushing a button, which control id is eqaul to a given parameter.
C<PushChildButton> tries to match parameter against control id or
caption.
PushChildById matches only against control id. Secondly, PushChildById
allows specifying search depth in the windows hierarchy tree.
The default is 2, which means that only direct children will be
pushed.

=end original

Allows pushing a button, which control id is eqaul to a given parameter.
C<PushChildButton> tries to match parameter against control id or
caption.
PushChildById matches only against control id. Secondly, PushChildById
allows specifying search depth in the windows hierarchy tree.
The default is 2, which means that only direct children will be
pushed.
(TBT)

=cut

=item WaitWindowLike($parent,$wndtitle,$wndclass,$wndid,$depth,$wait)

=begin original

Function which allows one to wait for a window to appear
vs. using hard waits (e.g. sleep 2).

=end original

Function which allows one to wait for a window to appear
vs. using hard waits (e.g. sleep 2).
(TBT)

=begin original

parent   - Where to start (parent window)

=end original

parent   - Where to start (parent window)
(TBT)

=begin original

wndtitle - Regexp for the window title

=end original

wndtitle - Regexp for the window title
(TBT)

=begin original

wndclass - Regexp for the window class name

=end original

wndclass - Regexp for the window class name
(TBT)

=begin original

wndid    - Numeric Window or Control ID

=end original

wndid    - Numeric Window or Control ID
(TBT)

=begin original

depth    - How deep should we search before we stop

=end original

depth    - How deep should we search before we stop
(TBT)

=begin original

wait     - How many seconds should we wait before giving up

=end original

wait     - How many seconds should we wait before giving up
(TBT)

=cut

=item WaitWindow($wndtitle,[$wait])

=begin original

Minimal version of WaitWindowLike. Only requires the window title
regexp. You can also specify the wait timeout in seconds.

=end original

Minimal version of WaitWindowLike. Only requires the window title
regexp. You can also specify the wait timeout in seconds.
(TBT)

=begin original

wndtitle - Regexp for the window title

=end original

wndtitle - Regexp for the window title
(TBT)

=begin original

wait     - How many seconds should we wait before giving up

=end original

wait     - How many seconds should we wait before giving up
(TBT)

=cut

=item IsWindowStyle($window, $style)

=begin original

    Determines if a window has the specified style.  See sample
    script for more details.

=end original

    Determines if a window has the specified style.  See sample
    script for more details.
(TBT)

=cut

=item IsWindowStyleEx($window, $exstyle)

=begin original

    Determines if a window has the specified extended
    style.  See sample script for more details.

=end original

    Determines if a window has the specified extended
    style.  See sample script for more details.
(TBT)

=cut

=item GetMenu

=begin original

Using the corresponding library function (see MSDN) it returns a MenuID number

=end original

Using the corresponding library function (see MSDN) it returns a MenuID number
(TBT)

=item GetMenuItemIndex($curr, $menu);

=begin original

$curr is a MenuId and $menu is the (localized !) name of the menu including the hot
key:  "Rep&eate"  
Returns the index of the menu item (-1 if not found) 

=end original

$curr is a MenuId and $menu is the (localized !) name of the menu including the hot
key:  "Rep&eate"  
Returns the index of the menu item (-1 if not found) 
(TBT)

=item GetMenuItemCount($menu)

=begin original

Returns the number of elements in the given menu.

=end original

Returns the number of elements in the given menu.
(TBT)

=item MenuSelect($menupath,$window,$menu)

=begin original

Allows selecting a menu programmatically.

=end original

Allows selecting a menu programmatically.
(TBT)

=begin original

Simple Examples:
    # Exit foreground application through application menu.
    MenuSelect("&File|E&xit");

=end original

Simple Examples:
    # Exit foreground application through application menu.
    MenuSelect("&File|E&xit");
(TBT)

    # Exit foreground application through system menu
    MenuSelect("&Close", 0, GetSystemMenu(GetForegroundWindow(), FALSE));

=item GetMenuItemInfo($menuHndl, $cnt)

=begin original

Receives a menu handler (one we got from GetMenu or GetSubMenu) and
a number (which is the location of the item within the given menu).

=end original

Receives a menu handler (one we got from GetMenu or GetSubMenu) and
a number (which is the location of the item within the given menu).
(TBT)

=begin original

Returns a hash of which there are currently 2 keys:
type can be either "string" or "separator"  - this is the type of the menu item
text is the visible text of the menu item (provided only for "string" type)

=end original

Returns a hash of which there are currently 2 keys:
type can be either "string" or "separator"  - this is the type of the menu item
text is the visible text of the menu item (provided only for "string" type)
(TBT)

=begin original

WARNING: This is an experimental function. Its behavior might change.

=end original

WARNING: This is an experimental function. Its behavior might change.
(TBT)

=cut

=item MouseClick($window [,$parent] [,$x_offset] [,$y_offset] [,$button] [,$delay])

=begin original

Allows one to easily interact with an application through mouse emulation.

=end original

Allows one to easily interact with an application through mouse emulation.
(TBT)

=begin original

window = Regexp for a Window caption / Child caption, or just a Child ID.

=end original

window = Regexp for a Window caption / Child caption, or just a Child ID.
(TBT)

=begin original

parent = Handle to parent window.  Default is foreground window.  Use
GetDesktopWindow() return value for this if clicking on an application
title bar.

=end original

parent = Handle to parent window.  Default is foreground window.  Use
GetDesktopWindow() return value for this if clicking on an application
title bar.
(TBT)

=begin original

x_offset = Offset for X axis.  Default is 0.

=end original

x_offset = Offset for X axis.  Default is 0.
(TBT)

=begin original

y_offset = Offset for Y axis.  Default is 0.

=end original

y_offset = Offset for Y axis.  Default is 0.
(TBT)

=begin original

button = {LEFT}, {MIDDLE}, {RIGHT}.  Default is {LEFT}

=end original

button = {LEFT}, {MIDDLE}, {RIGHT}.  Default is {LEFT}
(TBT)

=begin original

delay = Default is 0.  0.50 = 500 ms.  Delay between button down and
button up.

=end original

delay = Default is 0.  0.50 = 500 ms.  Delay between button down and
button up.
(TBT)

=begin original

Simple Examples:

=end original

Simple Examples:
(TBT)

    # Click on CE button if its parent window is in foreground.
    MouseClick('^CE$');

    # Right click on CE button if its parent window is in foreground
    MouseClick('^CE$', undef, undef, undef, '{RIGHT}');

    # Click on 8 button window under the specified parent window; where
    # [PARENTHWND] will be replaced by a parent handle variable.
    MouseClick('8', [PARENTHWND]);

    # Click on Calculator parent window itself
    MouseClick('Calculator', GetDesktopWindow());

=cut

=item $buf_str = AllocateVirtualBuffer( $hwnd, $size )

=begin original

Allocates memory in the address space of the process, which is an owner of
a window identified by $hwnd. Returns a reference to a hash, which has 2 elements:

=end original

Allocates memory in the address space of the process, which is an owner of
a window identified by $hwnd. Returns a reference to a hash, which has 2 elements:
(TBT)

=over 8

=item ptr - address of the allocated memory

=item process - process handle (in the Win32 meaning, as returned by Win32 OpenProcess
API function

=back

=cut

=item $value = ReadFromVirtualBuffer( $buf_str, $size )

=begin original

Read from a memory in the address space of the other process.
C<$buf_str> is a reference to a hash returned by AllocateVirtualBuffer.

=end original

Read from a memory in the address space of the other process.
C<$buf_str> is a reference to a hash returned by AllocateVirtualBuffer.
(TBT)

=begin original

Returns read value.

=end original

Returns read value.
(TBT)

=cut

=item WriteToVirtualBuffer( $buf_str, $value )

=begin original

Write to a memory in the address space of the other process.
C<$buf_str> is a reference to a hash returned by AllocateVirtualBuffer.
C<$value> is a value to be copied.

=end original

Write to a memory in the address space of the other process.
C<$buf_str> is a reference to a hash returned by AllocateVirtualBuffer.
C<$value> is a value to be copied.
(TBT)

=cut

=item FreeVirtualBuffer( $buf_str )

=begin original

Frees memory allocated by AllocateVirtualBuffer

=end original

Frees memory allocated by AllocateVirtualBuffer
(TBT)

=cut

=item $text = WMGetText($hwnd) *

=begin original

Sends a WM_GETTEXT to a window and returns its contents

=end original

Sends a WM_GETTEXT to a window and returns its contents
(TBT)

=item $set = WMSetText(hwnd,text) *

=begin original

Sends a WM_SETTEXT to a window setting its contents

=end original

Sends a WM_SETTEXT to a window setting its contents
(TBT)

=item ($x,$y) = GetCursorPos() *

=begin original

Retrieves the cursor's position,in screen coordinates as (x,y) array. 

=end original

Retrieves the cursor's position,in screen coordinates as (x,y) array. 
(TBT)

=item GetCaretPos()

=begin original

Retrieves the caret's position, in client coordinates as (x,y) array. (Like Windows function)

=end original

Retrieves the caret's position, in client coordinates as (x,y) array. (Like Windows function)
(TBT)

=item HWND SetFocus(hWnd)

=begin original

Sets the keyboard focus to the specified window

=end original

Sets the keyboard focus to the specified window
(TBT)

=item HWND GetDesktopWindow() *

=begin original

Returns a handle to the desktop window

=end original

Returns a handle to the desktop window
(TBT)

=item HWND GetWindow(hwnd,uCmd) *

=item SV * GetWindowText(hwnd) *

=begin original

Get the text name of the window as shown on the top of it.
Beware, this is text depends on localization.

=end original

Get the text name of the window as shown on the top of it.
Beware, this is text depends on localization.
(TBT)

=item $class = GetClassName(hwnd) *

=begin original

Using the same Windows library function returns the name
of the class wo which the specified window belongs.

=end original

Using the same Windows library function returns the name
of the class wo which the specified window belongs.
(TBT)

=begin original

See MSDN for more details.

=end original

See MSDN for more details.
(TBT)

=begin original

You can also check out MSDN to see an overview of the Window Classes.

=end original

You can also check out MSDN to see an overview of the Window Classes.
(TBT)

=item HWND GetParent(hwnd) *

=begin original

A library function (see MSDN) to return the WindowID of the parent window.
See MSDN for the special cases.

=end original

A library function (see MSDN) to return the WindowID of the parent window.
See MSDN for the special cases.
(TBT)

=item long GetWindowLong(hwnd,index) *

=item BOOL SetForegroundWindow(hWnd) *

=begin original

See corresponding Windows functions.

=end original

See corresponding Windows functions.
(TBT)

=item @wnds = GetChildWindows(hWnd)

=begin original

Using EnumChildWindows library function (see MSDN) it returns the WindowID 
of each child window. If the children have their own children the function
returns them too until the tree ends.

=end original

Using EnumChildWindows library function (see MSDN) it returns the WindowID 
of each child window. If the children have their own children the function
returns them too until the tree ends.
(TBT)

=item BOOL IsChild(hWndParent,hWnd) *

=begin original

Using the corresponding library function (see MSDN) it returns true
if the second window is an immediate child or a descendant window of
the first window.

=end original

Using the corresponding library function (see MSDN) it returns true
if the second window is an immediate child or a descendant window of
the first window.
(TBT)

=item $depth = GetChildDepth(hAncestor,hChild)

=begin original

Using the GetParent library function in a loop, returns the distance
between an ancestor window and a child (descendant) window.

=end original

Using the GetParent library function in a loop, returns the distance
between an ancestor window and a child (descendant) window.
(TBT)

=begin original

Features/bugs:
If the given "ancsetor" is not really an ancestor, the return value is the distance of child from the root window (0)
If you supply the same id for both the ancestor and the child you get 1.
If the ancestor you are checking is not 0 then the distance given is 1 larger than it should be.

=end original

Features/bugs:
If the given "ancsetor" is not really an ancestor, the return value is the distance of child from the root window (0)
If you supply the same id for both the ancestor and the child you get 1.
If the ancestor you are checking is not 0 then the distance given is 1 larger than it should be.
(TBT)

=begin original

see eg\get_child_depth.pl

=end original

see eg\get_child_depth.pl
(TBT)

=item $res = SendMessage(hWnd,Msg,wParam,lParam) *

=begin original

This is a library function (see MSDN) used by a number of the functions provided by
Win32::GuiTest. It sends the specified message to a window or windows.
HWnd is the WindowID or HWND_BROADCAST to send message to all top level windows.
     Message is not sent to child windows. (If I understand this correctly this means
     it is sent to all the immediate children of the root window (0).
Msg  the message
wParam additional parameter
lParam additioanl parameter

=end original

This is a library function (see MSDN) used by a number of the functions provided by
Win32::GuiTest. It sends the specified message to a window or windows.
HWnd is the WindowID or HWND_BROADCAST to send message to all top level windows.
     Message is not sent to child windows. (If I understand this correctly this means
     it is sent to all the immediate children of the root window (0).
Msg  the message
wParam additional parameter
lParam additioanl parameter
(TBT)

=begin original

It is most likely you won't use this directly but through one of the functions
implemented already in Win32::GuiTest.

=end original

It is most likely you won't use this directly but through one of the functions
implemented already in Win32::GuiTest.
(TBT)

=begin original

See the guitest.xs for some examples.

=end original

See the guitest.xs for some examples.
(TBT)

=item $res = PostMessage(hwnd,msg,wParam,lParam) *

=begin original

See corresponding Windows library function in MSDN.

=end original

See corresponding Windows library function in MSDN.
(TBT)

=item CheckButton(hwnd) 

=item UnCheckButton(hwnd) 

=item GrayOutButton(hwnd)

=item BOOL IsCheckedButton(hwnd)

=item BOOL IsGrayedButton(hwnd)

=begin original

The names say it.  Works on radio buttons and
checkboxes.  For regular buttons, use IsWindowEnabled.

=end original

The names say it.  Works on radio buttons and
checkboxes.  For regular buttons, use IsWindowEnabled.
(TBT)

=item BOOL IsWindow(hwnd) *

=item ($x,$y) = ScreenToClient(hwnd,x,y) *

=item ($x,$y) = ClientToScreen(hwnd,x,y) *

=item ($x,$y) = GetCaretPos(hwnd) *A

=item HWND SetFocus(hWnd) *A

=item HWND GetFocus(hwnd) *A

=item HWND GetActiveWindow(hwnd) *A

=item HWND GetForegroundWindow() *

=item HWND SetActiveWindow(hwnd) *A

=item BOOL EnableWindow(hwnd,fEnable) *

=item BOOL IsWindowEnabled(hwnd)*

=item BOOL IsWindowVisible(hwnd)*

=item BOOL ShowWindow(hwnd,nCmdShow) *A

=begin original

See corresponding Windows functions.

=end original

See corresponding Windows functions.
(TBT)

=item ($x,$y) = ScreenToNorm(x,y) 

=begin original

Returns normalised coordinates of given point (0-FFFF as a fraction of screen 
resolution)

=end original

Returns normalised coordinates of given point (0-FFFF as a fraction of screen 
resolution)
(TBT)

=item ($x,$y) = NormToScreen(x,y)

=begin original

The opposite transformation

=end original

The opposite transformation
(TBT)

=item ($x,$y) = GetScreenRes()

=begin original

Returns screen resolution

=end original

Returns screen resolution
(TBT)

=item HWND WindowFromPoint(x, y)

=item ($l,$t,$r,$b) = GetWindowRect(hWnd) *

=item ($l,$t,$r,$b) = GetClientRect(hWnd) *

=begin original

See corresponding Windows functions.

=end original

See corresponding Windows functions.
(TBT)

=cut

=item SelComboItem($window, $index)

=begin original

Selects an item in the combo box based off an index (zero-based).

=end original

Selects an item in the combo box based off an index (zero-based).
(TBT)

=item SelComboItemText($window, $txt)

=begin original

Selects an item in the combo box based off text (case insensitive).

=end original

Selects an item in the combo box based off text (case insensitive).
(TBT)

=item $txt = GetComboText(hwnd,index)

=item $txt = GetListText(hwnd,index)

=item @lst = GetComboContents(hWnd)

=item @lst = GetListContents(hWnd)

=begin original

Fetch the contents of the list and combo boxes.

=end original

Fetch the contents of the list and combo boxes.
(TBT)

=item GetAsyncKeyState($key)

=item IsKeyPressed($key)

=begin original

Wrapper around the GetAsyncKeyState API function. Returns TRUE if the user presses the 
specified key.

=end original

Wrapper around the GetAsyncKeyState API function. Returns TRUE if the user presses the 
specified key.
(TBT)

    IsKeyPressed("ESC");
    IsKeyPressed("A");
    IsKeyPressed("DOWN"); 
    IsKeyPressed( VK_DOWN);

=cut

=pod

=item SendRawKey($virtualkey,$flags)

=begin original

Wrapper around keybd_event. Allows sending low-level keys. The first argument is any of the VK_* constants. The second argument can be 0, KEYEVENTF_EXTENDEDKEY, KEYEVENTF_KEYUP or a combination of them.

=end original

Wrapper around keybd_event. Allows sending low-level keys. The first argument is any of the VK_* constants. The second argument can be 0, KEYEVENTF_EXTENDEDKEY, KEYEVENTF_KEYUP or a combination of them.
(TBT)

    KEYEVENTF_EXTENDEDKEY - Means it is an extended key (i.e. to distinguish between arrow keys on the numeric keypad and elsewhere). 
    KEYEVENTF_KEYUP       - Means keyup. Unspecified means keydown.

   #Example
   use Win32::GuiTest qw/:FUNC :VK/;

   while (1) {
       SendRawKey(VK_DOWN, KEYEVENTF_EXTENDEDKEY); 
       SendKeys "{PAUSE 200}";
   }

=item VkKeyScan(int)

=item C<GetListViewContents($handle)>

    Return the items of the list view with C<$handle> as a list, each
	element of which is a reference to an array containing the values
	in each column.

=cut

=item SelListViewItem($window, $idx, [$multi_select])

    Selects an item in the list view based off an index (zero-based).

	# Select first item, clears out any previous selections.
	SelListViewItem($win, 0);
	# Select an *additional* item.
	SelListViewItem($win, 1, 1);

=cut

=item SelListViewItemText($window, $txt, [$multi_select])

    Selects an item in the list view based off text (case insensitive).

	# Select first item, clears out any previous selections.
	SelListViewItemText($win, 'Temp');
	# Select an *additional* item.
	SelListViewItemText($win, 'cabs', 1);

=cut

=item IsListViewItemSel($window, $txt)

   Determines if the specified list view item is selected.

=cut

=item GetTabItems($window)

    Returns a list of a tab control's labels.

=cut

=item SelTabItem($window, $idx)

    Selects a tab based off an index (zero-based).

=cut

=item SelTabItemText($window, $txt)

    Selects a tab based off text label (case insensitive).

=cut

=item IsTabItemSel($window, $txt)

   Determines if the specified tab item is selected.

=cut

=item SelTreeViewItemPath($window, $path)

    Selects a tree view item based off a "path" (case insensitive).

    # Select Machine item and Processors sub-item.
    SelTreeViewItemPath($window, "Machine|Processors");

    SelTreeViewItemPath($window, "Item");

=cut

=item GetTreeViewSelPath($window)

   Returns a string containing the path (i.e., "parent|child") of
   the currently selected tree view item.

   $oldpath = GetTreeViewSelPath($window);
   SelTreeViewItemPath($window, "Parent|Child");
   SelTreeViewItemPath($window, $oldpath);

=cut

=item $hpopup = GetPopupHandle($hwnd, $x, $y, [$wait])

   This function gets the handle of a popup window generated by
   right-clicking at the $x and $y screen coordinates (absolute). An
   optional delay can be entered which will wait the given number of
   milliseconds after the right-click for the window to appear (default
   is 50). Zero is returned when no popup menu is found.

=back

=head2 DibSect

=begin original

A class to manage a Windows DIB section. Currently limited in functionality to 
24-bit images. Pulled from old code into GuiTest when I (jurasz@imb.uni-karlsruhe.de) 
needed to create several grayscale screen dumps.

=end original

A class to manage a Windows DIB section. Currently limited in functionality to 
24-bit images. Pulled from old code into GuiTest when I (jurasz@imb.uni-karlsruhe.de) 
needed to create several grayscale screen dumps.
(TBT)

=begin original

Possible future extenstions: other color resolutions, loading, comparison of bitmaps,
getting from clipboard.

=end original

Possible future extenstions: other color resolutions, loading, comparison of bitmaps,
getting from clipboard.
(TBT)

=begin original

Synopsis:

=end original

Synopsis:
(TBT)

  $ds = new Win32::GuiTest::DibSect;
  $ds->CopyWindow($w);
  $ds->ToGrayScale();
  $ds->SaveAs("bla.bmp");
  $ds->ToClipboard();

=over 8  

=item bool DibSect::CopyClient(hwnd,[rect])

=begin original

Copy a client area of given window (or possibly its subset) into a given DibSect.
The rectangle may be optionally passed as a reference to 4-element array.
To get the right result make sure the window you want to copy is not obscured by 
others.

=end original

Copy a client area of given window (or possibly its subset) into a given DibSect.
The rectangle may be optionally passed as a reference to 4-element array.
To get the right result make sure the window you want to copy is not obscured by 
others.
(TBT)

=item bool DibSect::CopyWindow(hwnd)

=begin original

Copy the window rectangle. Equivalent to 

=end original

Copy the window rectangle. Equivalent to 
(TBT)

  $ds->CopyClient(GetDesktopWindow(), \@{[GetWindowRect($w)]});

=item bool DibSect::SaveAs(szFile)

=begin original

Save the current contents of the DIB section in a given file. With 24-bit 
resolution it can grow quite big, so I immediately convert them to PNG (direct 
writing of PNG seemed to complicated to implement).

=end original

Save the current contents of the DIB section in a given file. With 24-bit 
resolution it can grow quite big, so I immediately convert them to PNG (direct 
writing of PNG seemed to complicated to implement).
(TBT)

=item bool DibSect::Invert()

=begin original

Invert the colors in a current DIB section.

=end original

Invert the colors in a current DIB section.
(TBT)

=item bool DibSect::ToGrayScale()

=begin original

Convert the DibSection to the gray scale. Note that it is still encoded as 24-bit
BMP for simplicity.

=end original

Convert the DibSection to the gray scale. Note that it is still encoded as 24-bit
BMP for simplicity.
(TBT)

=item bool DibSect::ToClipboard()

=begin original

Copies the DibSect to clipboard (as an old-fashioned metafile), so that it can 
be further processed with your favourite image processing software, for example 
automatically using SendKeys.

=end original

Copies the DibSect to clipboard (as an old-fashioned metafile), so that it can 
be further processed with your favourite image processing software, for example 
automatically using SendKeys.
(TBT)

=item bool DibSect::Destroy()

=begin original

Destroys the contents of the DIB section.

=end original

Destroys the contents of the DIB section.
(TBT)

=back

=cut

=head1 UNICODE SUPPORT

(Unicode 対応)

=begin original

Currently (2007) there's no consensus about unicode input in Perl, so
the module declares function C<UnicodeSemantics> that sets whether 
information queried from windows should use A or W syscalls. The
function that support this differentiation, and produce different
results depending on value set to C<UnicodeSemantics> is:

=end original

Currently (2007) there's no consensus about unicode input in Perl, so
the module declares function C<UnicodeSemantics> that sets whether 
information queried from windows should use A or W syscalls. The
function that support this differentiation, and produce different
results depending on value set to C<UnicodeSemantics> is:
(TBT)

=begin original

C<GetWindowText>, and all its callers, - FindWindowLike, WaitWindow,
WaitWindowLike

=end original

C<GetWindowText>, and all its callers, - FindWindowLike, WaitWindow,
WaitWindowLike
(TBT)

=begin original

C<SendKeys> translated unicode characters into set of ALT+NUMPAD keystrokes.
Note that not all applications can understand unicode input.

=end original

C<SendKeys> translated unicode characters into set of ALT+NUMPAD keystrokes.
Note that not all applications can understand unicode input.
(TBT)

=over

=item UnicodeSemantics [BOOL]

=begin original

If a boolean parameter is set, changes the semantics flag for functions
that return results of either A or W syscalls. If the parameter is
not set, returns the current value of the flag.

=end original

If a boolean parameter is set, changes the semantics flag for functions
that return results of either A or W syscalls. If the parameter is
not set, returns the current value of the flag.
(TBT)

=back

=head1 DEVELOPMENT

(開発)

=begin original

If you would like to participate in the development of this module there are 
several thing that need to be done. For some of them you only need Perl
and the latest source of the module from CVS for others you'll also need to 
have a C++ compiler.

=end original

If you would like to participate in the development of this module there are 
several thing that need to be done. For some of them you only need Perl
and the latest source of the module from CVS for others you'll also need to 
have a C++ compiler.
(TBT)

=begin original

To get the latest source code you need a CVS client and then do the following:

=end original

To get the latest source code you need a CVS client and then do the following:
(TBT)

 cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest login
 cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/winguitest co Win32-GuiTest

=begin original

See more detailed explanations here http://sourceforge.net/projects/winguitest/

=end original

See more detailed explanations here http://sourceforge.net/projects/winguitest/
(TBT)

=head2 cygwin

=begin original

g++ needs to be installed

=end original

g++ needs to be installed
(TBT)

  perl Makefile.PL
  make
  make test
  make install

=head2 MSVC environment

=begin original

To setup a development environment for compiling the C++ code you can either buy
Visual Studio with Visual C++ or you can download a few things free of charge from 
Microsoft. There might be other ways too we have not explored.

=end original

To setup a development environment for compiling the C++ code you can either buy
Visual Studio with Visual C++ or you can download a few things free of charge from 
Microsoft. There might be other ways too we have not explored.
(TBT)

=begin original

The instructions to get the free environment are here:

=end original

The instructions to get the free environment are here:
(TBT)

=begin original

From http://www.microsoft.com/ download and install:

=end original

From http://www.microsoft.com/ download and install:
(TBT)

 1) Microsoft .NET Framework Version 1.1 Redistributable Package
 2) .NET Framework SDK Version 1.1

=begin original

This is not enough as there are a number of header files and libraries that are 
not included in these distributions. You can get them from Microsoft in two additional
downloads. For these you will have to be using Internet Explorer.
Visit 

=end original

This is not enough as there are a number of header files and libraries that are 
not included in these distributions. You can get them from Microsoft in two additional
downloads. For these you will have to be using Internet Explorer.
Visit 
(TBT)

  http://www.microsoft.com/msdownload/platformsdk/sdkupdate/

=begin original

and install 

=end original

and install 
(TBT)

 1) Core SDK
 2) Microsoft Data Access Components 2.7

=begin original

Before you can compile you'll have to open a command prompt and execute the
C<sdkvars.bat> script from the.NET SDK that will set a number of environment
variables. In addition you'll have to run the C<setenv.bat> you got with the 
Core SDK (and located in C:\Program Files\Microsoft SDK) with the appropriate
parameters. For me this was /XP32 /RETAIL

=end original

Before you can compile you'll have to open a command prompt and execute the
C<sdkvars.bat> script from the.NET SDK that will set a number of environment
variables. In addition you'll have to run the C<setenv.bat> you got with the 
Core SDK (and located in C:\Program Files\Microsoft SDK) with the appropriate
parameters. For me this was /XP32 /RETAIL
(TBT)

=begin original

In order to finish the packaging you'll also need the tar, gzip and zip utilities from 

=end original

In order to finish the packaging you'll also need the tar, gzip and zip utilities from 
(TBT)

 http://gnuwin32.sourceforge.net/packages.html

=begin original

I have not tried it yet.

=end original

I have not tried it yet.
(TBT)

=begin original

After this you will probably be able to do the normal cycle:

=end original

After this you will probably be able to do the normal cycle:
(TBT)

 perl makefile.pl
 nmake
 nmake test

 or run

 perl makedist.pl

=head1 SEE ALSO

=begin original

Module's documentation is available at L<http://www.piotrkaluski.com/files/winguitest/docs/index.html>.

=end original

Module's documentation is available at L<http://www.piotrkaluski.com/files/winguitest/docs/index.html>.
(TBT)

=head1 TODO

=begin original

Here are a few items where help would be welcome. 

=end original

Here are a few items where help would be welcome. 
(TBT)

=head2 Perl only

 Improve Tests
 Improve documentation
 Add more examples and explain them

=head2 C++ compiler needed

 Add more calls to the C++ backend
 Fix current calls

 32bit custom controls (some already implemented)
 Possibly Java interfaces
 Retreive the list of the menu of a given window.

=cut

=head1 COPYRIGHT

The SendKeys function is based on the Delphi sourcecode
published by Al Williams  E<lt>http://www.al-williams.com/awc/E<gt> 
in Dr.Dobbs  E<lt>http://www.drdobbs.com/keys-to-the-kingdom/184410429E<gt>.

Copyright (c) 1998-2002 Ernesto Guisado, (c) 2004 Dennis K. Paulsen. All rights 
reserved. This program is free software; You may distribute it and/or modify it
under the same terms as Perl itself.

=head1 AUTHORS

Ernesto Guisado (erngui@acm.org), http://triumvir.org

=begin original

Jarek Jurasz (jurasz@imb.uni-karlsruhe.de), http://www.uni-karlsruhe.de/~gm07 wrote 
DibSect and some other pieces (see C<Changes> for details).

=end original

Jarek Jurasz (jurasz@imb.uni-karlsruhe.de), http://www.uni-karlsruhe.de/~gm07 wrote 
DibSect and some other pieces (see C<Changes> for details).
(TBT)

=begin original

Dennis K. Paulsen (ctrondlp@cpan.org) wrote various pieces (See C<Changes> for
details).

=end original

Dennis K. Paulsen (ctrondlp@cpan.org) wrote various pieces (See C<Changes> for
details).
(TBT)

=begin original

Dmitry Karasik (dmitry@karasik.eu.org) added support for unicode and cygwin/mingw.

=end original

Dmitry Karasik (dmitry@karasik.eu.org) added support for unicode and cygwin/mingw.
(TBT)

=head1 CREDITS

=begin original

Thanks very much to:

=end original

Thanks very much to:
(TBT)

=over 4

=item Johannes Maehner

=item Ben Shern

=item Phill Wolf

=item Mauro

=item Sohrab Niramwalla

=item Frank van Dijk

=item Jarek Jurasz

=item Wilson P. Snyder II

=item Rudi Farkas

=item Paul Covington

=item Piotr Kaluski

=item ...and more...

=begin original

for code, suggestions and bug fixes.

=end original

for code, suggestions and bug fixes.
(TBT)

=back

=begin meta

Translate: 川合孝典 <GCD00051@nifty.ne.jp> (1.3)
Update: Kentaro Shirakata <argrath@ub32.org> (1.64-)
Status: in progress

=end meta

=cut

