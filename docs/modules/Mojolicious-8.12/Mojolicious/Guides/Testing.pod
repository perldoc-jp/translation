
=encoding utf8

=head1 NAME

=begin original

Mojolicious::Guides::Testing - Web Application Testing Made Easy

=end original

Mojolicious::Guides::Testing - Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’ç°¡å˜ã«

(è¨³æ³¨: (TBR)ãŒã¤ã„ã¦ã„ã‚‹æ®µè½ã¯ã€Œã¿ã‚“ãªã®è‡ªå‹•ç¿»è¨³ï¼ TexTraã€ã«ã‚ˆã‚‹
æ©Ÿæ¢°ç¿»è¨³ã§ã™ã€‚)

=head1 OVERVIEW

=begin original

This document is an introduction to testing web applications with L<Test::Mojo>.
L<Test::Mojo> can be thought of as a module that provides all of the tools and
testing assertions needed to test web applications in a Perl-ish way.

=end original

ã“ã®æ–‡æ›¸ã§ã¯ã€L<Test::Mojo>ã‚’ä½¿ç”¨ã—ã¦Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹æ–¹æ³•ã‚’
ç´¹ä»‹ã—ã¾ã™ã€‚
L<Test::Mojo>ã¯ã€Perlé¢¨ã®æ–¹æ³•ã§Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«å¿…è¦ãª
ã™ã¹ã¦ã®ãƒ„ãƒ¼ãƒ«ã¨ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æä¾›ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

=begin original

While L<Test::Mojo> can be used to test any web application, it has shortcuts
designed to make testing L<Mojolicious> web applications easy and pain-free.

=end original

L<Test::Mojo>ã¯ã‚ã‚‰ã‚†ã‚‹ã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã«ä½¿ãˆã¾ã™ãŒã€
L<Mojolicious>ã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’ç°¡å˜ã‹ã¤è‹¦ç—›ãªãè¡Œã†ãŸã‚ã®
ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

=begin original

Please refer to the L<Test::Mojo> documentation for a complete reference to many
of the ideas and syntax introduced in this document.

=end original

ã“ã®æ–‡æ›¸ã§ç´¹ä»‹ã•ã‚Œã¦ã„ã‚‹å¤šãã®ã‚¢ã‚¤ãƒ‡ã‚¢ã¨æ§‹æ–‡ã®å®Œå…¨ãªå‚ç…§ã«ã¤ã„ã¦ã¯ã€
L<Test::Mojo>ã®æ–‡æ›¸ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

=begin original

A test file for a simple web application might look like:

=end original

å˜ç´”ãªWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™:

  use Mojo::Base -strict;

  use Test::Mojo;
  use Test::More;

  # Start a Mojolicious app named "Celestial"
  my $t = Test::Mojo->new('Celestial');

  # Post a JSON document
  $t->post_ok('/notifications' => json => {event => 'full moon'})
    ->status_is(201)
    ->json_is('/message' => 'notification created');

  # Perform GET requests and look at the responses
  $t->get_ok('/sunrise')
    ->status_is(200)
    ->content_like(qr/ am$/);
  $t->get_ok('/sunset')
    ->status_is(200)
    ->content_like(qr/ pm$/);

  # Post a URL-encoded form
  $t->post_ok('/insurance' => form => {name => 'Jimmy', amount => 'â‚¬3.000.000'})
    ->status_is(200);

  # Use Test::More's like() to check the response
  like $t->tx->res->dom->at('div#thanks')->text, qr/thank you/, 'thanks';

  done_testing();

=begin original

In the rest of this document we'll explore these concepts and others related to
L<Test::Mojo>.

=end original

ã“ã®æ–‡æ›¸ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§ã¯ã€ã“ã‚Œã‚‰ã®æ¦‚å¿µã¨L<Test::Mojo>ã«é–¢é€£ã™ã‚‹
ãã®ä»–ã®æ¦‚å¿µã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

=head1 CONCEPTS

=begin original

Essentials every L<Mojolicious> developer should know.

=end original

ã™ã¹ã¦ã®L<Mojolicious>é–‹ç™ºè€…ãŒçŸ¥ã£ã¦ãŠãã¹ãé‡è¦ãªã“ã¨ã€‚

=head2 L<Test::Mojo> at a glance

(L<Test::Mojo> ã®æ¦‚è¦)

=begin original

The L<Test::More> module bundled with Perl includes several primitive test
assertions, such as C<ok>, C<is>, C<isnt>, C<like>, C<unlike>, C<cmp_ok>, etc.
An assertion "passes" if its expression returns a true value. The assertion
method prints "ok" or "not ok" if an assertion passes or fails (respectively).

=end original

Perlã«åŒæ¢±ã•ã‚Œã¦ã„ã‚‹L<Test::More>ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€C<ok>ã€C<is>ã€C<isnt>ã€
C<like>ã€C<unlike>ã€C<cmp_ok>ãªã©ã€ã„ãã¤ã‹ã®åŸºæœ¬çš„ãª
ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãã®å¼ãŒçœŸã®å€¤ã‚’è¿”ã—ãŸå ´åˆã«ã€Œåˆæ ¼ã€ã—ã¾ã™ã€‚
ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒåˆæ ¼ã—ãŸå ´åˆã¯ã€Œokã€ã€
ä¸åˆæ ¼ã®å ´åˆã¯ã€Œnot okã€ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚

=begin original

L<Test::Mojo> supplies additional test assertions organized around the web
application request/response transaction (transport, response headers, response
bodies, etc.), and WebSocket communications.

=end original

L<Test::Mojo>ã¯ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¦æ±‚/å¿œç­”ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³
(ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã€å¿œç­”ãƒ˜ãƒƒãƒ€ãƒ¼ã€å¿œç­”ãƒœãƒ‡ã‚£ãªã©)ã¨WebSocketé€šä¿¡ã‚’ä¸­å¿ƒã«
æ§‹æˆã•ã‚ŒãŸè¿½åŠ ã®ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚

=begin original

One interesting thing of note: the return value of L<Test::Mojo> object
assertions is always the test object itself, allowing us to "chain" test
assertion methods. So rather than grouping related test statements like this:

=end original

æ³¨ç›®ã™ã¹ãèˆˆå‘³æ·±ã„ç‚¹ã¯ã€L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®æˆ»ã‚Šå€¤ã¯
å¸¸ã«ãƒ†ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã§ã‚ã‚Šã€ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰ã‚’
ã€Œãƒã‚§ãƒ¼ãƒ³ã€ã§ãã‚‹ã“ã¨ã§ã™;
ã—ãŸãŒã£ã¦ã€æ¬¡ã®ã‚ˆã†ã«é–¢é€£ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’
ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ã®ã§ã¯ãªã:

  $t->get_ok('/frogs');
  $t->status_is(200);
  $t->content_like(qr/bullfrog/);
  $t->content_like(qr/hypnotoad/);

=begin original

Method chaining allows us to connect test assertions that belong together:

=end original

ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€äº’ã„ã«å±ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¥ç¶šã§ãã¾ã™:

  $t->get_ok('/frogs')
    ->status_is(200)
    ->content_like(qr/bullfrog/)
    ->content_like(qr/hypnotoad/);

=begin original

This makes for a much more I<concise> and I<coherent> testing experience:
concise because we are not repeating the invocant for each test, and coherent
because assertions that belong to the same request are syntactically bound in
the same method chain.

=end original

ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ†ã‚¹ãƒˆã‚¨ã‚¯ã‚¹ãƒšãƒªã‚¨ãƒ³ã‚¹ã®I<ç°¡æ½”æ€§>ã¨I<å‡é›†æ€§>ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™ã€‚
ãƒ†ã‚¹ãƒˆã”ã¨ã«å‘¼ã³å‡ºã—ã‚’ç¹°ã‚Šè¿”ã•ãªã„ãŸã‚ç°¡æ½”ã§ã‚ã‚Šã€
åŒã˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å±ã™ã‚‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒåŒã˜ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³å†…ã§
æ§‹æ–‡çš„ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã‚‹ãŸã‚å‡é›†æ€§ãŒã‚ã‚Šã¾ã™ã€‚

=begin original

Occasionally it makes sense to break up a test to perform more complex
assertions on a response. L<Test::Mojo> exposes the entire transaction object so
you can get all the data you need from a response:

=end original

å ´åˆã«ã‚ˆã£ã¦ã¯ã€ãƒ†ã‚¹ãƒˆã‚’åˆ†å‰²ã—ã¦ã€å¿œç­”ã«å¯¾ã—ã¦ã‚ˆã‚Šè¤‡é›‘ãªã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’
å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒç†ã«ã‹ãªã£ã¦ã„ã¾ã™ã€‚
L<Test::Mojo>ã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‚’å…¬é–‹ã™ã‚‹ãŸã‚ã€
å¿œç­”ã‹ã‚‰å¿…è¦ãªã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã™:

  $t->put_ok('/bees' => json => {type => 'worker', name => 'Karl'})
    ->status_is(202)
    ->json_has('/id');

  # Pull out the id from the response
  my $newbee = $t->tx->res->json('/id');

  # Make a new request with data from the previous response
  $t->get_ok("/bees/$newbee")
    ->status_is(200)
    ->json_is('/name' => 'Karl');

=begin original

The L<Test::Mojo> object is I<stateful>. As long as we haven't started a new
transaction by invoking one of the C<*_ok> methods, the request and response
objects from the previous transaction are available in the L<Test::Mojo>
object:

=end original

L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯I<ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«>ã§ã™ã€‚
C<*_ok>ãƒ¡ã‚½ãƒƒãƒ‰ã®1ã¤ã‚’å‘¼ã³å‡ºã—ã¦æ–°ã—ã„ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¦ã„ãªã„é™ã‚Šã€
å‰ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®è¦æ±‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å¿œç­”ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯
L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ä½¿ç”¨ã§ãã¾ã™:

  # First transaction
  $t->get_ok('/frogs?q=bullfrog' => {'Content-Type' => 'application/json'})
    ->status_is(200)
    ->json_like('/0/species' => qr/catesbeianus/i);

  # Still first transaction
  $t->content_type_is('application/json');

  # Second transaction
  $t->get_ok('/frogs?q=banjo' => {'Content-Type' => 'text/html'})
    ->status_is(200)
    ->content_like(qr/interioris/i);

  # Still second transaction
  $t->content_type_is('text/html');

=begin original

This statefulness also enables L<Test::Mojo> to handle sessions, follow
redirects, and inspect past responses during a redirect.

=end original

ã“ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ã•ã«ã‚ˆã‚Šã€L<Test::Mojo>ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‡¦ç†ã—ã€
ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã«å¾“ã„ã€ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆä¸­ã«éå»ã®å¿œç­”ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

=head2 The L<Test::Mojo> object

(L<Test::Mojo> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ)

=begin original

The L<Test::Mojo> object manages the Mojolicious application lifecycle (if a
Mojolicious application class is supplied) as well as exposes the built-in
L<Mojo::UserAgent> object. To create a bare L<Test::Mojo> object:

=end original

L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã‚’ç®¡ç†ã—(Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆ)ã€
çµ„ã¿è¾¼ã¿ã®L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å…¬é–‹ã—ã¾ã™ã€‚
ãƒ™ã‚¢L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã«ã¯ã€æ¬¡ã®æ‰‹é †ã«å¾“ã„ã¾ã™ã€‚
(TBR)

  my $t = Test::Mojo->new;

=begin original

This object initializes a L<Mojo::UserAgent> object and provides a variety of
test assertion methods for accessing a web application. For example, with this
object, we could test any running web application:

=end original

ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆæœŸåŒ–ã—ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®æ§˜ã€…ãªãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚
ãŸã¨ãˆã°ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦ã€å®Ÿè¡Œä¸­ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™:
(TBR)

  $t->get_ok('https://www.google.com/')
    ->status_is(200)
    ->content_like(qr/search/i);

=begin original

You can access the user agent directly if you want to make web requests without
triggering test assertions:

=end original

ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒˆãƒªã‚¬ã›ãšã«Webè¦æ±‚ã‚’è¡Œã†å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
(TBR)

  my $tx = $t->ua->post(
    'https://duckduckgo.com/html' => form => {q => 'hypnotoad'});
  $tx->result->dom->find('a.result__a')->each(sub { say $_->text });

=begin original

See L<Mojo::UserAgent> for the complete API and return values.

=end original

å®Œå…¨ãªAPIã¨æˆ»ã‚Šå€¤ã«ã¤ã„ã¦ã¯ã€L<Mojo::UserAgent>ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
(TBR)

=head2 Testing Mojolicious applications

(Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ)

=begin original

If you pass the name of a L<Mojolicious> application class (e.g., 'MyApp') to
the L<Test::Mojo> constructor, L<Test::Mojo> will instantiate the class and
start it, and cause it to listen on a random (unused) port number. Testing a
Mojolicious application using L<Test::Mojo> will never conflict with running
applications, including the application you're testing.

=end original

L<Mojolicious>ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹ã®åå‰(ä¾‹:'MyApp')ã‚’L<Test::Mojo>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã™ã¨ã€L<Test::Mojo>ã¯ã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ã¦èµ·å‹•ã—ã€ãƒ©ãƒ³ãƒ€ãƒ ãª(æœªä½¿ç”¨ã®)ãƒãƒ¼ãƒˆç•ªå·ã‚’ãƒªãƒƒã‚¹ãƒ³ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
L<Test::Mojo>ã‚’ä½¿ç”¨ã—ã¦Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã—ã¦ã‚‚ã€ãƒ†ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å«ã‚ã¦ã€å®Ÿè¡Œä¸­ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ç«¶åˆã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
(TBR)

=begin original

The L<Mojo::UserAgent> object in L<Test::Mojo> will know where the application
is running and make requests to it. Once the tests have completed, the
L<Mojolicious> application will be torn down.

=end original

L<Test::Mojo>å†…ã®L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹å ´æ‰€ã‚’èªè­˜ã—ã€ãã‚Œã«å¯¾ã—ã¦è¦æ±‚ã‚’è¡Œã„ã¾ã™ã€‚
ãƒ†ã‚¹ãƒˆãŒå®Œäº†ã™ã‚‹ã¨ã€L<Mojolicious>ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ç ´æ£„ã•ã‚Œã¾ã™ã€‚
(TBR)

  # Listens on localhost:32114 (some unused TCP port)
  my $t = Test::Mojo->new('Frogs');

=begin original

This object initializes a L<Mojo::UserAgent> object, loads the Mojolicious
application C<Frogs>, binds and listens on a free TCP port (e.g., 32114), and
starts the application event loop. When the L<Test::Mojo> object (C<$t>) goes
out of scope, the application is stopped.

=end original

ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆæœŸåŒ–ã—ã€Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³C<Frogs>ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€ç©ºãTCPãƒãƒ¼ãƒˆ(ä¾‹:32114)ã«ãƒã‚¤ãƒ³ãƒ‰ã—ã¦ãƒªãƒƒã‚¹ãƒ³ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™ã€‚
L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(C<$t>)ãŒç¯„å›²å¤–ã«ãªã‚‹ã¨ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯åœæ­¢ã—ã¾ã™ã€‚
(TBR)

=begin original

Relative URLs in the test object method assertions (C<get_ok>, C<post_ok>, etc.)
will be sent to the Mojolicious application started by L<Test::Mojo>:

=end original

ãƒ†ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ç›¸å¯¾URL(C<get_ok>ã€C<post_ok>ãªã©)ã¯ã€L<Test::Mojo>ã«ã‚ˆã£ã¦èµ·å‹•ã•ã‚Œã‚‹Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é€ä¿¡ã•ã‚Œã¾ã™ã€‚
(TBR)

  # Rewritten to "http://localhost:32114/frogs"
  $t->get_ok('/frogs');

=begin original

L<Test::Mojo> has a lot of handy shortcuts built into it to make testing
L<Mojolicious> or L<Mojolicious::Lite> applications enjoyable.

=end original

L<Test::Mojo>ã«ã¯ã€L<Mojolicious>ã¾ãŸã¯L<Mojolicious::Lite>ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’æ¥½ã—ãã™ã‚‹ãŸã‚ã®ä¾¿åˆ©ãªã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆãŒãŸãã•ã‚“çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚
(TBR)

=head3 An example

(ä¾‹)

=begin original

Let's spin up a Mojolicious application using C<mojo generate app MyApp>. The
C<mojo> utility will create a working application and a C<t> directory with a
working test file:

=end original

C<mojo generate app MyApp>ã‚’ä½¿ç”¨ã—ã¦Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
C<mojo>ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¯ã€å‹•ä½œã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã€å‹•ä½œã™ã‚‹ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚€C<t>ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¾ã™ã€‚
(TBR)

  $ mojo generate app MyApp
  [mkdir] /my_app/script
  [write] /my_app/script/my_app
  [chmod] /my_app/script/my_app 744
  ...
  [mkdir] /my_app/t
  [write] /my_app/t/basic.t
  ...

=begin original

Let's run the tests (we'll create the C<log> directory to quiet the application
output):

=end original

ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ã¿ã¾ã—ã‚‡ã†(C<log>ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¦ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡ºåŠ›ã‚’æŠ‘åˆ¶ã—ã¾ã™)ã€‚
(TBR)

  $ cd my_app
  $ mkdir log
  $ prove -lv t
  t/basic.t ..
  ok 1 - GET /
  ok 2 - 200 OK
  ok 3 - content is similar
  1..3
  ok
  All tests successful.
  Files=1, Tests=3,  0 wallclock secs ( 0.03 usr  0.01 sys +  0.33 cusr  0.07
   csys =  0.44 CPU)
  Result: PASS

=begin original

The boilerplate test file looks like this:

=end original

ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
(TBR)

  use Mojo::Base -strict;

  use Test::More;
  use Test::Mojo;

  my $t = Test::Mojo->new('MyApp');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);

  done_testing();

=begin original

Here we can see our application class name C<MyApp> is passed to the
L<Test::Mojo> constructor. Under the hood, L<Test::Mojo> creates a new
L<Mojo::Server> instance, loads C<MyApp> (which we just created), and runs the
application. We write our tests with relative URLs because L<Test::Mojo> takes
care of getting the request to the running test application (since its port may
change between runs).

=end original

ã“ã“ã§ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹åC<MyApp>ãŒL<Test::Mojo>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«æ¸¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚
å†…éƒ¨ã§ã¯ã€L<Test::Mojo>ãŒæ–°ã—ã„L<Mojo::Server>ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã€C<MyApp>(å…ˆã»ã©ä½œæˆã—ãŸã‚‚ã®)ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
L<Test::Mojo>ãŒå®Ÿè¡Œä¸­ã®ãƒ†ã‚¹ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã®è¦æ±‚ã®å–å¾—ã‚’å‡¦ç†ã™ã‚‹ãŸã‚(å®Ÿè¡Œã®é–“ã«ãƒãƒ¼ãƒˆãŒå¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚)ã€ãƒ†ã‚¹ãƒˆã¯ç›¸å¯¾URLã§è¨˜è¿°ã—ã¾ã™ã€‚
(TBR)

=head3 Testing with configuration data

(è¨­å®šãƒ‡ãƒ¼ã‚¿ã®ãƒ†ã‚¹ãƒˆ)

=begin original

We can alter the behavior of our application using environment variables (such
as C<MOJO_MODE>) and through configuration values. One nice feature of
L<Test::Mojo> is its ability to pass configuration values directly from its
constructor.

=end original

ç’°å¢ƒå¤‰æ•°(C<MOJO_MODE>ãªã©)ã¨æ§‹æˆå€¤ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‹•ä½œã‚’å¤‰æ›´ã§ãã¾ã™ã€‚
L<Test::Mojo>ã®å„ªã‚ŒãŸæ©Ÿèƒ½ã®1ã¤ã¯ã€æ§‹æˆå€¤ã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‹ã‚‰ç›´æ¥æ¸¡ã™æ©Ÿèƒ½ã§ã™ã€‚
(TBR)

=begin original

Let's modify our application and add a "feature flag" to enable a new feature
when the C<enable_weather> configuration value is set:

=end original

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¤‰æ›´ã—ã€C<enable_weather>æ§‹æˆå€¤ãŒè¨­å®šã•ã‚ŒãŸã¨ãã«æ–°ã—ã„æ©Ÿèƒ½ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã€Œæ©Ÿèƒ½ãƒ•ãƒ©ã‚°ã€ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚
(TBR)

  # Load configuration from hash returned by "my_app.conf"
  my $config = $self->plugin('Config');

  # Normal route to controller
  $r->get('/')->to('example#welcome');

  # NEW: this route only exists if "enable_weather" is set in the configuration
  if ($config->{enable_weather}) {
    $r->get('/weather' => sub { shift->render(text => "It's hot! ğŸ”¥") }
  }

=begin original

To test this new feature, we don't even need to create a configuration fileâ€”we
can simply pass the configuration data to the application directly via
L<Test::Mojo>'s constructor:

=end original

ã“ã®æ–°æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã«ã¯ã€æ§‹æˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹å¿…è¦ã•ãˆãªãã€L<Test::Mojo>ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ä»‹ã—ã¦æ§‹æˆãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ç›´æ¥æ¸¡ã™ã ã‘ã§ã‚ˆã„ã€‚
(TBR)

  my $t = Test::Mojo->new(MyApp => {enable_weather => 1});
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  $t->get_ok('/weather')->status_is(200)->content_like(qr/ğŸ”¥/);

=begin original

When we run these tests, L<Test::Mojo> will pass this configuration data to the
application, which will cause it to create a special C</weather> route that we
can access in our tests. Unless C<enable_weather> is set in a configuration
file, this route will not exist when the application runs. Feature flags like
this allow us to do soft rollouts of features, targeting a small audience for a
period of time. Once the feature has been proven, we can refactor the
conditional and make it a full release.

=end original

ã“ã‚Œã‚‰ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€L<Test::Mojo>ã¯ã“ã®æ§‹æˆãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«æ¸¡ã—ã€ãƒ†ã‚¹ãƒˆã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ç‰¹åˆ¥ãªC</weather>ãƒ«ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
æ§‹æˆãƒ•ã‚¡ã‚¤ãƒ«ã«C<enable_weather>ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„é™ã‚Šã€ã“ã®ãƒ«ãƒ¼ãƒˆã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œæ™‚ã«ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚
ã“ã®ã‚ˆã†ãªæ©Ÿèƒ½ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä¸€å®šæœŸé–“ã€å°‘æ•°ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚¨ãƒ³ã‚¹ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã—ã¦ã€æ©Ÿèƒ½ã®ã‚½ãƒ•ãƒˆãƒ­ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
æ©Ÿèƒ½ãŒè¨¼æ˜ã•ã‚ŒãŸã‚‰ã€æ¡ä»¶ã‚’ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã—ã¦å®Œå…¨ãªãƒªãƒªãƒ¼ã‚¹ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
(TBR)

=begin original

This example shows how easy it is to start testing a Mojolicious application and
how to set specific application configuration directives from a test file.

=end original

ã“ã®ä¾‹ã§ã¯ã€Mojoliciousã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’ç°¡å˜ã«é–‹å§‹ã™ã‚‹æ–¹æ³•ã¨ã€ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç‰¹å®šã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ§‹æˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒ†ã‚£ãƒ–ã‚’è¨­å®šã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚
(TBR)

=head3 Testing application helpers

(ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ãƒ‘ãƒ¼ã®ãƒ†ã‚¹ãƒˆ)

=begin original

Let's say we register a helper in our application to generate an HTTP Basic
Authorization header:

=end original

HTTP Basic Authorizationãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ç™»éŒ²ã—ãŸã¨ã—ã¾ã™ã€‚
(TBR)

  use Mojo::Util 'b64_encode';

  app->helper(basic_auth => sub {
    my ($c, @values) = @_;
    return {Authorization => 'Basic ' . b64_encode join(':' => @values), ''};
  });

=begin original

How do we test application helpers like this? L<Test::Mojo> has access to the
application object, which allows us to invoke helpers from our test file:

=end original

ã“ã®ã‚ˆã†ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã—ã‚‡ã†ã‹?L<Test::Mojo>ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãŸã‚ã€ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
(TBR)

  my $t = Test::Mojo->new('MyApp');

  is_deeply $t->app->basic_auth(bif => "Bif's Passwerdd"),
    {Authorization => 'Basic YmlmOkJpZidzIFBhc3N3ZXJkZA=='},
    'correct header value';

=begin original

Any aspect of the application (helpers, plugins, routes, etc.) can be
introspected from L<Test::Mojo> through the application object. This enables us
to get deep test coverage of L<Mojolicious>-based applications.

=end original

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚ã‚‰ã‚†ã‚‹å´é¢(ãƒ˜ãƒ«ãƒ‘ãƒ¼ã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€ãƒ«ãƒ¼ãƒˆãªã©)ã¯ã€L<Test::Mojo>ã‹ã‚‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šã˜ã¦ç´¹ä»‹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€L<Mojolicious>ãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ·±ã„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
(TBR)

=head1 ASSERTIONS

(ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

=begin original

This section describes the basic test assertions supplied by L<Test::Mojo>.
There are four broad categories of assertions for HTTP requests:

=end original

ã“ã®é …ã§ã¯ã€L<Test::Mojo>ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚
HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã«ã¯ã€æ¬¡ã®4ã¤ã®å¤§ããªã‚«ãƒ†ã‚´ãƒªãŒã‚ã‚Šã¾ã™ã€‚
(TBR)

=over 2

=item * HTTP requests

=item * HTTP response status

=item * HTTP response headers

=item * HTTP response content/body

=back

=begin original

WebSocket test assertions are covered in L</Testing WebSocket web services>.

=end original

WebSocketãƒ†ã‚¹ãƒˆã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦ã¯ã€L</Testing WebSocket Web Services>ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
(TBR)

=head2 HTTP request assertions

(HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

=begin original

L<Test::Mojo> has a L<Mojo::UserAgent> object that allows it to make HTTP
requests and check for HTTP transport errors. HTTP request assertions include
C<get_ok>, C<post_ok>, etc. These assertions do not test whether the request
was handled I<successfully>, only that the web application handled the request
in an HTTP compliant way.

=end original

L<Test::Mojo>ã«ã¯ã€HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆã¨HTTPãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã‚’å¯èƒ½ã«ã™ã‚‹L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã«ã¯ã€C<get_ok>ã€C<post_ok>ãªã©ãŒå«ã¾ã‚Œã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒ<æ­£å¸¸ã«>å‡¦ç†ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã®ã§ã¯ãªãã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒHTTPæº–æ‹ ã®æ–¹æ³•ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ãŸã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã ã‘ã§ã™ã€‚
(TBR)

=begin original

You may also make HTTP requests using custom verbs (beyond C<GET>, C<POST>,
C<PUT>, etc.) by building your own transaction object. See
L</"Custom transactions"> below.

=end original

ç‹¬è‡ªã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã§ã€ã‚«ã‚¹ã‚¿ãƒ å‹•è©(C<GET>ã€C<POST>ã€C<PUT>ãªã©ä»¥å¤–)ã‚’ä½¿ç”¨ã—ã¦HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ä»¥ä¸‹ã®L</"Custom transactions">ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
(TBR)

=head3 Using HTTP request assertions

(HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†)

=begin original

To post a URL-encoded form to the C</calls> endpoint of an application, we
simply use the C<form> content type shortcut:

=end original

URLã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®C</calls>ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«é€ä¿¡ã™ã‚‹ã«ã¯ã€C<form>ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã ã‘ã§ã™ã€‚
(TBR)

  $t->post_ok('/calls' => form => {to => '+43.55.555.5555'});

=begin original

Which will create the following HTTP request:

=end original

ã“ã‚Œã«ã‚ˆã‚Šã€æ¬¡ã®HTTPè¦æ±‚ãŒä½œæˆã•ã‚Œã¾ã™ã€‚
(TBR)

  POST /calls HTTP/1.1
  Content-Length: 20
  Content-Type: application/x-www-form-urlencoded

  to=%2B43.55.555.5555

=begin original

The C<*_ok> HTTP request assertion methods accept the same arguments as their
corresponding L<Mojo::UserAgent> methods (except for the callback argument).
This allows us to set headers and build query strings for authentic test
situations:

=end original

C<*_ok>HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¯¾å¿œã™ã‚‹L<Mojo::UserAgent>ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜å¼•æ•°ã‚’å—ã‘å…¥ã‚Œã¾ã™(ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å¼•æ•°ã‚’é™¤ã)ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®šã—ã€ä¿¡é ¼ã§ãã‚‹ãƒ†ã‚¹ãƒˆçŠ¶æ³ã®ãŸã‚ã®ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚
(TBR)

  $t->get_ok('/internal/personnel' => {Authorization => 'Token secret-password'}
    => form => {q => 'Professor Plum'});

=begin original

which generates the following request:

=end original

ã“ã‚Œã«ã‚ˆã‚Šã€æ¬¡ã®è¦æ±‚ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚
(TBR)

  GET /internal/personnel?q=Professor+Plum HTTP/1.1
  Content-Length: 0
  Authorization: Token secret-password

=begin original

The C<form> content generator (see L<Mojo::UserAgent::Transactor>) will generate
a query string for C<GET> requests and C<application/x-www-form-urlencoded> or
C<multipart/form-data> for POST requests.

=end original

C<form>ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼(L<Mojo::UserAgent::Transactor>ã‚’å‚ç…§)ã¯ã€C<GET>è¦æ±‚ã«å¯¾ã—ã¦ã¯ç…§ä¼šã‚¹ãƒˆãƒªãƒ³ã‚°ã‚’ç”Ÿæˆã—ã€POSTè¦æ±‚ã«å¯¾ã—ã¦ã¯C<application/x-www-form-urlencoded>ã¾ãŸã¯C<multipart/form-data>ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
(TBR)

=begin original

While these C<*_ok> assertions make the HTTP I<requests> we expect, they tell us
little about I<how well> the application handled the request. The application
we're testing might have returned any content-type, body, or HTTP status code
(200, 302, 400, 404, 500, etc.) and we wouldn't know it.

=end original

ã“ã‚Œã‚‰ã®C<*_ok>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ç§ãŸã¡ãŒæœŸå¾…ã™ã‚‹HTTP I<ãƒªã‚¯ã‚¨ã‚¹ãƒˆ>ã‚’ä½œæˆã—ã¾ã™ãŒã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’<ã©ã‚Œã ã‘ã†ã¾ã>å‡¦ç†ã—ãŸã‹ã«ã¤ã„ã¦ã¯ã»ã¨ã‚“ã©æ•™ãˆã¦ãã‚Œã¾ã›ã‚“ã€‚
ç§ãŸã¡ãŒãƒ†ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ä»»æ„ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã€ãƒœãƒ‡ã‚£ã€ã¾ãŸã¯HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰(200ã€302ã€400ã€404ã€500ãªã©)ã‚’è¿”ã—ãŸå¯èƒ½æ€§ãŒã‚ã‚Šã€ç§ãŸã¡ã¯ãã‚Œã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
(TBR)

=begin original

L<Test::Mojo> provides assertions to test almost every aspect of the HTTP
response, including the HTTP response status code, the value of the
C<Content-Type> header, and other arbitrary HTTP header information.

=end original

L<Test::Mojo>ã¯ã€HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã€C<Content-Type>ãƒ˜ãƒƒãƒ€ãƒ¼ã®å€¤ã€ãã®ä»–ã®ä»»æ„ã®HTTPãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ãªã©ã€HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã»ã¼ã™ã¹ã¦ã®å´é¢ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æä¾›ã™ã‚‹ã€‚
(TBR)

=head2 HTTP response status code

(HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰)

=begin original

While not technically an HTTP header, the status line is the first line in an
HTTP response and is followed by the response headers. Testing the response
status code is common in REST-based and other web applications that use the HTTP
status codes to broadly indicate the type of response the server is returning.

=end original

æŠ€è¡“çš„ã«ã¯HTTPãƒ˜ãƒƒãƒ€ãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡Œã¯HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æœ€åˆã®è¡Œã§ã‚ã‚Šã€ãã®å¾Œã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ãŒç¶šãã¾ã™ã€‚
ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ†ã‚¹ãƒˆã¯ã€HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã‚µãƒ¼ãƒãƒ¼ãŒè¿”ã™ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¿ã‚¤ãƒ—ã‚’åºƒãç¤ºã™RESTãƒ™ãƒ¼ã‚¹ã‚„ãã®ä»–ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä¸€èˆ¬çš„ã§ã™ã€‚
(TBR)

=begin original

Testing the status code is as simple as adding the C<status_is> assertion:

=end original

ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ†ã‚¹ãƒˆã¯ã€Cã®<status_is>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã®ç°¡å˜ãªã‚‚ã®ã§ã™ã€‚
(TBR)

  $t->post_ok('/doorbell' => form => {action => 'ring once'})
    ->status_is(200);

=begin original

Along with C<status_isnt>, this will cover most needs. For more elaborate status
code testing, you can access the response internals directly:

=end original

C<status_isnt>ã¨ã¨ã‚‚ã«ã€ã“ã‚Œã¯ã»ã¨ã‚“ã©ã®ãƒ‹ãƒ¼ã‚ºã‚’ã‚«ãƒãƒ¼ã—ã¾ã™ã€‚
ã‚ˆã‚Šè©³ç´°ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆã®ãŸã‚ã«ã€å¿œç­”å†…éƒ¨ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
(TBR)

  $t->post_ok('/doorbell' => form => {action => 'ring once'});
  is $t->tx->res->message, 'Moved Permanently', 'try next door';

=head2 HTTP response headers

(HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€)

=begin original

L<Test::Mojo> allows us to inspect and make assertions about HTTP response
headers. The C<Content-Type> header is commonly tested and has its own
assertion:

=end original

L<Test::Mojo>ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ¤œæŸ»ã—ã¦ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã§ãã¾ã™ã€‚
C<Content-Type>ãƒ˜ãƒƒãƒ€ãƒ¼ã¯ä¸€èˆ¬çš„ã«ãƒ†ã‚¹ãƒˆã•ã‚Œã€ç‹¬è‡ªã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™:
(TBR)

  $t->get_ok('/map-of-the-world.pdf')
    ->content_type_is('application/pdf');

=begin original

This is equivalent to the more verbose:

=end original

ã“ã‚Œã¯ã€ã‚ˆã‚Šå†—é•·ãªæ¬¡ã®ã‚‚ã®ã¨ç­‰ä¾¡ã§ã™:

  $t->get_ok('/map-of-the-world.pdf')
    ->header_is('Content-Type' => 'application/pdf');

=begin original

We can test for multiple headers in a single response using method chains:

=end original

ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€1ã¤ã®å¿œç­”ã§è¤‡æ•°ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™ã€‚
(TBR)

  $t->get_ok('/map-of-the-world.pdf')
    ->content_type_is('application/pdf')
    ->header_isnt('Compression' => 'gzip')
    ->header_unlike('Server' => qr/IIS/i);

=head2 HTTP response content assertions

(HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å†…å®¹ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

=begin original

L<Test::Mojo> also exposes a rich set of assertions for testing the body of a
response, whether that body be HTML, plain-text, or JSON. The C<content_*>
methods look at the body of the response as plain text (as defined by the
response's character set):

=end original

L<Test::Mojo>ã¯ã€å¿œç­”ã®æœ¬æ–‡ãŒHTMLã€ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€JSONã®ã„ãšã‚Œã§ã‚ã£ã¦ã‚‚ã€ãã®æœ¬æ–‡ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã®è±Šå¯Œãªã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚»ãƒƒãƒˆã‚‚å…¬é–‹ã—ã¦ã„ã‚‹ã€‚
C<content_*>ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¿œç­”ã®æœ¬æ–‡ã‚’ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ(å¿œç­”ã®æ–‡å­—ã‚»ãƒƒãƒˆã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹)ã¨ã—ã¦è¦‹ã‚‹ã€‚
(TBR)

  $t->get_ok('/scary-things/spiders.json')
    ->content_is('{"arachnid":"brown recluse"}');

=begin original

Although this is a JSON document, C<content_is> treats it as if it were a text
document. This may be useful for situations where we're looking for a particular
string and not concerned with the structure of the document. For example, we can
do the same thing with an HTML document:

=end original

ã“ã‚Œã¯JSONæ–‡æ›¸ã§ã™ãŒã€C<content_is>ã¯ãã‚Œã‚’ãƒ†ã‚­ã‚¹ãƒˆæ–‡æ›¸ã®ã‚ˆã†ã«æ‰±ã„ã¾ã™ã€‚
ã“ã‚Œã¯ã€ç‰¹å®šã®æ–‡å­—åˆ—ã‚’æ¢ã—ã¦ã„ã¦ã€æ–‡æ›¸ã®æ§‹é€ ã«é–¢ä¿‚ã—ãªã„çŠ¶æ³ã§å½¹ç«‹ã¤å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
ãŸã¨ãˆã°ã€HTMLæ–‡æ›¸ã§åŒã˜ã“ã¨ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
(TBR)

  $t->get_ok('/scary-things/spiders.html')
    ->content_like(qr{<title>All The Spiders</title>});

=begin original

But because L<Test::Mojo> has access to everything that L<Mojo::UserAgent> does,
we can introspect JSON documents as well as DOM-based documents (HTML, XML) with
assertions that allow us to check for the existence of elements as well as
inspect the content of text nodes.

=end original

ã—ã‹ã—ã€L<Test::Mojo>ã¯L<Mojo::UserAgent>ãŒè¡Œã†ã™ã¹ã¦ã®ã“ã¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãŸã‚ã€è¦ç´ ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã®å†…å®¹ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€DOMãƒ™ãƒ¼ã‚¹ã®æ–‡æ›¸(HTMLã€XML)ã ã‘ã§ãªãJSONæ–‡æ›¸ã‚‚ã‚¤ãƒ³ãƒˆãƒ­ã‚¹ãƒšã‚¯ã‚·ãƒ§ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
(TBR)

=head3 JSON response assertions

(JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

=begin original

L<Test::Mojo>'s L<Mojo::UserAgent> has access to a JSON parser, which allows us
to test to see if a JSON response contains a value at a location in the document
using JSON pointer syntax:

=end original

L<Test::Mojo>ã®L<Mojo::UserAgent>ã¯JSONãƒ‘ãƒ¼ã‚µã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãŸã‚ã€JSONãƒã‚¤ãƒ³ã‚¿æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€JSONå¿œç­”ã«æ–‡æ›¸å†…ã®å ´æ‰€ã®å€¤ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
(TBR)

  $t->get_ok('/animals/friendly.json')
    ->json_has('/beings/jeremiah/age');

=begin original

This assertion tells us that the C<friendly.json> document contains a value at
the C</beings/jeremiah/age> JSON pointer location. We can also inspect the value
at JSON pointer locations:

=end original

ã“ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€C<friendly.json>æ–‡æ›¸ã«C</exists/jeremiah/age>JSONãƒã‚¤ãƒ³ã‚¿ã®å ´æ‰€ã«å€¤ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚
JSONãƒã‚¤ãƒ³ã‚¿ã®å ´æ‰€ã§å€¤ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
(TBR)

  $t->get_ok('/animals/friendly.json')
    ->json_has('/beings/jeremiah/age')
    ->json_is('/beings/jeremiah/age' => 42)
    ->json_like('/beings/jeremiah/species' => qr/bullfrog/i);

=begin original

JSON pointer syntax makes testing JSON responses simple and readable.

=end original

JSONãƒã‚¤ãƒ³ã‚¿ãƒ¼æ§‹æ–‡ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ†ã‚¹ãƒˆãŒç°¡å˜ã§èª­ã¿ã‚„ã™ããªã‚Šã¾ã™ã€‚
(TBR)

=head3 DOM response assertions

(DOMãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)

=begin original

We can also inspect HTML and XML responses using the L<Mojo::DOM> parser in the
user agent. Here are a few examples from the L<Test::Mojo> documentation:

=end original

ã¾ãŸã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®L<Mojo::DOM>ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã€HTMLãŠã‚ˆã³XMLã®å¿œç­”ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
L<Test::Mojo>ã®æ–‡æ›¸ã‹ã‚‰ã„ãã¤ã‹ã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚
(TBR)

  $t->text_is('div.foo[x=y]' => 'Hello!');
  $t->text_is('html head title' => 'Hello!', 'right title');

=begin original

The L<Mojo::DOM> parser uses the CSS selector syntax described in
L<Mojo::DOM::CSS>, allowing us to test for values in HTML and XML documents
without resorting to typically verbose and inflexible DOM traversal methods.

=end original

L<Mojo::DOM>ãƒ‘ãƒ¼ã‚µãƒ¼ã¯ã€L<Mojo::DOM::CSS>ã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹CSSã‚»ãƒ¬ã‚¯ã‚¿æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
(TBR)

=head1 ADVANCED TOPICS

=begin original

This section describes some complex (but common) testing situations that
L<Test::Mojo> excels in making simple.

=end original

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€L<Test::Mojo>ãŒã‚·ãƒ³ãƒ—ãƒ«ã«ã™ã‚‹ã®ã«å„ªã‚Œã¦ã„ã‚‹ã€è¤‡é›‘ãª(ã—ã‹ã—ä¸€èˆ¬çš„ãª)ãƒ†ã‚¹ãƒˆçŠ¶æ³ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹ã€‚
(TBR)

=head2 Redirects

(ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ)

=begin original

The L<Mojo::UserAgent> object in L<Test::Mojo> can handle HTTP redirections
internally to whatever level you need. Let's say we have a web service that
redirects C</1> to C</2>, C</2> redirects to C</3>, C</3> redirects to C</4>,
and C</4> redirects to C</5>:

=end original

L<Test::Mojo>ã®L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å¿…è¦ãªãƒ¬ãƒ™ãƒ«ã¾ã§å†…éƒ¨çš„ã«HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†ã§ãã¾ã™ã€‚
C</1>ã‚’C</2>ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã€C</2>ã‚’C</3>ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã€C</3>ã‚’C</4>ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã€C</4>ã‚’C</5>ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã™ã‚‹Webã‚µãƒ¼ãƒ“ã‚¹ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚
(TBR)

  GET /1

=begin original

returns:

=end original

ã“ã‚Œã¯æ¬¡ã‚’è¿”ã—:

  302 Found
  Location: /2

=begin original

and:

=end original

ãã—ã¦:

  GET /2

=begin original

returns:

=end original

ã“ã‚Œã¯æ¬¡ã‚’è¿”ã—:

  302 Found
  Location: /3

=begin original

and so forth, up to C</5>:

=end original

ä»¥ä¸‹ã€C</5>ã¾ã§:

  GET /5

=begin original

which returns the data we wanted:

=end original

å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒè¿”ã•ã‚Œã¾ã™ã€‚
(TBR)

  200 OK

  {"message":"this is five"}

=begin original

We can tell the user agent in L<Test::Mojo> how to deal with redirects. Each
test is making a request to C<GET /1>, but we vary the number of redirects the
user agent should follow with each test:

=end original

L<Test::Mojo>ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã®å‡¦ç†æ–¹æ³•ã‚’ä¼ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
å„ãƒ†ã‚¹ãƒˆã¯C<GET /1>ã«è¦æ±‚ã‚’è¡Œã„ã¾ã™ãŒã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå„ãƒ†ã‚¹ãƒˆã§å¾“ã†ã¹ããƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã®æ•°ã¯ç•°ãªã‚Šã¾ã™ã€‚
(TBR)

  my $t = Test::Mojo->new;

  $t->get_ok('/1')
    ->header_is(location => '/2');

  $t->ua->max_redirects(1);
  $t->get_ok('/1')
    ->header_is(location => '/3');

  $t->ua->max_redirects(2);
  $t->get_ok('/1')
    ->header_is(location => '/4');

  # Look at the previous hop
  is $t->tx->previous->res->headers->location, '/3', 'previous redirect';

  $t->ua->max_redirects(3);
  $t->get_ok('/1')
    ->header_is(location => '/5');

  $t->ua->max_redirects(4);
  $t->get_ok('/1')
    ->json_is('/message' => 'this is five');

=begin original

When we set C<max_redirects>, it stays set for the life of the test object until
we change it.

=end original

C<max_redirects>ã‚’è¨­å®šã™ã‚‹ã¨ã€å¤‰æ›´ã™ã‚‹ã¾ã§ãƒ†ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å­˜ç¶šæœŸé–“ä¸­ã€è¨­å®šã•ã‚ŒãŸã¾ã¾ã«ãªã‚Šã¾ã™ã€‚
(TBR)

=begin original

L<Test::Mojo>'s handling of HTTP redirects eliminates the need for making many,
sometimes an unknown number, of redirections to keep testing precise and easy to
follow (ahem).

=end original

L<Test::Mojo>ã®HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã®å‡¦ç†ã«ã‚ˆã‚Šã€ãƒ†ã‚¹ãƒˆã‚’æ­£ç¢ºã‹ã¤å®¹æ˜“ã«å®Ÿè¡Œã—ç¶šã‘ã‚‹ãŸã‚ã«ã€å¤šãã®(æ™‚ã«ã¯æœªçŸ¥ã®æ•°ã®)ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡Œã†å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚
(TBR)

=head2 Cookies and session management

(ã‚¯ãƒƒã‚­ãƒ¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†)

=begin original

We can use L<Test::Mojo> to test applications that keep session state in
cookies. By default, the L<Mojo::UserAgent> object in L<Test::Mojo> will manage
session for us by saving and sending cookies automatically, just like common web
browsers:

=end original

L<Test::Mojo>ã‚’ä½¿ç”¨ã—ã¦ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚’Cookieã«ä¿æŒã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™ã€‚
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€L<Test::Mojo>ã®L<Mojo::UserAgent>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ä¸€èˆ¬çš„ãªWebãƒ–ãƒ©ã‚¦ã‚¶ã¨åŒæ§˜ã«ã€Cookieã‚’è‡ªå‹•çš„ã«ä¿å­˜ãŠã‚ˆã³é€ä¿¡ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç®¡ç†ã—ã¾ã™ã€‚
(TBR)

  use Mojo::Base -strict;

  use Test::More;
  use Test::Mojo;

  my $t = Test::Mojo->new('MyApp');

  # No authorization cookie
  $t->get_ok('/')
    ->status_is(401)
    ->content_is('Please log in');

  # Application sets an authorization cookie
  $t->post_ok('/login' => form => {password => 'let me in'})
    ->status_is(200)
    ->content_is('You are logged in');

  # Sends the cookie from the previous transaction
  $t->get_ok('/')
    ->status_is(200)
    ->content_like(qr/You logged in at \d+/);

  # Clear the cookies
  $t->reset_session;

  # No authorization cookie again
  $t->get_ok('/')
    ->status_is(401)
    ->content_is('Please log in');

=begin original

We can also inspect cookies in responses for special values through the
transaction's response (L<Mojo::Message::Response>) object:

=end original

ã¾ãŸã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å¿œç­”(L<Mojo::Message::Response>)ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦ã€å¿œç­”å†…ã®ã‚¯ãƒƒã‚­ãƒ¼ã«ç‰¹åˆ¥ãªå€¤ãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
(TBR)

  $t->get_ok('/');
  like $t->tx->res->cookie('smarty'), qr/smarty=pants/, 'cookie found';

=head2 Custom transactions

(ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³)

=begin original

Let's say we have an application that responds to a new HTTP verb C<RING> and to
use it we must also pass in a secret cookie value. This is not a problem. We can
test the application by creating a L<Mojo::Transaction> object, setting the
cookie (see L<Mojo::Message::Request>), then passing the transaction object to
C<request_ok>:

=end original

æ–°ã—ã„HTTPå‹•è©C<RING>ã«å¿œç­”ã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ç§˜å¯†ã®ã‚¯ãƒƒã‚­ãƒ¼å€¤ã‚‚æ¸¡ã™å¿…è¦ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚
ã“ã‚Œã¯å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã«ã¯ã€L<Mojo::Transaction>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ã‚¯ãƒƒã‚­ãƒ¼ã‚’è¨­å®šã—(L<Mojo::Message::Request>ã‚’å‚ç…§)ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’C<request_ok>ã«æ¸¡ã—ã¾ã™ã€‚
(TBR)

  # Use custom "RING" verb
  my $tx = $t->ua->build_tx(RING => '/doorbell');

  # Set a special cookie
  $tx->req->cookies({name => 'Secret', value => "don't tell anybody"});

  # Make the request
  $t->request_ok($tx)
    ->status_is(200)
    ->json_is('/status' => 'ding dong');

=head2 Testing WebSocket web services

(WebSocket web ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ†ã‚¹ãƒˆ)

=begin original

While the message flow on WebSocket connections can be rather dynamic, it more
often than not is quite predictable, which allows this rather pleasant
L<Test::Mojo> WebSocket API to be used:

=end original

WebSocketæ¥ç¶šä¸Šã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ãƒ­ãƒ¼ã¯ã‹ãªã‚Šå‹•çš„ã§ã‚ã‚‹ãŒã€å¤šãã®å ´åˆã€ã‹ãªã‚Šäºˆæ¸¬å¯èƒ½ã§ã‚ã‚‹ãŸã‚ã€ã“ã®ã‹ãªã‚Šå¿«é©ãªL<Test::Mojo>WebSocket APIã‚’ä½¿ç”¨ã§ãã‚‹ã€‚
(TBR)

  use Mojo::Base -strict;

  use Test::More;
  use Test::Mojo;

  # Test echo web service
  my $t = Test::Mojo->new('EchoService');
  $t->websocket_ok('/echo')
    ->send_ok('Hello Mojo!')
    ->message_ok
    ->message_is('echo: Hello Mojo!')
    ->finish_ok;

  # Test JSON web service
  $t->websocket_ok('/echo.json')
    ->send_ok({json => {test => [1, 2, 3]}})
    ->message_ok
    ->json_message_is('/test' => [1, 2, 3])
    ->finish_ok;

  done_testing();

=begin original

Because of their inherent asynchronous nature, testing WebSocket communications
can be tricky. The L<Test::Mojo> WebSocket assertions serialize messages via
event loop primitives. This enables us to treat WebSocket messages as if they
were using the same request-response communication pattern we're accustomed to
with HTTP.

=end original

L<Test::Mojo>WebSocketã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚’ä»‹ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã€HTTPã§æ…£ã‚Œè¦ªã—ã‚“ã åŒã˜è¦æ±‚-å¿œç­”ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‹ã®ã‚ˆã†ã«æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚
(TBR)

=begin original

To illustrate, let's walk through these tests. In the first test, we use the
C<websocket_ok> assertion to ensure that we can connect to our application's
WebSocket route at C</echo> and that it's "speaking" WebSocket protocol to us.
The next C<send_ok> assertion tests the connection again (in case it closed, for
example) and attempts to send the message C<Hello Mojo!>. The next assertion,
C<message_ok>, blocks (using the L<Mojo::IOLoop> singleton in the application)
and waits for a response from the server. The response is then compared with
C<'echo: Hello Mojo!'> in the C<message_is> assertion, and finally we close and
test our connection status again with C<finish_ok>.

=end original

èª¬æ˜ã®ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®ãƒ†ã‚¹ãƒˆã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
æœ€åˆã®ãƒ†ã‚¹ãƒˆã§ã¯ã€C<WebSocket_ok>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®WebSocketãƒ«ãƒ¼ãƒˆã«C</echo>ã§æ¥ç¶šã§ãã‚‹ã“ã¨ã€ãŠã‚ˆã³WebSocketãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ã€Œè©±ã—ã¦ã„ã‚‹ã€ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
æ¬¡ã®C<send_ok>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€æ¥ç¶šã‚’å†åº¦ãƒ†ã‚¹ãƒˆã—(ãŸã¨ãˆã°ã€æ¥ç¶šãŒé–‰ã˜ãŸå ´åˆ)ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸C<Hello Mojo!>ã‚’é€ä¿¡ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚
æ¬¡ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚ã‚‹C<message_ok>ã¯ã€(ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®L<Mojo::IOLoop>ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚’ä½¿ç”¨ã—ã¦)ãƒ–ãƒ­ãƒƒã‚¯ã—ã€ã‚µãƒ¼ãƒã‹ã‚‰ã®å¿œç­”ã‚’å¾…ã¡ã¾ã™ã€‚
æ¬¡ã«ã€å¿œç­”ã¯C<message_is>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³å†…ã®C<'echo: Hello Mojo!'>ã¨æ¯”è¼ƒã•ã‚Œã€æœ€å¾Œã«ã€C<finish_ok>ã§æ¥ç¶šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†åº¦ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚
(TBR)

=begin original

The second test is like the first, but now we're sending and expecting JSON
documents at C</echo.json>. In the C<send_ok> assertion we take advantage of
L<Mojo::UserAgent>'s JSON content generator (see L<Mojo::UserAgent::Transactor>)
to marshal hash and array references into JSON documents, and then send them as
a WebSocket message. We wait (block) for a response from the server with
C<message_ok>. Then because we're expecting a JSON document back, we can
leverage C<json_message_ok> which parses the WebSocket response body and returns
an object we can access through L<Mojo::JSON::Pointer> syntax. Then we close
(and test) our WebSocket connection.

=end original

2ç•ªç›®ã®ãƒ†ã‚¹ãƒˆã¯æœ€åˆã®ãƒ†ã‚¹ãƒˆã¨ä¼¼ã¦ã„ã¾ã™ãŒã€ç¾åœ¨ã¯C</echo.json>ã§JSONæ–‡æ›¸ã‚’é€ä¿¡ã—ã¦æœŸå¾…ã—ã¦ã„ã¾ã™ã€‚
C<send_ok>ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€L<Mojo::UserAgent>ã®JSONã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿(L<Mojo::UserAgent::Transactor>ã‚’å‚ç…§)ã‚’åˆ©ç”¨ã—ã¦ã€ãƒãƒƒã‚·ãƒ¥ã¨é…åˆ—å‚ç…§ã‚’JSONæ–‡æ›¸ã«ãƒãƒ¼ã‚·ãƒ£ãƒªãƒ³ã‚°ã—ã€WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã—ã¦é€ä¿¡ã—ã¾ã™ã€‚
C<message_ok>ã§ã‚µãƒ¼ãƒã‹ã‚‰ã®å¿œç­”ã‚’å¾…ã¡ã¾ã™(ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã™)ã€‚
æ¬¡ã«ã€JSONæ–‡æ›¸ãŒè¿”ã•ã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…ã—ã¦ã„ã‚‹ãŸã‚ã€WebSocketå¿œç­”æœ¬ä½“ã‚’è§£æã—ã€L<Mojo::JSON::Pointer>æ§‹æ–‡ã‚’é€šã˜ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™C<json_message_ok>ã‚’æ´»ç”¨ã§ãã¾ã™ã€‚
æ¬¡ã«ã€WebSocketæ¥ç¶šã‚’é–‰ã˜ã¾ã™(ãã—ã¦ãƒ†ã‚¹ãƒˆã—ã¾ã™)ã€‚
(TBR)

=begin original

Testing WebSocket servers does not get any simpler than with L<Test::Mojo>.

=end original

WebSocketã‚µãƒ¼ãƒã®ãƒ†ã‚¹ãƒˆã¯ã€L<Test::Mojo>ã‚ˆã‚Šã‚‚ç°¡å˜ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚

=head2 Extending L<Test::Mojo>

(L<Test::Mojo> ã®æ‹¡å¼µ)

=begin original

If you see that you're writing a lot of test assertions that aren't chainable,
you may benefit from writing your own test assertions. Let's say we want to test
the C<Location> header after a redirect. We'll create a new class with
L<Role::Tiny> that implements a test assertion named C<location_is>:

=end original

ãƒã‚§ãƒ¼ãƒ³åŒ–ã§ããªã„ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¤§é‡ã«ä½œæˆã—ã¦ã„ã‚‹å ´åˆã¯ã€ç‹¬è‡ªã®ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ã¨ä¾¿åˆ©ã§ã™ã€‚
ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆå¾Œã«C<Location>ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ã—ã¾ã™ã€‚
C<location_is>ã¨ã„ã†åå‰ã®ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹L<Role::Tiny>ã‚’æŒã¤æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
(TBR)

  package Test::Mojo::Role::Location;
  use Mojo::Base -role;

  use Test::More;

  sub location_is {
    my ($t, $value, $desc) = @_;
    $desc ||= "Location: $value";
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $t->success(is($t->tx->res->headers->location, $value, $desc));
  }

  1;

=begin original

When we make new test assertions using roles, we want to use method signatures
that match other C<*_is> methods in L<Test::Mojo>, so here we accept the test
object, the value to compare, and an optional description.

=end original

ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹å ´åˆã€L<Test::Mojo>å†…ã®ä»–ã®C<*_is>ãƒ¡ã‚½ãƒƒãƒ‰ã¨ä¸€è‡´ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ãƒ†ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€æ¯”è¼ƒã™ã‚‹å€¤ã€ãŠã‚ˆã³ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®èª¬æ˜ã‚’å—ã‘å…¥ã‚Œã‚‹ã€‚
(TBR)

=begin original

We assign a default description value (C<$desc>), set the L<Test::Builder>
C<Level> global variable one level higher (which tells L<Test::Builder> how far
up the call stack to look when something fails), then we use L<Test::More>'s
C<is> function to compare the location header with the expected header value. We
wrap that in the C<success> attribute, which records the boolean test result and
propagates the L<Test::Mojo> object for method chaining.

=end original

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨˜è¿°å€¤(C<$desc>)ã‚’å‰²ã‚Šå½“ã¦ã€L<Test::Builder>C<Level>ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’1ãƒ¬ãƒ™ãƒ«ä¸Šã«è¨­å®šã—(ã“ã‚Œã«ã‚ˆã‚Šã€L<Test::Builder>ã¯ã€ä½•ã‹ãŒå¤±æ•—ã—ãŸã¨ãã«å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯ã®ã©ã“ã¾ã§èª¿ã¹ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™)ã€L<Test::More>ã®C<is>é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’äºˆæƒ³ã•ã‚Œã‚‹ãƒ˜ãƒƒãƒ€ãƒ¼å€¤ã¨æ¯”è¼ƒã—ã¾ã™ã€‚
ã“ã‚Œã‚’C<success>å±æ€§ã«ãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚
ã“ã®å±æ€§ã¯ã€ãƒ–ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆçµæœã‚’è¨˜éŒ²ã—ã€ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³ç”¨ã®L<Test::Mojo>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¼æ’­ã—ã¾ã™ã€‚
(TBR)

=begin original

With this new package, we're ready to compose a new test object that uses the
role:

=end original

ã“ã®æ–°ã—ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹æº–å‚™ãŒæ•´ã„ã¾ã—ãŸã€‚
(TBR)

  my $t = Test::Mojo->with_roles('+Location')->new('MyApp');

  $t->post_ok('/redirect/mojo' => json => {message => 'Mojo, here I come!'})
    ->status_is(302)
    ->location_is('http://mojolicious.org')
    ->or(sub { diag 'I miss tempire.' });

=begin original

In this section we've covered how to add custom test assertions to L<Test::Mojo>
with roles and how to use those roles to simplify testing.

=end original

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦L<Test::Mojo>ã«ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹æ–¹æ³•ã¨ã€ãã‚Œã‚‰ã®ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãƒ†ã‚¹ãƒˆã‚’ç°¡ç´ åŒ–ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã—ãŸã€‚
(TBR)

=head1 MORE

=begin original

You can continue with L<Mojolicious::Guides> now or take a look at the
L<Mojolicious wiki|http://github.com/mojolicious/mojo/wiki>, which contains a
lot more documentation and examples by many different authors.

=end original

L<Mojolicious::Guides>ã‚’ä»Šã™ãç¶šã‘ã‚‹ã“ã¨ã‚‚ã€L<Mojolicious wiki|http://github.com/mogoliement/mojo/wiki>ã‚’è¦‹ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ã“ã®L<Mojolicious wiki|http://github.com/mogoliement/mojo/wiki>ã«ã¯ã€ã•ã¾ã–ã¾ãªè‘—è€…ã«ã‚ˆã‚‹å¤šãã®æ–‡æ›¸ã¨ä¾‹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
(TBR)

=head1 SUPPORT

=begin original

If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
L<mailing list|http://groups.google.com/group/mojolicious> or the official IRC
channel C<#mojo> on C<irc.freenode.net> (L<chat
now!|https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?>).

=end original

æ–‡æ›¸ã§ã¾ã å›ç­”ã•ã‚Œã¦ã„ãªã„è³ªå•ãŒã‚ã‚‹å ´åˆã¯ã€L<mailing list|http://groups.google.com/group/mojolicious>ã¾ãŸã¯C<irc.freenode.net>ã®å…¬å¼IRCãƒãƒ£ãƒãƒ«C<#mojo>(L<chat now!|https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?>)ã§é æ…®ãªãè³ªå•ã—ã¦ãã ã•ã„ã€‚

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org> (8.12)
Status: in progress

=end meta

=cut

